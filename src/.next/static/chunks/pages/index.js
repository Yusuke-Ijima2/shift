/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@fullcalendar/interaction/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/main.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": function() { return /* binding */ ExternalDraggable; },\n/* harmony export */   \"FeaturefulElementDragging\": function() { return /* binding */ FeaturefulElementDragging; },\n/* harmony export */   \"PointerDragging\": function() { return /* binding */ PointerDragging; },\n/* harmony export */   \"ThirdPartyDraggable\": function() { return /* binding */ ThirdPartyDraggable; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/\nvar PointerDragging = /** @class */ (function () {\n    function PointerDragging(containerEl) {\n        var _this = this;\n        this.subjectEl = null;\n        // options that can be directly assigned by caller\n        this.selector = ''; // will cause subjectEl in all emitted events to be this element\n        this.handleSelector = '';\n        this.shouldIgnoreMove = false;\n        this.shouldWatchScroll = true; // for simulating pointermove on scroll\n        // internal states\n        this.isDragging = false;\n        this.isTouchDragging = false;\n        this.wasTouchScroll = false;\n        // Mouse\n        // ----------------------------------------------------------------------------------------------------\n        this.handleMouseDown = function (ev) {\n            if (!_this.shouldIgnoreMouse() &&\n                isPrimaryMouseButton(ev) &&\n                _this.tryStart(ev)) {\n                var pev = _this.createEventFromMouse(ev, true);\n                _this.emitter.trigger('pointerdown', pev);\n                _this.initScrollWatch(pev);\n                if (!_this.shouldIgnoreMove) {\n                    document.addEventListener('mousemove', _this.handleMouseMove);\n                }\n                document.addEventListener('mouseup', _this.handleMouseUp);\n            }\n        };\n        this.handleMouseMove = function (ev) {\n            var pev = _this.createEventFromMouse(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger('pointermove', pev);\n        };\n        this.handleMouseUp = function (ev) {\n            document.removeEventListener('mousemove', _this.handleMouseMove);\n            document.removeEventListener('mouseup', _this.handleMouseUp);\n            _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));\n            _this.cleanup(); // call last so that pointerup has access to props\n        };\n        // Touch\n        // ----------------------------------------------------------------------------------------------------\n        this.handleTouchStart = function (ev) {\n            if (_this.tryStart(ev)) {\n                _this.isTouchDragging = true;\n                var pev = _this.createEventFromTouch(ev, true);\n                _this.emitter.trigger('pointerdown', pev);\n                _this.initScrollWatch(pev);\n                // unlike mouse, need to attach to target, not document\n                // https://stackoverflow.com/a/45760014\n                var targetEl = ev.target;\n                if (!_this.shouldIgnoreMove) {\n                    targetEl.addEventListener('touchmove', _this.handleTouchMove);\n                }\n                targetEl.addEventListener('touchend', _this.handleTouchEnd);\n                targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end\n                // attach a handler to get called when ANY scroll action happens on the page.\n                // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                // http://stackoverflow.com/a/32954565/96342\n                window.addEventListener('scroll', _this.handleTouchScroll, true);\n            }\n        };\n        this.handleTouchMove = function (ev) {\n            var pev = _this.createEventFromTouch(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger('pointermove', pev);\n        };\n        this.handleTouchEnd = function (ev) {\n            if (_this.isDragging) { // done to guard against touchend followed by touchcancel\n                var targetEl = ev.target;\n                targetEl.removeEventListener('touchmove', _this.handleTouchMove);\n                targetEl.removeEventListener('touchend', _this.handleTouchEnd);\n                targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);\n                window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true\n                _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));\n                _this.cleanup(); // call last so that pointerup has access to props\n                _this.isTouchDragging = false;\n                startIgnoringMouse();\n            }\n        };\n        this.handleTouchScroll = function () {\n            _this.wasTouchScroll = true;\n        };\n        this.handleScroll = function (ev) {\n            if (!_this.shouldIgnoreMove) {\n                var pageX = (window.pageXOffset - _this.prevScrollX) + _this.prevPageX;\n                var pageY = (window.pageYOffset - _this.prevScrollY) + _this.prevPageY;\n                _this.emitter.trigger('pointermove', {\n                    origEvent: ev,\n                    isTouch: _this.isTouchDragging,\n                    subjectEl: _this.subjectEl,\n                    pageX: pageX,\n                    pageY: pageY,\n                    deltaX: pageX - _this.origPageX,\n                    deltaY: pageY - _this.origPageY,\n                });\n            }\n        };\n        this.containerEl = containerEl;\n        this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n        containerEl.addEventListener('mousedown', this.handleMouseDown);\n        containerEl.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        listenerCreated();\n    }\n    PointerDragging.prototype.destroy = function () {\n        this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n        this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        listenerDestroyed();\n    };\n    PointerDragging.prototype.tryStart = function (ev) {\n        var subjectEl = this.querySubjectEl(ev);\n        var downEl = ev.target;\n        if (subjectEl &&\n            (!this.handleSelector || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, this.handleSelector))) {\n            this.subjectEl = subjectEl;\n            this.isDragging = true; // do this first so cancelTouchScroll will work\n            this.wasTouchScroll = false;\n            return true;\n        }\n        return false;\n    };\n    PointerDragging.prototype.cleanup = function () {\n        isWindowTouchMoveCancelled = false;\n        this.isDragging = false;\n        this.subjectEl = null;\n        // keep wasTouchScroll around for later access\n        this.destroyScrollWatch();\n    };\n    PointerDragging.prototype.querySubjectEl = function (ev) {\n        if (this.selector) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.target, this.selector);\n        }\n        return this.containerEl;\n    };\n    PointerDragging.prototype.shouldIgnoreMouse = function () {\n        return ignoreMouseDepth || this.isTouchDragging;\n    };\n    // can be called by user of this class, to cancel touch-based scrolling for the current drag\n    PointerDragging.prototype.cancelTouchScroll = function () {\n        if (this.isDragging) {\n            isWindowTouchMoveCancelled = true;\n        }\n    };\n    // Scrolling that simulates pointermoves\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.initScrollWatch = function (ev) {\n        if (this.shouldWatchScroll) {\n            this.recordCoords(ev);\n            window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n        }\n    };\n    PointerDragging.prototype.recordCoords = function (ev) {\n        if (this.shouldWatchScroll) {\n            this.prevPageX = ev.pageX;\n            this.prevPageY = ev.pageY;\n            this.prevScrollX = window.pageXOffset;\n            this.prevScrollY = window.pageYOffset;\n        }\n    };\n    PointerDragging.prototype.destroyScrollWatch = function () {\n        if (this.shouldWatchScroll) {\n            window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n        }\n    };\n    // Event Normalization\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {\n        var deltaX = 0;\n        var deltaY = 0;\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = ev.pageX;\n            this.origPageY = ev.pageY;\n        }\n        else {\n            deltaX = ev.pageX - this.origPageX;\n            deltaY = ev.pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: false,\n            subjectEl: this.subjectEl,\n            pageX: ev.pageX,\n            pageY: ev.pageY,\n            deltaX: deltaX,\n            deltaY: deltaY,\n        };\n    };\n    PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {\n        var touches = ev.touches;\n        var pageX;\n        var pageY;\n        var deltaX = 0;\n        var deltaY = 0;\n        // if touch coords available, prefer,\n        // because FF would give bad ev.pageX ev.pageY\n        if (touches && touches.length) {\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        }\n        else {\n            pageX = ev.pageX;\n            pageY = ev.pageY;\n        }\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = pageX;\n            this.origPageY = pageY;\n        }\n        else {\n            deltaX = pageX - this.origPageX;\n            deltaY = pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: true,\n            subjectEl: this.subjectEl,\n            pageX: pageX,\n            pageY: pageY,\n            deltaX: deltaX,\n            deltaY: deltaY,\n        };\n    };\n    return PointerDragging;\n}());\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n    return ev.button === 0 && !ev.ctrlKey;\n}\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\nfunction startIgnoringMouse() {\n    ignoreMouseDepth += 1;\n    setTimeout(function () {\n        ignoreMouseDepth -= 1;\n    }, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait);\n}\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\nfunction listenerCreated() {\n    listenerCnt += 1;\n    if (listenerCnt === 1) {\n        window.addEventListener('touchmove', onWindowTouchMove, { passive: false });\n    }\n}\nfunction listenerDestroyed() {\n    listenerCnt -= 1;\n    if (!listenerCnt) {\n        window.removeEventListener('touchmove', onWindowTouchMove, { passive: false });\n    }\n}\nfunction onWindowTouchMove(ev) {\n    if (isWindowTouchMoveCancelled) {\n        ev.preventDefault();\n    }\n}\n\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/\nvar ElementMirror = /** @class */ (function () {\n    function ElementMirror() {\n        this.isVisible = false; // must be explicitly enabled\n        this.sourceEl = null;\n        this.mirrorEl = null;\n        this.sourceElRect = null; // screen coords relative to viewport\n        // options that can be set directly by caller\n        this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n        this.zIndex = 9999;\n        this.revertDuration = 0;\n    }\n    ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {\n        this.sourceEl = sourceEl;\n        this.sourceElRect = this.sourceEl.getBoundingClientRect();\n        this.origScreenX = pageX - window.pageXOffset;\n        this.origScreenY = pageY - window.pageYOffset;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.updateElPosition();\n    };\n    ElementMirror.prototype.handleMove = function (pageX, pageY) {\n        this.deltaX = (pageX - window.pageXOffset) - this.origScreenX;\n        this.deltaY = (pageY - window.pageYOffset) - this.origScreenY;\n        this.updateElPosition();\n    };\n    // can be called before start\n    ElementMirror.prototype.setIsVisible = function (bool) {\n        if (bool) {\n            if (!this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = '';\n                }\n                this.isVisible = bool; // needs to happen before updateElPosition\n                this.updateElPosition(); // because was not updating the position while invisible\n            }\n        }\n        else if (this.isVisible) {\n            if (this.mirrorEl) {\n                this.mirrorEl.style.display = 'none';\n            }\n            this.isVisible = bool;\n        }\n    };\n    // always async\n    ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {\n        var _this = this;\n        var done = function () {\n            _this.cleanup();\n            callback();\n        };\n        if (needsRevertAnimation &&\n            this.mirrorEl &&\n            this.isVisible &&\n            this.revertDuration && // if 0, transition won't work\n            (this.deltaX || this.deltaY) // if same coords, transition won't work\n        ) {\n            this.doRevertAnimation(done, this.revertDuration);\n        }\n        else {\n            setTimeout(done, 0);\n        }\n    };\n    ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {\n        var mirrorEl = this.mirrorEl;\n        var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n        mirrorEl.style.transition =\n            'top ' + revertDuration + 'ms,' +\n                'left ' + revertDuration + 'ms';\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n            left: finalSourceElRect.left,\n            top: finalSourceElRect.top,\n        });\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.whenTransitionDone)(mirrorEl, function () {\n            mirrorEl.style.transition = '';\n            callback();\n        });\n    };\n    ElementMirror.prototype.cleanup = function () {\n        if (this.mirrorEl) {\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.removeElement)(this.mirrorEl);\n            this.mirrorEl = null;\n        }\n        this.sourceEl = null;\n    };\n    ElementMirror.prototype.updateElPosition = function () {\n        if (this.sourceEl && this.isVisible) {\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(this.getMirrorEl(), {\n                left: this.sourceElRect.left + this.deltaX,\n                top: this.sourceElRect.top + this.deltaY,\n            });\n        }\n    };\n    ElementMirror.prototype.getMirrorEl = function () {\n        var sourceElRect = this.sourceElRect;\n        var mirrorEl = this.mirrorEl;\n        if (!mirrorEl) {\n            mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n            // we don't want long taps or any mouse interaction causing selection/menus.\n            // would use preventSelection(), but that prevents selectstart, causing problems.\n            mirrorEl.classList.add('fc-unselectable');\n            mirrorEl.classList.add('fc-event-dragging');\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n                position: 'fixed',\n                zIndex: this.zIndex,\n                visibility: '',\n                boxSizing: 'border-box',\n                width: sourceElRect.right - sourceElRect.left,\n                height: sourceElRect.bottom - sourceElRect.top,\n                right: 'auto',\n                bottom: 'auto',\n                margin: 0,\n            });\n            this.parentNode.appendChild(mirrorEl);\n        }\n        return mirrorEl;\n    };\n    return ElementMirror;\n}());\n\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/\nvar ScrollGeomCache = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ScrollGeomCache, _super);\n    function ScrollGeomCache(scrollController, doesListening) {\n        var _this = _super.call(this) || this;\n        _this.handleScroll = function () {\n            _this.scrollTop = _this.scrollController.getScrollTop();\n            _this.scrollLeft = _this.scrollController.getScrollLeft();\n            _this.handleScrollChange();\n        };\n        _this.scrollController = scrollController;\n        _this.doesListening = doesListening;\n        _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n        _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n        _this.scrollWidth = scrollController.getScrollWidth();\n        _this.scrollHeight = scrollController.getScrollHeight();\n        _this.clientWidth = scrollController.getClientWidth();\n        _this.clientHeight = scrollController.getClientHeight();\n        _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n        if (_this.doesListening) {\n            _this.getEventTarget().addEventListener('scroll', _this.handleScroll);\n        }\n        return _this;\n    }\n    ScrollGeomCache.prototype.destroy = function () {\n        if (this.doesListening) {\n            this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n        }\n    };\n    ScrollGeomCache.prototype.getScrollTop = function () {\n        return this.scrollTop;\n    };\n    ScrollGeomCache.prototype.getScrollLeft = function () {\n        return this.scrollLeft;\n    };\n    ScrollGeomCache.prototype.setScrollTop = function (top) {\n        this.scrollController.setScrollTop(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.setScrollLeft = function (top) {\n        this.scrollController.setScrollLeft(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.getClientWidth = function () {\n        return this.clientWidth;\n    };\n    ScrollGeomCache.prototype.getClientHeight = function () {\n        return this.clientHeight;\n    };\n    ScrollGeomCache.prototype.getScrollWidth = function () {\n        return this.scrollWidth;\n    };\n    ScrollGeomCache.prototype.getScrollHeight = function () {\n        return this.scrollHeight;\n    };\n    ScrollGeomCache.prototype.handleScrollChange = function () {\n    };\n    return ScrollGeomCache;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ScrollController));\n\nvar ElementScrollGeomCache = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ElementScrollGeomCache, _super);\n    function ElementScrollGeomCache(el, doesListening) {\n        return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementScrollController(el), doesListening) || this;\n    }\n    ElementScrollGeomCache.prototype.getEventTarget = function () {\n        return this.scrollController.el;\n    };\n    ElementScrollGeomCache.prototype.computeClientRect = function () {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeInnerRect)(this.scrollController.el);\n    };\n    return ElementScrollGeomCache;\n}(ScrollGeomCache));\n\nvar WindowScrollGeomCache = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WindowScrollGeomCache, _super);\n    function WindowScrollGeomCache(doesListening) {\n        return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WindowScrollController(), doesListening) || this;\n    }\n    WindowScrollGeomCache.prototype.getEventTarget = function () {\n        return window;\n    };\n    WindowScrollGeomCache.prototype.computeClientRect = function () {\n        return {\n            left: this.scrollLeft,\n            right: this.scrollLeft + this.clientWidth,\n            top: this.scrollTop,\n            bottom: this.scrollTop + this.clientHeight,\n        };\n    };\n    // the window is the only scroll object that changes it's rectangle relative\n    // to the document's topleft as it scrolls\n    WindowScrollGeomCache.prototype.handleScrollChange = function () {\n        this.clientRect = this.computeClientRect();\n    };\n    return WindowScrollGeomCache;\n}(ScrollGeomCache));\n\n// If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nvar getTime = typeof performance === 'function' ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/\nvar AutoScroller = /** @class */ (function () {\n    function AutoScroller() {\n        var _this = this;\n        // options that can be set by caller\n        this.isEnabled = true;\n        this.scrollQuery = [window, '.fc-scroller'];\n        this.edgeThreshold = 50; // pixels\n        this.maxVelocity = 300; // pixels per second\n        // internal state\n        this.pointerScreenX = null;\n        this.pointerScreenY = null;\n        this.isAnimating = false;\n        this.scrollCaches = null;\n        // protect against the initial pointerdown being too close to an edge and starting the scroll\n        this.everMovedUp = false;\n        this.everMovedDown = false;\n        this.everMovedLeft = false;\n        this.everMovedRight = false;\n        this.animate = function () {\n            if (_this.isAnimating) { // wasn't cancelled between animation calls\n                var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n                if (edge) {\n                    var now = getTime();\n                    _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n                    _this.requestAnimation(now);\n                }\n                else {\n                    _this.isAnimating = false; // will stop animation\n                }\n            }\n        };\n    }\n    AutoScroller.prototype.start = function (pageX, pageY, scrollStartEl) {\n        if (this.isEnabled) {\n            this.scrollCaches = this.buildCaches(scrollStartEl);\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.handleMove(pageX, pageY);\n        }\n    };\n    AutoScroller.prototype.handleMove = function (pageX, pageY) {\n        if (this.isEnabled) {\n            var pointerScreenX = pageX - window.pageXOffset;\n            var pointerScreenY = pageY - window.pageYOffset;\n            var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n            var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n            if (yDelta < 0) {\n                this.everMovedUp = true;\n            }\n            else if (yDelta > 0) {\n                this.everMovedDown = true;\n            }\n            if (xDelta < 0) {\n                this.everMovedLeft = true;\n            }\n            else if (xDelta > 0) {\n                this.everMovedRight = true;\n            }\n            this.pointerScreenX = pointerScreenX;\n            this.pointerScreenY = pointerScreenY;\n            if (!this.isAnimating) {\n                this.isAnimating = true;\n                this.requestAnimation(getTime());\n            }\n        }\n    };\n    AutoScroller.prototype.stop = function () {\n        if (this.isEnabled) {\n            this.isAnimating = false; // will stop animation\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                scrollCache.destroy();\n            }\n            this.scrollCaches = null;\n        }\n    };\n    AutoScroller.prototype.requestAnimation = function (now) {\n        this.msSinceRequest = now;\n        requestAnimationFrame(this.animate);\n    };\n    AutoScroller.prototype.handleSide = function (edge, seconds) {\n        var scrollCache = edge.scrollCache;\n        var edgeThreshold = this.edgeThreshold;\n        var invDistance = edgeThreshold - edge.distance;\n        var velocity = // the closer to the edge, the faster we scroll\n         ((invDistance * invDistance) / (edgeThreshold * edgeThreshold)) * // quadratic\n            this.maxVelocity * seconds;\n        var sign = 1;\n        switch (edge.name) {\n            case 'left':\n                sign = -1;\n            // falls through\n            case 'right':\n                scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                break;\n            case 'top':\n                sign = -1;\n            // falls through\n            case 'bottom':\n                scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                break;\n        }\n    };\n    // left/top are relative to document topleft\n    AutoScroller.prototype.computeBestEdge = function (left, top) {\n        var edgeThreshold = this.edgeThreshold;\n        var bestSide = null;\n        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n            var scrollCache = _a[_i];\n            var rect = scrollCache.clientRect;\n            var leftDist = left - rect.left;\n            var rightDist = rect.right - left;\n            var topDist = top - rect.top;\n            var bottomDist = rect.bottom - top;\n            // completely within the rect?\n            if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&\n                    (!bestSide || bestSide.distance > topDist)) {\n                    bestSide = { scrollCache: scrollCache, name: 'top', distance: topDist };\n                }\n                if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&\n                    (!bestSide || bestSide.distance > bottomDist)) {\n                    bestSide = { scrollCache: scrollCache, name: 'bottom', distance: bottomDist };\n                }\n                if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&\n                    (!bestSide || bestSide.distance > leftDist)) {\n                    bestSide = { scrollCache: scrollCache, name: 'left', distance: leftDist };\n                }\n                if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&\n                    (!bestSide || bestSide.distance > rightDist)) {\n                    bestSide = { scrollCache: scrollCache, name: 'right', distance: rightDist };\n                }\n            }\n        }\n        return bestSide;\n    };\n    AutoScroller.prototype.buildCaches = function (scrollStartEl) {\n        return this.queryScrollEls(scrollStartEl).map(function (el) {\n            if (el === window) {\n                return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n            }\n            return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n        });\n    };\n    AutoScroller.prototype.queryScrollEls = function (scrollStartEl) {\n        var els = [];\n        for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {\n            var query = _a[_i];\n            if (typeof query === 'object') {\n                els.push(query);\n            }\n            else {\n                els.push.apply(els, Array.prototype.slice.call((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(scrollStartEl).querySelectorAll(query)));\n            }\n        }\n        return els;\n    };\n    return AutoScroller;\n}());\n\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/\nvar FeaturefulElementDragging = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FeaturefulElementDragging, _super);\n    function FeaturefulElementDragging(containerEl, selector) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.containerEl = containerEl;\n        // options that can be directly set by caller\n        // the caller can also set the PointerDragging's options as well\n        _this.delay = null;\n        _this.minDistance = 0;\n        _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n        _this.mirrorNeedsRevert = false;\n        _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n        _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n        _this.isDelayEnded = false;\n        _this.isDistanceSurpassed = false;\n        _this.delayTimeoutId = null;\n        _this.onPointerDown = function (ev) {\n            if (!_this.isDragging) { // so new drag doesn't happen while revert animation is going\n                _this.isInteracting = true;\n                _this.isDelayEnded = false;\n                _this.isDistanceSurpassed = false;\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventSelection)(document.body);\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventContextMenu)(document.body);\n                // prevent links from being visited if there's an eventual drag.\n                // also prevents selection in older browsers (maybe?).\n                // not necessary for touch, besides, browser would complain about passiveness.\n                if (!ev.isTouch) {\n                    ev.origEvent.preventDefault();\n                }\n                _this.emitter.trigger('pointerdown', ev);\n                if (_this.isInteracting && // not destroyed via pointerdown handler\n                    !_this.pointer.shouldIgnoreMove) {\n                    // actions related to initiating dragstart+dragmove+dragend...\n                    _this.mirror.setIsVisible(false); // reset. caller must set-visible\n                    _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                    _this.startDelay(ev);\n                    if (!_this.minDistance) {\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n            }\n        };\n        _this.onPointerMove = function (ev) {\n            if (_this.isInteracting) {\n                _this.emitter.trigger('pointermove', ev);\n                if (!_this.isDistanceSurpassed) {\n                    var minDistance = _this.minDistance;\n                    var distanceSq = void 0; // current distance from the origin, squared\n                    var deltaX = ev.deltaX, deltaY = ev.deltaY;\n                    distanceSq = deltaX * deltaX + deltaY * deltaY;\n                    if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n                if (_this.isDragging) {\n                    // a real pointer move? (not one simulated by scrolling)\n                    if (ev.origEvent.type !== 'scroll') {\n                        _this.mirror.handleMove(ev.pageX, ev.pageY);\n                        _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                    }\n                    _this.emitter.trigger('dragmove', ev);\n                }\n            }\n        };\n        _this.onPointerUp = function (ev) {\n            if (_this.isInteracting) {\n                _this.isInteracting = false;\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowSelection)(document.body);\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowContextMenu)(document.body);\n                _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n                if (_this.isDragging) {\n                    _this.autoScroller.stop();\n                    _this.tryStopDrag(ev); // which will stop the mirror\n                }\n                if (_this.delayTimeoutId) {\n                    clearTimeout(_this.delayTimeoutId);\n                    _this.delayTimeoutId = null;\n                }\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on('pointerdown', _this.onPointerDown);\n        pointer.emitter.on('pointermove', _this.onPointerMove);\n        pointer.emitter.on('pointerup', _this.onPointerUp);\n        if (selector) {\n            pointer.selector = selector;\n        }\n        _this.mirror = new ElementMirror();\n        _this.autoScroller = new AutoScroller();\n        return _this;\n    }\n    FeaturefulElementDragging.prototype.destroy = function () {\n        this.pointer.destroy();\n        // HACK: simulate a pointer-up to end the current drag\n        // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n        this.onPointerUp({});\n    };\n    FeaturefulElementDragging.prototype.startDelay = function (ev) {\n        var _this = this;\n        if (typeof this.delay === 'number') {\n            this.delayTimeoutId = setTimeout(function () {\n                _this.delayTimeoutId = null;\n                _this.handleDelayEnd(ev);\n            }, this.delay); // not assignable to number!\n        }\n        else {\n            this.handleDelayEnd(ev);\n        }\n    };\n    FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {\n        this.isDelayEnded = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {\n        this.isDistanceSurpassed = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {\n        if (this.isDelayEnded && this.isDistanceSurpassed) {\n            if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                this.isDragging = true;\n                this.mirrorNeedsRevert = false;\n                this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                this.emitter.trigger('dragstart', ev);\n                if (this.touchScrollAllowed === false) {\n                    this.pointer.cancelTouchScroll();\n                }\n            }\n        }\n    };\n    FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {\n        // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n        // that come from the document to fire beforehand. much more convenient this way.\n        this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n    };\n    FeaturefulElementDragging.prototype.stopDrag = function (ev) {\n        this.isDragging = false;\n        this.emitter.trigger('dragend', ev);\n    };\n    // fill in the implementations...\n    FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {\n        this.pointer.shouldIgnoreMove = bool;\n    };\n    FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {\n        this.mirror.setIsVisible(bool);\n    };\n    FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n        this.mirrorNeedsRevert = bool;\n    };\n    FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n        this.autoScroller.isEnabled = bool;\n    };\n    return FeaturefulElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging));\n\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/\nvar OffsetTracker = /** @class */ (function () {\n    function OffsetTracker(el) {\n        this.origRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(el);\n        // will work fine for divs that have overflow:hidden\n        this.scrollCaches = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getClippingParents)(el).map(function (scrollEl) { return new ElementScrollGeomCache(scrollEl, true); });\n    }\n    OffsetTracker.prototype.destroy = function () {\n        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n            var scrollCache = _a[_i];\n            scrollCache.destroy();\n        }\n    };\n    OffsetTracker.prototype.computeLeft = function () {\n        var left = this.origRect.left;\n        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n            var scrollCache = _a[_i];\n            left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n        }\n        return left;\n    };\n    OffsetTracker.prototype.computeTop = function () {\n        var top = this.origRect.top;\n        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n            var scrollCache = _a[_i];\n            top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n        }\n        return top;\n    };\n    OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {\n        var point = { left: pageX, top: pageY };\n        for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n            var scrollCache = _a[_i];\n            if (!isIgnoredClipping(scrollCache.getEventTarget()) &&\n                !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.pointInsideRect)(point, scrollCache.clientRect)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return OffsetTracker;\n}());\n// certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node) {\n    var tagName = node.tagName;\n    return tagName === 'HTML' || tagName === 'BODY';\n}\n\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/\nvar HitDragging = /** @class */ (function () {\n    function HitDragging(dragging, droppableStore) {\n        var _this = this;\n        // options that can be set by caller\n        this.useSubjectCenter = false;\n        this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n        this.initialHit = null;\n        this.movingHit = null;\n        this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n        this.handlePointerDown = function (ev) {\n            var dragging = _this.dragging;\n            _this.initialHit = null;\n            _this.movingHit = null;\n            _this.finalHit = null;\n            _this.prepareHits();\n            _this.processFirstCoord(ev);\n            if (_this.initialHit || !_this.requireInitial) {\n                dragging.setIgnoreMove(false);\n                // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                _this.emitter.trigger('pointerdown', ev);\n            }\n            else {\n                dragging.setIgnoreMove(true);\n            }\n        };\n        this.handleDragStart = function (ev) {\n            _this.emitter.trigger('dragstart', ev);\n            _this.handleMove(ev, true); // force = fire even if initially null\n        };\n        this.handleDragMove = function (ev) {\n            _this.emitter.trigger('dragmove', ev);\n            _this.handleMove(ev);\n        };\n        this.handlePointerUp = function (ev) {\n            _this.releaseHits();\n            _this.emitter.trigger('pointerup', ev);\n        };\n        this.handleDragEnd = function (ev) {\n            if (_this.movingHit) {\n                _this.emitter.trigger('hitupdate', null, true, ev);\n            }\n            _this.finalHit = _this.movingHit;\n            _this.movingHit = null;\n            _this.emitter.trigger('dragend', ev);\n        };\n        this.droppableStore = droppableStore;\n        dragging.emitter.on('pointerdown', this.handlePointerDown);\n        dragging.emitter.on('dragstart', this.handleDragStart);\n        dragging.emitter.on('dragmove', this.handleDragMove);\n        dragging.emitter.on('pointerup', this.handlePointerUp);\n        dragging.emitter.on('dragend', this.handleDragEnd);\n        this.dragging = dragging;\n        this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n    }\n    // sets initialHit\n    // sets coordAdjust\n    HitDragging.prototype.processFirstCoord = function (ev) {\n        var origPoint = { left: ev.pageX, top: ev.pageY };\n        var adjustedPoint = origPoint;\n        var subjectEl = ev.subjectEl;\n        var subjectRect;\n        if (subjectEl instanceof HTMLElement) { // i.e. not a Document/ShadowRoot\n            subjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(subjectEl);\n            adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.constrainPoint)(adjustedPoint, subjectRect);\n        }\n        var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n        if (initialHit) {\n            if (this.useSubjectCenter && subjectRect) {\n                var slicedSubjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRects)(subjectRect, initialHit.rect);\n                if (slicedSubjectRect) {\n                    adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRectCenter)(slicedSubjectRect);\n                }\n            }\n            this.coordAdjust = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffPoints)(adjustedPoint, origPoint);\n        }\n        else {\n            this.coordAdjust = { left: 0, top: 0 };\n        }\n    };\n    HitDragging.prototype.handleMove = function (ev, forceHandle) {\n        var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n        if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n            this.movingHit = hit;\n            this.emitter.trigger('hitupdate', hit, false, ev);\n        }\n    };\n    HitDragging.prototype.prepareHits = function () {\n        this.offsetTrackers = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.mapHash)(this.droppableStore, function (interactionSettings) {\n            interactionSettings.component.prepareHits();\n            return new OffsetTracker(interactionSettings.el);\n        });\n    };\n    HitDragging.prototype.releaseHits = function () {\n        var offsetTrackers = this.offsetTrackers;\n        for (var id in offsetTrackers) {\n            offsetTrackers[id].destroy();\n        }\n        this.offsetTrackers = {};\n    };\n    HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {\n        var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;\n        var bestHit = null;\n        for (var id in droppableStore) {\n            var component = droppableStore[id].component;\n            var offsetTracker = offsetTrackers[id];\n            if (offsetTracker && // wasn't destroyed mid-drag\n                offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                var originLeft = offsetTracker.computeLeft();\n                var originTop = offsetTracker.computeTop();\n                var positionLeft = offsetLeft - originLeft;\n                var positionTop = offsetTop - originTop;\n                var origRect = offsetTracker.origRect;\n                var width = origRect.right - origRect.left;\n                var height = origRect.bottom - origRect.top;\n                if (\n                // must be within the element's bounds\n                positionLeft >= 0 && positionLeft < width &&\n                    positionTop >= 0 && positionTop < height) {\n                    var hit = component.queryHit(positionLeft, positionTop, width, height);\n                    if (hit && (\n                    // make sure the hit is within activeRange, meaning it's not a dead cell\n                    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.rangeContainsRange)(hit.dateProfile.activeRange, hit.dateSpan.range)) &&\n                        (!bestHit || hit.layer > bestHit.layer)) {\n                        hit.componentId = id;\n                        hit.context = component.context;\n                        // TODO: better way to re-orient rectangle\n                        hit.rect.left += originLeft;\n                        hit.rect.right += originLeft;\n                        hit.rect.top += originTop;\n                        hit.rect.bottom += originTop;\n                        bestHit = hit;\n                    }\n                }\n            }\n        }\n        return bestHit;\n    };\n    return HitDragging;\n}());\nfunction isHitsEqual(hit0, hit1) {\n    if (!hit0 && !hit1) {\n        return true;\n    }\n    if (Boolean(hit0) !== Boolean(hit1)) {\n        return false;\n    }\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSpansEqual)(hit0.dateSpan, hit1.dateSpan);\n}\n\nfunction buildDatePointApiWithContext(dateSpan, context) {\n    var props = {};\n    for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {\n        var transform = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, transform(dateSpan, context));\n    }\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, buildDatePointApi(dateSpan, context.dateEnv));\n    return props;\n}\nfunction buildDatePointApi(span, dateEnv) {\n    return {\n        date: dateEnv.toDate(span.range.start),\n        dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),\n        allDay: span.allDay,\n    };\n}\n\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/\nvar DateClicking = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateClicking, _super);\n    function DateClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handlePointerDown = function (pev) {\n            var dragging = _this.dragging;\n            var downEl = pev.origEvent.target;\n            // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n            dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n        };\n        // won't even fire if moving was ignored\n        _this.handleDragEnd = function (ev) {\n            var component = _this.component;\n            var pointer = _this.dragging.pointer;\n            if (!pointer.wasTouchScroll) {\n                var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;\n                if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                    var context = component.context;\n                    var arg = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });\n                    context.emitter.trigger('dateClick', arg);\n                }\n            }\n        };\n        // we DO want to watch pointer moves because otherwise finalHit won't get populated\n        _this.dragging = new FeaturefulElementDragging(settings.el);\n        _this.dragging.autoScroller.isEnabled = false;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n        hitDragging.emitter.on('dragend', _this.handleDragEnd);\n        return _this;\n    }\n    DateClicking.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    return DateClicking;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction));\n\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/\nvar DateSelecting = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateSelecting, _super);\n    function DateSelecting(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.dragSelection = null;\n        _this.handlePointerDown = function (ev) {\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var options = component.context.options;\n            var canSelect = options.selectable &&\n                component.isValidDateDownEl(ev.origEvent.target);\n            // don't bother to watch expensive moves if component won't do selection\n            dragging.setIgnoreMove(!canSelect);\n            // if touch, require user to hold down\n            dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n        };\n        _this.handleDragStart = function (ev) {\n            _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n        };\n        _this.handleHitUpdate = function (hit, isFinal) {\n            var context = _this.component.context;\n            var dragSelection = null;\n            var isInvalid = false;\n            if (hit) {\n                var initialHit = _this.hitDragging.initialHit;\n                var disallowed = hit.componentId === initialHit.componentId\n                    && _this.isHitComboAllowed\n                    && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                }\n                if (!dragSelection || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSelectionValid)(dragSelection, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    dragSelection = null;\n                }\n            }\n            if (dragSelection) {\n                context.dispatch({ type: 'SELECT_DATES', selection: dragSelection });\n            }\n            else if (!isFinal) { // only unselect if moved away while dragging\n                context.dispatch({ type: 'UNSELECT_DATES' });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            }\n            else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n            }\n        };\n        _this.handlePointerUp = function (pev) {\n            if (_this.dragSelection) {\n                // selection is already rendered, so just need to report selection\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.triggerDateSelect)(_this.dragSelection, pev, _this.component.context);\n                _this.dragSelection = null;\n            }\n        };\n        var component = settings.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.touchScrollAllowed = false;\n        dragging.minDistance = options.selectMinDistance || 0;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n        hitDragging.emitter.on('dragstart', _this.handleDragStart);\n        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n        hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n        return _this;\n    }\n    DateSelecting.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    return DateSelecting;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction));\nfunction getComponentTouchDelay$1(component) {\n    var options = component.context.options;\n    var delay = options.selectLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var ms = [\n        dateSpan0.range.start,\n        dateSpan0.range.end,\n        dateSpan1.range.start,\n        dateSpan1.range.end,\n    ];\n    ms.sort(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.compareNumbers);\n    var props = {};\n    for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {\n        var transformer = dateSelectionTransformers_1[_i];\n        var res = transformer(hit0, hit1);\n        if (res === false) {\n            return null;\n        }\n        if (res) {\n            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, res);\n        }\n    }\n    props.range = { start: ms[0], end: ms[3] };\n    props.allDay = dateSpan0.allDay;\n    return props;\n}\n\nvar EventDragging = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventDragging, _super);\n    function EventDragging(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.subjectEl = null;\n        _this.subjectSeg = null; // the seg being selected/dragged\n        _this.isDragging = false;\n        _this.eventRange = null;\n        _this.relevantEvents = null; // the events being dragged\n        _this.receivingContext = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function (ev) {\n            var origTarget = ev.origEvent.target;\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var mirror = dragging.mirror;\n            var options = component.context.options;\n            var initialContext = component.context;\n            _this.subjectEl = ev.subjectEl;\n            var subjectSeg = _this.subjectSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(ev.subjectEl);\n            var eventRange = _this.eventRange = subjectSeg.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(initialContext.getCurrentData().eventStore, eventInstanceId);\n            dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n            dragging.delay =\n                // only do a touch delay if touch and this event hasn't been selected yet\n                (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?\n                    getComponentTouchDelay(component) :\n                    null;\n            if (options.fixedMirrorParent) {\n                mirror.parentNode = options.fixedMirrorParent;\n            }\n            else {\n                mirror.parentNode = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc');\n            }\n            mirror.revertDuration = options.dragRevertDuration;\n            var isValid = component.isValidSegDownEl(origTarget) &&\n                !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc-event-resizer'); // NOT on a resizer\n            dragging.setIgnoreMove(!isValid);\n            // disable dragging for elements that are resizable (ie, selectable)\n            // but are not draggable\n            _this.isDragging = isValid &&\n                ev.subjectEl.classList.contains('fc-event-draggable');\n        };\n        _this.handleDragStart = function (ev) {\n            var initialContext = _this.component.context;\n            var eventRange = _this.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            if (ev.isTouch) {\n                // need to select a different event?\n                if (eventInstanceId !== _this.component.props.eventSelection) {\n                    initialContext.dispatch({ type: 'SELECT_EVENT', eventInstanceId: eventInstanceId });\n                }\n            }\n            else {\n                // if now using mouse, but was previous touch interaction, clear selected event\n                initialContext.dispatch({ type: 'UNSELECT_EVENT' });\n            }\n            if (_this.isDragging) {\n                initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                initialContext.emitter.trigger('eventDragStart', {\n                    el: _this.subjectEl,\n                    event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: initialContext.viewApi,\n                });\n            }\n        };\n        _this.handleHitUpdate = function (hit, isFinal) {\n            if (!_this.isDragging) {\n                return;\n            }\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var initialContext = _this.component.context;\n            // states based on new hit\n            var receivingContext = null;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: true,\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                var receivingOptions = receivingContext.options;\n                if (initialContext === receivingContext ||\n                    (receivingOptions.editable && receivingOptions.droppable)) {\n                    mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                    if (mutation) {\n                        mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                        interaction.mutatedEvents = mutatedRelevantEvents;\n                        if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext)) {\n                            isInvalid = true;\n                            mutation = null;\n                            mutatedRelevantEvents = null;\n                            interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n                        }\n                    }\n                }\n                else {\n                    receivingContext = null;\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            }\n            else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                if (initialContext === receivingContext && // TODO: write test for this\n                    isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.dragging.setMirrorNeedsRevert(!mutation);\n                // render the mirror if no already-rendered mirror\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                _this.dragging.setMirrorIsVisible(!hit || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(_this.subjectEl).querySelector('.fc-event-mirror'));\n                // assign states based on new hit\n                _this.receivingContext = receivingContext;\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handlePointerUp = function () {\n            if (!_this.isDragging) {\n                _this.cleanup(); // because handleDragEnd won't fire\n            }\n        };\n        _this.handleDragEnd = function (ev) {\n            if (_this.isDragging) {\n                var initialContext_1 = _this.component.context;\n                var initialView = initialContext_1.viewApi;\n                var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;\n                var eventDef = _this.eventRange.def;\n                var eventInstance = _this.eventRange.instance;\n                var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, eventDef, eventInstance);\n                var relevantEvents_1 = _this.relevantEvents;\n                var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n                var finalHit = _this.hitDragging.finalHit;\n                _this.clearDrag(); // must happen after revert animation\n                initialContext_1.emitter.trigger('eventDragStop', {\n                    el: _this.subjectEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: initialView,\n                });\n                if (validMutation) {\n                    // dropped within same calendar\n                    if (receivingContext_1 === initialContext_1) {\n                        var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n                        initialContext_1.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: mutatedRelevantEvents_1,\n                        });\n                        var eventChangeArg = {\n                            oldEvent: eventApi,\n                            event: updatedEventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n                            revert: function () {\n                                initialContext_1.dispatch({\n                                    type: 'MERGE_EVENTS',\n                                    eventStore: relevantEvents_1, // the pre-change data\n                                });\n                            },\n                        };\n                        var transformed = {};\n                        for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {\n                            var transformer = _b[_i];\n                            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(transformed, transformer(validMutation, initialContext_1));\n                        }\n                        initialContext_1.emitter.trigger('eventDrop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));\n                        initialContext_1.emitter.trigger('eventChange', eventChangeArg);\n                        // dropped in different calendar\n                    }\n                    else if (receivingContext_1) {\n                        var eventRemoveArg = {\n                            event: eventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(relevantEvents_1, initialContext_1, eventInstance),\n                            revert: function () {\n                                initialContext_1.dispatch({\n                                    type: 'MERGE_EVENTS',\n                                    eventStore: relevantEvents_1,\n                                });\n                            },\n                        };\n                        initialContext_1.emitter.trigger('eventLeave', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));\n                        initialContext_1.dispatch({\n                            type: 'REMOVE_EVENTS',\n                            eventStore: relevantEvents_1,\n                        });\n                        initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);\n                        var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n                        var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n                        var addedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n                        receivingContext_1.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: mutatedRelevantEvents_1,\n                        });\n                        var eventAddArg = {\n                            event: addedEventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n                            revert: function () {\n                                receivingContext_1.dispatch({\n                                    type: 'REMOVE_EVENTS',\n                                    eventStore: mutatedRelevantEvents_1,\n                                });\n                            },\n                        };\n                        receivingContext_1.emitter.trigger('eventAdd', eventAddArg);\n                        if (ev.isTouch) {\n                            receivingContext_1.dispatch({\n                                type: 'SELECT_EVENT',\n                                eventInstanceId: eventInstance.instanceId,\n                            });\n                        }\n                        receivingContext_1.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));\n                        receivingContext_1.emitter.trigger('eventReceive', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));\n                    }\n                }\n                else {\n                    initialContext_1.emitter.trigger('_noEventDrop');\n                }\n            }\n            _this.cleanup();\n        };\n        var component = _this.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = EventDragging.SELECTOR;\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n        hitDragging.useSubjectCenter = settings.useEventCenter;\n        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n        hitDragging.emitter.on('dragstart', _this.handleDragStart);\n        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n        hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n        hitDragging.emitter.on('dragend', _this.handleDragEnd);\n        return _this;\n    }\n    EventDragging.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    // render a drag state on the next receivingCalendar\n    EventDragging.prototype.displayDrag = function (nextContext, state) {\n        var initialContext = this.component.context;\n        var prevContext = this.receivingContext;\n        // does the previous calendar need to be cleared?\n        if (prevContext && prevContext !== nextContext) {\n            // does the initial calendar need to be cleared?\n            // if so, don't clear all the way. we still need to to hide the affectedEvents\n            if (prevContext === initialContext) {\n                prevContext.dispatch({\n                    type: 'SET_EVENT_DRAG',\n                    state: {\n                        affectedEvents: state.affectedEvents,\n                        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                        isEvent: true,\n                    },\n                });\n                // completely clear the old calendar if it wasn't the initial\n            }\n            else {\n                prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n            }\n        }\n        if (nextContext) {\n            nextContext.dispatch({ type: 'SET_EVENT_DRAG', state: state });\n        }\n    };\n    EventDragging.prototype.clearDrag = function () {\n        var initialCalendar = this.component.context;\n        var receivingContext = this.receivingContext;\n        if (receivingContext) {\n            receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n        }\n        // the initial calendar might have an dummy drag state from displayDrag\n        if (initialCalendar !== receivingContext) {\n            initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });\n        }\n    };\n    EventDragging.prototype.cleanup = function () {\n        this.subjectSeg = null;\n        this.isDragging = false;\n        this.eventRange = null;\n        this.relevantEvents = null;\n        this.receivingContext = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n    };\n    // TODO: test this in IE11\n    // QUESTION: why do we need it on the resizable???\n    EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n    return EventDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction));\nfunction computeEventMutation(hit0, hit1, massagers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var date0 = dateSpan0.range.start;\n    var date1 = dateSpan1.range.start;\n    var standardProps = {};\n    if (dateSpan0.allDay !== dateSpan1.allDay) {\n        standardProps.allDay = dateSpan1.allDay;\n        standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n        if (dateSpan1.allDay) {\n            // means date1 is already start-of-day,\n            // but date0 needs to be converted\n            date0 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(date0);\n        }\n    }\n    var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ?\n        hit0.largeUnit :\n        null);\n    if (delta.milliseconds) { // has hours/minutes/seconds\n        standardProps.allDay = false;\n    }\n    var mutation = {\n        datesDelta: delta,\n        standardProps: standardProps,\n    };\n    for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {\n        var massager = massagers_1[_i];\n        massager(mutation, hit0, hit1);\n    }\n    return mutation;\n}\nfunction getComponentTouchDelay(component) {\n    var options = component.context.options;\n    var delay = options.eventLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\n\nvar EventResizing = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventResizing, _super);\n    function EventResizing(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.draggingSegEl = null;\n        _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n        _this.eventRange = null;\n        _this.relevantEvents = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function (ev) {\n            var component = _this.component;\n            var segEl = _this.querySegEl(ev);\n            var seg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n            var eventRange = _this.eventRange = seg.eventRange;\n            _this.dragging.minDistance = component.context.options.eventDragMinDistance;\n            // if touch, need to be working with a selected event\n            _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) ||\n                (ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId));\n        };\n        _this.handleDragStart = function (ev) {\n            var context = _this.component.context;\n            var eventRange = _this.eventRange;\n            _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n            var segEl = _this.querySegEl(ev);\n            _this.draggingSegEl = segEl;\n            _this.draggingSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n            context.calendarApi.unselect();\n            context.emitter.trigger('eventResizeStart', {\n                el: segEl,\n                event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventRange.def, eventRange.instance),\n                jsEvent: ev.origEvent,\n                view: context.viewApi,\n            });\n        };\n        _this.handleHitUpdate = function (hit, isFinal, ev) {\n            var context = _this.component.context;\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var eventInstance = _this.eventRange.instance;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: true,\n            };\n            if (hit) {\n                var disallowed = hit.componentId === initialHit.componentId\n                    && _this.isHitComboAllowed\n                    && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n                }\n            }\n            if (mutation) {\n                mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                interaction.mutatedEvents = mutatedRelevantEvents;\n                if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    mutation = null;\n                    mutatedRelevantEvents = null;\n                    interaction.mutatedEvents = null;\n                }\n            }\n            if (mutatedRelevantEvents) {\n                context.dispatch({\n                    type: 'SET_EVENT_RESIZE',\n                    state: interaction,\n                });\n            }\n            else {\n                context.dispatch({ type: 'UNSET_EVENT_RESIZE' });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            }\n            else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                if (mutation && isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handleDragEnd = function (ev) {\n            var context = _this.component.context;\n            var eventDef = _this.eventRange.def;\n            var eventInstance = _this.eventRange.instance;\n            var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventDef, eventInstance);\n            var relevantEvents = _this.relevantEvents;\n            var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n            context.emitter.trigger('eventResizeStop', {\n                el: _this.draggingSegEl,\n                event: eventApi,\n                jsEvent: ev.origEvent,\n                view: context.viewApi,\n            });\n            if (_this.validMutation) {\n                var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                context.dispatch({\n                    type: 'MERGE_EVENTS',\n                    eventStore: mutatedRelevantEvents,\n                });\n                var eventChangeArg = {\n                    oldEvent: eventApi,\n                    event: updatedEventApi,\n                    relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents, context, eventInstance),\n                    revert: function () {\n                        context.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: relevantEvents, // the pre-change events\n                        });\n                    },\n                };\n                context.emitter.trigger('eventResize', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), { el: _this.draggingSegEl, startDelta: _this.validMutation.startDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0), endDelta: _this.validMutation.endDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0), jsEvent: ev.origEvent, view: context.viewApi }));\n                context.emitter.trigger('eventChange', eventChangeArg);\n            }\n            else {\n                context.emitter.trigger('_noEventResize');\n            }\n            // reset all internal state\n            _this.draggingSeg = null;\n            _this.relevantEvents = null;\n            _this.validMutation = null;\n            // okay to keep eventInstance around. useful to set it in handlePointerDown\n        };\n        var component = settings.component;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = '.fc-event-resizer';\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n        hitDragging.emitter.on('dragstart', _this.handleDragStart);\n        hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n        hitDragging.emitter.on('dragend', _this.handleDragEnd);\n        return _this;\n    }\n    EventResizing.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    EventResizing.prototype.querySegEl = function (ev) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.subjectEl, '.fc-event');\n    };\n    return EventResizing;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction));\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n    var dateEnv = hit0.context.dateEnv;\n    var date0 = hit0.dateSpan.range.start;\n    var date1 = hit1.dateSpan.range.start;\n    var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, dateEnv, hit0.largeUnit);\n    if (isFromStart) {\n        if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n            return { startDelta: delta };\n        }\n    }\n    else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n        return { endDelta: delta };\n    }\n    return null;\n}\n\nvar UnselectAuto = /** @class */ (function () {\n    function UnselectAuto(context) {\n        var _this = this;\n        this.context = context;\n        this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n        this.matchesCancel = false;\n        this.matchesEvent = false;\n        this.onSelect = function (selectInfo) {\n            if (selectInfo.jsEvent) {\n                _this.isRecentPointerDateSelect = true;\n            }\n        };\n        this.onDocumentPointerDown = function (pev) {\n            var unselectCancel = _this.context.options.unselectCancel;\n            var downEl = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getEventTargetViaRoot)(pev.origEvent);\n            _this.matchesCancel = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, unselectCancel);\n            _this.matchesEvent = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, EventDragging.SELECTOR); // interaction started on an event?\n        };\n        this.onDocumentPointerUp = function (pev) {\n            var context = _this.context;\n            var documentPointer = _this.documentPointer;\n            var calendarState = context.getCurrentData();\n            // touch-scrolling should never unfocus any type of selection\n            if (!documentPointer.wasTouchScroll) {\n                if (calendarState.dateSelection && // an existing date selection?\n                    !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                ) {\n                    var unselectAuto = context.options.unselectAuto;\n                    if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n                        context.calendarApi.unselect(pev);\n                    }\n                }\n                if (calendarState.eventSelection && // an existing event selected?\n                    !_this.matchesEvent // interaction DIDN'T start on an event\n                ) {\n                    context.dispatch({ type: 'UNSELECT_EVENT' });\n                }\n            }\n            _this.isRecentPointerDateSelect = false;\n        };\n        var documentPointer = this.documentPointer = new PointerDragging(document);\n        documentPointer.shouldIgnoreMove = true;\n        documentPointer.shouldWatchScroll = false;\n        documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n        documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n        /*\n        TODO: better way to know about whether there was a selection with the pointer\n        */\n        context.emitter.on('select', this.onSelect);\n    }\n    UnselectAuto.prototype.destroy = function () {\n        this.context.emitter.off('select', this.onSelect);\n        this.documentPointer.destroy();\n    };\n    return UnselectAuto;\n}());\n\nvar OPTION_REFINERS = {\n    fixedMirrorParent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n};\nvar LISTENER_REFINERS = {\n    dateClick: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDragStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDragStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDrop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResizeStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResizeStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResize: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    drop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventReceive: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventLeave: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n};\n\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/\nvar ExternalElementDragging = /** @class */ (function () {\n    function ExternalElementDragging(dragging, suppliedDragMeta) {\n        var _this = this;\n        this.receivingContext = null;\n        this.droppableEvent = null; // will exist for all drags, even if create:false\n        this.suppliedDragMeta = null;\n        this.dragMeta = null;\n        this.handleDragStart = function (ev) {\n            _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n        };\n        this.handleHitUpdate = function (hit, isFinal, ev) {\n            var dragging = _this.hitDragging.dragging;\n            var receivingContext = null;\n            var droppableEvent = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: _this.dragMeta.create,\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                    droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n                    interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n                    isInvalid = !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext);\n                    if (isInvalid) {\n                        interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n                        droppableEvent = null;\n                    }\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n            // TODO: wish we could somehow wait for dispatch to guarantee render\n            dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            }\n            else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                dragging.setMirrorNeedsRevert(!droppableEvent);\n                _this.receivingContext = receivingContext;\n                _this.droppableEvent = droppableEvent;\n            }\n        };\n        this.handleDragEnd = function (pev) {\n            var _a = _this, receivingContext = _a.receivingContext, droppableEvent = _a.droppableEvent;\n            _this.clearDrag();\n            if (receivingContext && droppableEvent) {\n                var finalHit = _this.hitDragging.finalHit;\n                var finalView = finalHit.context.viewApi;\n                var dragMeta = _this.dragMeta;\n                receivingContext.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: pev.subjectEl, jsEvent: pev.origEvent, view: finalView }));\n                if (dragMeta.create) {\n                    var addingEvents_1 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n                    receivingContext.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: addingEvents_1,\n                    });\n                    if (pev.isTouch) {\n                        receivingContext.dispatch({\n                            type: 'SELECT_EVENT',\n                            eventInstanceId: droppableEvent.instance.instanceId,\n                        });\n                    }\n                    // signal that an external event landed\n                    receivingContext.emitter.trigger('eventReceive', {\n                        event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n                        relatedEvents: [],\n                        revert: function () {\n                            receivingContext.dispatch({\n                                type: 'REMOVE_EVENTS',\n                                eventStore: addingEvents_1,\n                            });\n                        },\n                        draggedEl: pev.subjectEl,\n                        view: finalView,\n                    });\n                }\n            }\n            _this.receivingContext = null;\n            _this.droppableEvent = null;\n        };\n        var hitDragging = this.hitDragging = new HitDragging(dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n        hitDragging.requireInitial = false; // will start outside of a component\n        hitDragging.emitter.on('dragstart', this.handleDragStart);\n        hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n        hitDragging.emitter.on('dragend', this.handleDragEnd);\n        this.suppliedDragMeta = suppliedDragMeta;\n    }\n    ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {\n        if (typeof this.suppliedDragMeta === 'object') {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta);\n        }\n        if (typeof this.suppliedDragMeta === 'function') {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta(subjectEl));\n        }\n        return getDragMetaFromEl(subjectEl);\n    };\n    ExternalElementDragging.prototype.displayDrag = function (nextContext, state) {\n        var prevContext = this.receivingContext;\n        if (prevContext && prevContext !== nextContext) {\n            prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n        }\n        if (nextContext) {\n            nextContext.dispatch({ type: 'SET_EVENT_DRAG', state: state });\n        }\n    };\n    ExternalElementDragging.prototype.clearDrag = function () {\n        if (this.receivingContext) {\n            this.receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n        }\n    };\n    ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingContext) {\n        var dropAccept = receivingContext.options.dropAccept;\n        if (typeof dropAccept === 'function') {\n            return dropAccept.call(receivingContext.calendarApi, el);\n        }\n        if (typeof dropAccept === 'string' && dropAccept) {\n            return Boolean((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementMatches)(el, dropAccept));\n        }\n        return true;\n    };\n    return ExternalElementDragging;\n}());\n// Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n    var defProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dragMeta.leftoverProps);\n    for (var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++) {\n        var transform = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(defProps, transform(dateSpan, dragMeta));\n    }\n    var _b = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.refineEventDef)(defProps, context), refined = _b.refined, extra = _b.extra;\n    var def = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseEventDef)(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd\n    context);\n    var start = dateSpan.range.start;\n    // only rely on time info if drop zone is all-day,\n    // otherwise, we already know the time\n    if (dateSpan.allDay && dragMeta.startTime) {\n        start = context.dateEnv.add(start, dragMeta.startTime);\n    }\n    var end = dragMeta.duration ?\n        context.dateEnv.add(start, dragMeta.duration) :\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getDefaultEventEnd)(dateSpan.allDay, start, context);\n    var instance = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEventInstance)(def.defId, { start: start, end: end });\n    return { def: def, instance: instance };\n}\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\nfunction getDragMetaFromEl(el) {\n    var str = getEmbeddedElData(el, 'event');\n    var obj = str ?\n        JSON.parse(str) :\n        { create: false }; // if no embedded data, assume no event creation\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(obj);\n}\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix = '';\nfunction getEmbeddedElData(el, name) {\n    var prefix = _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix;\n    var prefixedName = (prefix ? prefix + '-' : '') + name;\n    return el.getAttribute('data-' + prefixedName) || '';\n}\n\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/\nvar ExternalDraggable = /** @class */ (function () {\n    function ExternalDraggable(el, settings) {\n        var _this = this;\n        if (settings === void 0) { settings = {}; }\n        this.handlePointerDown = function (ev) {\n            var dragging = _this.dragging;\n            var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;\n            dragging.minDistance =\n                minDistance != null ?\n                    minDistance :\n                    (ev.isTouch ? 0 : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.eventDragMinDistance);\n            dragging.delay =\n                ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv\n                    (longPressDelay != null ? longPressDelay : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.longPressDelay) :\n                    0;\n        };\n        this.handleDragStart = function (ev) {\n            if (ev.isTouch &&\n                _this.dragging.delay &&\n                ev.subjectEl.classList.contains('fc-event')) {\n                _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n            }\n        };\n        this.settings = settings;\n        var dragging = this.dragging = new FeaturefulElementDragging(el);\n        dragging.touchScrollAllowed = false;\n        if (settings.itemSelector != null) {\n            dragging.pointer.selector = settings.itemSelector;\n        }\n        if (settings.appendTo != null) {\n            dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n        }\n        dragging.emitter.on('pointerdown', this.handlePointerDown);\n        dragging.emitter.on('dragstart', this.handleDragStart);\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ExternalDraggable.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    return ExternalDraggable;\n}());\n\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/\nvar InferredElementDragging = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(InferredElementDragging, _super);\n    function InferredElementDragging(containerEl) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.shouldIgnoreMove = false;\n        _this.mirrorSelector = '';\n        _this.currentMirrorEl = null;\n        _this.handlePointerDown = function (ev) {\n            _this.emitter.trigger('pointerdown', ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragstart right away. does not support delay or min-distance\n                _this.emitter.trigger('dragstart', ev);\n            }\n        };\n        _this.handlePointerMove = function (ev) {\n            if (!_this.shouldIgnoreMove) {\n                _this.emitter.trigger('dragmove', ev);\n            }\n        };\n        _this.handlePointerUp = function (ev) {\n            _this.emitter.trigger('pointerup', ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragend right away. does not support a revert animation\n                _this.emitter.trigger('dragend', ev);\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on('pointerdown', _this.handlePointerDown);\n        pointer.emitter.on('pointermove', _this.handlePointerMove);\n        pointer.emitter.on('pointerup', _this.handlePointerUp);\n        return _this;\n    }\n    InferredElementDragging.prototype.destroy = function () {\n        this.pointer.destroy();\n    };\n    InferredElementDragging.prototype.setIgnoreMove = function (bool) {\n        this.shouldIgnoreMove = bool;\n    };\n    InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {\n        if (bool) {\n            // restore a previously hidden element.\n            // use the reference in case the selector class has already been removed.\n            if (this.currentMirrorEl) {\n                this.currentMirrorEl.style.visibility = '';\n                this.currentMirrorEl = null;\n            }\n        }\n        else {\n            var mirrorEl = this.mirrorSelector\n                // TODO: somehow query FullCalendars WITHIN shadow-roots\n                ? document.querySelector(this.mirrorSelector)\n                : null;\n            if (mirrorEl) {\n                this.currentMirrorEl = mirrorEl;\n                mirrorEl.style.visibility = 'hidden';\n            }\n        }\n    };\n    return InferredElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging));\n\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/\nvar ThirdPartyDraggable = /** @class */ (function () {\n    function ThirdPartyDraggable(containerOrSettings, settings) {\n        var containerEl = document;\n        if (\n        // wish we could just test instanceof EventTarget, but doesn't work in IE11\n        containerOrSettings === document ||\n            containerOrSettings instanceof Element) {\n            containerEl = containerOrSettings;\n            settings = settings || {};\n        }\n        else {\n            settings = (containerOrSettings || {});\n        }\n        var dragging = this.dragging = new InferredElementDragging(containerEl);\n        if (typeof settings.itemSelector === 'string') {\n            dragging.pointer.selector = settings.itemSelector;\n        }\n        else if (containerEl === document) {\n            dragging.pointer.selector = '[data-event]';\n        }\n        if (typeof settings.mirrorSelector === 'string') {\n            dragging.mirrorSelector = settings.mirrorSelector;\n        }\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ThirdPartyDraggable.prototype.destroy = function () {\n        this.dragging.destroy();\n    };\n    return ThirdPartyDraggable;\n}());\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n    calendarInteractions: [UnselectAuto],\n    elementDraggingImpl: FeaturefulElementDragging,\n    optionRefiners: OPTION_REFINERS,\n    listenerRefiners: LISTENER_REFINERS,\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n//# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdThCO0FBQzM1Qjs7QUFFNUMsNkVBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFPO0FBQ2xDO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsZUFBZTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0VB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aW50ZXJhY3Rpb24vbWFpbi5qcz8yMTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjEwLjFcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIxIEFkYW0gU2hhd1xuKi9cbmltcG9ydCB7IGNvbmZpZywgZWxlbWVudENsb3Nlc3QsIEVtaXR0ZXIsIGFwcGx5U3R5bGUsIHdoZW5UcmFuc2l0aW9uRG9uZSwgcmVtb3ZlRWxlbWVudCwgU2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIGNvbXB1dGVJbm5lclJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsIGdldEVsUm9vdCwgcHJldmVudFNlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd1NlbGVjdGlvbiwgYWxsb3dDb250ZXh0TWVudSwgRWxlbWVudERyYWdnaW5nLCBjb21wdXRlUmVjdCwgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBwb2ludEluc2lkZVJlY3QsIGlzRGF0ZVNwYW5zRXF1YWwsIGNvbnN0cmFpblBvaW50LCBpbnRlcnNlY3RSZWN0cywgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgbWFwSGFzaCwgcmFuZ2VDb250YWluc1JhbmdlLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSwgSW50ZXJhY3Rpb24sIGlzRGF0ZVNlbGVjdGlvblZhbGlkLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsIHRyaWdnZXJEYXRlU2VsZWN0LCBjb21wYXJlTnVtYmVycywgZ2V0RWxTZWcsIGdldFJlbGV2YW50RXZlbnRzLCBFdmVudEFwaSwgY3JlYXRlRW1wdHlFdmVudFN0b3JlLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlLCBpc0ludGVyYWN0aW9uVmFsaWQsIGJ1aWxkRXZlbnRBcGlzLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsIHN0YXJ0T2ZEYXksIGRpZmZEYXRlcywgY3JlYXRlRHVyYXRpb24sIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCwgaWRlbnRpdHksIGV2ZW50VHVwbGVUb1N0b3JlLCBwYXJzZURyYWdNZXRhLCBlbGVtZW50TWF0Y2hlcywgcmVmaW5lRXZlbnREZWYsIHBhcnNlRXZlbnREZWYsIGdldERlZmF1bHRFdmVudEVuZCwgY3JlYXRlRXZlbnRJbnN0YW5jZSwgQkFTRV9PUFRJT05fREVGQVVMVFMsIGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJztcbmltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcbnZhciBpZ25vcmVNb3VzZURlcHRoID0gMDtcbnZhciBsaXN0ZW5lckNudCA9IDA7XG52YXIgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG52YXIgUG9pbnRlckRyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgYXNzaWduZWQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSAnJzsgLy8gd2lsbCBjYXVzZSBzdWJqZWN0RWwgaW4gYWxsIGVtaXR0ZWQgZXZlbnRzIHRvIGJlIHRoaXMgZWxlbWVudFxuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdG9yID0gJyc7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZFdhdGNoU2Nyb2xsID0gdHJ1ZTsgLy8gZm9yIHNpbXVsYXRpbmcgcG9pbnRlcm1vdmUgb24gc2Nyb2xsXG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlc1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAvLyBNb3VzZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpO1xuICAgICAgICAgICAgX3RoaXMucmVjb3JkQ29vcmRzKHBldik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBfdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldikpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICB9O1xuICAgICAgICAvLyBUb3VjaFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzVG91Y2hEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0U2Nyb2xsV2F0Y2gocGV2KTtcbiAgICAgICAgICAgICAgICAvLyB1bmxpa2UgbW91c2UsIG5lZWQgdG8gYXR0YWNoIHRvIHRhcmdldCwgbm90IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1NzYwMDE0XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KTtcbiAgICAgICAgICAgIF90aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIGRvbmUgdG8gZ3VhcmQgYWdhaW5zdCB0b3VjaGVuZCBmb2xsb3dlZCBieSB0b3VjaGNhbmNlbFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX3RoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICAgICAgICAgIF90aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMud2FzVG91Y2hTY3JvbGwgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VYID0gKHdpbmRvdy5wYWdlWE9mZnNldCAtIF90aGlzLnByZXZTY3JvbGxYKSArIF90aGlzLnByZXZQYWdlWDtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IC0gX3RoaXMucHJldlNjcm9sbFkpICsgX3RoaXMucHJldlBhZ2VZO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2g6IF90aGlzLmlzVG91Y2hEcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdEVsOiBfdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVg6IHBhZ2VYIC0gX3RoaXMub3JpZ1BhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVk6IHBhZ2VZIC0gX3RoaXMub3JpZ1BhZ2VZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckNyZWF0ZWQoKTtcbiAgICB9XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyRGVzdHJveWVkKCk7XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLnRyeVN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBzdWJqZWN0RWwgPSB0aGlzLnF1ZXJ5U3ViamVjdEVsKGV2KTtcbiAgICAgICAgdmFyIGRvd25FbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCAmJlxuICAgICAgICAgICAgKCF0aGlzLmhhbmRsZVNlbGVjdG9yIHx8IGVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7IC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgd2FzVG91Y2hTY3JvbGwgYXJvdW5kIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKTtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUucXVlcnlTdWJqZWN0RWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsO1xuICAgIH07XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZU1vdXNlRGVwdGggfHwgdGhpcy5pc1RvdWNoRHJhZ2dpbmc7XG4gICAgfTtcbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuY2FuY2VsVG91Y2hTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2Nyb2xsaW5nIHRoYXQgc2ltdWxhdGVzIHBvaW50ZXJtb3Zlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmluaXRTY3JvbGxXYXRjaCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMoZXYpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZT10cnVlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUucmVjb3JkQ29vcmRzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3lTY3JvbGxXYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRXZlbnQgTm9ybWFsaXphdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNyZWF0ZUV2ZW50RnJvbU1vdXNlID0gZnVuY3Rpb24gKGV2LCBpc0ZpcnN0KSB7XG4gICAgICAgIHZhciBkZWx0YVggPSAwO1xuICAgICAgICB2YXIgZGVsdGFZID0gMDtcbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gZXYucGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IGV2LnBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiBmYWxzZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWDogZXYucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXYucGFnZVksXG4gICAgICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5jcmVhdGVFdmVudEZyb21Ub3VjaCA9IGZ1bmN0aW9uIChldiwgaXNGaXJzdCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXM7XG4gICAgICAgIHZhciBwYWdlWDtcbiAgICAgICAgdmFyIHBhZ2VZO1xuICAgICAgICB2YXIgZGVsdGFYID0gMDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIGlmIHRvdWNoIGNvb3JkcyBhdmFpbGFibGUsIHByZWZlcixcbiAgICAgICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxuICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IHBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUG9pbnRlckRyYWdnaW5nO1xufSgpKTtcbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcbiAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xufVxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XG4gICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XG4gICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcbn1cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgKz0gMTtcbiAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICAgIGxpc3RlbmVyQ250IC09IDE7XG4gICAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcbiAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG52YXIgRWxlbWVudE1pcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50TWlycm9yKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXG4gICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcbiAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IChwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCkgLSB0aGlzLm9yaWdTY3JlZW5YO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IChwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCkgLSB0aGlzLm9yaWdTY3JlZW5ZO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9O1xuICAgIC8vIGNhbiBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuc2V0SXNWaXNpYmxlID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sOyAvLyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHVwZGF0ZUVsUG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTsgLy8gYmVjYXVzZSB3YXMgbm90IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBpbnZpc2libGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2w7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGFsd2F5cyBhc3luY1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5lZWRzUmV2ZXJ0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSAmJlxuICAgICAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiAmJiAvLyBpZiAwLCB0cmFuc2l0aW9uIHdvbid0IHdvcmtcbiAgICAgICAgICAgICh0aGlzLmRlbHRhWCB8fCB0aGlzLmRlbHRhWSkgLy8gaWYgc2FtZSBjb29yZHMsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuZG9SZXZlcnRBbmltYXRpb24oZG9uZSwgdGhpcy5yZXZlcnREdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5kb1JldmVydEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcmV2ZXJ0RHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbDtcbiAgICAgICAgdmFyIGZpbmFsU291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gYmVjYXVzZSBhdXRvc2Nyb2xsaW5nIG1pZ2h0IGhhdmUgaGFwcGVuZWRcbiAgICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgICAgICAgICAndG9wICcgKyByZXZlcnREdXJhdGlvbiArICdtcywnICtcbiAgICAgICAgICAgICAgICAnbGVmdCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMnO1xuICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgIH0pO1xuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmUobWlycm9yRWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnVwZGF0ZUVsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUVsICYmIHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHRoaXMuZ2V0TWlycm9yRWwoKSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc291cmNlRWxSZWN0LmxlZnQgKyB0aGlzLmRlbHRhWCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc291cmNlRWxSZWN0LnRvcCArIHRoaXMuZGVsdGFZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmdldE1pcnJvckVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3Q7XG4gICAgICAgIHZhciBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGlmICghbWlycm9yRWwpIHtcbiAgICAgICAgICAgIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCA9IHRoaXMuc291cmNlRWwuY2xvbmVOb2RlKHRydWUpOyAvLyBjbG9uZUNoaWxkcmVuPXRydWVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJyk7XG4gICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNvdXJjZUVsUmVjdC5yaWdodCAtIHNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogc291cmNlRWxSZWN0LmJvdHRvbSAtIHNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pcnJvckVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRNaXJyb3I7XG59KCkpO1xuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG52YXIgU2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nyb2xsR2VvbUNhY2hlKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9wID0gX3RoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbExlZnQgPSBfdGhpcy5zY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlcjtcbiAgICAgICAgX3RoaXMuZG9lc0xpc3RlbmluZyA9IGRvZXNMaXN0ZW5pbmc7XG4gICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IF90aGlzLm9yaWdTY3JvbGxUb3AgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gX3RoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgICAgIF90aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xuICAgICAgICBfdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICBfdGhpcy5jbGllbnRSZWN0ID0gX3RoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgaWYgKF90aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIF90aGlzLmdldEV2ZW50VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbEdlb21DYWNoZTtcbn0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG52YXIgRWxlbWVudFNjcm9sbEdlb21DYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFNjcm9sbEdlb21DYWNoZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUlubmVyUmVjdCh0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGU7XG59KFNjcm9sbEdlb21DYWNoZSkpO1xuXG52YXIgV2luZG93U2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93U2Nyb2xsR2VvbUNhY2hlKGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCksIGRvZXNMaXN0ZW5pbmcpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0RXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gdGhlIHdpbmRvdyBpcyB0aGUgb25seSBzY3JvbGwgb2JqZWN0IHRoYXQgY2hhbmdlcyBpdCdzIHJlY3RhbmdsZSByZWxhdGl2ZVxuICAgIC8vIHRvIHRoZSBkb2N1bWVudCdzIHRvcGxlZnQgYXMgaXQgc2Nyb2xsc1xuICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U2Nyb2xsR2VvbUNhY2hlO1xufShTY3JvbGxHZW9tQ2FjaGUpKTtcblxuLy8gSWYgYXZhaWxhYmxlIHdlIGFyZSB1c2luZyBuYXRpdmUgXCJwZXJmb3JtYW5jZVwiIEFQSSBpbnN0ZWFkIG9mIFwiRGF0ZVwiXG4vLyBSZWFkIG1vcmUgYWJvdXQgaXQgb24gTUROOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlXG52YXIgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xuLypcbkZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcbmFwcHJvYWNoZXMgdGhlIGVkZ2UuXG5cblRoZSBjYWxsZXIgbXVzdCBjYWxsIHN0YXJ0ICsgaGFuZGxlTW92ZSArIHN0b3AuXG4qL1xudmFyIEF1dG9TY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvU2Nyb2xsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsUXVlcnkgPSBbd2luZG93LCAnLmZjLXNjcm9sbGVyJ107XG4gICAgICAgIHRoaXMuZWRnZVRocmVzaG9sZCA9IDUwOyAvLyBwaXhlbHNcbiAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSA9IDMwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHRoZSBpbml0aWFsIHBvaW50ZXJkb3duIGJlaW5nIHRvbyBjbG9zZSB0byBhbiBlZGdlIGFuZCBzdGFydGluZyB0aGUgc2Nyb2xsXG4gICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0FuaW1hdGluZykgeyAvLyB3YXNuJ3QgY2FuY2VsbGVkIGJldHdlZW4gYW5pbWF0aW9uIGNhbGxzXG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpcy5jb21wdXRlQmVzdEVkZ2UoX3RoaXMucG9pbnRlclNjcmVlblggKyB3aW5kb3cucGFnZVhPZmZzZXQsIF90aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTaWRlKGVkZ2UsIChub3cgLSBfdGhpcy5tc1NpbmNlUmVxdWVzdCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRlclNjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIHZhciB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIHZhciB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxDYWNoZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5yZXF1ZXN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcbiAgICB9O1xuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuaGFuZGxlU2lkZSA9IGZ1bmN0aW9uIChlZGdlLCBzZWNvbmRzKSB7XG4gICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IGVkZ2Uuc2Nyb2xsQ2FjaGU7XG4gICAgICAgIHZhciBlZGdlVGhyZXNob2xkID0gdGhpcy5lZGdlVGhyZXNob2xkO1xuICAgICAgICB2YXIgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcbiAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xuICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XG4gICAgICAgIHZhciBzaWduID0gMTtcbiAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmNvbXB1dGVCZXN0RWRnZSA9IGZ1bmN0aW9uIChsZWZ0LCB0b3ApIHtcbiAgICAgICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSB0aGlzLmVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBiZXN0U2lkZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcbiAgICAgICAgICAgIHZhciBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xuICAgICAgICAgICAgdmFyIGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xuICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAnYm90dG9tJywgZGlzdGFuY2U6IGJvdHRvbURpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRMZWZ0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbExlZnQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gbGVmdERpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlOiBzY3JvbGxDYWNoZSwgbmFtZTogJ3JpZ2h0JywgZGlzdGFuY2U6IHJpZ2h0RGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdFNpZGU7XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmJ1aWxkQ2FjaGVzID0gZnVuY3Rpb24gKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTY3JvbGxFbHMoc2Nyb2xsU3RhcnRFbCkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpbmRvd1Njcm9sbEdlb21DYWNoZShmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShlbCwgZmFsc2UpOyAvLyBmYWxzZSA9IGRvbid0IGxpc3RlbiB0byB1c2VyLWdlbmVyYXRlZCBzY3JvbGxzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5xdWVyeVNjcm9sbEVscyA9IGZ1bmN0aW9uIChzY3JvbGxTdGFydEVsKSB7XG4gICAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsUXVlcnk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoLmFwcGx5KGVscywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0RWxSb290KHNjcm9sbFN0YXJ0RWwpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9O1xuICAgIHJldHVybiBBdXRvU2Nyb2xsZXI7XG59KCkpO1xuXG4vKlxuTW9uaXRvcnMgZHJhZ2dpbmcgb24gYW4gZWxlbWVudC4gSGFzIGEgbnVtYmVyIG9mIGhpZ2gtbGV2ZWwgZmVhdHVyZXM6XG4tIG1pbmltdW0gZGlzdGFuY2UgcmVxdWlyZWQgYmVmb3JlIGRyYWdnaW5nXG4tIG1pbmltdW0gd2FpdCB0aW1lIChcImRlbGF5XCIpIGJlZm9yZSBkcmFnZ2luZ1xuLSBhIG1pcnJvciBlbGVtZW50IHRoYXQgZm9sbG93cyB0aGUgcG9pbnRlclxuKi9cbnZhciBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lckVsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICBfdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIF90aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgX3RoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIF90aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTsgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIF90aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldmVudFNlbGVjdGlvbihkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxuICAgICAgICAgICAgICAgIC8vIGFsc28gcHJldmVudHMgc2VsZWN0aW9uIGluIG9sZGVyIGJyb3dzZXJzIChtYXliZT8pLlxuICAgICAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxuICAgICAgICAgICAgICAgIGlmICghZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZyAmJiAvLyBub3QgZGVzdHJveWVkIHZpYSBwb2ludGVyZG93biBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5wb2ludGVyLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9ucyByZWxhdGVkIHRvIGluaXRpYXRpbmcgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQuLi5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3Iuc3RhcnQoZXYuc3ViamVjdEVsLCBldi5wYWdlWCwgZXYucGFnZVkpOyAvLyBtdXN0IGhhcHBlbiBvbiBmaXJzdCBwb2ludGVyIGRvd25cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnREZWxheShldik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSBfdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlU3EgPSB2b2lkIDA7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBldi5kZWx0YVgsIGRlbHRhWSA9IGV2LmRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmVhbCBwb2ludGVyIG1vdmU/IChub3Qgb25lIHNpbXVsYXRlZCBieSBzY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5vcmlnRXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdXRvU2Nyb2xsZXIuaGFuZGxlTW92ZShldi5wYWdlWCwgZXYucGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsb3dTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGF5VGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgX3RoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCBfdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcG9pbnRlci5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm1pcnJvciA9IG5ldyBFbGVtZW50TWlycm9yKCk7XG4gICAgICAgIF90aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyBIQUNLOiBzaW11bGF0ZSBhIHBvaW50ZXItdXAgdG8gZW5kIHRoZSBjdXJyZW50IGRyYWdcbiAgICAgICAgLy8gVE9ETzogZmlyZSAnZHJhZ2VuZCcgZGlyZWN0bHkgYW5kIHN0b3AgaW50ZXJhY3Rpb24uIGRpc2NvdXJhZ2UgdXNlIG9mIHBvaW50ZXJ1cCBldmVudCAoYi9jIG1pZ2h0IG5vdCBmaXJlKVxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwKHt9KTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnN0YXJ0RGVsYXkgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTsgLy8gbm90IGFzc2lnbmFibGUgdG8gbnVtYmVyIVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZURlbGF5RW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUudHJ5U3RhcnREcmFnID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCAmJiB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyLndhc1RvdWNoU2Nyb2xsIHx8IHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RhcnQoZXYucGFnZVgsIGV2LnBhZ2VZLCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLmNhbmNlbFRvdWNoU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS50cnlTdG9wRHJhZyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgIH07XG4gICAgLy8gZmlsbCBpbiB0aGUgaW1wbGVtZW50YXRpb25zLi4uXG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0SWdub3JlTW92ZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbDtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvck5lZWRzUmV2ZXJ0ID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGJvb2w7XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRBdXRvU2Nyb2xsRW5hYmxlZCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGJvb2w7XG4gICAgfTtcbiAgICByZXR1cm4gRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZztcbn0oRWxlbWVudERyYWdnaW5nKSk7XG5cbi8qXG5XaGVuIHRoaXMgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBpdCByZWNvcmRzIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvcGxlZnQpLFxuYW5kIGNvbnRpbnVlcyB0byBtb25pdG9yIHNjcm9sbGluZywgdXBkYXRpbmcgdGhlIGNhY2hlZCBjb29yZGluYXRlcyBpZiBpdCBuZWVkcyB0by5cbkRvZXMgbm90IGFjY2VzcyB0aGUgRE9NIGFmdGVyIGluc3RhbnRpYXRpb24sIHNvIGhpZ2hseSBwZXJmb3JtYW50LlxuXG5BbHNvIGtlZXBzIHRyYWNrIG9mIGFsbCBzY3JvbGxpbmcvb3ZlcmZsb3c6aGlkZGVuIGNvbnRhaW5lcnMgdGhhdCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuYW5kIGFuIGRldGVybWluZSBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgY29tYmluZWQgY2xpcHBpbmcgcmVjdGFuZ2xlLlxuKi9cbnZhciBPZmZzZXRUcmFja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9mZnNldFRyYWNrZXIoZWwpIHtcbiAgICAgICAgdGhpcy5vcmlnUmVjdCA9IGNvbXB1dGVSZWN0KGVsKTtcbiAgICAgICAgLy8gd2lsbCB3b3JrIGZpbmUgZm9yIGRpdnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlblxuICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCkubWFwKGZ1bmN0aW9uIChzY3JvbGxFbCkgeyByZXR1cm4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoc2Nyb2xsRWwsIHRydWUpOyB9KTtcbiAgICB9XG4gICAgT2Zmc2V0VHJhY2tlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm9yaWdSZWN0LmxlZnQ7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcbiAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5vcmlnUmVjdC50b3A7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9O1xuICAgIE9mZnNldFRyYWNrZXIucHJvdG90eXBlLmlzV2l0aGluQ2xpcHBpbmcgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHsgbGVmdDogcGFnZVgsIHRvcDogcGFnZVkgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAgICAgICAgICFwb2ludEluc2lkZVJlY3QocG9pbnQsIHNjcm9sbENhY2hlLmNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9mZnNldFRyYWNrZXI7XG59KCkpO1xuLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxuZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xuICAgIHZhciB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xufVxuXG4vKlxuVHJhY2tzIG1vdmVtZW50IG92ZXIgbXVsdGlwbGUgZHJvcHBhYmxlIGFyZWFzIChha2EgXCJoaXRzXCIpXG50aGF0IGV4aXN0IGluIG9uZSBvciBtb3JlIERhdGVDb21wb25lbnRzLlxuUmVsaWVzIG9uIGFuIGV4aXN0aW5nIGRyYWdnYWJsZS5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcbi0gcG9pbnRlcnVwXG4tIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcbi0gZHJhZ2VuZFxuKi9cbnZhciBIaXREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaXREcmFnZ2luZyhkcmFnZ2luZywgZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMudXNlU3ViamVjdENlbnRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVpcmVJbml0aWFsID0gdHJ1ZTsgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xuICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbEhpdCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuZmluYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucHJlcGFyZUhpdHMoKTtcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NGaXJzdENvb3JkKGV2KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbml0aWFsSGl0IHx8ICFfdGhpcy5yZXF1aXJlSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZU1vdmUoZXYsIHRydWUpOyAvLyBmb3JjZSA9IGZpcmUgZXZlbiBpZiBpbml0aWFsbHkgbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW92ZShldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5yZWxlYXNlSGl0cygpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm1vdmluZ0hpdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgbnVsbCwgdHJ1ZSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZmluYWxIaXQgPSBfdGhpcy5tb3ZpbmdIaXQ7XG4gICAgICAgICAgICBfdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyb3BwYWJsZVN0b3JlID0gZHJvcHBhYmxlU3RvcmU7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ21vdmUnLCB0aGlzLmhhbmRsZURyYWdNb3ZlKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnByb2Nlc3NGaXJzdENvb3JkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIHZhciBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICB2YXIgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICB2YXIgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBjb25zdHJhaW5Qb2ludChhZGp1c3RlZFBvaW50LCBzdWJqZWN0UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApO1xuICAgICAgICBpZiAoaW5pdGlhbEhpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3ViamVjdENlbnRlciAmJiBzdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gZ2V0UmVjdENlbnRlcihzbGljZWRTdWJqZWN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldiwgZm9yY2VIYW5kbGUpIHtcbiAgICAgICAgdmFyIGhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoZXYucGFnZVggKyB0aGlzLmNvb3JkQWRqdXN0LmxlZnQsIGV2LnBhZ2VZICsgdGhpcy5jb29yZEFkanVzdC50b3ApO1xuICAgICAgICBpZiAoZm9yY2VIYW5kbGUgfHwgIWlzSGl0c0VxdWFsKHRoaXMubW92aW5nSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IGhpdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBoaXQsIGZhbHNlLCBldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhpdERyYWdnaW5nLnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IG1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgZnVuY3Rpb24gKGludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0VHJhY2tlcnMgPSB0aGlzLm9mZnNldFRyYWNrZXJzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0ge307XG4gICAgfTtcbiAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucXVlcnlIaXRGb3JPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRyb3BwYWJsZVN0b3JlID0gX2EuZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzID0gX2Eub2Zmc2V0VHJhY2tlcnM7XG4gICAgICAgIHZhciBiZXN0SGl0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9mZnNldFRyYWNrZXIgPSBvZmZzZXRUcmFja2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAob2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5pc1dpdGhpbkNsaXBwaW5nKG9mZnNldExlZnQsIG9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luTGVmdCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZUxlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luVG9wID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlVG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uTGVmdCA9IG9mZnNldExlZnQgLSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblRvcCA9IG9mZnNldFRvcCAtIG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ1JlY3QgPSBvZmZzZXRUcmFja2VyLm9yaWdSZWN0O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHdpdGhpbiB0aGUgZWxlbWVudCdzIGJvdW5kc1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxuICAgICAgICAgICAgICAgICAgICByYW5nZUNvbnRhaW5zUmFuZ2UoaGl0LmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBoaXQuZGF0ZVNwYW4ucmFuZ2UpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XG4gICAgfTtcbiAgICByZXR1cm4gSGl0RHJhZ2dpbmc7XG59KCkpO1xuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIF9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgICAgIGRhdGVTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICAgIH07XG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG52YXIgRGF0ZUNsaWNraW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlQ2xpY2tpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNsaWNraW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xuICAgICAgICAgICAgdmFyIGRvd25FbCA9IHBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghX3RoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRvd25FbCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3b24ndCBldmVuIGZpcmUgaWYgbW92aW5nIHdhcyBpZ25vcmVkXG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLmRyYWdnaW5nLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5oaXREcmFnZ2luZywgaW5pdGlhbEhpdCA9IF9hLmluaXRpYWxIaXQsIGZpbmFsSGl0ID0gX2EuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQgJiYgZmluYWxIaXQgJiYgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgZmluYWxIaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChpbml0aWFsSGl0LmRhdGVTcGFuLCBjb250ZXh0KSksIHsgZGF5RWw6IGluaXRpYWxIaXQuZGF5RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVDbGljaycsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcbn0oSW50ZXJhY3Rpb24pKTtcblxuLypcblRyYWNrcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBwb3J0aW9uIG9mIHRpbWUgb2YgYSBjb21wb25lbnQsXG5jb25zdGl0dXRlZCBieSBhIGRyYWcgb3ZlciBkYXRlIGNlbGxzLCB3aXRoIGEgcG9zc2libGUgZGVsYXkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZHJhZy5cbiovXG52YXIgRGF0ZVNlbGVjdGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZVNlbGVjdGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlU2VsZWN0aW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGRyYWdnaW5nID0gX2EuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgY2FuU2VsZWN0ID0gb3B0aW9ucy5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHRvIHdhdGNoIGV4cGVuc2l2ZSBtb3ZlcyBpZiBjb21wb25lbnQgd29uJ3QgZG8gc2VsZWN0aW9uXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFjYW5TZWxlY3QpO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIHJlcXVpcmUgdXNlciB0byBob2xkIGRvd25cbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID0gZXYuaXNUb3VjaCA/IGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSGl0VXBkYXRlID0gZnVuY3Rpb24gKGhpdCwgaXNGaW5hbCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgX3RoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIV90aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBkcmFnU2VsZWN0aW9uOyAvLyBvbmx5IGNsZWFyIGlmIG1vdmVkIGF3YXkgZnJvbSBhbGwgaGl0cyB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KF90aGlzLmRyYWdTZWxlY3Rpb24sIHBldiwgX3RoaXMuY29tcG9uZW50LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBvcHRpb25zLnNlbGVjdE1pbkRpc3RhbmNlIHx8IDA7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIHZhciBoaXREcmFnZ2luZyA9IF90aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKF90aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgX3RoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlU2VsZWN0aW5nO1xufShJbnRlcmFjdGlvbikpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkge1xuICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcbiAgICB2YXIgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICB2YXIgbXMgPSBbXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxuICAgIF07XG4gICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzXzEgPSBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOyBfaSA8IGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgdmFyIHJlcyA9IHRyYW5zZm9ybWVyKGhpdDAsIGhpdDEpO1xuICAgICAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgX19hc3NpZ24ocHJvcHMsIHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMucmFuZ2UgPSB7IHN0YXJ0OiBtc1swXSwgZW5kOiBtc1szXSB9O1xuICAgIHByb3BzLmFsbERheSA9IGRhdGVTcGFuMC5hbGxEYXk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG52YXIgRXZlbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnREcmFnZ2luZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudERyYWdnaW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICBfdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdWJqZWN0U2VnID0gbnVsbDsgLy8gdGhlIHNlZyBiZWluZyBzZWxlY3RlZC9kcmFnZ2VkXG4gICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDsgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIF90aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBvcmlnVGFyZ2V0ID0gZXYub3JpZ0V2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGRyYWdnaW5nID0gX2EuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgbWlycm9yID0gZHJhZ2dpbmcubWlycm9yO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICBfdGhpcy5zdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgICAgICB2YXIgc3ViamVjdFNlZyA9IF90aGlzLnN1YmplY3RTZWcgPSBnZXRFbFNlZyhldi5zdWJqZWN0RWwpO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLCBldmVudEluc3RhbmNlSWQpO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIGV2ZW50SW5zdGFuY2VJZCAhPT0gY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBpc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNlbGVjdCBhIGRpZmZlcmVudCBldmVudD9cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUlkICE9PSBfdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkOiBldmVudEluc3RhbmNlSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm93IHVzaW5nIG1vdXNlLCBidXQgd2FzIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uLCBjbGVhciBzZWxlY3RlZCBldmVudFxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IF90aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IGZ1bmN0aW9uIChoaXQsIGlzRmluYWwpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50cyA9IF90aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxIaXQgPSBfdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAvLyBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgICAgICAgICAgdmFyIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmluZ09wdGlvbnMgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgIChyZWNlaXZpbmdPcHRpb25zLmVkaXRhYmxlICYmIHJlY2VpdmluZ09wdGlvbnMuZHJvcHBhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVFdmVudE11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghbXV0YXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoIWhpdCB8fCAhZ2V0RWxSb290KF90aGlzLnN1YmplY3RFbCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0XzEgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZpZXcgPSBpbml0aWFsQ29udGV4dF8xLnZpZXdBcGk7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHJlY2VpdmluZ0NvbnRleHRfMSA9IF9hLnJlY2VpdmluZ0NvbnRleHQsIHZhbGlkTXV0YXRpb24gPSBfYS52YWxpZE11dGF0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBldmVudERlZiA9IF90aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gX3RoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoaW5pdGlhbENvbnRleHRfMSwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50c18xID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRSZWxldmFudEV2ZW50c18xID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIHZhciBmaW5hbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyRHJhZygpOyAvLyBtdXN0IGhhcHBlbiBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIHdpdGhpbiBzYW1lIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0XzEgPT09IGluaXRpYWxDb250ZXh0XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoaW5pdGlhbENvbnRleHRfMSwgbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSwgaW5pdGlhbENvbnRleHRfMSwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50c18xLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gaW5pdGlhbENvbnRleHRfMS5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVyczsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0XzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudERyb3AnLCBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB0cmFuc2Zvcm1lZCksIHsgZWw6IGV2LnN1YmplY3RFbCwgZGVsdGE6IHZhbGlkTXV0YXRpb24uZGF0ZXNEZWx0YSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBpbml0aWFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50UmVtb3ZlQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50c18xLCBpbml0aWFsQ29udGV4dF8xLCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRSZW1vdmVBcmcpLCB7IGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLCB2aWV3OiBpbml0aWFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dF8xLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHNfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywgZXZlbnRSZW1vdmVBcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGVkRXZlbnREZWYgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKHJlY2VpdmluZ0NvbnRleHRfMSwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEFkZEFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogYWRkZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSwgcmVjZWl2aW5nQ29udGV4dF8xLCBhZGRlZEV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCBldmVudEFkZEFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dF8xKSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudEFkZEFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBFdmVudERyYWdnaW5nLlNFTEVDVE9SO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IG9wdGlvbnMuZHJhZ1Njcm9sbDtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIF90aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kaXNwbGF5RHJhZyA9IGZ1bmN0aW9uIChuZXh0Q29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHN0YXRlLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgY2xlYXIgdGhlIG9sZCBjYWxlbmRhciBpZiBpdCB3YXNuJ3QgdGhlIGluaXRpYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNsZWFyRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDYWxlbmRhciA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIHZhciByZWNlaXZpbmdDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgaW5pdGlhbCBjYWxlbmRhciBtaWdodCBoYXZlIGFuIGR1bW15IGRyYWcgc3RhdGUgZnJvbSBkaXNwbGF5RHJhZ1xuICAgICAgICBpZiAoaW5pdGlhbENhbGVuZGFyICE9PSByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgIH07XG4gICAgLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcbiAgICAvLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xuICAgIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IgPSAnLmZjLWV2ZW50LWRyYWdnYWJsZSwgLmZjLWV2ZW50LXJlc2l6YWJsZSc7XG4gICAgcmV0dXJuIEV2ZW50RHJhZ2dpbmc7XG59KEludGVyYWN0aW9uKSk7XG5mdW5jdGlvbiBjb21wdXRlRXZlbnRNdXRhdGlvbihoaXQwLCBoaXQxLCBtYXNzYWdlcnMpIHtcbiAgICB2YXIgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZTAgPSBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGRhdGUxID0gZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0O1xuICAgIHZhciBzdGFuZGFyZFByb3BzID0ge307XG4gICAgaWYgKGRhdGVTcGFuMC5hbGxEYXkgIT09IGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjEuYWxsRGF5O1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGhpdDEuY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgICAgICAvLyBtZWFucyBkYXRlMSBpcyBhbHJlYWR5IHN0YXJ0LW9mLWRheSxcbiAgICAgICAgICAgIC8vIGJ1dCBkYXRlMCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgIGRhdGUwID0gc3RhcnRPZkRheShkYXRlMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRlbHRhID0gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgaGl0MC5jb250ZXh0LmRhdGVFbnYsIGhpdDAuY29tcG9uZW50SWQgPT09IGhpdDEuY29tcG9uZW50SWQgP1xuICAgICAgICBoaXQwLmxhcmdlVW5pdCA6XG4gICAgICAgIG51bGwpO1xuICAgIGlmIChkZWx0YS5taWxsaXNlY29uZHMpIHsgLy8gaGFzIGhvdXJzL21pbnV0ZXMvc2Vjb25kc1xuICAgICAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbXV0YXRpb24gPSB7XG4gICAgICAgIGRhdGVzRGVsdGE6IGRlbHRhLFxuICAgICAgICBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBtYXNzYWdlcnNfMSA9IG1hc3NhZ2VyczsgX2kgPCBtYXNzYWdlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG1hc3NhZ2VyID0gbWFzc2FnZXJzXzFbX2ldO1xuICAgICAgICBtYXNzYWdlcihtdXRhdGlvbiwgaGl0MCwgaGl0MSk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cblxudmFyIEV2ZW50UmVzaXppbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50UmVzaXppbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRSZXNpemluZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmdTZWdFbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nU2VnID0gbnVsbDsgLy8gVE9ETzogcmVuYW1lIHRvIHJlc2l6aW5nU2VnPyBzdWJqZWN0U2VnP1xuICAgICAgICBfdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBfdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLm1pbkRpc3RhbmNlID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoLCBuZWVkIHRvIGJlIHdvcmtpbmcgd2l0aCBhIHNlbGVjdGVkIGV2ZW50XG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFfdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIF90aGlzLmNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbiAhPT0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gX3RoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBfdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSGl0VXBkYXRlID0gZnVuY3Rpb24gKGhpdCwgaXNGaW5hbCwgZXYpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gX3RoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgX3RoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIV90aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IF90aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gX3RoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHtcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMuZHJhZ2dpbmdTZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLnZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplJywgX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgeyBlbDogX3RoaXMuZHJhZ2dpbmdTZWdFbCwgc3RhcnREZWx0YTogX3RoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogX3RoaXMudmFsaWRNdXRhdGlvbi5lbmREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICcuZmMtZXZlbnQtcmVzaXplcic7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnF1ZXJ5U2VnRWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRDbG9zZXN0KGV2LnN1YmplY3RFbCwgJy5mYy1ldmVudCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50UmVzaXppbmc7XG59KEludGVyYWN0aW9uKSk7XG5mdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xuICAgIHZhciBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcbiAgICB2YXIgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XG4gICAgaWYgKGlzRnJvbVN0YXJ0KSB7XG4gICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBVbnNlbGVjdEF1dG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5zZWxlY3RBdXRvKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7IC8vIHdpc2ggd2UgY291bGQgdXNlIGEgc2VsZWN0b3IgdG8gZGV0ZWN0IGRhdGUgc2VsZWN0aW9uLCBidXQgdXNlcyBoaXQgc3lzdGVtXG4gICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdEluZm8pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24gPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICB2YXIgdW5zZWxlY3RDYW5jZWwgPSBfdGhpcy5jb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RDYW5jZWw7XG4gICAgICAgICAgICB2YXIgZG93bkVsID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KHBldi5vcmlnRXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICBfdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUik7IC8vIGludGVyYWN0aW9uIHN0YXJ0ZWQgb24gYW4gZXZlbnQ/XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXMuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBkb2N1bWVudFBvaW50ZXIgPSBfdGhpcy5kb2N1bWVudFBvaW50ZXI7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIHRvdWNoLXNjcm9sbGluZyBzaG91bGQgbmV2ZXIgdW5mb2N1cyBhbnkgdHlwZSBvZiBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmICghZG9jdW1lbnRQb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBkYXRlIHNlbGVjdGlvbj9cbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5zZWxlY3RBdXRvID0gY29udGV4dC5vcHRpb25zLnVuc2VsZWN0QXV0bztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc2VsZWN0QXV0byAmJiAoIXVuc2VsZWN0QXV0byB8fCAhX3RoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLm1hdGNoZXNFdmVudCAvLyBpbnRlcmFjdGlvbiBESUROJ1Qgc3RhcnQgb24gYW4gZXZlbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZG9jdW1lbnRQb2ludGVyID0gdGhpcy5kb2N1bWVudFBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGRvY3VtZW50KTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZElnbm9yZU1vdmUgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkV2F0Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24pO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICB9XG4gICAgVW5zZWxlY3RBdXRvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5vZmYoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xuICAgICAgICB0aGlzLmRvY3VtZW50UG9pbnRlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5zZWxlY3RBdXRvO1xufSgpKTtcblxudmFyIE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHksXG59O1xudmFyIExJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RhcnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJhZ1N0b3A6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemVTdGFydDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemVTdG9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZTogaWRlbnRpdHksXG4gICAgZHJvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZWNlaXZlOiBpZGVudGl0eSxcbiAgICBldmVudExlYXZlOiBpZGVudGl0eSxcbn07XG5cbi8qXG5HaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcbkludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXG5vZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cbiovXG52YXIgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHN1cHBsaWVkRHJhZ01ldGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5kcmFnTWV0YSA9IF90aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsLCBldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBfdGhpcy5kcmFnTWV0YS5jcmVhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oaGl0LmRhdGVTcGFuLCBfdGhpcy5kcmFnTWV0YSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NvbnRleHQsIGludGVyYWN0aW9uKTtcbiAgICAgICAgICAgIC8vIHNob3cgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yIGVsZW1lbnQgT1IgaWYgd2UgYXJlIHNodXR0aW5nIGRvd24gdGhlIG1pcnJvciAoPylcbiAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoaXNGaW5hbCB8fCAhZHJvcHBhYmxlRXZlbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSk7XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGFibGVFdmVudCA9IGRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgcmVjZWl2aW5nQ29udGV4dCA9IF9hLnJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50ID0gX2EuZHJvcHBhYmxlRXZlbnQ7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckRyYWcoKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0ICYmIGRyb3BwYWJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ01ldGEgPSBfdGhpcy5kcmFnTWV0YTtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZHJvcCcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGluZ0V2ZW50c18xID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZTsgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YTtcbiAgICB9XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ01ldGEgPSBmdW5jdGlvbiAoc3ViamVjdEVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKHN1YmplY3RFbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXREcmFnTWV0YUZyb21FbChzdWJqZWN0RWwpO1xuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRpc3BsYXlEcmFnID0gZnVuY3Rpb24gKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4dGVybmFsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhckRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmNhbkRyb3BFbE9uQ2FsZW5kYXIgPSBmdW5jdGlvbiAoZWwsIHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnMuZHJvcEFjY2VwdDtcbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdC5jYWxsKHJlY2VpdmluZ0NvbnRleHQuY2FsZW5kYXJBcGksIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRNYXRjaGVzKGVsLCBkcm9wQWNjZXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmc7XG59KCkpO1xuLy8gVXRpbHMgZm9yIGNvbXB1dGluZyBldmVudCBzdG9yZSBmcm9tIHRoZSBEcmFnTWV0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oZGF0ZVNwYW4sIGRyYWdNZXRhLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZlByb3BzID0gX19hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3JtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hW19pXTtcbiAgICAgICAgX19hc3NpZ24oZGVmUHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgZHJhZ01ldGEpKTtcbiAgICB9XG4gICAgdmFyIF9iID0gcmVmaW5lRXZlbnREZWYoZGVmUHJvcHMsIGNvbnRleHQpLCByZWZpbmVkID0gX2IucmVmaW5lZCwgZXh0cmEgPSBfYi5leHRyYTtcbiAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZHJhZ01ldGEuc291cmNlSWQsIGRhdGVTcGFuLmFsbERheSwgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgdmFyIHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxuICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgdmFyIGVuZCA9IGRyYWdNZXRhLmR1cmF0aW9uID9cbiAgICAgICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kKGRhdGVTcGFuLmFsbERheSwgc3RhcnQsIGNvbnRleHQpO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xufVxuLy8gVXRpbHMgZm9yIGV4dHJhY3RpbmcgZGF0YSBmcm9tIGVsZW1lbnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldERyYWdNZXRhRnJvbUVsKGVsKSB7XG4gICAgdmFyIHN0ciA9IGdldEVtYmVkZGVkRWxEYXRhKGVsLCAnZXZlbnQnKTtcbiAgICB2YXIgb2JqID0gc3RyID9cbiAgICAgICAgSlNPTi5wYXJzZShzdHIpIDpcbiAgICAgICAgeyBjcmVhdGU6IGZhbHNlIH07IC8vIGlmIG5vIGVtYmVkZGVkIGRhdGEsIGFzc3VtZSBubyBldmVudCBjcmVhdGlvblxuICAgIHJldHVybiBwYXJzZURyYWdNZXRhKG9iaik7XG59XG5jb25maWcuZGF0YUF0dHJQcmVmaXggPSAnJztcbmZ1bmN0aW9uIGdldEVtYmVkZGVkRWxEYXRhKGVsLCBuYW1lKSB7XG4gICAgdmFyIHByZWZpeCA9IGNvbmZpZy5kYXRhQXR0clByZWZpeDtcbiAgICB2YXIgcHJlZml4ZWROYW1lID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIG5hbWU7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgcHJlZml4ZWROYW1lKSB8fCAnJztcbn1cblxuLypcbk1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cbkNhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cbkxldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cbiovXG52YXIgRXh0ZXJuYWxEcmFnZ2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxEcmFnZ2FibGUoZWwsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zZXR0aW5ncywgbWluRGlzdGFuY2UgPSBfYS5taW5EaXN0YW5jZSwgbG9uZ1ByZXNzRGVsYXkgPSBfYS5sb25nUHJlc3NEZWxheTtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID1cbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgOlxuICAgICAgICAgICAgICAgICAgICAoZXYuaXNUb3VjaCA/IDAgOiBCQVNFX09QVElPTl9ERUZBVUxUUy5ldmVudERyYWdNaW5EaXN0YW5jZSk7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgZXYuaXNUb3VjaCA/IC8vIFRPRE86IGV2ZW50dWFsbHkgcmVhZCBldmVudExvbmdQcmVzc0RlbGF5IGluc3RlYWQgdnZ2XG4gICAgICAgICAgICAgICAgICAgIChsb25nUHJlc3NEZWxheSAhPSBudWxsID8gbG9uZ1ByZXNzRGVsYXkgOiBCQVNFX09QVElPTl9ERUZBVUxUUy5sb25nUHJlc3NEZWxheSkgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2ggJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5kZWxheSAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgICAgIH1cbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIEV4dGVybmFsRHJhZ2dhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlcm5hbERyYWdnYWJsZTtcbn0oKSk7XG5cbi8qXG5EZXRlY3RzIHdoZW4gYSAqVEhJUkQtUEFSVFkqIGRyYWctbi1kcm9wIHN5c3RlbSBpbnRlcmFjdHMgd2l0aCBlbGVtZW50cy5cblRoZSB0aGlyZC1wYXJ0eSBzeXN0ZW0gaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgdGhlIHZpc3VhbHMgZWZmZWN0cyBvZiB0aGUgZHJhZy5cblRoaXMgY2xhc3Mgc2ltcGx5IG1vbml0b3JzIGZvciBwb2ludGVyIG1vdmVtZW50cyBhbmQgZmlyZXMgZXZlbnRzLlxuSXQgYWxzbyBoYXMgdGhlIGFiaWxpdHkgdG8gaGlkZSB0aGUgbW92aW5nIGVsZW1lbnQgKHRoZSBcIm1pcnJvclwiKSBkdXJpbmcgdGhlIGRyYWcuXG4qL1xudmFyIEluZmVycmVkRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZlcnJlZEVsZW1lbnREcmFnZ2luZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250YWluZXJFbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xuICAgICAgICBfdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ3N0YXJ0IHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgZGVsYXkgb3IgbWluLWRpc3RhbmNlXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZmVycmVkRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgIH07XG4gICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldElnbm9yZU1vdmUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xuICAgIH07XG4gICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcbiAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEluZmVycmVkRWxlbWVudERyYWdnaW5nO1xufShFbGVtZW50RHJhZ2dpbmcpKTtcblxuLypcbkJyaWRnZXMgdGhpcmQtcGFydHkgZHJhZy1uLWRyb3Agc3lzdGVtcyB3aXRoIEZ1bGxDYWxlbmRhci5cbk11c3QgYmUgaW5zdGFudGlhdGVkIGFuZCBkZXN0cm95ZWQgYnkgY2FsbGVyLlxuKi9cbnZhciBUaGlyZFBhcnR5RHJhZ2dhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRoaXJkUGFydHlEcmFnZ2FibGUoY29udGFpbmVyT3JTZXR0aW5ncywgc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gZG9jdW1lbnQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gd2lzaCB3ZSBjb3VsZCBqdXN0IHRlc3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCwgYnV0IGRvZXNuJ3Qgd29yayBpbiBJRTExXG4gICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgPT09IGRvY3VtZW50IHx8XG4gICAgICAgICAgICBjb250YWluZXJPclNldHRpbmdzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgY29udGFpbmVyRWwgPSBjb250YWluZXJPclNldHRpbmdzO1xuICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0gKGNvbnRhaW5lck9yU2V0dGluZ3MgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLml0ZW1TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyRWwgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJ1tkYXRhLWV2ZW50XSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5taXJyb3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvclNlbGVjdG9yID0gc2V0dGluZ3MubWlycm9yU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cbiAgICBUaGlyZFBhcnR5RHJhZ2dhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBUaGlyZFBhcnR5RHJhZ2dhYmxlO1xufSgpKTtcblxudmFyIG1haW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYWluO1xuZXhwb3J0IHsgRXh0ZXJuYWxEcmFnZ2FibGUgYXMgRHJhZ2dhYmxlLCBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBQb2ludGVyRHJhZ2dpbmcsIFRoaXJkUGFydHlEcmFnZ2FibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/interaction/main.js\n");

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/react */ \"./node_modules/@fullcalendar/react/dist/main.js\");\n/* harmony import */ var _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/timegrid */ \"./node_modules/@fullcalendar/timegrid/main.js\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/interaction */ \"./node_modules/@fullcalendar/interaction/main.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* module decorator */ module = __webpack_require__.hmd(module);\nvar _jsxFileName = \"/Users/iijimayuusuke/devPortfolio/fullcallendar-test/pages/index.tsx\",\n    _this = undefined;\n\n\n\n\n\n\n\nvar Home = function Home() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n    plugins: [_fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_1__[\"default\"]],\n    initialView: \"timeGridWeek\",\n    nowIndicator: true,\n    editable: true,\n    initialEvents: [{\n      title: 'nice event',\n      start: new Date()\n    }]\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 8,\n    columnNumber: 5\n  }, _this);\n};\n\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\n\nvar _c;\n\n$RefreshReg$(_c, \"Home\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLElBQU1JLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQU07QUFDakIsc0JBQ0UsOERBQUMsMkRBQUQ7QUFDQSxXQUFPLEVBQUUsQ0FBQ0YsaUVBQUQsRUFBb0JELDhEQUFwQixDQURUO0FBRUEsZUFBVyxFQUFDLGNBRlo7QUFHQSxnQkFBWSxFQUFFLElBSGQ7QUFJQSxZQUFRLEVBQUUsSUFKVjtBQUtBLGlCQUFhLEVBQUUsQ0FDYjtBQUFFSSxNQUFBQSxLQUFLLEVBQUUsWUFBVDtBQUF1QkMsTUFBQUEsS0FBSyxFQUFFLElBQUlDLElBQUo7QUFBOUIsS0FEYTtBQUxmO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQVdELENBWkQ7O0tBQU1IO0FBY04sK0RBQWVBLElBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXgudHN4PzA3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZ1bGxDYWxlbmRhciBmcm9tICdAZnVsbGNhbGVuZGFyL3JlYWN0J1xuaW1wb3J0IHRpbWVHcmlkUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvdGltZWdyaWQnXG5pbXBvcnQgaW50ZXJhY3Rpb25QbHVnaW4gZnJvbSAnQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbidcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IEhvbWUgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPEZ1bGxDYWxlbmRhclxuICAgIHBsdWdpbnM9e1tpbnRlcmFjdGlvblBsdWdpbiwgdGltZUdyaWRQbHVnaW5dfVxuICAgIGluaXRpYWxWaWV3PSd0aW1lR3JpZFdlZWsnXG4gICAgbm93SW5kaWNhdG9yPXt0cnVlfVxuICAgIGVkaXRhYmxlPXt0cnVlfVxuICAgIGluaXRpYWxFdmVudHM9e1tcbiAgICAgIHsgdGl0bGU6ICduaWNlIGV2ZW50Jywgc3RhcnQ6IG5ldyBEYXRlKCkgfVxuICAgIF19XG4gIC8+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgSG9tZTsiXSwibmFtZXMiOlsiRnVsbENhbGVuZGFyIiwidGltZUdyaWRQbHVnaW4iLCJpbnRlcmFjdGlvblBsdWdpbiIsIlJlYWN0IiwiSG9tZSIsInRpdGxlIiwic3RhcnQiLCJEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.tsx\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": function() { return /* binding */ BASE_OPTION_DEFAULTS; },\n/* harmony export */   \"BASE_OPTION_REFINERS\": function() { return /* binding */ BASE_OPTION_REFINERS; },\n/* harmony export */   \"BaseComponent\": function() { return /* binding */ BaseComponent; },\n/* harmony export */   \"BgEvent\": function() { return /* binding */ BgEvent; },\n/* harmony export */   \"CalendarApi\": function() { return /* binding */ CalendarApi; },\n/* harmony export */   \"CalendarContent\": function() { return /* binding */ CalendarContent; },\n/* harmony export */   \"CalendarDataManager\": function() { return /* binding */ CalendarDataManager; },\n/* harmony export */   \"CalendarDataProvider\": function() { return /* binding */ CalendarDataProvider; },\n/* harmony export */   \"CalendarRoot\": function() { return /* binding */ CalendarRoot; },\n/* harmony export */   \"ContentHook\": function() { return /* binding */ ContentHook; },\n/* harmony export */   \"CustomContentRenderContext\": function() { return /* binding */ CustomContentRenderContext; },\n/* harmony export */   \"DateComponent\": function() { return /* binding */ DateComponent; },\n/* harmony export */   \"DateEnv\": function() { return /* binding */ DateEnv; },\n/* harmony export */   \"DateProfileGenerator\": function() { return /* binding */ DateProfileGenerator; },\n/* harmony export */   \"DayCellContent\": function() { return /* binding */ DayCellContent; },\n/* harmony export */   \"DayCellRoot\": function() { return /* binding */ DayCellRoot; },\n/* harmony export */   \"DayHeader\": function() { return /* binding */ DayHeader; },\n/* harmony export */   \"DaySeriesModel\": function() { return /* binding */ DaySeriesModel; },\n/* harmony export */   \"DayTableModel\": function() { return /* binding */ DayTableModel; },\n/* harmony export */   \"DelayedRunner\": function() { return /* binding */ DelayedRunner; },\n/* harmony export */   \"ElementDragging\": function() { return /* binding */ ElementDragging; },\n/* harmony export */   \"ElementScrollController\": function() { return /* binding */ ElementScrollController; },\n/* harmony export */   \"Emitter\": function() { return /* binding */ Emitter; },\n/* harmony export */   \"EventApi\": function() { return /* binding */ EventApi; },\n/* harmony export */   \"EventRoot\": function() { return /* binding */ EventRoot; },\n/* harmony export */   \"EventSourceApi\": function() { return /* binding */ EventSourceApi; },\n/* harmony export */   \"Interaction\": function() { return /* binding */ Interaction; },\n/* harmony export */   \"MoreLinkRoot\": function() { return /* binding */ MoreLinkRoot; },\n/* harmony export */   \"MountHook\": function() { return /* binding */ MountHook; },\n/* harmony export */   \"NamedTimeZoneImpl\": function() { return /* binding */ NamedTimeZoneImpl; },\n/* harmony export */   \"NowIndicatorRoot\": function() { return /* binding */ NowIndicatorRoot; },\n/* harmony export */   \"NowTimer\": function() { return /* binding */ NowTimer; },\n/* harmony export */   \"PositionCache\": function() { return /* binding */ PositionCache; },\n/* harmony export */   \"RefMap\": function() { return /* binding */ RefMap; },\n/* harmony export */   \"RenderHook\": function() { return /* binding */ RenderHook; },\n/* harmony export */   \"ScrollController\": function() { return /* binding */ ScrollController; },\n/* harmony export */   \"ScrollResponder\": function() { return /* binding */ ScrollResponder; },\n/* harmony export */   \"Scroller\": function() { return /* binding */ Scroller; },\n/* harmony export */   \"SegHierarchy\": function() { return /* binding */ SegHierarchy; },\n/* harmony export */   \"SimpleScrollGrid\": function() { return /* binding */ SimpleScrollGrid; },\n/* harmony export */   \"Slicer\": function() { return /* binding */ Slicer; },\n/* harmony export */   \"Splitter\": function() { return /* binding */ Splitter; },\n/* harmony export */   \"StandardEvent\": function() { return /* binding */ StandardEvent; },\n/* harmony export */   \"TableDateCell\": function() { return /* binding */ TableDateCell; },\n/* harmony export */   \"TableDowCell\": function() { return /* binding */ TableDowCell; },\n/* harmony export */   \"Theme\": function() { return /* binding */ Theme; },\n/* harmony export */   \"ViewApi\": function() { return /* binding */ ViewApi; },\n/* harmony export */   \"ViewContextType\": function() { return /* binding */ ViewContextType; },\n/* harmony export */   \"ViewRoot\": function() { return /* binding */ ViewRoot; },\n/* harmony export */   \"WeekNumberRoot\": function() { return /* binding */ WeekNumberRoot; },\n/* harmony export */   \"WindowScrollController\": function() { return /* binding */ WindowScrollController; },\n/* harmony export */   \"addDays\": function() { return /* binding */ addDays; },\n/* harmony export */   \"addDurations\": function() { return /* binding */ addDurations; },\n/* harmony export */   \"addMs\": function() { return /* binding */ addMs; },\n/* harmony export */   \"addWeeks\": function() { return /* binding */ addWeeks; },\n/* harmony export */   \"allowContextMenu\": function() { return /* binding */ allowContextMenu; },\n/* harmony export */   \"allowSelection\": function() { return /* binding */ allowSelection; },\n/* harmony export */   \"applyMutationToEventStore\": function() { return /* binding */ applyMutationToEventStore; },\n/* harmony export */   \"applyStyle\": function() { return /* binding */ applyStyle; },\n/* harmony export */   \"applyStyleProp\": function() { return /* binding */ applyStyleProp; },\n/* harmony export */   \"asCleanDays\": function() { return /* binding */ asCleanDays; },\n/* harmony export */   \"asRoughMinutes\": function() { return /* binding */ asRoughMinutes; },\n/* harmony export */   \"asRoughMs\": function() { return /* binding */ asRoughMs; },\n/* harmony export */   \"asRoughSeconds\": function() { return /* binding */ asRoughSeconds; },\n/* harmony export */   \"binarySearch\": function() { return /* binding */ binarySearch; },\n/* harmony export */   \"buildClassNameNormalizer\": function() { return /* binding */ buildClassNameNormalizer; },\n/* harmony export */   \"buildEntryKey\": function() { return /* binding */ buildEntryKey; },\n/* harmony export */   \"buildEventApis\": function() { return /* binding */ buildEventApis; },\n/* harmony export */   \"buildEventRangeKey\": function() { return /* binding */ buildEventRangeKey; },\n/* harmony export */   \"buildHashFromArray\": function() { return /* binding */ buildHashFromArray; },\n/* harmony export */   \"buildIsoString\": function() { return /* binding */ buildIsoString; },\n/* harmony export */   \"buildNavLinkAttrs\": function() { return /* binding */ buildNavLinkAttrs; },\n/* harmony export */   \"buildSegCompareObj\": function() { return /* binding */ buildSegCompareObj; },\n/* harmony export */   \"buildSegTimeText\": function() { return /* binding */ buildSegTimeText; },\n/* harmony export */   \"collectFromHash\": function() { return /* binding */ collectFromHash; },\n/* harmony export */   \"combineEventUis\": function() { return /* binding */ combineEventUis; },\n/* harmony export */   \"compareByFieldSpec\": function() { return /* binding */ compareByFieldSpec; },\n/* harmony export */   \"compareByFieldSpecs\": function() { return /* binding */ compareByFieldSpecs; },\n/* harmony export */   \"compareNumbers\": function() { return /* binding */ compareNumbers; },\n/* harmony export */   \"compareObjs\": function() { return /* binding */ compareObjs; },\n/* harmony export */   \"computeEarliestSegStart\": function() { return /* binding */ computeEarliestSegStart; },\n/* harmony export */   \"computeEdges\": function() { return /* binding */ computeEdges; },\n/* harmony export */   \"computeFallbackHeaderFormat\": function() { return /* binding */ computeFallbackHeaderFormat; },\n/* harmony export */   \"computeHeightAndMargins\": function() { return /* binding */ computeHeightAndMargins; },\n/* harmony export */   \"computeInnerRect\": function() { return /* binding */ computeInnerRect; },\n/* harmony export */   \"computeRect\": function() { return /* binding */ computeRect; },\n/* harmony export */   \"computeSegDraggable\": function() { return /* binding */ computeSegDraggable; },\n/* harmony export */   \"computeSegEndResizable\": function() { return /* binding */ computeSegEndResizable; },\n/* harmony export */   \"computeSegStartResizable\": function() { return /* binding */ computeSegStartResizable; },\n/* harmony export */   \"computeShrinkWidth\": function() { return /* binding */ computeShrinkWidth; },\n/* harmony export */   \"computeSmallestCellWidth\": function() { return /* binding */ computeSmallestCellWidth; },\n/* harmony export */   \"computeVisibleDayRange\": function() { return /* binding */ computeVisibleDayRange; },\n/* harmony export */   \"config\": function() { return /* binding */ config; },\n/* harmony export */   \"constrainPoint\": function() { return /* binding */ constrainPoint; },\n/* harmony export */   \"createAriaClickAttrs\": function() { return /* binding */ createAriaClickAttrs; },\n/* harmony export */   \"createDuration\": function() { return /* binding */ createDuration; },\n/* harmony export */   \"createEmptyEventStore\": function() { return /* binding */ createEmptyEventStore; },\n/* harmony export */   \"createEventInstance\": function() { return /* binding */ createEventInstance; },\n/* harmony export */   \"createEventUi\": function() { return /* binding */ createEventUi; },\n/* harmony export */   \"createFormatter\": function() { return /* binding */ createFormatter; },\n/* harmony export */   \"createPlugin\": function() { return /* binding */ createPlugin; },\n/* harmony export */   \"diffDates\": function() { return /* binding */ diffDates; },\n/* harmony export */   \"diffDayAndTime\": function() { return /* binding */ diffDayAndTime; },\n/* harmony export */   \"diffDays\": function() { return /* binding */ diffDays; },\n/* harmony export */   \"diffPoints\": function() { return /* binding */ diffPoints; },\n/* harmony export */   \"diffWeeks\": function() { return /* binding */ diffWeeks; },\n/* harmony export */   \"diffWholeDays\": function() { return /* binding */ diffWholeDays; },\n/* harmony export */   \"diffWholeWeeks\": function() { return /* binding */ diffWholeWeeks; },\n/* harmony export */   \"disableCursor\": function() { return /* binding */ disableCursor; },\n/* harmony export */   \"elementClosest\": function() { return /* binding */ elementClosest; },\n/* harmony export */   \"elementMatches\": function() { return /* binding */ elementMatches; },\n/* harmony export */   \"enableCursor\": function() { return /* binding */ enableCursor; },\n/* harmony export */   \"eventTupleToStore\": function() { return /* binding */ eventTupleToStore; },\n/* harmony export */   \"filterEventStoreDefs\": function() { return /* binding */ filterEventStoreDefs; },\n/* harmony export */   \"filterHash\": function() { return /* binding */ filterHash; },\n/* harmony export */   \"findDirectChildren\": function() { return /* binding */ findDirectChildren; },\n/* harmony export */   \"findElements\": function() { return /* binding */ findElements; },\n/* harmony export */   \"flexibleCompare\": function() { return /* binding */ flexibleCompare; },\n/* harmony export */   \"formatDate\": function() { return /* binding */ formatDate; },\n/* harmony export */   \"formatDayString\": function() { return /* binding */ formatDayString; },\n/* harmony export */   \"formatIsoTimeString\": function() { return /* binding */ formatIsoTimeString; },\n/* harmony export */   \"formatRange\": function() { return /* binding */ formatRange; },\n/* harmony export */   \"getAllowYScrolling\": function() { return /* binding */ getAllowYScrolling; },\n/* harmony export */   \"getCanVGrowWithinCell\": function() { return /* binding */ getCanVGrowWithinCell; },\n/* harmony export */   \"getClippingParents\": function() { return /* binding */ getClippingParents; },\n/* harmony export */   \"getDateMeta\": function() { return /* binding */ getDateMeta; },\n/* harmony export */   \"getDayClassNames\": function() { return /* binding */ getDayClassNames; },\n/* harmony export */   \"getDefaultEventEnd\": function() { return /* binding */ getDefaultEventEnd; },\n/* harmony export */   \"getElRoot\": function() { return /* binding */ getElRoot; },\n/* harmony export */   \"getElSeg\": function() { return /* binding */ getElSeg; },\n/* harmony export */   \"getEntrySpanEnd\": function() { return /* binding */ getEntrySpanEnd; },\n/* harmony export */   \"getEventClassNames\": function() { return /* binding */ getEventClassNames; },\n/* harmony export */   \"getEventTargetViaRoot\": function() { return /* binding */ getEventTargetViaRoot; },\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": function() { return /* binding */ getIsRtlScrollbarOnLeft; },\n/* harmony export */   \"getRectCenter\": function() { return /* binding */ getRectCenter; },\n/* harmony export */   \"getRelevantEvents\": function() { return /* binding */ getRelevantEvents; },\n/* harmony export */   \"getScrollGridClassNames\": function() { return /* binding */ getScrollGridClassNames; },\n/* harmony export */   \"getScrollbarWidths\": function() { return /* binding */ getScrollbarWidths; },\n/* harmony export */   \"getSectionClassNames\": function() { return /* binding */ getSectionClassNames; },\n/* harmony export */   \"getSectionHasLiquidHeight\": function() { return /* binding */ getSectionHasLiquidHeight; },\n/* harmony export */   \"getSegAnchorAttrs\": function() { return /* binding */ getSegAnchorAttrs; },\n/* harmony export */   \"getSegMeta\": function() { return /* binding */ getSegMeta; },\n/* harmony export */   \"getSlotClassNames\": function() { return /* binding */ getSlotClassNames; },\n/* harmony export */   \"getStickyFooterScrollbar\": function() { return /* binding */ getStickyFooterScrollbar; },\n/* harmony export */   \"getStickyHeaderDates\": function() { return /* binding */ getStickyHeaderDates; },\n/* harmony export */   \"getUnequalProps\": function() { return /* binding */ getUnequalProps; },\n/* harmony export */   \"getUniqueDomId\": function() { return /* binding */ getUniqueDomId; },\n/* harmony export */   \"globalLocales\": function() { return /* binding */ globalLocales; },\n/* harmony export */   \"globalPlugins\": function() { return /* binding */ globalPlugins; },\n/* harmony export */   \"greatestDurationDenominator\": function() { return /* binding */ greatestDurationDenominator; },\n/* harmony export */   \"groupIntersectingEntries\": function() { return /* binding */ groupIntersectingEntries; },\n/* harmony export */   \"guid\": function() { return /* binding */ guid; },\n/* harmony export */   \"hasBgRendering\": function() { return /* binding */ hasBgRendering; },\n/* harmony export */   \"hasShrinkWidth\": function() { return /* binding */ hasShrinkWidth; },\n/* harmony export */   \"identity\": function() { return /* binding */ identity; },\n/* harmony export */   \"interactionSettingsStore\": function() { return /* binding */ interactionSettingsStore; },\n/* harmony export */   \"interactionSettingsToStore\": function() { return /* binding */ interactionSettingsToStore; },\n/* harmony export */   \"intersectRanges\": function() { return /* binding */ intersectRanges; },\n/* harmony export */   \"intersectRects\": function() { return /* binding */ intersectRects; },\n/* harmony export */   \"intersectSpans\": function() { return /* binding */ intersectSpans; },\n/* harmony export */   \"isArraysEqual\": function() { return /* binding */ isArraysEqual; },\n/* harmony export */   \"isColPropsEqual\": function() { return /* binding */ isColPropsEqual; },\n/* harmony export */   \"isDateSelectionValid\": function() { return /* binding */ isDateSelectionValid; },\n/* harmony export */   \"isDateSpansEqual\": function() { return /* binding */ isDateSpansEqual; },\n/* harmony export */   \"isInt\": function() { return /* binding */ isInt; },\n/* harmony export */   \"isInteractionValid\": function() { return /* binding */ isInteractionValid; },\n/* harmony export */   \"isMultiDayRange\": function() { return /* binding */ isMultiDayRange; },\n/* harmony export */   \"isPropsEqual\": function() { return /* binding */ isPropsEqual; },\n/* harmony export */   \"isPropsValid\": function() { return /* binding */ isPropsValid; },\n/* harmony export */   \"isValidDate\": function() { return /* binding */ isValidDate; },\n/* harmony export */   \"joinSpans\": function() { return /* binding */ joinSpans; },\n/* harmony export */   \"listenBySelector\": function() { return /* binding */ listenBySelector; },\n/* harmony export */   \"mapHash\": function() { return /* binding */ mapHash; },\n/* harmony export */   \"memoize\": function() { return /* binding */ memoize; },\n/* harmony export */   \"memoizeArraylike\": function() { return /* binding */ memoizeArraylike; },\n/* harmony export */   \"memoizeHashlike\": function() { return /* binding */ memoizeHashlike; },\n/* harmony export */   \"memoizeObjArg\": function() { return /* binding */ memoizeObjArg; },\n/* harmony export */   \"mergeEventStores\": function() { return /* binding */ mergeEventStores; },\n/* harmony export */   \"multiplyDuration\": function() { return /* binding */ multiplyDuration; },\n/* harmony export */   \"padStart\": function() { return /* binding */ padStart; },\n/* harmony export */   \"parseBusinessHours\": function() { return /* binding */ parseBusinessHours; },\n/* harmony export */   \"parseClassNames\": function() { return /* binding */ parseClassNames; },\n/* harmony export */   \"parseDragMeta\": function() { return /* binding */ parseDragMeta; },\n/* harmony export */   \"parseEventDef\": function() { return /* binding */ parseEventDef; },\n/* harmony export */   \"parseFieldSpecs\": function() { return /* binding */ parseFieldSpecs; },\n/* harmony export */   \"parseMarker\": function() { return /* binding */ parse; },\n/* harmony export */   \"pointInsideRect\": function() { return /* binding */ pointInsideRect; },\n/* harmony export */   \"preventContextMenu\": function() { return /* binding */ preventContextMenu; },\n/* harmony export */   \"preventDefault\": function() { return /* binding */ preventDefault; },\n/* harmony export */   \"preventSelection\": function() { return /* binding */ preventSelection; },\n/* harmony export */   \"rangeContainsMarker\": function() { return /* binding */ rangeContainsMarker; },\n/* harmony export */   \"rangeContainsRange\": function() { return /* binding */ rangeContainsRange; },\n/* harmony export */   \"rangesEqual\": function() { return /* binding */ rangesEqual; },\n/* harmony export */   \"rangesIntersect\": function() { return /* binding */ rangesIntersect; },\n/* harmony export */   \"refineEventDef\": function() { return /* binding */ refineEventDef; },\n/* harmony export */   \"refineProps\": function() { return /* binding */ refineProps; },\n/* harmony export */   \"removeElement\": function() { return /* binding */ removeElement; },\n/* harmony export */   \"removeExact\": function() { return /* binding */ removeExact; },\n/* harmony export */   \"renderChunkContent\": function() { return /* binding */ renderChunkContent; },\n/* harmony export */   \"renderFill\": function() { return /* binding */ renderFill; },\n/* harmony export */   \"renderMicroColGroup\": function() { return /* binding */ renderMicroColGroup; },\n/* harmony export */   \"renderScrollShim\": function() { return /* binding */ renderScrollShim; },\n/* harmony export */   \"requestJson\": function() { return /* binding */ requestJson; },\n/* harmony export */   \"sanitizeShrinkWidth\": function() { return /* binding */ sanitizeShrinkWidth; },\n/* harmony export */   \"setElSeg\": function() { return /* binding */ setElSeg; },\n/* harmony export */   \"setRef\": function() { return /* binding */ setRef; },\n/* harmony export */   \"sliceEventStore\": function() { return /* binding */ sliceEventStore; },\n/* harmony export */   \"sliceEvents\": function() { return /* binding */ sliceEvents; },\n/* harmony export */   \"sortEventSegs\": function() { return /* binding */ sortEventSegs; },\n/* harmony export */   \"startOfDay\": function() { return /* binding */ startOfDay; },\n/* harmony export */   \"translateRect\": function() { return /* binding */ translateRect; },\n/* harmony export */   \"triggerDateSelect\": function() { return /* binding */ triggerDateSelect; },\n/* harmony export */   \"unpromisify\": function() { return /* binding */ unpromisify; },\n/* harmony export */   \"version\": function() { return /* binding */ version; },\n/* harmony export */   \"whenTransitionDone\": function() { return /* binding */ whenTransitionDone; },\n/* harmony export */   \"wholeDivideDurations\": function() { return /* binding */ wholeDivideDurations; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/common/vdom.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vdom_js__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"BASE_OPTION_DEFAULTS\",\"BASE_OPTION_REFINERS\",\"BaseComponent\",\"BgEvent\",\"CalendarApi\",\"CalendarContent\",\"CalendarDataManager\",\"CalendarDataProvider\",\"CalendarRoot\",\"ContentHook\",\"CustomContentRenderContext\",\"DateComponent\",\"DateEnv\",\"DateProfileGenerator\",\"DayCellContent\",\"DayCellRoot\",\"DayHeader\",\"DaySeriesModel\",\"DayTableModel\",\"DelayedRunner\",\"ElementDragging\",\"ElementScrollController\",\"Emitter\",\"EventApi\",\"EventRoot\",\"EventSourceApi\",\"Interaction\",\"MoreLinkRoot\",\"MountHook\",\"NamedTimeZoneImpl\",\"NowIndicatorRoot\",\"NowTimer\",\"PositionCache\",\"RefMap\",\"RenderHook\",\"ScrollController\",\"ScrollResponder\",\"Scroller\",\"SegHierarchy\",\"SimpleScrollGrid\",\"Slicer\",\"Splitter\",\"StandardEvent\",\"TableDateCell\",\"TableDowCell\",\"Theme\",\"ViewApi\",\"ViewContextType\",\"ViewRoot\",\"WeekNumberRoot\",\"WindowScrollController\",\"addDays\",\"addDurations\",\"addMs\",\"addWeeks\",\"allowContextMenu\",\"allowSelection\",\"applyMutationToEventStore\",\"applyStyle\",\"applyStyleProp\",\"asCleanDays\",\"asRoughMinutes\",\"asRoughMs\",\"asRoughSeconds\",\"binarySearch\",\"buildClassNameNormalizer\",\"buildEntryKey\",\"buildEventApis\",\"buildEventRangeKey\",\"buildHashFromArray\",\"buildIsoString\",\"buildNavLinkAttrs\",\"buildSegCompareObj\",\"buildSegTimeText\",\"collectFromHash\",\"combineEventUis\",\"compareByFieldSpec\",\"compareByFieldSpecs\",\"compareNumbers\",\"compareObjs\",\"computeEarliestSegStart\",\"computeEdges\",\"computeFallbackHeaderFormat\",\"computeHeightAndMargins\",\"computeInnerRect\",\"computeRect\",\"computeSegDraggable\",\"computeSegEndResizable\",\"computeSegStartResizable\",\"computeShrinkWidth\",\"computeSmallestCellWidth\",\"computeVisibleDayRange\",\"config\",\"constrainPoint\",\"createAriaClickAttrs\",\"createDuration\",\"createEmptyEventStore\",\"createEventInstance\",\"createEventUi\",\"createFormatter\",\"createPlugin\",\"diffDates\",\"diffDayAndTime\",\"diffDays\",\"diffPoints\",\"diffWeeks\",\"diffWholeDays\",\"diffWholeWeeks\",\"disableCursor\",\"elementClosest\",\"elementMatches\",\"enableCursor\",\"eventTupleToStore\",\"filterEventStoreDefs\",\"filterHash\",\"findDirectChildren\",\"findElements\",\"flexibleCompare\",\"formatDate\",\"formatDayString\",\"formatIsoTimeString\",\"formatRange\",\"getAllowYScrolling\",\"getCanVGrowWithinCell\",\"getClippingParents\",\"getDateMeta\",\"getDayClassNames\",\"getDefaultEventEnd\",\"getElRoot\",\"getElSeg\",\"getEntrySpanEnd\",\"getEventClassNames\",\"getEventTargetViaRoot\",\"getIsRtlScrollbarOnLeft\",\"getRectCenter\",\"getRelevantEvents\",\"getScrollGridClassNames\",\"getScrollbarWidths\",\"getSectionClassNames\",\"getSectionHasLiquidHeight\",\"getSegAnchorAttrs\",\"getSegMeta\",\"getSlotClassNames\",\"getStickyFooterScrollbar\",\"getStickyHeaderDates\",\"getUnequalProps\",\"getUniqueDomId\",\"globalLocales\",\"globalPlugins\",\"greatestDurationDenominator\",\"groupIntersectingEntries\",\"guid\",\"hasBgRendering\",\"hasShrinkWidth\",\"identity\",\"interactionSettingsStore\",\"interactionSettingsToStore\",\"intersectRanges\",\"intersectRects\",\"intersectSpans\",\"isArraysEqual\",\"isColPropsEqual\",\"isDateSelectionValid\",\"isDateSpansEqual\",\"isInt\",\"isInteractionValid\",\"isMultiDayRange\",\"isPropsEqual\",\"isPropsValid\",\"isValidDate\",\"joinSpans\",\"listenBySelector\",\"mapHash\",\"memoize\",\"memoizeArraylike\",\"memoizeHashlike\",\"memoizeObjArg\",\"mergeEventStores\",\"multiplyDuration\",\"padStart\",\"parseBusinessHours\",\"parseClassNames\",\"parseDragMeta\",\"parseEventDef\",\"parseFieldSpecs\",\"parseMarker\",\"pointInsideRect\",\"preventContextMenu\",\"preventDefault\",\"preventSelection\",\"rangeContainsMarker\",\"rangeContainsRange\",\"rangesEqual\",\"rangesIntersect\",\"refineEventDef\",\"refineProps\",\"removeElement\",\"removeExact\",\"renderChunkContent\",\"renderFill\",\"renderMicroColGroup\",\"renderScrollShim\",\"requestJson\",\"sanitizeShrinkWidth\",\"setElSeg\",\"setRef\",\"sliceEventStore\",\"sliceEvents\",\"sortEventSegs\",\"startOfDay\",\"translateRect\",\"triggerDateSelect\",\"unpromisify\",\"version\",\"whenTransitionDone\",\"wholeDivideDurations\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _vdom_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\nvar EventSourceApi = function () {\n  function EventSourceApi(context, internalEventSource) {\n    this.context = context;\n    this.internalEventSource = internalEventSource;\n  }\n\n  EventSourceApi.prototype.remove = function () {\n    this.context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: this.internalEventSource.sourceId\n    });\n  };\n\n  EventSourceApi.prototype.refetch = function () {\n    this.context.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      sourceIds: [this.internalEventSource.sourceId],\n      isRefetch: true\n    });\n  };\n\n  Object.defineProperty(EventSourceApi.prototype, \"id\", {\n    get: function get() {\n      return this.internalEventSource.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"url\", {\n    get: function get() {\n      return this.internalEventSource.meta.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"format\", {\n    get: function get() {\n      return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return EventSourceApi;\n}();\n\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n} // Querying\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction elementClosest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector); // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  }\n\n  if (!document.documentElement.contains(el)) {\n    return null;\n  }\n\n  do {\n    if (elementMatches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n}\n\nfunction elementMatches(el, selector) {\n  var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n  return method.call(el, selector);\n} // accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\n\n\nfunction findElements(container, selector) {\n  var containers = container instanceof HTMLElement ? [container] : container;\n  var allMatches = [];\n\n  for (var i = 0; i < containers.length; i += 1) {\n    var matches = containers[i].querySelectorAll(selector);\n\n    for (var j = 0; j < matches.length; j += 1) {\n      allMatches.push(matches[j]);\n    }\n  }\n\n  return allMatches;\n} // accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\n\n\nfunction findDirectChildren(parent, selector) {\n  var parents = parent instanceof HTMLElement ? [parent] : parent;\n  var allMatches = [];\n\n  for (var i = 0; i < parents.length; i += 1) {\n    var childNodes = parents[i].children; // only ever elements\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      var childNode = childNodes[j];\n\n      if (!selector || elementMatches(childNode, selector)) {\n        allMatches.push(childNode);\n      }\n    }\n  }\n\n  return allMatches;\n} // Style\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n\nfunction applyStyle(el, props) {\n  for (var propName in props) {\n    applyStyleProp(el, propName, props[propName]);\n  }\n}\n\nfunction applyStyleProp(el, name, val) {\n  if (val == null) {\n    el.style[name] = '';\n  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n    el.style[name] = val + \"px\";\n  } else {\n    el.style[name] = val;\n  }\n} // Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\n\n\nfunction getEventTargetViaRoot(ev) {\n  var _a, _b;\n\n  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n} // Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction getElRoot(el) {\n  return el.getRootNode ? el.getRootNode() : document;\n} // Unique ID for DOM attribute\n\n\nvar guid$1 = 0;\n\nfunction getUniqueDomId() {\n  guid$1 += 1;\n  return 'fc-dom-' + guid$1;\n} // Stops a mouse/touch event from doing it's native browser action\n\n\nfunction preventDefault(ev) {\n  ev.preventDefault();\n} // Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildDelegationHandler(selector, handler) {\n  return function (ev) {\n    var matchedChild = elementClosest(ev.target, selector);\n\n    if (matchedChild) {\n      handler.call(matchedChild, ev, matchedChild);\n    }\n  };\n}\n\nfunction listenBySelector(container, eventType, selector, handler) {\n  var attachedHandler = buildDelegationHandler(selector, handler);\n  container.addEventListener(eventType, attachedHandler);\n  return function () {\n    container.removeEventListener(eventType, attachedHandler);\n  };\n}\n\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n  var currentMatchedChild;\n  return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {\n    if (matchedChild !== currentMatchedChild) {\n      currentMatchedChild = matchedChild;\n      onMouseEnter(mouseOverEv, matchedChild);\n\n      var realOnMouseLeave_1 = function realOnMouseLeave_1(mouseLeaveEv) {\n        currentMatchedChild = null;\n        onMouseLeave(mouseLeaveEv, matchedChild);\n        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n      }; // listen to the next mouseleave, and then unattach\n\n\n      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n    }\n  });\n} // Animation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes\n\nfunction whenTransitionDone(el, callback) {\n  var realCallback = function realCallback(ev) {\n    callback(ev);\n    transitionEventNames.forEach(function (eventName) {\n      el.removeEventListener(eventName, realCallback);\n    });\n  };\n\n  transitionEventNames.forEach(function (eventName) {\n    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n  });\n} // ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction createAriaClickAttrs(handler) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n    onClick: handler\n  }, createAriaKeyboardAttrs(handler));\n}\n\nfunction createAriaKeyboardAttrs(handler) {\n  return {\n    tabIndex: 0,\n    onKeyDown: function onKeyDown(ev) {\n      if (ev.key === 'Enter' || ev.key === ' ') {\n        handler(ev);\n        ev.preventDefault(); // if space, don't scroll down page\n      }\n    }\n  };\n}\n\nvar guidNumber = 0;\n\nfunction guid() {\n  guidNumber += 1;\n  return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\n\n\nfunction disableCursor() {\n  document.body.classList.add('fc-not-allowed');\n} // Returns the mouse cursor to its original look\n\n\nfunction enableCursor() {\n  document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventSelection(el) {\n  el.classList.add('fc-unselectable');\n  el.addEventListener('selectstart', preventDefault);\n}\n\nfunction allowSelection(el) {\n  el.classList.remove('fc-unselectable');\n  el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventContextMenu(el) {\n  el.addEventListener('contextmenu', preventDefault);\n}\n\nfunction allowContextMenu(el) {\n  el.removeEventListener('contextmenu', preventDefault);\n}\n\nfunction parseFieldSpecs(input) {\n  var specs = [];\n  var tokens = [];\n  var i;\n  var token;\n\n  if (typeof input === 'string') {\n    tokens = input.split(/\\s*,\\s*/);\n  } else if (typeof input === 'function') {\n    tokens = [input];\n  } else if (Array.isArray(input)) {\n    tokens = input;\n  }\n\n  for (i = 0; i < tokens.length; i += 1) {\n    token = tokens[i];\n\n    if (typeof token === 'string') {\n      specs.push(token.charAt(0) === '-' ? {\n        field: token.substring(1),\n        order: -1\n      } : {\n        field: token,\n        order: 1\n      });\n    } else if (typeof token === 'function') {\n      specs.push({\n        func: token\n      });\n    }\n  }\n\n  return specs;\n}\n\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n  var i;\n  var cmp;\n\n  for (i = 0; i < fieldSpecs.length; i += 1) {\n    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n\n    if (cmp) {\n      return cmp;\n    }\n  }\n\n  return 0;\n}\n\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n  if (fieldSpec.func) {\n    return fieldSpec.func(obj0, obj1);\n  }\n\n  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\n\nfunction flexibleCompare(a, b) {\n  if (!a && !b) {\n    return 0;\n  }\n\n  if (b == null) {\n    return -1;\n  }\n\n  if (a == null) {\n    return 1;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return String(a).localeCompare(String(b));\n  }\n\n  return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction padStart(val, len) {\n  var s = String(val);\n  return '000'.substr(0, len - s.length) + s;\n}\n\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n  if (typeof formatter === 'function') {\n    return formatter.apply(void 0, args);\n  }\n\n  if (typeof formatter === 'string') {\n    // non-blank string\n    return args.reduce(function (str, arg, index) {\n      return str.replace('$' + index, arg || '');\n    }, formatter);\n  }\n\n  return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isInt(n) {\n  return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction computeSmallestCellWidth(cellEl) {\n  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n\n  if (!allWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n  }\n\n  if (!contentWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-cushion className');\n  }\n\n  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n  contentWidthEl.getBoundingClientRect().width;\n}\n\nvar DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding\n\nfunction addWeeks(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n * 7;\n  return arrayToUtcDate(a);\n}\n\nfunction addDays(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n;\n  return arrayToUtcDate(a);\n}\n\nfunction addMs(m, n) {\n  var a = dateToUtcArray(m);\n  a[6] += n;\n  return arrayToUtcDate(a);\n} // Diffing (all return floats)\n// TODO: why not use ranges?\n\n\nfunction diffWeeks(m0, m1) {\n  return diffDays(m0, m1) / 7;\n}\n\nfunction diffDays(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\n\nfunction diffHours(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\n\nfunction diffMinutes(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\n\nfunction diffSeconds(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / 1000;\n}\n\nfunction diffDayAndTime(m0, m1) {\n  var m0day = startOfDay(m0);\n  var m1day = startOfDay(m1);\n  return {\n    years: 0,\n    months: 0,\n    days: Math.round(diffDays(m0day, m1day)),\n    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n  };\n} // Diffing Whole Units\n\n\nfunction diffWholeWeeks(m0, m1) {\n  var d = diffWholeDays(m0, m1);\n\n  if (d !== null && d % 7 === 0) {\n    return d / 7;\n  }\n\n  return null;\n}\n\nfunction diffWholeDays(m0, m1) {\n  if (timeAsMs(m0) === timeAsMs(m1)) {\n    return Math.round(diffDays(m0, m1));\n  }\n\n  return null;\n} // Start-Of\n\n\nfunction startOfDay(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);\n}\n\nfunction startOfHour(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);\n}\n\nfunction startOfMinute(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);\n}\n\nfunction startOfSecond(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);\n} // Week Computation\n\n\nfunction weekOfYear(marker, dow, doy) {\n  var y = marker.getUTCFullYear();\n  var w = weekOfGivenYear(marker, y, dow, doy);\n\n  if (w < 1) {\n    return weekOfGivenYear(marker, y - 1, dow, doy);\n  }\n\n  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n\n  if (nextW >= 1) {\n    return Math.min(w, nextW);\n  }\n\n  return w;\n}\n\nfunction weekOfGivenYear(marker, year, dow, doy) {\n  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n  var dayStart = startOfDay(marker);\n  var days = Math.round(diffDays(firstWeekStart, dayStart));\n  return Math.floor(days / 7) + 1; // zero-indexed\n} // start-of-first-week - start-of-year\n\n\nfunction firstWeekOffset(year, dow, doy) {\n  // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd\n\n  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n  return -fwdlw + fwd - 1;\n} // Array Conversion\n\n\nfunction dateToLocalArray(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n}\n\nfunction arrayToLocalDate(a) {\n  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n  a[3] || 0, a[4] || 0, a[5] || 0);\n}\n\nfunction dateToUtcArray(date) {\n  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];\n}\n\nfunction arrayToUtcDate(a) {\n  // according to web standards (and Safari), a month index is required.\n  // massage if only given a year.\n  if (a.length === 1) {\n    a = a.concat([0]);\n  }\n\n  return new Date(Date.UTC.apply(Date, a));\n} // Other Utils\n\n\nfunction isValidDate(m) {\n  return !isNaN(m.valueOf());\n}\n\nfunction timeAsMs(m) {\n  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n  return {\n    instanceId: guid(),\n    defId: defId,\n    range: range,\n    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n\nfunction mergeProps(propObjs, complexPropsMap) {\n  var dest = {};\n\n  if (complexPropsMap) {\n    for (var name_1 in complexPropsMap) {\n      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n      for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n        var val = propObjs[i][name_1];\n\n        if (typeof val === 'object' && val) {\n          // non-null object\n          complexObjs.unshift(val);\n        } else if (val !== undefined) {\n          dest[name_1] = val; // if there were no objects, this value will be used\n\n          break;\n        }\n      } // if the trailing values were objects, use the merged value\n\n\n      if (complexObjs.length) {\n        dest[name_1] = mergeProps(complexObjs);\n      }\n    }\n  } // copy values into the destination, going from last to first\n\n\n  for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n    var props = propObjs[i];\n\n    for (var name_2 in props) {\n      if (!(name_2 in dest)) {\n        // if already assigned by previous props or complex props, don't reassign\n        dest[name_2] = props[name_2];\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction filterHash(hash, func) {\n  var filtered = {};\n\n  for (var key in hash) {\n    if (func(hash[key], key)) {\n      filtered[key] = hash[key];\n    }\n  }\n\n  return filtered;\n}\n\nfunction mapHash(hash, func) {\n  var newHash = {};\n\n  for (var key in hash) {\n    newHash[key] = func(hash[key], key);\n  }\n\n  return newHash;\n}\n\nfunction arrayToHash(a) {\n  var hash = {};\n\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var item = a_1[_i];\n    hash[item] = true;\n  }\n\n  return hash;\n}\n\nfunction buildHashFromArray(a, func) {\n  var hash = {};\n\n  for (var i = 0; i < a.length; i += 1) {\n    var tuple = func(a[i], i);\n    hash[tuple[0]] = tuple[1];\n  }\n\n  return hash;\n}\n\nfunction hashValuesToArray(obj) {\n  var a = [];\n\n  for (var key in obj) {\n    a.push(obj[key]);\n  }\n\n  return a;\n}\n\nfunction isPropsEqual(obj0, obj1) {\n  if (obj0 === obj1) {\n    return true;\n  }\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        return false;\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getUnequalProps(obj0, obj1) {\n  var keys = [];\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        keys.push(key);\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        keys.push(key);\n      }\n    }\n  }\n\n  return keys;\n}\n\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n  if (equalityFuncs === void 0) {\n    equalityFuncs = {};\n  }\n\n  if (oldProps === newProps) {\n    return true;\n  }\n\n  for (var key in newProps) {\n    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {\n      return false;\n    }\n  } // check for props that were omitted in the new\n\n\n  for (var key in oldProps) {\n    if (!(key in newProps)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\n\n\nfunction isObjValsEqual(val0, val1, comparator) {\n  if (val0 === val1 || comparator === true) {\n    return true;\n  }\n\n  if (comparator) {\n    return comparator(val0, val1);\n  }\n\n  return false;\n}\n\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n  if (startIndex === void 0) {\n    startIndex = 0;\n  }\n\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var res = [];\n\n  if (endIndex == null) {\n    endIndex = Object.keys(hash).length;\n  }\n\n  for (var i = startIndex; i < endIndex; i += step) {\n    var val = hash[i];\n\n    if (val !== undefined) {\n      // will disregard undefined for sparse arrays\n      res.push(val);\n    }\n  }\n\n  return res;\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n  for (var i = 0; i < recurringTypes.length; i += 1) {\n    var parsed = recurringTypes[i].parse(refined, dateEnv);\n\n    if (parsed) {\n      var allDay = refined.allDay;\n\n      if (allDay == null) {\n        allDay = defaultAllDay;\n\n        if (allDay == null) {\n          allDay = parsed.allDayGuess;\n\n          if (allDay == null) {\n            allDay = false;\n          }\n        }\n      }\n\n      return {\n        allDay: allDay,\n        duration: parsed.duration,\n        typeData: parsed.typeData,\n        typeId: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction expandRecurring(eventStore, framingRange, context) {\n  var dateEnv = context.dateEnv,\n      pluginHooks = context.pluginHooks,\n      options = context.options;\n  var defs = eventStore.defs,\n      instances = eventStore.instances; // remove existing recurring instances\n  // TODO: bad. always expand events as a second step\n\n  instances = filterHash(instances, function (instance) {\n    return !defs[instance.defId].recurringDef;\n  });\n\n  for (var defId in defs) {\n    var def = defs[defId];\n\n    if (def.recurringDef) {\n      var duration = def.recurringDef.duration;\n\n      if (!duration) {\n        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n      }\n\n      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n\n      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n        var start = starts_1[_i];\n        var instance = createEventInstance(defId, {\n          start: start,\n          end: dateEnv.add(start, duration)\n        });\n        instances[instance.instanceId] = instance;\n      }\n    }\n  }\n\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n/*\nEvent MUST have a recurringDef\n*/\n\n\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n  var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n  var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n    start: dateEnv.subtract(framingRange.start, duration),\n    end: framingRange.end\n  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n\n  if (eventDef.allDay) {\n    markers = markers.map(startOfDay);\n  }\n\n  return markers;\n}\n\nvar INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/; // Parsing and Creation\n\nfunction createDuration(input, unit) {\n  var _a;\n\n  if (typeof input === 'string') {\n    return parseString(input);\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseObject(input);\n  }\n\n  if (typeof input === 'number') {\n    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n  }\n\n  return null;\n}\n\nfunction parseString(s) {\n  var m = PARSE_RE.exec(s);\n\n  if (m) {\n    var sign = m[1] ? -1 : 1;\n    return {\n      years: 0,\n      months: 0,\n      days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0) // ms\n      )\n    };\n  }\n\n  return null;\n}\n\nfunction parseObject(obj) {\n  var duration = {\n    years: obj.years || obj.year || 0,\n    months: obj.months || obj.month || 0,\n    days: obj.days || obj.day || 0,\n    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n    (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n\n  };\n  var weeks = obj.weeks || obj.week;\n\n  if (weeks) {\n    duration.days += weeks * 7;\n    duration.specifiedWeeks = true;\n  }\n\n  return duration;\n} // Equality\n\n\nfunction durationsEqual(d0, d1) {\n  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\n\nfunction asCleanDays(dur) {\n  if (!dur.years && !dur.months && !dur.milliseconds) {\n    return dur.days;\n  }\n\n  return 0;\n} // Simple Math\n\n\nfunction addDurations(d0, d1) {\n  return {\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    days: d0.days + d1.days,\n    milliseconds: d0.milliseconds + d1.milliseconds\n  };\n}\n\nfunction subtractDurations(d1, d0) {\n  return {\n    years: d1.years - d0.years,\n    months: d1.months - d0.months,\n    days: d1.days - d0.days,\n    milliseconds: d1.milliseconds - d0.milliseconds\n  };\n}\n\nfunction multiplyDuration(d, n) {\n  return {\n    years: d.years * n,\n    months: d.months * n,\n    days: d.days * n,\n    milliseconds: d.milliseconds * n\n  };\n} // Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\n\n\nfunction asRoughYears(dur) {\n  return asRoughDays(dur) / 365;\n}\n\nfunction asRoughMonths(dur) {\n  return asRoughDays(dur) / 30;\n}\n\nfunction asRoughDays(dur) {\n  return asRoughMs(dur) / 864e5;\n}\n\nfunction asRoughMinutes(dur) {\n  return asRoughMs(dur) / (1000 * 60);\n}\n\nfunction asRoughSeconds(dur) {\n  return asRoughMs(dur) / 1000;\n}\n\nfunction asRoughMs(dur) {\n  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n} // Advanced Math\n\n\nfunction wholeDivideDurations(numerator, denominator) {\n  var res = null;\n\n  for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {\n    var unit = INTERNAL_UNITS[i];\n\n    if (denominator[unit]) {\n      var localRes = numerator[unit] / denominator[unit];\n\n      if (!isInt(localRes) || res !== null && res !== localRes) {\n        return null;\n      }\n\n      res = localRes;\n    } else if (numerator[unit]) {\n      // needs to divide by something but can't!\n      return null;\n    }\n  }\n\n  return res;\n}\n\nfunction greatestDurationDenominator(dur) {\n  var ms = dur.milliseconds;\n\n  if (ms) {\n    if (ms % 1000 !== 0) {\n      return {\n        unit: 'millisecond',\n        value: ms\n      };\n    }\n\n    if (ms % (1000 * 60) !== 0) {\n      return {\n        unit: 'second',\n        value: ms / 1000\n      };\n    }\n\n    if (ms % (1000 * 60 * 60) !== 0) {\n      return {\n        unit: 'minute',\n        value: ms / (1000 * 60)\n      };\n    }\n\n    if (ms) {\n      return {\n        unit: 'hour',\n        value: ms / (1000 * 60 * 60)\n      };\n    }\n  }\n\n  if (dur.days) {\n    if (dur.specifiedWeeks && dur.days % 7 === 0) {\n      return {\n        unit: 'week',\n        value: dur.days / 7\n      };\n    }\n\n    return {\n      unit: 'day',\n      value: dur.days\n    };\n  }\n\n  if (dur.months) {\n    return {\n      unit: 'month',\n      value: dur.months\n    };\n  }\n\n  if (dur.years) {\n    return {\n      unit: 'year',\n      value: dur.years\n    };\n  }\n\n  return {\n    unit: 'millisecond',\n    value: 0\n  };\n} // timeZoneOffset is in minutes\n\n\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n  if (stripZeroTime === void 0) {\n    stripZeroTime = false;\n  }\n\n  var s = marker.toISOString();\n  s = s.replace('.000', '');\n\n  if (stripZeroTime) {\n    s = s.replace('T00:00:00Z', '');\n  }\n\n  if (s.length > 10) {\n    // time part wasn't stripped, can add timezone info\n    if (timeZoneOffset == null) {\n      s = s.replace('Z', '');\n    } else if (timeZoneOffset !== 0) {\n      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n    } // otherwise, its UTC-0 and we want to keep the Z\n\n  }\n\n  return s;\n} // formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\n\n\nfunction formatDayString(marker) {\n  return marker.toISOString().replace(/T.*$/, '');\n} // TODO: use Date::toISOString and use everything after the T?\n\n\nfunction formatIsoTimeString(marker) {\n  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n}\n\nfunction formatTimeZoneOffset(minutes, doIso) {\n  if (doIso === void 0) {\n    doIso = false;\n  }\n\n  var sign = minutes < 0 ? '-' : '+';\n  var abs = Math.abs(minutes);\n  var hours = Math.floor(abs / 60);\n  var mins = Math.round(abs % 60);\n\n  if (doIso) {\n    return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n  }\n\n  return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : '');\n} // TODO: new util arrayify?\n\n\nfunction removeExact(array, exactVal) {\n  var removeCnt = 0;\n  var i = 0;\n\n  while (i < array.length) {\n    if (array[i] === exactVal) {\n      array.splice(i, 1);\n      removeCnt += 1;\n    } else {\n      i += 1;\n    }\n  }\n\n  return removeCnt;\n}\n\nfunction isArraysEqual(a0, a1, equalityFunc) {\n  if (a0 === a1) {\n    return true;\n  }\n\n  var len = a0.length;\n  var i;\n\n  if (len !== a1.length) {\n    // not array? or not same length?\n    return false;\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n  var currentArgs;\n  var currentRes;\n  return function () {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (!currentArgs) {\n      currentRes = workerFunc.apply(this, newArgs);\n    } else if (!isArraysEqual(currentArgs, newArgs)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.apply(this, newArgs);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArgs = newArgs;\n    return currentRes;\n  };\n}\n\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArg;\n  var currentRes;\n  return function (newArg) {\n    if (!currentArg) {\n      currentRes = workerFunc.call(_this, newArg);\n    } else if (!isPropsEqual(currentArg, newArg)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.call(_this, newArg);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArg = newArg;\n    return currentRes;\n  };\n}\n\nfunction memoizeArraylike( // used at all?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgSets = [];\n  var currentResults = [];\n  return function (newArgSets) {\n    var currentLen = currentArgSets.length;\n    var newLen = newArgSets.length;\n    var i = 0;\n\n    for (; i < currentLen; i += 1) {\n      if (!newArgSets[i]) {\n        // one of the old sets no longer exists\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n\n        var res = workerFunc.apply(_this, newArgSets[i]);\n\n        if (!resEquality || !resEquality(res, currentResults[i])) {\n          currentResults[i] = res;\n        }\n      }\n    }\n\n    for (; i < newLen; i += 1) {\n      currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n    }\n\n    currentArgSets = newArgSets;\n    currentResults.splice(newLen); // remove excess\n\n    return currentResults;\n  };\n}\n\nfunction memoizeHashlike( // used?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgHash = {};\n  var currentResHash = {};\n  return function (newArgHash) {\n    var newResHash = {};\n\n    for (var key in newArgHash) {\n      if (!currentResHash[key]) {\n        newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n        if (teardownFunc) {\n          teardownFunc(currentResHash[key]);\n        }\n\n        var res = workerFunc.apply(_this, newArgHash[key]);\n        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n      } else {\n        newResHash[key] = currentResHash[key];\n      }\n    }\n\n    currentArgHash = newArgHash;\n    currentResHash = newResHash;\n    return newResHash;\n  };\n}\n\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n  week: 3,\n  separator: 0,\n  omitZeroMinute: 0,\n  meridiem: 0,\n  omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n  timeZoneName: 7,\n  era: 6,\n  year: 5,\n  month: 4,\n  day: 2,\n  weekday: 2,\n  hour: 1,\n  minute: 1,\n  second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n\nvar COMMA_RE = /,/g; // we need re for globalness\n\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\n\nvar UTC_RE = /UTC|GMT/;\n\nvar NativeFormatter = function () {\n  function NativeFormatter(formatSettings) {\n    var standardDateProps = {};\n    var extendedSettings = {};\n    var severity = 0;\n\n    for (var name_1 in formatSettings) {\n      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n        extendedSettings[name_1] = formatSettings[name_1];\n        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n      } else {\n        standardDateProps[name_1] = formatSettings[name_1];\n\n        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n          // TODO: what about hour12? no severity\n          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n        }\n      }\n    }\n\n    this.standardDateProps = standardDateProps;\n    this.extendedSettings = extendedSettings;\n    this.severity = severity;\n    this.buildFormattingFunc = memoize(buildFormattingFunc);\n  }\n\n  NativeFormatter.prototype.format = function (date, context) {\n    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n  };\n\n  NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    var _a = this,\n        standardDateProps = _a.standardDateProps,\n        extendedSettings = _a.extendedSettings;\n\n    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n\n    if (!diffSeverity) {\n      return this.format(start, context);\n    }\n\n    var biggestUnitForPartial = diffSeverity;\n\n    if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n    }\n\n    var full0 = this.format(start, context);\n    var full1 = this.format(end, context);\n\n    if (full0 === full1) {\n      return full0;\n    }\n\n    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n    var partial0 = partialFormattingFunc(start);\n    var partial1 = partialFormattingFunc(end);\n    var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n    var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n\n    if (insertion) {\n      return insertion.before + partial0 + separator + partial1 + insertion.after;\n    }\n\n    return full0 + separator + full1;\n  };\n\n  NativeFormatter.prototype.getLargestUnit = function () {\n    switch (this.severity) {\n      case 7:\n      case 6:\n      case 5:\n        return 'year';\n\n      case 4:\n        return 'month';\n\n      case 3:\n        return 'week';\n\n      case 2:\n        return 'day';\n\n      default:\n        return 'time';\n      // really?\n    }\n  };\n\n  return NativeFormatter;\n}();\n\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n  var standardDatePropCnt = Object.keys(standardDateProps).length;\n\n  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n    return function (date) {\n      return formatTimeZoneOffset(date.timeZoneOffset);\n    };\n  }\n\n  if (standardDatePropCnt === 0 && extendedSettings.week) {\n    return function (date) {\n      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n    };\n  }\n\n  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\n\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n  standardDateProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, standardDateProps); // copy\n\n  extendedSettings = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, extendedSettings); // copy\n\n  sanitizeSettings(standardDateProps, extendedSettings);\n  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n\n  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n  var zeroFormat; // needed?\n\n  if (extendedSettings.omitZeroMinute) {\n    var zeroProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, standardDateProps);\n\n    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n\n    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n  }\n\n  return function (date) {\n    var marker = date.marker;\n    var format;\n\n    if (zeroFormat && !marker.getUTCMinutes()) {\n      format = zeroFormat;\n    } else {\n      format = normalFormat;\n    }\n\n    var s = format.format(marker);\n    return postProcess(s, date, standardDateProps, extendedSettings, context);\n  };\n}\n\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n  // deal with a browser inconsistency where formatting the timezone\n  // requires that the hour/minute be present.\n  if (standardDateProps.timeZoneName) {\n    if (!standardDateProps.hour) {\n      standardDateProps.hour = '2-digit';\n    }\n\n    if (!standardDateProps.minute) {\n      standardDateProps.minute = '2-digit';\n    }\n  } // only support short timezone names\n\n\n  if (standardDateProps.timeZoneName === 'long') {\n    standardDateProps.timeZoneName = 'short';\n  } // if requesting to display seconds, MUST display minutes\n\n\n  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n    delete extendedSettings.omitZeroMinute;\n  }\n}\n\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n\n  if (standardDateProps.timeZoneName === 'short') {\n    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does \"GMT\"\n    formatTimeZoneOffset(date.timeZoneOffset));\n  }\n\n  if (extendedSettings.omitCommas) {\n    s = s.replace(COMMA_RE, '').trim();\n  }\n\n  if (extendedSettings.omitZeroMinute) {\n    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n  } // ^ do anything that might create adjacent spaces before this point,\n  // because MERIDIEM_RE likes to eat up loading spaces\n\n\n  if (extendedSettings.meridiem === false) {\n    s = s.replace(MERIDIEM_RE, '').trim();\n  } else if (extendedSettings.meridiem === 'narrow') {\n    // a/p\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase();\n    });\n  } else if (extendedSettings.meridiem === 'short') {\n    // am/pm\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase() + \"m\";\n    });\n  } else if (extendedSettings.meridiem === 'lowercase') {\n    // other meridiem transformers already converted to lowercase\n    s = s.replace(MERIDIEM_RE, function (m0) {\n      return m0.toLocaleLowerCase();\n    });\n  }\n\n  s = s.replace(MULTI_SPACE_RE, ' ');\n  s = s.trim();\n  return s;\n}\n\nfunction injectTzoStr(s, tzoStr) {\n  var replaced = false;\n  s = s.replace(UTC_RE, function () {\n    replaced = true;\n    return tzoStr;\n  }); // IE11 doesn't include UTC/GMT in the original string, so append to end\n\n  if (!replaced) {\n    s += \" \" + tzoStr;\n  }\n\n  return s;\n}\n\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n  var parts = [];\n\n  if (display === 'long') {\n    parts.push(weekTextLong);\n  } else if (display === 'short' || display === 'narrow') {\n    parts.push(weekText);\n  }\n\n  if (display === 'long' || display === 'short') {\n    parts.push(' ');\n  }\n\n  parts.push(locale.simpleNumberFormat.format(num));\n\n  if (locale.options.direction === 'rtl') {\n    // TODO: use control characters instead?\n    parts.reverse();\n  }\n\n  return parts.join('');\n} // Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\n\n\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n    return 5;\n  }\n\n  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n    return 4;\n  }\n\n  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n    return 2;\n  }\n\n  if (timeAsMs(d0) !== timeAsMs(d1)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction computePartialFormattingOptions(options, biggestUnit) {\n  var partialOptions = {};\n\n  for (var name_2 in options) {\n    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n      partialOptions[name_2] = options[name_2];\n    }\n  }\n\n  return partialOptions;\n}\n\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n  var i0 = 0;\n\n  while (i0 < full0.length) {\n    var found0 = full0.indexOf(partial0, i0);\n\n    if (found0 === -1) {\n      break;\n    }\n\n    var before0 = full0.substr(0, found0);\n    i0 = found0 + partial0.length;\n    var after0 = full0.substr(i0);\n    var i1 = 0;\n\n    while (i1 < full1.length) {\n      var found1 = full1.indexOf(partial1, i1);\n\n      if (found1 === -1) {\n        break;\n      }\n\n      var before1 = full1.substr(0, found1);\n      i1 = found1 + partial1.length;\n      var after1 = full1.substr(i1);\n\n      if (before0 === before1 && after0 === after1) {\n        return {\n          before: before0,\n          after: after0\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n  var a = calendarSystem.markerToArray(dateInfo.marker);\n  return {\n    marker: dateInfo.marker,\n    timeZoneOffset: dateInfo.timeZoneOffset,\n    array: a,\n    year: a[0],\n    month: a[1],\n    day: a[2],\n    hour: a[3],\n    minute: a[4],\n    second: a[5],\n    millisecond: a[6]\n  };\n}\n\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n  var startInfo = expandZonedMarker(start, context.calendarSystem);\n  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n  return {\n    date: startInfo,\n    start: startInfo,\n    end: endInfo,\n    timeZone: context.timeZone,\n    localeCodes: context.locale.codes,\n    defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n  };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\n\n\nvar CmdFormatter = function () {\n  function CmdFormatter(cmdStr) {\n    this.cmdStr = cmdStr;\n  }\n\n  CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return CmdFormatter;\n}();\n\nvar FuncFormatter = function () {\n  function FuncFormatter(func) {\n    this.func = func;\n  }\n\n  FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return FuncFormatter;\n}();\n\nfunction createFormatter(input) {\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return new NativeFormatter(input);\n  }\n\n  if (typeof input === 'string') {\n    return new CmdFormatter(input);\n  }\n\n  if (typeof input === 'function') {\n    return new FuncFormatter(input);\n  }\n\n  return null;\n} // base options\n// ------------\n\n\nvar BASE_OPTION_REFINERS = {\n  navLinkDayClick: identity,\n  navLinkWeekClick: identity,\n  duration: createDuration,\n  bootstrapFontAwesome: identity,\n  buttonIcons: identity,\n  customButtons: identity,\n  defaultAllDayEventDuration: createDuration,\n  defaultTimedEventDuration: createDuration,\n  nextDayThreshold: createDuration,\n  scrollTime: createDuration,\n  scrollTimeReset: Boolean,\n  slotMinTime: createDuration,\n  slotMaxTime: createDuration,\n  dayPopoverFormat: createFormatter,\n  slotDuration: createDuration,\n  snapDuration: createDuration,\n  headerToolbar: identity,\n  footerToolbar: identity,\n  defaultRangeSeparator: String,\n  titleRangeSeparator: String,\n  forceEventDuration: Boolean,\n  dayHeaders: Boolean,\n  dayHeaderFormat: createFormatter,\n  dayHeaderClassNames: identity,\n  dayHeaderContent: identity,\n  dayHeaderDidMount: identity,\n  dayHeaderWillUnmount: identity,\n  dayCellClassNames: identity,\n  dayCellContent: identity,\n  dayCellDidMount: identity,\n  dayCellWillUnmount: identity,\n  initialView: String,\n  aspectRatio: Number,\n  weekends: Boolean,\n  weekNumberCalculation: identity,\n  weekNumbers: Boolean,\n  weekNumberClassNames: identity,\n  weekNumberContent: identity,\n  weekNumberDidMount: identity,\n  weekNumberWillUnmount: identity,\n  editable: Boolean,\n  viewClassNames: identity,\n  viewDidMount: identity,\n  viewWillUnmount: identity,\n  nowIndicator: Boolean,\n  nowIndicatorClassNames: identity,\n  nowIndicatorContent: identity,\n  nowIndicatorDidMount: identity,\n  nowIndicatorWillUnmount: identity,\n  showNonCurrentDates: Boolean,\n  lazyFetching: Boolean,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String,\n  timeZone: String,\n  locales: identity,\n  locale: identity,\n  themeSystem: String,\n  dragRevertDuration: Number,\n  dragScroll: Boolean,\n  allDayMaintainDuration: Boolean,\n  unselectAuto: Boolean,\n  dropAccept: identity,\n  eventOrder: parseFieldSpecs,\n  eventOrderStrict: Boolean,\n  handleWindowResize: Boolean,\n  windowResizeDelay: Number,\n  longPressDelay: Number,\n  eventDragMinDistance: Number,\n  expandRows: Boolean,\n  height: identity,\n  contentHeight: identity,\n  direction: String,\n  weekNumberFormat: createFormatter,\n  eventResizableFromStart: Boolean,\n  displayEventTime: Boolean,\n  displayEventEnd: Boolean,\n  weekText: String,\n  weekTextLong: String,\n  progressiveEventRendering: Boolean,\n  businessHours: identity,\n  initialDate: identity,\n  now: identity,\n  eventDataTransform: identity,\n  stickyHeaderDates: identity,\n  stickyFooterScrollbar: identity,\n  viewHeight: identity,\n  defaultAllDay: Boolean,\n  eventSourceFailure: identity,\n  eventSourceSuccess: identity,\n  eventDisplay: String,\n  eventStartEditable: Boolean,\n  eventDurationEditable: Boolean,\n  eventOverlap: identity,\n  eventConstraint: identity,\n  eventAllow: identity,\n  eventBackgroundColor: String,\n  eventBorderColor: String,\n  eventTextColor: String,\n  eventColor: String,\n  eventClassNames: identity,\n  eventContent: identity,\n  eventDidMount: identity,\n  eventWillUnmount: identity,\n  selectConstraint: identity,\n  selectOverlap: identity,\n  selectAllow: identity,\n  droppable: Boolean,\n  unselectCancel: String,\n  slotLabelFormat: identity,\n  slotLaneClassNames: identity,\n  slotLaneContent: identity,\n  slotLaneDidMount: identity,\n  slotLaneWillUnmount: identity,\n  slotLabelClassNames: identity,\n  slotLabelContent: identity,\n  slotLabelDidMount: identity,\n  slotLabelWillUnmount: identity,\n  dayMaxEvents: identity,\n  dayMaxEventRows: identity,\n  dayMinWidth: Number,\n  slotLabelInterval: createDuration,\n  allDayText: String,\n  allDayClassNames: identity,\n  allDayContent: identity,\n  allDayDidMount: identity,\n  allDayWillUnmount: identity,\n  slotMinWidth: Number,\n  navLinks: Boolean,\n  eventTimeFormat: createFormatter,\n  rerenderDelay: Number,\n  moreLinkText: identity,\n  moreLinkHint: identity,\n  selectMinDistance: Number,\n  selectable: Boolean,\n  selectLongPressDelay: Number,\n  eventLongPressDelay: Number,\n  selectMirror: Boolean,\n  eventMaxStack: Number,\n  eventMinHeight: Number,\n  eventMinWidth: Number,\n  eventShortHeight: Number,\n  slotEventOverlap: Boolean,\n  plugins: identity,\n  firstDay: Number,\n  dayCount: Number,\n  dateAlignment: String,\n  dateIncrement: createDuration,\n  hiddenDays: identity,\n  monthMode: Boolean,\n  fixedWeekCount: Boolean,\n  validRange: identity,\n  visibleRange: identity,\n  titleFormat: identity,\n  eventInteractive: Boolean,\n  // only used by list-view, but languages define the value, so we need it in base options\n  noEventsText: String,\n  viewHint: identity,\n  navLinkHint: identity,\n  closeHint: String,\n  timeHint: String,\n  eventHint: String,\n  moreLinkClick: identity,\n  moreLinkClassNames: identity,\n  moreLinkContent: identity,\n  moreLinkDidMount: identity,\n  moreLinkWillUnmount: identity\n}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\n\nvar BASE_OPTION_DEFAULTS = {\n  eventDisplay: 'auto',\n  defaultRangeSeparator: ' - ',\n  titleRangeSeparator: \" \\u2013 \",\n  defaultTimedEventDuration: '01:00:00',\n  defaultAllDayEventDuration: {\n    day: 1\n  },\n  forceEventDuration: false,\n  nextDayThreshold: '00:00:00',\n  dayHeaders: true,\n  initialView: '',\n  aspectRatio: 1.35,\n  headerToolbar: {\n    start: 'title',\n    center: '',\n    end: 'today prev,next'\n  },\n  weekends: true,\n  weekNumbers: false,\n  weekNumberCalculation: 'local',\n  editable: false,\n  nowIndicator: false,\n  scrollTime: '06:00:00',\n  scrollTimeReset: true,\n  slotMinTime: '00:00:00',\n  slotMaxTime: '24:00:00',\n  showNonCurrentDates: true,\n  lazyFetching: true,\n  startParam: 'start',\n  endParam: 'end',\n  timeZoneParam: 'timeZone',\n  timeZone: 'local',\n  locales: [],\n  locale: '',\n  themeSystem: 'standard',\n  dragRevertDuration: 500,\n  dragScroll: true,\n  allDayMaintainDuration: false,\n  unselectAuto: true,\n  dropAccept: '*',\n  eventOrder: 'start,-duration,allDay,title',\n  dayPopoverFormat: {\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric'\n  },\n  handleWindowResize: true,\n  windowResizeDelay: 100,\n  longPressDelay: 1000,\n  eventDragMinDistance: 5,\n  expandRows: false,\n  navLinks: false,\n  selectable: false,\n  eventMinHeight: 15,\n  eventMinWidth: 30,\n  eventShortHeight: 30\n}; // calendar listeners\n// ------------------\n\nvar CALENDAR_LISTENER_REFINERS = {\n  datesSet: identity,\n  eventsSet: identity,\n  eventAdd: identity,\n  eventChange: identity,\n  eventRemove: identity,\n  windowResize: identity,\n  eventClick: identity,\n  eventMouseEnter: identity,\n  eventMouseLeave: identity,\n  select: identity,\n  unselect: identity,\n  loading: identity,\n  // internal\n  _unmount: identity,\n  _beforeprint: identity,\n  _afterprint: identity,\n  _noEventDrop: identity,\n  _noEventResize: identity,\n  _resize: identity,\n  _scrollRequest: identity\n}; // calendar-specific options\n// -------------------------\n\nvar CALENDAR_OPTION_REFINERS = {\n  buttonText: identity,\n  buttonHints: identity,\n  views: identity,\n  plugins: identity,\n  initialEvents: identity,\n  events: identity,\n  eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n  headerToolbar: isBoolComplexEqual,\n  footerToolbar: isBoolComplexEqual,\n  buttonText: isBoolComplexEqual,\n  buttonHints: isBoolComplexEqual,\n  buttonIcons: isBoolComplexEqual\n};\n\nfunction isBoolComplexEqual(a, b) {\n  if (typeof a === 'object' && typeof b === 'object' && a && b) {\n    // both non-null objects\n    return isPropsEqual(a, b);\n  }\n\n  return a === b;\n} // view-specific options\n// ---------------------\n\n\nvar VIEW_OPTION_REFINERS = {\n  type: String,\n  component: identity,\n  buttonText: String,\n  buttonTextKey: String,\n  dateProfileGeneratorClass: identity,\n  usesMinMaxTime: Boolean,\n  classNames: identity,\n  content: identity,\n  didMount: identity,\n  willUnmount: identity\n}; // util funcs\n// ----------------------------------------------------------------------------------------------------\n\nfunction mergeRawOptions(optionSets) {\n  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\n\nfunction refineProps(input, refiners) {\n  var refined = {};\n  var extra = {};\n\n  for (var propName in refiners) {\n    if (propName in input) {\n      refined[propName] = refiners[propName](input[propName]);\n    }\n  }\n\n  for (var propName in input) {\n    if (!(propName in refiners)) {\n      extra[propName] = input[propName];\n    }\n  }\n\n  return {\n    refined: refined,\n    extra: extra\n  };\n}\n\nfunction identity(raw) {\n  return raw;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n  var eventStore = createEmptyEventStore();\n  var eventRefiners = buildEventRefiners(context);\n\n  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n    var rawEvent = rawEvents_1[_i];\n    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n\n    if (tuple) {\n      eventTupleToStore(tuple, eventStore);\n    }\n  }\n\n  return eventStore;\n}\n\nfunction eventTupleToStore(tuple, eventStore) {\n  if (eventStore === void 0) {\n    eventStore = createEmptyEventStore();\n  }\n\n  eventStore.defs[tuple.def.defId] = tuple.def;\n\n  if (tuple.instance) {\n    eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n  }\n\n  return eventStore;\n} // retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\n\n\nfunction getRelevantEvents(eventStore, instanceId) {\n  var instance = eventStore.instances[instanceId];\n\n  if (instance) {\n    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group\n\n    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n      return isEventDefsGrouped(def_1, lookDef);\n    }); // add the original\n    // TODO: wish we could use eventTupleToStore or something like it\n\n    newStore.defs[def_1.defId] = def_1;\n    newStore.instances[instance.instanceId] = instance;\n    return newStore;\n  }\n\n  return createEmptyEventStore();\n}\n\nfunction isEventDefsGrouped(def0, def1) {\n  return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\n\nfunction createEmptyEventStore() {\n  return {\n    defs: {},\n    instances: {}\n  };\n}\n\nfunction mergeEventStores(store0, store1) {\n  return {\n    defs: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, store0.defs), store1.defs),\n    instances: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, store0.instances), store1.instances)\n  };\n}\n\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n  var defs = filterHash(eventStore.defs, filterFunc);\n  var instances = filterHash(eventStore.instances, function (instance) {\n    return defs[instance.defId] // still exists?\n    ;\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeSubEventStore(master, sub) {\n  var defs = master.defs,\n      instances = master.instances;\n  var filteredDefs = {};\n  var filteredInstances = {};\n\n  for (var defId in defs) {\n    if (!sub.defs[defId]) {\n      // not explicitly excluded\n      filteredDefs[defId] = defs[defId];\n    }\n  }\n\n  for (var instanceId in instances) {\n    if (!sub.instances[instanceId] && // not explicitly excluded\n    filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n    ) {\n      filteredInstances[instanceId] = instances[instanceId];\n    }\n  }\n\n  return {\n    defs: filteredDefs,\n    instances: filteredInstances\n  };\n}\n\nfunction normalizeConstraint(input, context) {\n  if (Array.isArray(input)) {\n    return parseEvents(input, null, context, true); // allowOpenRange=true\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseEvents([input], null, context, true); // allowOpenRange=true\n  }\n\n  if (input != null) {\n    return String(input);\n  }\n\n  return null;\n}\n\nfunction parseClassNames(raw) {\n  if (Array.isArray(raw)) {\n    return raw;\n  }\n\n  if (typeof raw === 'string') {\n    return raw.split(/\\s+/);\n  }\n\n  return [];\n} // TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n\n\nvar EVENT_UI_REFINERS = {\n  display: String,\n  editable: Boolean,\n  startEditable: Boolean,\n  durationEditable: Boolean,\n  constraint: identity,\n  overlap: identity,\n  allow: identity,\n  className: parseClassNames,\n  classNames: parseClassNames,\n  color: String,\n  backgroundColor: String,\n  borderColor: String,\n  textColor: String\n};\nvar EMPTY_EVENT_UI = {\n  display: null,\n  startEditable: null,\n  durationEditable: null,\n  constraints: [],\n  overlap: null,\n  allows: [],\n  backgroundColor: '',\n  borderColor: '',\n  textColor: '',\n  classNames: []\n};\n\nfunction createEventUi(refined, context) {\n  var constraint = normalizeConstraint(refined.constraint, context);\n  return {\n    display: refined.display || null,\n    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n    constraints: constraint != null ? [constraint] : [],\n    overlap: refined.overlap != null ? refined.overlap : null,\n    allows: refined.allow != null ? [refined.allow] : [],\n    backgroundColor: refined.backgroundColor || refined.color || '',\n    borderColor: refined.borderColor || refined.color || '',\n    textColor: refined.textColor || '',\n    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural\n\n  };\n} // TODO: prevent against problems with <2 args!\n\n\nfunction combineEventUis(uis) {\n  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\n\nfunction combineTwoEventUis(item0, item1) {\n  return {\n    display: item1.display != null ? item1.display : item0.display,\n    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n    constraints: item0.constraints.concat(item1.constraints),\n    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n    allows: item0.allows.concat(item1.allows),\n    backgroundColor: item1.backgroundColor || item0.backgroundColor,\n    borderColor: item1.borderColor || item0.borderColor,\n    textColor: item1.textColor || item0.textColor,\n    classNames: item0.classNames.concat(item1.classNames)\n  };\n}\n\nvar EVENT_NON_DATE_REFINERS = {\n  id: String,\n  groupId: String,\n  title: String,\n  url: String,\n  interactive: Boolean\n};\nvar EVENT_DATE_REFINERS = {\n  start: identity,\n  end: identity,\n  date: identity,\n  allDay: Boolean\n};\n\nvar EVENT_REFINERS = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n  extendedProps: identity\n});\n\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  var _a = refineEventDef(raw, context, refiners),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n\n  if (recurringRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n    def.recurringDef = {\n      typeId: recurringRes.typeId,\n      typeData: recurringRes.typeData,\n      duration: recurringRes.duration\n    };\n    return {\n      def: def,\n      instance: null\n    };\n  }\n\n  var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n\n  if (singleRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n    var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n    return {\n      def: def,\n      instance: instance\n    };\n  }\n\n  return null;\n}\n\nfunction refineEventDef(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  return refineProps(raw, refiners);\n}\n\nfunction buildEventRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\n\n\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n  var def = {\n    title: refined.title || '',\n    groupId: refined.groupId || '',\n    publicId: refined.id || '',\n    url: refined.url || '',\n    recurringDef: null,\n    defId: guid(),\n    sourceId: sourceId,\n    allDay: allDay,\n    hasEnd: hasEnd,\n    interactive: refined.interactive,\n    ui: createEventUi(refined, context),\n    extendedProps: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, refined.extendedProps || {}), extra)\n  };\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n    var memberAdder = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(def, memberAdder(refined));\n  } // help out EventApi from having user modify props\n\n\n  Object.freeze(def.ui.classNames);\n  Object.freeze(def.extendedProps);\n  return def;\n}\n\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n  var allDay = refined.allDay;\n  var startMeta;\n  var startMarker = null;\n  var hasEnd = false;\n  var endMeta;\n  var endMarker = null;\n  var startInput = refined.start != null ? refined.start : refined.date;\n  startMeta = context.dateEnv.createMarkerMeta(startInput);\n\n  if (startMeta) {\n    startMarker = startMeta.marker;\n  } else if (!allowOpenRange) {\n    return null;\n  }\n\n  if (refined.end != null) {\n    endMeta = context.dateEnv.createMarkerMeta(refined.end);\n  }\n\n  if (allDay == null) {\n    if (defaultAllDay != null) {\n      allDay = defaultAllDay;\n    } else {\n      // fall back to the date props LAST\n      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n    }\n  }\n\n  if (allDay && startMarker) {\n    startMarker = startOfDay(startMarker);\n  }\n\n  if (endMeta) {\n    endMarker = endMeta.marker;\n\n    if (allDay) {\n      endMarker = startOfDay(endMarker);\n    }\n\n    if (startMarker && endMarker <= startMarker) {\n      endMarker = null;\n    }\n  }\n\n  if (endMarker) {\n    hasEnd = true;\n  } else if (!allowOpenRange) {\n    hasEnd = context.options.forceEventDuration || false;\n    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n  }\n\n  return {\n    allDay: allDay,\n    hasEnd: hasEnd,\n    range: {\n      start: startMarker,\n      end: endMarker\n    },\n    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n    forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n  };\n}\n\nfunction computeIsDefaultAllDay(eventSource, context) {\n  var res = null;\n\n  if (eventSource) {\n    res = eventSource.defaultAllDay;\n  }\n\n  if (res == null) {\n    res = context.options.defaultAllDay;\n  }\n\n  return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\n\n\nfunction computeAlignedDayRange(timedRange) {\n  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n  var start = startOfDay(timedRange.start);\n  var end = addDays(start, dayCnt);\n  return {\n    start: start,\n    end: end\n  };\n} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\n\n\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n  if (nextDayThreshold === void 0) {\n    nextDayThreshold = createDuration(0);\n  }\n\n  var startDay = null;\n  var endDay = null;\n\n  if (timedRange.end) {\n    endDay = startOfDay(timedRange.end);\n    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n    // If the end time is actually inclusively part of the next day and is equal to or\n    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n      endDay = addDays(endDay, 1);\n    }\n  }\n\n  if (timedRange.start) {\n    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n\n    if (endDay && endDay <= startDay) {\n      endDay = addDays(startDay, 1);\n    }\n  }\n\n  return {\n    start: startDay,\n    end: endDay\n  };\n} // spans from one day into another?\n\n\nfunction isMultiDayRange(range) {\n  var visibleRange = computeVisibleDayRange(range);\n  return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\n\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n  if (largeUnit === 'year') {\n    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n  }\n\n  if (largeUnit === 'month') {\n    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n  }\n\n  return diffDayAndTime(date0, date1); // returns a duration\n}\n\nfunction parseRange(input, dateEnv) {\n  var start = null;\n  var end = null;\n\n  if (input.start) {\n    start = dateEnv.createMarker(input.start);\n  }\n\n  if (input.end) {\n    end = dateEnv.createMarker(input.end);\n  }\n\n  if (!start && !end) {\n    return null;\n  }\n\n  if (start && end && end < start) {\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n} // SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\n\n\nfunction invertRanges(ranges, constraintRange) {\n  var invertedRanges = [];\n  var start = constraintRange.start; // the end of the previous range. the start of the new range\n\n  var i;\n  var dateRange; // ranges need to be in order. required for our date-walking algorithm\n\n  ranges.sort(compareRanges);\n\n  for (i = 0; i < ranges.length; i += 1) {\n    dateRange = ranges[i]; // add the span of time before the event (if there is any)\n\n    if (dateRange.start > start) {\n      // compare millisecond time (skip any ambig logic)\n      invertedRanges.push({\n        start: start,\n        end: dateRange.start\n      });\n    }\n\n    if (dateRange.end > start) {\n      start = dateRange.end;\n    }\n  } // add the span of time after the last event (if there is any)\n\n\n  if (start < constraintRange.end) {\n    // compare millisecond time (skip any ambig logic)\n    invertedRanges.push({\n      start: start,\n      end: constraintRange.end\n    });\n  }\n\n  return invertedRanges;\n}\n\nfunction compareRanges(range0, range1) {\n  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\n\nfunction intersectRanges(range0, range1) {\n  var start = range0.start,\n      end = range0.end;\n  var newRange = null;\n\n  if (range1.start !== null) {\n    if (start === null) {\n      start = range1.start;\n    } else {\n      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n    }\n  }\n\n  if (range1.end != null) {\n    if (end === null) {\n      end = range1.end;\n    } else {\n      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n    }\n  }\n\n  if (start === null || end === null || start < end) {\n    newRange = {\n      start: start,\n      end: end\n    };\n  }\n\n  return newRange;\n}\n\nfunction rangesEqual(range0, range1) {\n  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\n\nfunction rangesIntersect(range0, range1) {\n  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\n\nfunction rangeContainsRange(outerRange, innerRange) {\n  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\n\nfunction rangeContainsMarker(range, date) {\n  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n} // If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n\n\nfunction constrainMarkerToRange(date, range) {\n  if (range.start != null && date < range.start) {\n    return range.start;\n  }\n\n  if (range.end != null && date >= range.end) {\n    return new Date(range.end.valueOf() - 1);\n  }\n\n  return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\n\n\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n  var inverseBgByGroupId = {};\n  var inverseBgByDefId = {};\n  var defByGroupId = {};\n  var bgRanges = [];\n  var fgRanges = [];\n  var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    var ui = eventUis[def.defId];\n\n    if (ui.display === 'inverse-background') {\n      if (def.groupId) {\n        inverseBgByGroupId[def.groupId] = [];\n\n        if (!defByGroupId[def.groupId]) {\n          defByGroupId[def.groupId] = def;\n        }\n      } else {\n        inverseBgByDefId[defId] = [];\n      }\n    }\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = eventStore.defs[instance.defId];\n    var ui = eventUis[def.defId];\n    var origRange = instance.range;\n    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n    var slicedRange = intersectRanges(normalRange, framingRange);\n\n    if (slicedRange) {\n      if (ui.display === 'inverse-background') {\n        if (def.groupId) {\n          inverseBgByGroupId[def.groupId].push(slicedRange);\n        } else {\n          inverseBgByDefId[instance.defId].push(slicedRange);\n        }\n      } else if (ui.display !== 'none') {\n        (ui.display === 'background' ? bgRanges : fgRanges).push({\n          def: def,\n          ui: ui,\n          instance: instance,\n          range: slicedRange,\n          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n        });\n      }\n    }\n  }\n\n  for (var groupId in inverseBgByGroupId) {\n    // BY GROUP\n    var ranges = inverseBgByGroupId[groupId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n      var invertedRange = invertedRanges_1[_i];\n      var def = defByGroupId[groupId];\n      var ui = eventUis[def.defId];\n      bgRanges.push({\n        def: def,\n        ui: ui,\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  for (var defId in inverseBgByDefId) {\n    var ranges = inverseBgByDefId[defId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n      var invertedRange = invertedRanges_2[_a];\n      bgRanges.push({\n        def: eventStore.defs[defId],\n        ui: eventUis[defId],\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  return {\n    bg: bgRanges,\n    fg: fgRanges\n  };\n}\n\nfunction hasBgRendering(def) {\n  return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\n\nfunction setElSeg(el, seg) {\n  el.fcSeg = seg;\n}\n\nfunction getElSeg(el) {\n  return el.fcSeg || el.parentNode.fcSeg || // for the harness\n  null;\n} // event ui computation\n\n\nfunction compileEventUis(eventDefs, eventUiBases) {\n  return mapHash(eventDefs, function (eventDef) {\n    return compileEventUi(eventDef, eventUiBases);\n  });\n}\n\nfunction compileEventUi(eventDef, eventUiBases) {\n  var uis = [];\n\n  if (eventUiBases['']) {\n    uis.push(eventUiBases['']);\n  }\n\n  if (eventUiBases[eventDef.defId]) {\n    uis.push(eventUiBases[eventDef.defId]);\n  }\n\n  uis.push(eventDef.ui);\n  return combineEventUis(uis);\n}\n\nfunction sortEventSegs(segs, eventOrderSpecs) {\n  var objs = segs.map(buildSegCompareObj);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n} // returns a object with all primitive props that can be compared\n\n\nfunction buildSegCompareObj(seg) {\n  var eventRange = seg.eventRange;\n  var eventDef = eventRange.def;\n  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n\n  var end = range.end ? range.end.valueOf() : 0; // \"\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventDef.extendedProps), eventDef), {\n    id: eventDef.publicId,\n    start: start,\n    end: end,\n    duration: end - start,\n    allDay: Number(eventDef.allDay),\n    _seg: seg\n  });\n}\n\nfunction computeSegDraggable(seg, context) {\n  var pluginHooks = context.pluginHooks;\n  var transformers = pluginHooks.isDraggableTransformers;\n  var _a = seg.eventRange,\n      def = _a.def,\n      ui = _a.ui;\n  var val = ui.startEditable;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    val = transformer(val, def, ui, context);\n  }\n\n  return val;\n}\n\nfunction computeSegStartResizable(seg, context) {\n  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\n\nfunction computeSegEndResizable(seg, context) {\n  return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\n\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var displayEventTime = options.displayEventTime,\n      displayEventEnd = options.displayEventEnd;\n  var eventDef = seg.eventRange.def;\n  var eventInstance = seg.eventRange.instance;\n\n  if (displayEventTime == null) {\n    displayEventTime = defaultDisplayEventTime !== false;\n  }\n\n  if (displayEventEnd == null) {\n    displayEventEnd = defaultDisplayEventEnd !== false;\n  }\n\n  var wholeEventStart = eventInstance.range.start;\n  var wholeEventEnd = eventInstance.range.end;\n  var segStart = startOverride || seg.start || seg.eventRange.range.start;\n  var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n  var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n  var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n\n  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n    segStart = isStartDay ? wholeEventStart : segStart;\n    segEnd = isEndDay ? wholeEventEnd : segEnd;\n\n    if (displayEventEnd && eventDef.hasEnd) {\n      return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(segStart, timeFormat, {\n      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same\n\n    });\n  }\n\n  return '';\n}\n\nfunction getSegMeta(seg, todayRange, nowDate) {\n  var segRange = seg.eventRange.range;\n  return {\n    isPast: segRange.end < (nowDate || todayRange.start),\n    isFuture: segRange.start >= (nowDate || todayRange.end),\n    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n  };\n}\n\nfunction getEventClassNames(props) {\n  var classNames = ['fc-event'];\n\n  if (props.isMirror) {\n    classNames.push('fc-event-mirror');\n  }\n\n  if (props.isDraggable) {\n    classNames.push('fc-event-draggable');\n  }\n\n  if (props.isStartResizable || props.isEndResizable) {\n    classNames.push('fc-event-resizable');\n  }\n\n  if (props.isDragging) {\n    classNames.push('fc-event-dragging');\n  }\n\n  if (props.isResizing) {\n    classNames.push('fc-event-resizing');\n  }\n\n  if (props.isSelected) {\n    classNames.push('fc-event-selected');\n  }\n\n  if (props.isStart) {\n    classNames.push('fc-event-start');\n  }\n\n  if (props.isEnd) {\n    classNames.push('fc-event-end');\n  }\n\n  if (props.isPast) {\n    classNames.push('fc-event-past');\n  }\n\n  if (props.isToday) {\n    classNames.push('fc-event-today');\n  }\n\n  if (props.isFuture) {\n    classNames.push('fc-event-future');\n  }\n\n  return classNames;\n}\n\nfunction buildEventRangeKey(eventRange) {\n  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution\n}\n\nfunction getSegAnchorAttrs(seg, context) {\n  var _a = seg.eventRange,\n      def = _a.def,\n      instance = _a.instance;\n  var url = def.url;\n\n  if (url) {\n    return {\n      href: url\n    };\n  }\n\n  var emitter = context.emitter,\n      options = context.options;\n  var eventInteractive = options.eventInteractive;\n\n  if (eventInteractive == null) {\n    eventInteractive = def.interactive;\n\n    if (eventInteractive == null) {\n      eventInteractive = Boolean(emitter.hasHandlers('eventClick'));\n    }\n  } // mock what happens in EventClicking\n\n\n  if (eventInteractive) {\n    // only attach keyboard-related handlers because click handler is already done in EventClicking\n    return createAriaKeyboardAttrs(function (ev) {\n      emitter.trigger('eventClick', {\n        el: ev.target,\n        event: new EventApi(context, def, instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    });\n  }\n\n  return {};\n}\n\nvar STANDARD_PROPS = {\n  start: identity,\n  end: identity,\n  allDay: Boolean\n};\n\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n  var span = parseOpenDateSpan(raw, dateEnv);\n  var range = span.range;\n\n  if (!range.start) {\n    return null;\n  }\n\n  if (!range.end) {\n    if (defaultDuration == null) {\n      return null;\n    }\n\n    range.end = dateEnv.add(range.start, defaultDuration);\n  }\n\n  return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\n\n\nfunction parseOpenDateSpan(raw, dateEnv) {\n  var _a = refineProps(raw, STANDARD_PROPS),\n      standardProps = _a.refined,\n      extra = _a.extra;\n\n  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n  var allDay = standardProps.allDay;\n\n  if (allDay == null) {\n    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n    range: {\n      start: startMeta ? startMeta.marker : null,\n      end: endMeta ? endMeta.marker : null\n    },\n    allDay: allDay\n  }, extra);\n}\n\nfunction isDateSpansEqual(span0, span1) {\n  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n} // the NON-DATE-RELATED props\n\n\nfunction isSpanPropsEqual(span0, span1) {\n  for (var propName in span1) {\n    if (propName !== 'range' && propName !== 'allDay') {\n      if (span0[propName] !== span1[propName]) {\n        return false;\n      }\n    }\n  } // are there any props that span0 has that span1 DOESN'T have?\n  // both have range/allDay, so no need to special-case.\n\n\n  for (var propName in span0) {\n    if (!(propName in span1)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction buildDateSpanApi(span, dateEnv) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n    allDay: span.allDay\n  });\n}\n\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildRangeApi(range, dateEnv, omitTime)), {\n    timeZone: dateEnv.timeZone\n  });\n}\n\nfunction buildRangeApi(range, dateEnv, omitTime) {\n  return {\n    start: dateEnv.toDate(range.start),\n    end: dateEnv.toDate(range.end),\n    startStr: dateEnv.formatIso(range.start, {\n      omitTime: omitTime\n    }),\n    endStr: dateEnv.formatIso(range.end, {\n      omitTime: omitTime\n    })\n  };\n}\n\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n  var res = refineEventDef({\n    editable: false\n  }, context);\n  var def = parseEventDef(res.refined, res.extra, '', // sourceId\n  dateSpan.allDay, true, // hasEnd\n  context);\n  return {\n    def: def,\n    ui: compileEventUi(def, eventUiBases),\n    instance: createEventInstance(def.defId, dateSpan.range),\n    range: dateSpan.range,\n    isStart: true,\n    isEnd: true\n  };\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n  context.emitter.trigger('select', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDateSpanApiWithContext(selection, context)), {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  }));\n}\n\nfunction triggerDateUnselect(pev, context) {\n  context.emitter.trigger('unselect', {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  });\n}\n\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, transform(dateSpan, context));\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, buildDateSpanApi(dateSpan, context.dateEnv));\n\n  return props;\n} // Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\n\n\nfunction getDefaultEventEnd(allDay, marker, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var end = marker;\n\n  if (allDay) {\n    end = startOfDay(end);\n    end = dateEnv.add(end, options.defaultAllDayEventDuration);\n  } else {\n    end = dateEnv.add(end, options.defaultTimedEventDuration);\n  }\n\n  return end;\n} // applies the mutation to ALL defs/instances within the event store\n\n\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n  var dest = createEmptyEventStore();\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = dest.defs[instance.defId]; // important to grab the newly modified def\n\n    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n  }\n\n  return dest;\n}\n\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.\n  // if duration will change, there's no way the default duration will persist,\n  // and thus, we need to mark the event as having a real end\n\n  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n    standardProps.hasEnd = true; // TODO: is this mutation okay?\n  }\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventDef), standardProps), {\n    ui: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventDef.ui), standardProps.ui)\n  });\n\n  if (mutation.extendedProps) {\n    copy.extendedProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, copy.extendedProps), mutation.extendedProps);\n  }\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n    var applier = _a[_i];\n    applier(copy, mutation, context);\n  }\n\n  if (!copy.hasEnd && context.options.forceEventDuration) {\n    copy.hasEnd = true;\n  }\n\n  return copy;\n}\n\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n  var dateEnv = context.dateEnv;\n  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventInstance);\n\n  if (forceAllDay) {\n    copy.range = computeAlignedDayRange(copy.range);\n  }\n\n  if (mutation.datesDelta && eventConfig.startEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.datesDelta),\n      end: dateEnv.add(copy.range.end, mutation.datesDelta)\n    };\n  }\n\n  if (mutation.startDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.startDelta),\n      end: copy.range.end\n    };\n  }\n\n  if (mutation.endDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: copy.range.start,\n      end: dateEnv.add(copy.range.end, mutation.endDelta)\n    };\n  }\n\n  if (clearEnd) {\n    copy.range = {\n      start: copy.range.start,\n      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n    };\n  } // in case event was all-day but the supplied deltas were not\n  // better util for this?\n\n\n  if (eventDef.allDay) {\n    copy.range = {\n      start: startOfDay(copy.range.start),\n      end: startOfDay(copy.range.end)\n    };\n  } // handle invalid durations\n\n\n  if (copy.range.end < copy.range.start) {\n    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n  }\n\n  return copy;\n} // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar ViewApi = function () {\n  function ViewApi(type, getCurrentData, dateEnv) {\n    this.type = type;\n    this.getCurrentData = getCurrentData;\n    this.dateEnv = dateEnv;\n  }\n\n  Object.defineProperty(ViewApi.prototype, \"calendar\", {\n    get: function get() {\n      return this.getCurrentData().calendarApi;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"title\", {\n    get: function get() {\n      return this.getCurrentData().viewTitle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ViewApi.prototype.getOption = function (name) {\n    return this.getCurrentData().options[name]; // are the view-specific options\n  };\n\n  return ViewApi;\n}();\n\nvar EVENT_SOURCE_REFINERS = {\n  id: String,\n  defaultAllDay: Boolean,\n  url: String,\n  format: String,\n  events: identity,\n  eventDataTransform: identity,\n  // for any network-related sources\n  success: identity,\n  failure: identity\n};\n\nfunction parseEventSource(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventSourceRefiners(context);\n  }\n\n  var rawObj;\n\n  if (typeof raw === 'string') {\n    rawObj = {\n      url: raw\n    };\n  } else if (typeof raw === 'function' || Array.isArray(raw)) {\n    rawObj = {\n      events: raw\n    };\n  } else if (typeof raw === 'object' && raw) {\n    // not null\n    rawObj = raw;\n  }\n\n  if (rawObj) {\n    var _a = refineProps(rawObj, refiners),\n        refined = _a.refined,\n        extra = _a.extra;\n\n    var metaRes = buildEventSourceMeta(refined, context);\n\n    if (metaRes) {\n      return {\n        _raw: raw,\n        isFetching: false,\n        latestFetchId: '',\n        fetchRange: null,\n        defaultAllDay: refined.defaultAllDay,\n        eventDataTransform: refined.eventDataTransform,\n        success: refined.success,\n        failure: refined.failure,\n        publicId: refined.id || '',\n        sourceId: guid(),\n        sourceDefId: metaRes.sourceDefId,\n        meta: metaRes.meta,\n        ui: createEventUi(refined, context),\n        extendedProps: extra\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction buildEventSourceRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\n\nfunction buildEventSourceMeta(raw, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n\n  for (var i = defs.length - 1; i >= 0; i -= 1) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(raw);\n\n    if (meta) {\n      return {\n        sourceDefId: i,\n        meta: meta\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n  switch (action.type) {\n    case 'CHANGE_DATE':\n      return action.dateMarker;\n\n    default:\n      return currentDate;\n  }\n}\n\nfunction getInitialDate(options, dateEnv) {\n  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date\n\n  if (initialDateInput != null) {\n    return dateEnv.createMarker(initialDateInput);\n  }\n\n  return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\n\nfunction getNow(nowInput, dateEnv) {\n  if (typeof nowInput === 'function') {\n    nowInput = nowInput();\n  }\n\n  if (nowInput == null) {\n    return dateEnv.createNowMarker();\n  }\n\n  return dateEnv.createMarker(nowInput);\n}\n\nvar CalendarApi = function () {\n  function CalendarApi() {}\n\n  CalendarApi.prototype.getCurrentData = function () {\n    return this.currentDataManager.getCurrentData();\n  };\n\n  CalendarApi.prototype.dispatch = function (action) {\n    return this.currentDataManager.dispatch(action);\n  };\n\n  Object.defineProperty(CalendarApi.prototype, \"view\", {\n    get: function get() {\n      return this.getCurrentData().viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  CalendarApi.prototype.batchRendering = function (callback) {\n    callback();\n  };\n\n  CalendarApi.prototype.updateSize = function () {\n    this.trigger('_resize', true);\n  }; // Options\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.setOption = function (name, val) {\n    this.dispatch({\n      type: 'SET_OPTION',\n      optionName: name,\n      rawOptionValue: val\n    });\n  };\n\n  CalendarApi.prototype.getOption = function (name) {\n    return this.currentDataManager.currentCalendarOptionsInput[name];\n  };\n\n  CalendarApi.prototype.getAvailableLocaleCodes = function () {\n    return Object.keys(this.getCurrentData().availableRawLocales);\n  }; // Trigger\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.on = function (handlerName, handler) {\n    var currentDataManager = this.currentDataManager;\n\n    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n      currentDataManager.emitter.on(handlerName, handler);\n    } else {\n      console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n    }\n  };\n\n  CalendarApi.prototype.off = function (handlerName, handler) {\n    this.currentDataManager.emitter.off(handlerName, handler);\n  }; // not meant for public use\n\n\n  CalendarApi.prototype.trigger = function (handlerName) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.currentDataManager.emitter).trigger.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([handlerName], args));\n  }; // View\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n    var _this = this;\n\n    this.batchRendering(function () {\n      _this.unselect();\n\n      if (dateOrRange) {\n        if (dateOrRange.start && dateOrRange.end) {\n          // a range\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType\n          });\n\n          _this.dispatch({\n            type: 'SET_OPTION',\n            optionName: 'visibleRange',\n            rawOptionValue: dateOrRange\n          });\n        } else {\n          var dateEnv = _this.getCurrentData().dateEnv;\n\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType,\n            dateMarker: dateEnv.createMarker(dateOrRange)\n          });\n        }\n      } else {\n        _this.dispatch({\n          type: 'CHANGE_VIEW_TYPE',\n          viewType: viewType\n        });\n      }\n    });\n  }; // Forces navigation to a view for the given date.\n  // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n  // needs to change\n\n\n  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n    var state = this.getCurrentData();\n    var spec;\n    viewType = viewType || 'day'; // day is default zoom\n\n    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n    this.unselect();\n\n    if (spec) {\n      this.dispatch({\n        type: 'CHANGE_VIEW_TYPE',\n        viewType: spec.type,\n        dateMarker: dateMarker\n      });\n    } else {\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: dateMarker\n      });\n    }\n  }; // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n  // Preference is given to views that have corresponding buttons.\n\n\n  CalendarApi.prototype.getUnitViewSpec = function (unit) {\n    var _a = this.getCurrentData(),\n        viewSpecs = _a.viewSpecs,\n        toolbarConfig = _a.toolbarConfig;\n\n    var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n    var i;\n    var spec;\n\n    for (var viewType in viewSpecs) {\n      viewTypes.push(viewType);\n    }\n\n    for (i = 0; i < viewTypes.length; i += 1) {\n      spec = viewSpecs[viewTypes[i]];\n\n      if (spec) {\n        if (spec.singleUnit === unit) {\n          return spec;\n        }\n      }\n    }\n\n    return null;\n  }; // Current Date\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.prev = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'PREV'\n    });\n  };\n\n  CalendarApi.prototype.next = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'NEXT'\n    });\n  };\n\n  CalendarApi.prototype.prevYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n    });\n  };\n\n  CalendarApi.prototype.nextYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n    });\n  };\n\n  CalendarApi.prototype.today = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n    });\n  };\n\n  CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.createMarker(zonedDateInput)\n    });\n  };\n\n  CalendarApi.prototype.incrementDate = function (deltaInput) {\n    var state = this.getCurrentData();\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // else, warn about invalid input?\n      this.unselect();\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: state.dateEnv.add(state.currentDate, delta)\n      });\n    }\n  }; // for external API\n\n\n  CalendarApi.prototype.getDate = function () {\n    var state = this.getCurrentData();\n    return state.dateEnv.toDate(state.currentDate);\n  }; // Date Formatting Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.formatDate = function (d, formatter) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n  }; // `settings` is for formatter AND isEndExclusive\n\n\n  CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n  };\n\n  CalendarApi.prototype.formatIso = function (d, omitTime) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatIso(dateEnv.createMarker(d), {\n      omitTime: omitTime\n    });\n  }; // Date Selection / Event Selection / DayClick\n  // -----------------------------------------------------------------------------------------------------------------\n  // this public method receives start/end dates in any format, with any timezone\n  // NOTE: args were changed from v3\n\n\n  CalendarApi.prototype.select = function (dateOrObj, endDate) {\n    var selectionInput;\n\n    if (endDate == null) {\n      if (dateOrObj.start != null) {\n        selectionInput = dateOrObj;\n      } else {\n        selectionInput = {\n          start: dateOrObj,\n          end: null\n        };\n      }\n    } else {\n      selectionInput = {\n        start: dateOrObj,\n        end: endDate\n      };\n    }\n\n    var state = this.getCurrentData();\n    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n      days: 1\n    }));\n\n    if (selection) {\n      // throw parse error otherwise?\n      this.dispatch({\n        type: 'SELECT_DATES',\n        selection: selection\n      });\n      triggerDateSelect(selection, null, state);\n    }\n  }; // public method\n\n\n  CalendarApi.prototype.unselect = function (pev) {\n    var state = this.getCurrentData();\n\n    if (state.dateSelection) {\n      this.dispatch({\n        type: 'UNSELECT_DATES'\n      });\n      triggerDateUnselect(pev, state);\n    }\n  }; // Public Events API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n    if (eventInput instanceof EventApi) {\n      var def = eventInput._def;\n      var instance = eventInput._instance;\n      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot\n\n      if (!currentData.eventStore.defs[def.defId]) {\n        this.dispatch({\n          type: 'ADD_EVENTS',\n          eventStore: eventTupleToStore({\n            def: def,\n            instance: instance\n          }) // TODO: better util for two args?\n\n        });\n        this.triggerEventAdd(eventInput);\n      }\n\n      return eventInput;\n    }\n\n    var state = this.getCurrentData();\n    var eventSource;\n\n    if (sourceInput instanceof EventSourceApi) {\n      eventSource = sourceInput.internalEventSource;\n    } else if (typeof sourceInput === 'boolean') {\n      if (sourceInput) {\n        // true. part of the first event source\n        eventSource = hashValuesToArray(state.eventSources)[0];\n      }\n    } else if (sourceInput != null) {\n      // an ID. accepts a number too\n      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n\n      if (!sourceApi) {\n        console.warn(\"Could not find an event source with ID \\\"\" + sourceInput + \"\\\"\"); // TODO: test\n\n        return null;\n      }\n\n      eventSource = sourceApi.internalEventSource;\n    }\n\n    var tuple = parseEvent(eventInput, eventSource, state, false);\n\n    if (tuple) {\n      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n      this.dispatch({\n        type: 'ADD_EVENTS',\n        eventStore: eventTupleToStore(tuple)\n      });\n      this.triggerEventAdd(newEventApi);\n      return newEventApi;\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n    var _this = this;\n\n    var emitter = this.getCurrentData().emitter;\n    emitter.trigger('eventAdd', {\n      event: eventApi,\n      relatedEvents: [],\n      revert: function revert() {\n        _this.dispatch({\n          type: 'REMOVE_EVENTS',\n          eventStore: eventApiToStore(eventApi)\n        });\n      }\n    });\n  }; // TODO: optimize\n\n\n  CalendarApi.prototype.getEventById = function (id) {\n    var state = this.getCurrentData();\n    var _a = state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    id = String(id);\n\n    for (var defId in defs) {\n      var def = defs[defId];\n\n      if (def.publicId === id) {\n        if (def.recurringDef) {\n          return new EventApi(state, def, null);\n        }\n\n        for (var instanceId in instances) {\n          var instance = instances[instanceId];\n\n          if (instance.defId === def.defId) {\n            return new EventApi(state, def, instance);\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.getEvents = function () {\n    var currentData = this.getCurrentData();\n    return buildEventApis(currentData.eventStore, currentData);\n  };\n\n  CalendarApi.prototype.removeAllEvents = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENTS'\n    });\n  }; // Public Event Sources API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.getEventSources = function () {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    var sourceApis = [];\n\n    for (var internalId in sourceHash) {\n      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n    }\n\n    return sourceApis;\n  };\n\n  CalendarApi.prototype.getEventSourceById = function (id) {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    id = String(id);\n\n    for (var sourceId in sourceHash) {\n      if (sourceHash[sourceId].publicId === id) {\n        return new EventSourceApi(state, sourceHash[sourceId]);\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.addEventSource = function (sourceInput) {\n    var state = this.getCurrentData();\n\n    if (sourceInput instanceof EventSourceApi) {\n      // not already present? don't want to add an old snapshot\n      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n        this.dispatch({\n          type: 'ADD_EVENT_SOURCES',\n          sources: [sourceInput.internalEventSource]\n        });\n      }\n\n      return sourceInput;\n    }\n\n    var eventSource = parseEventSource(sourceInput, state);\n\n    if (eventSource) {\n      // TODO: error otherwise?\n      this.dispatch({\n        type: 'ADD_EVENT_SOURCES',\n        sources: [eventSource]\n      });\n      return new EventSourceApi(state, eventSource);\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.removeAllEventSources = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENT_SOURCES'\n    });\n  };\n\n  CalendarApi.prototype.refetchEvents = function () {\n    this.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      isRefetch: true\n    });\n  }; // Scroll\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.scrollToTime = function (timeInput) {\n    var time = createDuration(timeInput);\n\n    if (time) {\n      this.trigger('_scrollRequest', {\n        time: time\n      });\n    }\n  };\n\n  return CalendarApi;\n}();\n\nvar EventApi = function () {\n  // instance will be null if expressing a recurring event that has no current instances,\n  // OR if trying to validate an incoming external event that has no dates assigned\n  function EventApi(context, def, instance) {\n    this._context = context;\n    this._def = def;\n    this._instance = instance || null;\n  }\n  /*\n  TODO: make event struct more responsible for this\n  */\n\n\n  EventApi.prototype.setProp = function (name, val) {\n    var _a, _b;\n\n    if (name in EVENT_DATE_REFINERS) {\n      console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?\n    } else if (name === 'id') {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: {\n          publicId: val\n        } // hardcoded internal name\n\n      });\n    } else if (name in EVENT_NON_DATE_REFINERS) {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: (_a = {}, _a[name] = val, _a)\n      });\n    } else if (name in EVENT_UI_REFINERS) {\n      var ui = EVENT_UI_REFINERS[name](val);\n\n      if (name === 'color') {\n        ui = {\n          backgroundColor: val,\n          borderColor: val\n        };\n      } else if (name === 'editable') {\n        ui = {\n          startEditable: val,\n          durationEditable: val\n        };\n      } else {\n        ui = (_b = {}, _b[name] = val, _b);\n      }\n\n      this.mutate({\n        standardProps: {\n          ui: ui\n        }\n      });\n    } else {\n      console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n    }\n  };\n\n  EventApi.prototype.setExtendedProp = function (name, val) {\n    var _a;\n\n    this.mutate({\n      extendedProps: (_a = {}, _a[name] = val, _a)\n    });\n  };\n\n  EventApi.prototype.setStart = function (startInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var start = dateEnv.createMarker(startInput);\n\n    if (start && this._instance) {\n      // TODO: warning if parsed bad\n      var instanceRange = this._instance.range;\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n\n      if (options.maintainDuration) {\n        this.mutate({\n          datesDelta: startDelta\n        });\n      } else {\n        this.mutate({\n          startDelta: startDelta\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setEnd = function (endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var end;\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        return; // TODO: warning if parsed bad\n      }\n    }\n\n    if (this._instance) {\n      if (end) {\n        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n        this.mutate({\n          endDelta: endDelta\n        });\n      } else {\n        this.mutate({\n          standardProps: {\n            hasEnd: false\n          }\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setDates = function (startInput, endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var standardProps = {\n      allDay: options.allDay\n    };\n    var start = dateEnv.createMarker(startInput);\n    var end;\n\n    if (!start) {\n      return; // TODO: warning if parsed bad\n    }\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        // TODO: warning if parsed bad\n        return;\n      }\n    }\n\n    if (this._instance) {\n      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,\n      // compute diff off of the all-day values the way event-mutation does.\n\n      if (options.allDay === true) {\n        instanceRange = computeAlignedDayRange(instanceRange);\n      }\n\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n\n      if (end) {\n        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n\n        if (durationsEqual(startDelta, endDelta)) {\n          this.mutate({\n            datesDelta: startDelta,\n            standardProps: standardProps\n          });\n        } else {\n          this.mutate({\n            startDelta: startDelta,\n            endDelta: endDelta,\n            standardProps: standardProps\n          });\n        }\n      } else {\n        // means \"clear the end\"\n        standardProps.hasEnd = false;\n        this.mutate({\n          datesDelta: startDelta,\n          standardProps: standardProps\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.moveStart = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        startDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveEnd = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        endDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveDates = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        datesDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.setAllDay = function (allDay, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var standardProps = {\n      allDay: allDay\n    };\n    var maintainDuration = options.maintainDuration;\n\n    if (maintainDuration == null) {\n      maintainDuration = this._context.options.allDayMaintainDuration;\n    }\n\n    if (this._def.allDay !== allDay) {\n      standardProps.hasEnd = maintainDuration;\n    }\n\n    this.mutate({\n      standardProps: standardProps\n    });\n  };\n\n  EventApi.prototype.formatRange = function (formatInput) {\n    var dateEnv = this._context.dateEnv;\n    var instance = this._instance;\n    var formatter = createFormatter(formatInput);\n\n    if (this._def.hasEnd) {\n      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n        forcedStartTzo: instance.forcedStartTzo,\n        forcedEndTzo: instance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(instance.range.start, formatter, {\n      forcedTzo: instance.forcedStartTzo\n    });\n  };\n\n  EventApi.prototype.mutate = function (mutation) {\n    var instance = this._instance;\n\n    if (instance) {\n      var def = this._def;\n      var context_1 = this._context;\n      var eventStore_1 = context_1.getCurrentData().eventStore;\n      var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n      var eventConfigBase = {\n        '': {\n          display: '',\n          startEditable: true,\n          durationEditable: true,\n          constraints: [],\n          overlap: null,\n          allows: [],\n          backgroundColor: '',\n          borderColor: '',\n          textColor: '',\n          classNames: []\n        }\n      };\n      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n      var oldEvent = new EventApi(context_1, def, instance); // snapshot\n\n      this._def = relevantEvents.defs[def.defId];\n      this._instance = relevantEvents.instances[instance.instanceId];\n      context_1.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: relevantEvents\n      });\n      context_1.emitter.trigger('eventChange', {\n        oldEvent: oldEvent,\n        event: this,\n        relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n        revert: function revert() {\n          context_1.dispatch({\n            type: 'RESET_EVENTS',\n            eventStore: eventStore_1\n          });\n        }\n      });\n    }\n  };\n\n  EventApi.prototype.remove = function () {\n    var context = this._context;\n    var asStore = eventApiToStore(this);\n    context.dispatch({\n      type: 'REMOVE_EVENTS',\n      eventStore: asStore\n    });\n    context.emitter.trigger('eventRemove', {\n      event: this,\n      relatedEvents: [],\n      revert: function revert() {\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: asStore\n        });\n      }\n    });\n  };\n\n  Object.defineProperty(EventApi.prototype, \"source\", {\n    get: function get() {\n      var sourceId = this._def.sourceId;\n\n      if (sourceId) {\n        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"start\", {\n    get: function get() {\n      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"end\", {\n    get: function get() {\n      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance) {\n        return this._context.dateEnv.formatIso(instance.range.start, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedStartTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"endStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance && this._def.hasEnd) {\n        return this._context.dateEnv.formatIso(instance.range.end, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedEndTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"id\", {\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get: function get() {\n      return this._def.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"groupId\", {\n    get: function get() {\n      return this._def.groupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allDay\", {\n    get: function get() {\n      return this._def.allDay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"title\", {\n    get: function get() {\n      return this._def.title;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"url\", {\n    get: function get() {\n      return this._def.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"display\", {\n    get: function get() {\n      return this._def.ui.display || 'auto';\n    } // bad. just normalize the type earlier\n    ,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startEditable\", {\n    get: function get() {\n      return this._def.ui.startEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n    get: function get() {\n      return this._def.ui.durationEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"constraint\", {\n    get: function get() {\n      return this._def.ui.constraints[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"overlap\", {\n    get: function get() {\n      return this._def.ui.overlap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allow\", {\n    get: function get() {\n      return this._def.ui.allows[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n    get: function get() {\n      return this._def.ui.backgroundColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"borderColor\", {\n    get: function get() {\n      return this._def.ui.borderColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"textColor\", {\n    get: function get() {\n      return this._def.ui.textColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"classNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function get() {\n      return this._def.ui.classNames;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n    get: function get() {\n      return this._def.extendedProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EventApi.prototype.toPlainObject = function (settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var def = this._def;\n    var ui = def.ui;\n\n    var _a = this,\n        startStr = _a.startStr,\n        endStr = _a.endStr;\n\n    var res = {};\n\n    if (def.title) {\n      res.title = def.title;\n    }\n\n    if (startStr) {\n      res.start = startStr;\n    }\n\n    if (endStr) {\n      res.end = endStr;\n    }\n\n    if (def.publicId) {\n      res.id = def.publicId;\n    }\n\n    if (def.groupId) {\n      res.groupId = def.groupId;\n    }\n\n    if (def.url) {\n      res.url = def.url;\n    }\n\n    if (ui.display && ui.display !== 'auto') {\n      res.display = ui.display;\n    } // TODO: what about recurring-event properties???\n    // TODO: include startEditable/durationEditable/constraint/overlap/allow\n\n\n    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n      res.color = ui.backgroundColor;\n    } else {\n      if (ui.backgroundColor) {\n        res.backgroundColor = ui.backgroundColor;\n      }\n\n      if (ui.borderColor) {\n        res.borderColor = ui.borderColor;\n      }\n    }\n\n    if (ui.textColor) {\n      res.textColor = ui.textColor;\n    }\n\n    if (ui.classNames.length) {\n      res.classNames = ui.classNames;\n    }\n\n    if (Object.keys(def.extendedProps).length) {\n      if (settings.collapseExtendedProps) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(res, def.extendedProps);\n      } else {\n        res.extendedProps = def.extendedProps;\n      }\n    }\n\n    return res;\n  };\n\n  EventApi.prototype.toJSON = function () {\n    return this.toPlainObject();\n  };\n\n  return EventApi;\n}();\n\nfunction eventApiToStore(eventApi) {\n  var _a, _b;\n\n  var def = eventApi._def;\n  var instance = eventApi._instance;\n  return {\n    defs: (_a = {}, _a[def.defId] = def, _a),\n    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n  };\n}\n\nfunction buildEventApis(eventStore, context, excludeInstance) {\n  var defs = eventStore.defs,\n      instances = eventStore.instances;\n  var eventApis = [];\n  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n\n  for (var id in instances) {\n    var instance = instances[id];\n    var def = defs[instance.defId];\n\n    if (instance.instanceId !== excludeInstanceId) {\n      eventApis.push(new EventApi(context, def, instance));\n    }\n  }\n\n  return eventApis;\n}\n\nvar calendarSystemClassMap = {};\n\nfunction registerCalendarSystem(name, theClass) {\n  calendarSystemClassMap[name] = theClass;\n}\n\nfunction createCalendarSystem(name) {\n  return new calendarSystemClassMap[name]();\n}\n\nvar GregorianCalendarSystem = function () {\n  function GregorianCalendarSystem() {}\n\n  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n    return d.getUTCFullYear();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n    return d.getUTCMonth();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n    return d.getUTCDate();\n  };\n\n  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n    return arrayToUtcDate(arr);\n  };\n\n  GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n    return dateToUtcArray(marker);\n  };\n\n  return GregorianCalendarSystem;\n}();\n\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n\nfunction parse(str) {\n  var m = ISO_RE.exec(str);\n\n  if (m) {\n    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n\n    if (isValidDate(marker)) {\n      var timeZoneOffset = null;\n\n      if (m[13]) {\n        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n      }\n\n      return {\n        marker: marker,\n        isTimeUnspecified: !m[6],\n        timeZoneOffset: timeZoneOffset\n      };\n    }\n  }\n\n  return null;\n}\n\nvar DateEnv = function () {\n  function DateEnv(settings) {\n    var timeZone = this.timeZone = settings.timeZone;\n    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n\n    if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n    }\n\n    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n    this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n    this.locale = settings.locale;\n    this.weekDow = settings.locale.week.dow;\n    this.weekDoy = settings.locale.week.doy;\n\n    if (settings.weekNumberCalculation === 'ISO') {\n      this.weekDow = 1;\n      this.weekDoy = 4;\n    }\n\n    if (typeof settings.firstDay === 'number') {\n      this.weekDow = settings.firstDay;\n    }\n\n    if (typeof settings.weekNumberCalculation === 'function') {\n      this.weekNumberFunc = settings.weekNumberCalculation;\n    }\n\n    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n    this.cmdFormatter = settings.cmdFormatter;\n    this.defaultSeparator = settings.defaultSeparator;\n  } // Creating / Parsing\n\n\n  DateEnv.prototype.createMarker = function (input) {\n    var meta = this.createMarkerMeta(input);\n\n    if (meta === null) {\n      return null;\n    }\n\n    return meta.marker;\n  };\n\n  DateEnv.prototype.createNowMarker = function () {\n    if (this.canComputeOffset) {\n      return this.timestampToMarker(new Date().valueOf());\n    } // if we can't compute the current date val for a timezone,\n    // better to give the current local date vals than UTC\n\n\n    return arrayToUtcDate(dateToLocalArray(new Date()));\n  };\n\n  DateEnv.prototype.createMarkerMeta = function (input) {\n    if (typeof input === 'string') {\n      return this.parse(input);\n    }\n\n    var marker = null;\n\n    if (typeof input === 'number') {\n      marker = this.timestampToMarker(input);\n    } else if (input instanceof Date) {\n      input = input.valueOf();\n\n      if (!isNaN(input)) {\n        marker = this.timestampToMarker(input);\n      }\n    } else if (Array.isArray(input)) {\n      marker = arrayToUtcDate(input);\n    }\n\n    if (marker === null || !isValidDate(marker)) {\n      return null;\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: false,\n      forcedTzo: null\n    };\n  };\n\n  DateEnv.prototype.parse = function (s) {\n    var parts = parse(s);\n\n    if (parts === null) {\n      return null;\n    }\n\n    var marker = parts.marker;\n    var forcedTzo = null;\n\n    if (parts.timeZoneOffset !== null) {\n      if (this.canComputeOffset) {\n        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n      } else {\n        forcedTzo = parts.timeZoneOffset;\n      }\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: parts.isTimeUnspecified,\n      forcedTzo: forcedTzo\n    };\n  }; // Accessors\n\n\n  DateEnv.prototype.getYear = function (marker) {\n    return this.calendarSystem.getMarkerYear(marker);\n  };\n\n  DateEnv.prototype.getMonth = function (marker) {\n    return this.calendarSystem.getMarkerMonth(marker);\n  }; // Adding / Subtracting\n\n\n  DateEnv.prototype.add = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += dur.years;\n    a[1] += dur.months;\n    a[2] += dur.days;\n    a[6] += dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.subtract = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] -= dur.years;\n    a[1] -= dur.months;\n    a[2] -= dur.days;\n    a[6] -= dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addYears = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addMonths = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[1] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  }; // Diffing Whole Units\n\n\n  DateEnv.prototype.diffWholeYears = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n    }\n\n    return null;\n  }; // Range / Duration\n\n\n  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n    var n = this.diffWholeYears(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'year',\n        value: n\n      };\n    }\n\n    n = this.diffWholeMonths(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'month',\n        value: n\n      };\n    }\n\n    n = diffWholeWeeks(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'week',\n        value: n\n      };\n    }\n\n    n = diffWholeDays(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'day',\n        value: n\n      };\n    }\n\n    n = diffHours(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'hour',\n        value: n\n      };\n    }\n\n    n = diffMinutes(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'minute',\n        value: n\n      };\n    }\n\n    n = diffSeconds(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'second',\n        value: n\n      };\n    }\n\n    return {\n      unit: 'millisecond',\n      value: m1.valueOf() - m0.valueOf()\n    };\n  };\n\n  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n    // TODO: can use greatestWholeUnit\n    var diff;\n\n    if (d.years) {\n      diff = this.diffWholeYears(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughYears(d);\n      }\n    }\n\n    if (d.months) {\n      diff = this.diffWholeMonths(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughMonths(d);\n      }\n    }\n\n    if (d.days) {\n      diff = diffWholeDays(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughDays(d);\n      }\n    }\n\n    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n  }; // Start-Of\n  // these DON'T return zoned-dates. only UTC start-of dates\n\n\n  DateEnv.prototype.startOf = function (m, unit) {\n    if (unit === 'year') {\n      return this.startOfYear(m);\n    }\n\n    if (unit === 'month') {\n      return this.startOfMonth(m);\n    }\n\n    if (unit === 'week') {\n      return this.startOfWeek(m);\n    }\n\n    if (unit === 'day') {\n      return startOfDay(m);\n    }\n\n    if (unit === 'hour') {\n      return startOfHour(m);\n    }\n\n    if (unit === 'minute') {\n      return startOfMinute(m);\n    }\n\n    if (unit === 'second') {\n      return startOfSecond(m);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.startOfYear = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);\n  };\n\n  DateEnv.prototype.startOfMonth = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);\n  };\n\n  DateEnv.prototype.startOfWeek = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);\n  }; // Week Number\n\n\n  DateEnv.prototype.computeWeekNumber = function (marker) {\n    if (this.weekNumberFunc) {\n      return this.weekNumberFunc(this.toDate(marker));\n    }\n\n    return weekOfYear(marker, this.weekDow, this.weekDoy);\n  }; // TODO: choke on timeZoneName: long\n\n\n  DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    return formatter.format({\n      marker: marker,\n      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n    }, this);\n  };\n\n  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    if (dateOptions.isEndExclusive) {\n      end = addMs(end, -1);\n    }\n\n    return formatter.formatRange({\n      marker: start,\n      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n    }, {\n      marker: end,\n      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n    }, this, dateOptions.defaultSeparator);\n  };\n  /*\n  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n  might as well use buildIsoString or some other util directly\n  */\n\n\n  DateEnv.prototype.formatIso = function (marker, extraOptions) {\n    if (extraOptions === void 0) {\n      extraOptions = {};\n    }\n\n    var timeZoneOffset = null;\n\n    if (!extraOptions.omitTimeZoneOffset) {\n      if (extraOptions.forcedTzo != null) {\n        timeZoneOffset = extraOptions.forcedTzo;\n      } else {\n        timeZoneOffset = this.offsetForMarker(marker);\n      }\n    }\n\n    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n  }; // TimeZone\n\n\n  DateEnv.prototype.timestampToMarker = function (ms) {\n    if (this.timeZone === 'local') {\n      return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n    }\n\n    if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n      return new Date(ms);\n    }\n\n    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n  };\n\n  DateEnv.prototype.offsetForMarker = function (m) {\n    if (this.timeZone === 'local') {\n      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n    }\n\n    if (this.timeZone === 'UTC') {\n      return 0;\n    }\n\n    if (this.namedTimeZoneImpl) {\n      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n    }\n\n    return null;\n  }; // Conversion\n\n\n  DateEnv.prototype.toDate = function (m, forcedTzo) {\n    if (this.timeZone === 'local') {\n      return arrayToLocalDate(dateToUtcArray(m));\n    }\n\n    if (this.timeZone === 'UTC') {\n      return new Date(m.valueOf()); // make sure it's a copy\n    }\n\n    if (!this.namedTimeZoneImpl) {\n      return new Date(m.valueOf() - (forcedTzo || 0));\n    }\n\n    return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n  };\n\n  return DateEnv;\n}();\n\nvar globalLocales = [];\nvar MINIMAL_RAW_EN_LOCALE = {\n  code: 'en',\n  week: {\n    dow: 0,\n    doy: 4 // 4 days need to be within the year to be considered the first week\n\n  },\n  direction: 'ltr',\n  buttonText: {\n    prev: 'prev',\n    next: 'next',\n    prevYear: 'prev year',\n    nextYear: 'next year',\n    year: 'year',\n    today: 'today',\n    month: 'month',\n    week: 'week',\n    day: 'day',\n    list: 'list'\n  },\n  weekText: 'W',\n  weekTextLong: 'Week',\n  closeHint: 'Close',\n  timeHint: 'Time',\n  eventHint: 'Event',\n  allDayText: 'all-day',\n  moreLinkText: 'more',\n  noEventsText: 'No events to display'\n};\n\nvar RAW_EN_LOCALE = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, MINIMAL_RAW_EN_LOCALE), {\n  // Includes things we don't want other locales to inherit,\n  // things that derive from other translatable strings.\n  buttonHints: {\n    prev: 'Previous $0',\n    next: 'Next $0',\n    today: function today(buttonText, unit) {\n      return unit === 'day' ? 'Today' : \"This \" + buttonText;\n    }\n  },\n  viewHint: '$0 view',\n  navLinkHint: 'Go to $0',\n  moreLinkHint: function moreLinkHint(eventCnt) {\n    return \"Show \" + eventCnt + \" more event\" + (eventCnt === 1 ? '' : 's');\n  }\n});\n\nfunction organizeRawLocales(explicitRawLocales) {\n  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n  var allRawLocales = globalLocales.concat(explicitRawLocales);\n  var rawLocaleMap = {\n    en: RAW_EN_LOCALE\n  };\n\n  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n    var rawLocale = allRawLocales_1[_i];\n    rawLocaleMap[rawLocale.code] = rawLocale;\n  }\n\n  return {\n    map: rawLocaleMap,\n    defaultCode: defaultCode\n  };\n}\n\nfunction buildLocale(inputSingular, available) {\n  if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n  }\n\n  return queryLocale(inputSingular, available);\n}\n\nfunction queryLocale(codeArg, available) {\n  var codes = [].concat(codeArg || []); // will convert to array\n\n  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n  return parseLocale(codeArg, codes, raw);\n}\n\nfunction queryRawLocale(codes, available) {\n  for (var i = 0; i < codes.length; i += 1) {\n    var parts = codes[i].toLocaleLowerCase().split('-');\n\n    for (var j = parts.length; j > 0; j -= 1) {\n      var simpleId = parts.slice(0, j).join('-');\n\n      if (available[simpleId]) {\n        return available[simpleId];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseLocale(codeArg, codes, raw) {\n  var merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);\n  delete merged.code; // don't want this part of the options\n\n  var week = merged.week;\n  delete merged.week;\n  return {\n    codeArg: codeArg,\n    codes: codes,\n    week: week,\n    simpleNumberFormat: new Intl.NumberFormat(codeArg),\n    options: merged\n  };\n}\n\nfunction formatDate(dateInput, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dateEnv = buildDateEnv$1(options);\n  var formatter = createFormatter(options);\n  var dateMeta = dateEnv.createMarkerMeta(dateInput);\n\n  if (!dateMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.format(dateMeta.marker, formatter, {\n    forcedTzo: dateMeta.forcedTzo\n  });\n}\n\nfunction formatRange(startInput, endInput, options) {\n  var dateEnv = buildDateEnv$1(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n\n  var formatter = createFormatter(options);\n  var startMeta = dateEnv.createMarkerMeta(startInput);\n  var endMeta = dateEnv.createMarkerMeta(endInput);\n\n  if (!startMeta || !endMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n    forcedStartTzo: startMeta.forcedTzo,\n    forcedEndTzo: endMeta.forcedTzo,\n    isEndExclusive: options.isEndExclusive,\n    defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n  });\n} // TODO: more DRY and optimized\n\n\nfunction buildDateEnv$1(settings) {\n  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n\n  return new DateEnv((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n    timeZone: BASE_OPTION_DEFAULTS.timeZone,\n    calendarSystem: 'gregory'\n  }, settings), {\n    locale: locale\n  }));\n}\n\nvar DEF_DEFAULTS = {\n  startTime: '09:00',\n  endTime: '17:00',\n  daysOfWeek: [1, 2, 3, 4, 5],\n  display: 'inverse-background',\n  classNames: 'fc-non-business',\n  groupId: '_businessHours' // so multiple defs get grouped\n\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\n\nfunction parseBusinessHours(input, context) {\n  return parseEvents(refineInputs(input), null, context);\n}\n\nfunction refineInputs(input) {\n  var rawDefs;\n\n  if (input === true) {\n    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n  } else if (Array.isArray(input)) {\n    // if specifying an array, every sub-definition NEEDS a day-of-week\n    rawDefs = input.filter(function (rawDef) {\n      return rawDef.daysOfWeek;\n    });\n  } else if (typeof input === 'object' && input) {\n    // non-null object\n    rawDefs = [input];\n  } else {\n    // is probably false\n    rawDefs = [];\n  }\n\n  rawDefs = rawDefs.map(function (rawDef) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, DEF_DEFAULTS), rawDef);\n  });\n  return rawDefs;\n}\n\nfunction pointInsideRect(point, rect) {\n  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n\nfunction intersectRects(rect1, rect2) {\n  var res = {\n    left: Math.max(rect1.left, rect2.left),\n    right: Math.min(rect1.right, rect2.right),\n    top: Math.max(rect1.top, rect2.top),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n\n  if (res.left < res.right && res.top < res.bottom) {\n    return res;\n  }\n\n  return false;\n}\n\nfunction translateRect(rect, deltaX, deltaY) {\n  return {\n    left: rect.left + deltaX,\n    right: rect.right + deltaX,\n    top: rect.top + deltaY,\n    bottom: rect.bottom + deltaY\n  };\n} // Returns a new point that will have been moved to reside within the given rectangle\n\n\nfunction constrainPoint(point, rect) {\n  return {\n    left: Math.min(Math.max(point.left, rect.left), rect.right),\n    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n  };\n} // Returns a point that is the center of the given rectangle\n\n\nfunction getRectCenter(rect) {\n  return {\n    left: (rect.left + rect.right) / 2,\n    top: (rect.top + rect.bottom) / 2\n  };\n} // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\nfunction diffPoints(point1, point2) {\n  return {\n    left: point1.left - point2.left,\n    top: point1.top - point2.top\n  };\n}\n\nvar canVGrowWithinCell;\n\nfunction getCanVGrowWithinCell() {\n  if (canVGrowWithinCell == null) {\n    canVGrowWithinCell = computeCanVGrowWithinCell();\n  }\n\n  return canVGrowWithinCell;\n}\n\nfunction computeCanVGrowWithinCell() {\n  // for SSR, because this function is call immediately at top-level\n  // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.left = '0px';\n  el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n  el.querySelector('table').style.height = '100px';\n  el.querySelector('div').style.height = '100%';\n  document.body.appendChild(el);\n  var div = el.querySelector('div');\n  var possible = div.offsetHeight > 0;\n  document.body.removeChild(el);\n  return possible;\n}\n\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n\nvar Splitter = function () {\n  function Splitter() {\n    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n    this.splitDateSelection = memoize(this._splitDateSpan);\n    this.splitEventStore = memoize(this._splitEventStore);\n    this.splitIndividualUi = memoize(this._splitIndividualUi);\n    this.splitEventDrag = memoize(this._splitInteraction);\n    this.splitEventResize = memoize(this._splitInteraction);\n    this.eventUiBuilders = {}; // TODO: typescript protection\n  }\n\n  Splitter.prototype.splitProps = function (props) {\n    var _this = this;\n\n    var keyInfos = this.getKeyInfo(props);\n    var defKeys = this.getKeysForEventDefs(props.eventStore);\n    var dateSelections = this.splitDateSelection(props.dateSelection);\n    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n\n    var eventStores = this.splitEventStore(props.eventStore, defKeys);\n    var eventDrags = this.splitEventDrag(props.eventDrag);\n    var eventResizes = this.splitEventResize(props.eventResize);\n    var splitProps = {};\n    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n    });\n\n    for (var key in keyInfos) {\n      var keyInfo = keyInfos[key];\n      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n      var buildEventUi = this.eventUiBuilders[key];\n      splitProps[key] = {\n        businessHours: keyInfo.businessHours || props.businessHours,\n        dateSelection: dateSelections[key] || null,\n        eventStore: eventStore,\n        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n        eventDrag: eventDrags[key] || null,\n        eventResize: eventResizes[key] || null\n      };\n    }\n\n    return splitProps;\n  };\n\n  Splitter.prototype._splitDateSpan = function (dateSpan) {\n    var dateSpans = {};\n\n    if (dateSpan) {\n      var keys = this.getKeysForDateSpan(dateSpan);\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        dateSpans[key] = dateSpan;\n      }\n    }\n\n    return dateSpans;\n  };\n\n  Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n    var _this = this;\n\n    return mapHash(eventStore.defs, function (eventDef) {\n      return _this.getKeysForEventDef(eventDef);\n    });\n  };\n\n  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n    var defs = eventStore.defs,\n        instances = eventStore.instances;\n    var splitStores = {};\n\n    for (var defId in defs) {\n      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!splitStores[key]) {\n          splitStores[key] = createEmptyEventStore();\n        }\n\n        splitStores[key].defs[defId] = defs[defId];\n      }\n    }\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n\n      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n        var key = _c[_b];\n\n        if (splitStores[key]) {\n          // must have already been created\n          splitStores[key].instances[instanceId] = instance;\n        }\n      }\n    }\n\n    return splitStores;\n  };\n\n  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n    var splitHashes = {};\n\n    for (var defId in eventUiBases) {\n      if (defId) {\n        // not the '' key\n        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n          var key = _a[_i];\n\n          if (!splitHashes[key]) {\n            splitHashes[key] = {};\n          }\n\n          splitHashes[key][defId] = eventUiBases[defId];\n        }\n      }\n    }\n\n    return splitHashes;\n  };\n\n  Splitter.prototype._splitInteraction = function (interaction) {\n    var splitStates = {};\n\n    if (interaction) {\n      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents)); // can't rely on defKeys because event data is mutated\n\n\n      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n\n      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n\n      var populate = function populate(key) {\n        if (!splitStates[key]) {\n          splitStates[key] = {\n            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n            isEvent: interaction.isEvent\n          };\n        }\n      };\n\n      for (var key in affectedStores_1) {\n        populate(key);\n      }\n\n      for (var key in mutatedStores_1) {\n        populate(key);\n      }\n    }\n\n    return splitStates;\n  };\n\n  return Splitter;\n}();\n\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n  var baseParts = [];\n\n  if (allUi) {\n    baseParts.push(allUi);\n  }\n\n  if (eventUiForKey) {\n    baseParts.push(eventUiForKey);\n  }\n\n  var stuff = {\n    '': combineEventUis(baseParts)\n  };\n\n  if (individualUi) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(stuff, individualUi);\n  }\n\n  return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n  return {\n    dow: date.getUTCDay(),\n    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n  };\n}\n\nfunction getDayClassNames(meta, theme) {\n  var classNames = ['fc-day', \"fc-day-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-day-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-day-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-day-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-day-future');\n    }\n\n    if (meta.isOther) {\n      classNames.push('fc-day-other');\n    }\n  }\n\n  return classNames;\n}\n\nfunction getSlotClassNames(meta, theme) {\n  var classNames = ['fc-slot', \"fc-slot-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-slot-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-slot-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-slot-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-slot-future');\n    }\n  }\n\n  return classNames;\n}\n\nvar DAY_FORMAT = createFormatter({\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric'\n});\nvar WEEK_FORMAT = createFormatter({\n  week: 'long'\n});\n\nfunction buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {\n  if (viewType === void 0) {\n    viewType = 'day';\n  }\n\n  if (isTabbable === void 0) {\n    isTabbable = true;\n  }\n\n  var dateEnv = context.dateEnv,\n      options = context.options,\n      calendarApi = context.calendarApi;\n  var dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);\n\n  if (options.navLinks) {\n    var zonedDate = dateEnv.toDate(dateMarker);\n\n    var handleInteraction = function handleInteraction(ev) {\n      var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n\n      if (typeof customAction === 'function') {\n        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n      } else {\n        if (typeof customAction === 'string') {\n          viewType = customAction;\n        }\n\n        calendarApi.zoomTo(dateMarker, viewType);\n      }\n    };\n\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr),\n      'data-navlink': ''\n    }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n      onClick: handleInteraction\n    });\n  }\n\n  return {\n    'aria-label': dateStr\n  };\n}\n\nvar _isRtlScrollbarOnLeft = null;\n\nfunction getIsRtlScrollbarOnLeft() {\n  if (_isRtlScrollbarOnLeft === null) {\n    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n  }\n\n  return _isRtlScrollbarOnLeft;\n}\n\nfunction computeIsRtlScrollbarOnLeft() {\n  var outerEl = document.createElement('div');\n  applyStyle(outerEl, {\n    position: 'absolute',\n    top: -1000,\n    left: 0,\n    border: 0,\n    padding: 0,\n    overflow: 'scroll',\n    direction: 'rtl'\n  });\n  outerEl.innerHTML = '<div></div>';\n  document.body.appendChild(outerEl);\n  var innerEl = outerEl.firstChild;\n  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n  removeElement(outerEl);\n  return res;\n}\n\nvar _scrollbarWidths;\n\nfunction getScrollbarWidths() {\n  if (!_scrollbarWidths) {\n    _scrollbarWidths = computeScrollbarWidths();\n  }\n\n  return _scrollbarWidths;\n}\n\nfunction computeScrollbarWidths() {\n  var el = document.createElement('div');\n  el.style.overflow = 'scroll';\n  el.style.position = 'absolute';\n  el.style.top = '-9999px';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  var res = computeScrollbarWidthsForEl(el);\n  document.body.removeChild(el);\n  return res;\n} // WARNING: will include border\n\n\nfunction computeScrollbarWidthsForEl(el) {\n  return {\n    x: el.offsetHeight - el.clientHeight,\n    y: el.offsetWidth - el.clientWidth\n  };\n}\n\nfunction computeEdges(el, getPadding) {\n  if (getPadding === void 0) {\n    getPadding = false;\n  }\n\n  var computedStyle = window.getComputedStyle(el);\n  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n\n  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n  var res = {\n    borderLeft: borderLeft,\n    borderRight: borderRight,\n    borderTop: borderTop,\n    borderBottom: borderBottom,\n    scrollbarBottom: scrollbarBottom,\n    scrollbarLeft: 0,\n    scrollbarRight: 0\n  };\n\n  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n    // is the scrollbar on the left side?\n    res.scrollbarLeft = scrollbarLeftRight;\n  } else {\n    res.scrollbarRight = scrollbarLeftRight;\n  }\n\n  if (getPadding) {\n    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n  }\n\n  return res;\n}\n\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n  if (goWithinPadding === void 0) {\n    goWithinPadding = false;\n  }\n\n  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n  var edges = computeEdges(el, goWithinPadding);\n  var res = {\n    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n    right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n    top: outerRect.top + edges.borderTop,\n    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n  };\n\n  if (goWithinPadding) {\n    res.left += edges.paddingLeft;\n    res.right -= edges.paddingRight;\n    res.top += edges.paddingTop;\n    res.bottom -= edges.paddingBottom;\n  }\n\n  return res;\n}\n\nfunction computeRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    right: rect.right + window.pageXOffset,\n    bottom: rect.bottom + window.pageYOffset\n  };\n}\n\nfunction computeClippedClientRect(el) {\n  var clippingParents = getClippingParents(el);\n  var rect = el.getBoundingClientRect();\n\n  for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {\n    var clippingParent = clippingParents_1[_i];\n    var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n\n    if (intersection) {\n      rect = intersection;\n    } else {\n      return null;\n    }\n  }\n\n  return rect;\n}\n\nfunction computeHeightAndMargins(el) {\n  return el.getBoundingClientRect().height + computeVMargins(el);\n}\n\nfunction computeVMargins(el) {\n  var computed = window.getComputedStyle(el);\n  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n} // does not return window\n\n\nfunction getClippingParents(el) {\n  var parents = [];\n\n  while (el instanceof HTMLElement) {\n    // will stop when gets to document or null\n    var computedStyle = window.getComputedStyle(el);\n\n    if (computedStyle.position === 'fixed') {\n      break;\n    }\n\n    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n      parents.push(el);\n    }\n\n    el = el.parentNode;\n  }\n\n  return parents;\n} // given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\n\n\nfunction unpromisify(func, success, failure) {\n  // guard against success/failure callbacks being called more than once\n  // and guard against a promise AND callback being used together.\n  var isResolved = false;\n\n  var wrappedSuccess = function wrappedSuccess() {\n    if (!isResolved) {\n      isResolved = true;\n      success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n    }\n  };\n\n  var wrappedFailure = function wrappedFailure() {\n    if (!isResolved) {\n      isResolved = true;\n\n      if (failure) {\n        failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n      }\n    }\n  };\n\n  var res = func(wrappedSuccess, wrappedFailure);\n\n  if (res && typeof res.then === 'function') {\n    res.then(wrappedSuccess, wrappedFailure);\n  }\n}\n\nvar Emitter = function () {\n  function Emitter() {\n    this.handlers = {};\n    this.thisContext = null;\n  }\n\n  Emitter.prototype.setThisContext = function (thisContext) {\n    this.thisContext = thisContext;\n  };\n\n  Emitter.prototype.setOptions = function (options) {\n    this.options = options;\n  };\n\n  Emitter.prototype.on = function (type, handler) {\n    addToHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.off = function (type, handler) {\n    removeFromHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var attachedHandlers = this.handlers[type] || [];\n    var optionHandler = this.options && this.options[type];\n    var handlers = [].concat(optionHandler || [], attachedHandlers);\n\n    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n      var handler = handlers_1[_a];\n      handler.apply(this.thisContext, args);\n    }\n  };\n\n  Emitter.prototype.hasHandlers = function (type) {\n    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n  };\n\n  return Emitter;\n}();\n\nfunction addToHash(hash, type, handler) {\n  (hash[type] || (hash[type] = [])).push(handler);\n}\n\nfunction removeFromHash(hash, type, handler) {\n  if (handler) {\n    if (hash[type]) {\n      hash[type] = hash[type].filter(function (func) {\n        return func !== handler;\n      });\n    }\n  } else {\n    delete hash[type]; // remove all handler funcs for this type\n  }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\n\n\nvar PositionCache = function () {\n  function PositionCache(originEl, els, isHorizontal, isVertical) {\n    this.els = els;\n    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n\n    if (isHorizontal) {\n      this.buildElHorizontals(originClientRect.left);\n    }\n\n    if (isVertical) {\n      this.buildElVerticals(originClientRect.top);\n    }\n  } // Populates the left/right internal coordinate arrays\n\n\n  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n    var lefts = [];\n    var rights = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      lefts.push(rect.left - originClientLeft);\n      rights.push(rect.right - originClientLeft);\n    }\n\n    this.lefts = lefts;\n    this.rights = rights;\n  }; // Populates the top/bottom internal coordinate arrays\n\n\n  PositionCache.prototype.buildElVerticals = function (originClientTop) {\n    var tops = [];\n    var bottoms = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      tops.push(rect.top - originClientTop);\n      bottoms.push(rect.bottom - originClientTop);\n    }\n\n    this.tops = tops;\n    this.bottoms = bottoms;\n  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.leftToIndex = function (leftPosition) {\n    var _a = this,\n        lefts = _a.lefts,\n        rights = _a.rights;\n\n    var len = lefts.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.topToIndex = function (topPosition) {\n    var _a = this,\n        tops = _a.tops,\n        bottoms = _a.bottoms;\n\n    var len = tops.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Gets the width of the element at the given index\n\n\n  PositionCache.prototype.getWidth = function (leftIndex) {\n    return this.rights[leftIndex] - this.lefts[leftIndex];\n  }; // Gets the height of the element at the given index\n\n\n  PositionCache.prototype.getHeight = function (topIndex) {\n    return this.bottoms[topIndex] - this.tops[topIndex];\n  };\n\n  return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */\n\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\n\n\nvar ScrollController = function () {\n  function ScrollController() {}\n\n  ScrollController.prototype.getMaxScrollTop = function () {\n    return this.getScrollHeight() - this.getClientHeight();\n  };\n\n  ScrollController.prototype.getMaxScrollLeft = function () {\n    return this.getScrollWidth() - this.getClientWidth();\n  };\n\n  ScrollController.prototype.canScrollVertically = function () {\n    return this.getMaxScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollHorizontally = function () {\n    return this.getMaxScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollUp = function () {\n    return this.getScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollDown = function () {\n    return this.getScrollTop() < this.getMaxScrollTop();\n  };\n\n  ScrollController.prototype.canScrollLeft = function () {\n    return this.getScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollRight = function () {\n    return this.getScrollLeft() < this.getMaxScrollLeft();\n  };\n\n  return ScrollController;\n}();\n\nvar ElementScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ElementScrollController, _super);\n\n  function ElementScrollController(el) {\n    var _this = _super.call(this) || this;\n\n    _this.el = el;\n    return _this;\n  }\n\n  ElementScrollController.prototype.getScrollTop = function () {\n    return this.el.scrollTop;\n  };\n\n  ElementScrollController.prototype.getScrollLeft = function () {\n    return this.el.scrollLeft;\n  };\n\n  ElementScrollController.prototype.setScrollTop = function (top) {\n    this.el.scrollTop = top;\n  };\n\n  ElementScrollController.prototype.setScrollLeft = function (left) {\n    this.el.scrollLeft = left;\n  };\n\n  ElementScrollController.prototype.getScrollWidth = function () {\n    return this.el.scrollWidth;\n  };\n\n  ElementScrollController.prototype.getScrollHeight = function () {\n    return this.el.scrollHeight;\n  };\n\n  ElementScrollController.prototype.getClientHeight = function () {\n    return this.el.clientHeight;\n  };\n\n  ElementScrollController.prototype.getClientWidth = function () {\n    return this.el.clientWidth;\n  };\n\n  return ElementScrollController;\n}(ScrollController);\n\nvar WindowScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WindowScrollController, _super);\n\n  function WindowScrollController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WindowScrollController.prototype.getScrollTop = function () {\n    return window.pageYOffset;\n  };\n\n  WindowScrollController.prototype.getScrollLeft = function () {\n    return window.pageXOffset;\n  };\n\n  WindowScrollController.prototype.setScrollTop = function (n) {\n    window.scroll(window.pageXOffset, n);\n  };\n\n  WindowScrollController.prototype.setScrollLeft = function (n) {\n    window.scroll(n, window.pageYOffset);\n  };\n\n  WindowScrollController.prototype.getScrollWidth = function () {\n    return document.documentElement.scrollWidth;\n  };\n\n  WindowScrollController.prototype.getScrollHeight = function () {\n    return document.documentElement.scrollHeight;\n  };\n\n  WindowScrollController.prototype.getClientHeight = function () {\n    return document.documentElement.clientHeight;\n  };\n\n  WindowScrollController.prototype.getClientWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  return WindowScrollController;\n}(ScrollController);\n\nvar Theme = function () {\n  function Theme(calendarOptions) {\n    if (this.iconOverrideOption) {\n      this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n    }\n  }\n\n  Theme.prototype.setIconOverride = function (iconOverrideHash) {\n    var iconClassesCopy;\n    var buttonName;\n\n    if (typeof iconOverrideHash === 'object' && iconOverrideHash) {\n      // non-null object\n      iconClassesCopy = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, this.iconClasses);\n\n      for (buttonName in iconOverrideHash) {\n        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n      }\n\n      this.iconClasses = iconClassesCopy;\n    } else if (iconOverrideHash === false) {\n      this.iconClasses = {};\n    }\n  };\n\n  Theme.prototype.applyIconOverridePrefix = function (className) {\n    var prefix = this.iconOverridePrefix;\n\n    if (prefix && className.indexOf(prefix) !== 0) {\n      // if not already present\n      className = prefix + className;\n    }\n\n    return className;\n  };\n\n  Theme.prototype.getClass = function (key) {\n    return this.classes[key] || '';\n  };\n\n  Theme.prototype.getIconClass = function (buttonName, isRtl) {\n    var className;\n\n    if (isRtl && this.rtlIconClasses) {\n      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n    } else {\n      className = this.iconClasses[buttonName];\n    }\n\n    if (className) {\n      return this.baseIconClass + \" \" + className;\n    }\n\n    return '';\n  };\n\n  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n    var className;\n\n    if (this.iconOverrideCustomButtonOption) {\n      className = customButtonProps[this.iconOverrideCustomButtonOption];\n\n      if (className) {\n        return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n      }\n    }\n\n    return '';\n  };\n\n  return Theme;\n}();\n\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\nvar ScrollResponder = function () {\n  function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n    var _this = this;\n\n    this.execFunc = execFunc;\n    this.emitter = emitter;\n    this.scrollTime = scrollTime;\n    this.scrollTimeReset = scrollTimeReset;\n\n    this.handleScrollRequest = function (request) {\n      _this.queuedRequest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, _this.queuedRequest || {}, request);\n\n      _this.drain();\n    };\n\n    emitter.on('_scrollRequest', this.handleScrollRequest);\n    this.fireInitialScroll();\n  }\n\n  ScrollResponder.prototype.detach = function () {\n    this.emitter.off('_scrollRequest', this.handleScrollRequest);\n  };\n\n  ScrollResponder.prototype.update = function (isDatesNew) {\n    if (isDatesNew && this.scrollTimeReset) {\n      this.fireInitialScroll(); // will drain\n    } else {\n      this.drain();\n    }\n  };\n\n  ScrollResponder.prototype.fireInitialScroll = function () {\n    this.handleScrollRequest({\n      time: this.scrollTime\n    });\n  };\n\n  ScrollResponder.prototype.drain = function () {\n    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n      this.queuedRequest = null;\n    }\n  };\n\n  return ScrollResponder;\n}();\n\nvar ViewContextType = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createContext)({}); // for Components\n\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n  return {\n    dateEnv: dateEnv,\n    options: viewOptions,\n    pluginHooks: pluginHooks,\n    emitter: emitter,\n    dispatch: dispatch,\n    getCurrentData: getCurrentData,\n    calendarApi: calendarApi,\n    viewSpec: viewSpec,\n    viewApi: viewApi,\n    dateProfileGenerator: dateProfileGenerator,\n    theme: theme,\n    isRtl: viewOptions.direction === 'rtl',\n    addResizeHandler: function addResizeHandler(handler) {\n      emitter.on('_resize', handler);\n    },\n    removeResizeHandler: function removeResizeHandler(handler) {\n      emitter.off('_resize', handler);\n    },\n    createScrollResponder: function createScrollResponder(execFunc) {\n      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n    },\n    registerInteractiveComponent: registerInteractiveComponent,\n    unregisterInteractiveComponent: unregisterInteractiveComponent\n  };\n}\n/* eslint max-classes-per-file: off */\n\n\nvar PureComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PureComponent, _super);\n\n  function PureComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    if (this.debug) {\n      // eslint-disable-next-line no-console\n      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n    }\n\n    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n  };\n\n  PureComponent.addPropsEquality = addPropsEquality;\n  PureComponent.addStateEquality = addStateEquality;\n  PureComponent.contextType = ViewContextType;\n  return PureComponent;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\n\nvar BaseComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(BaseComponent, _super);\n\n  function BaseComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BaseComponent.contextType = ViewContextType;\n  return BaseComponent;\n}(PureComponent);\n\nfunction addPropsEquality(propEquality) {\n  var hash = Object.create(this.prototype.propEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(hash, propEquality);\n\n  this.prototype.propEquality = hash;\n}\n\nfunction addStateEquality(stateEquality) {\n  var hash = Object.create(this.prototype.stateEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(hash, stateEquality);\n\n  this.prototype.stateEquality = hash;\n} // use other one\n\n\nfunction setRef(ref, current) {\n  if (typeof ref === 'function') {\n    ref(current);\n  } else if (ref) {\n    // see https://github.com/facebook/react/issues/13029\n    ref.current = current;\n  }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\n\n\nvar DateComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateComponent, _super);\n\n  function DateComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.uid = guid();\n    return _this;\n  } // Hit System\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.prepareHits = function () {};\n\n  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    return null; // this should be abstract\n  }; // Pointer Interaction Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isValidSegDownEl = function (el) {\n    return !this.props.eventDrag && // HACK\n    !this.props.eventResize && // HACK\n    !elementClosest(el, '.fc-event-mirror');\n  };\n\n  DateComponent.prototype.isValidDateDownEl = function (el) {\n    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n    !elementClosest(el, '.fc-popover'); // hack\n  };\n\n  return DateComponent;\n}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things\n\n\nfunction createPlugin(input) {\n  return {\n    id: guid(),\n    deps: input.deps || [],\n    reducers: input.reducers || [],\n    isLoadingFuncs: input.isLoadingFuncs || [],\n    contextInit: [].concat(input.contextInit || []),\n    eventRefiners: input.eventRefiners || {},\n    eventDefMemberAdders: input.eventDefMemberAdders || [],\n    eventSourceRefiners: input.eventSourceRefiners || {},\n    isDraggableTransformers: input.isDraggableTransformers || [],\n    eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n    eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n    dateSelectionTransformers: input.dateSelectionTransformers || [],\n    datePointTransforms: input.datePointTransforms || [],\n    dateSpanTransforms: input.dateSpanTransforms || [],\n    views: input.views || {},\n    viewPropsTransformers: input.viewPropsTransformers || [],\n    isPropsValid: input.isPropsValid || null,\n    externalDefTransforms: input.externalDefTransforms || [],\n    viewContainerAppends: input.viewContainerAppends || [],\n    eventDropTransformers: input.eventDropTransformers || [],\n    componentInteractions: input.componentInteractions || [],\n    calendarInteractions: input.calendarInteractions || [],\n    themeClasses: input.themeClasses || {},\n    eventSourceDefs: input.eventSourceDefs || [],\n    cmdFormatter: input.cmdFormatter,\n    recurringTypes: input.recurringTypes || [],\n    namedTimeZonedImpl: input.namedTimeZonedImpl,\n    initialView: input.initialView || '',\n    elementDraggingImpl: input.elementDraggingImpl,\n    optionChangeHandlers: input.optionChangeHandlers || {},\n    scrollGridImpl: input.scrollGridImpl || null,\n    contentTypeHandlers: input.contentTypeHandlers || {},\n    listenerRefiners: input.listenerRefiners || {},\n    optionRefiners: input.optionRefiners || {},\n    propSetHandlers: input.propSetHandlers || {}\n  };\n}\n\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n  var isAdded = {};\n  var hooks = {\n    reducers: [],\n    isLoadingFuncs: [],\n    contextInit: [],\n    eventRefiners: {},\n    eventDefMemberAdders: [],\n    eventSourceRefiners: {},\n    isDraggableTransformers: [],\n    eventDragMutationMassagers: [],\n    eventDefMutationAppliers: [],\n    dateSelectionTransformers: [],\n    datePointTransforms: [],\n    dateSpanTransforms: [],\n    views: {},\n    viewPropsTransformers: [],\n    isPropsValid: null,\n    externalDefTransforms: [],\n    viewContainerAppends: [],\n    eventDropTransformers: [],\n    componentInteractions: [],\n    calendarInteractions: [],\n    themeClasses: {},\n    eventSourceDefs: [],\n    cmdFormatter: null,\n    recurringTypes: [],\n    namedTimeZonedImpl: null,\n    initialView: '',\n    elementDraggingImpl: null,\n    optionChangeHandlers: {},\n    scrollGridImpl: null,\n    contentTypeHandlers: {},\n    listenerRefiners: {},\n    optionRefiners: {},\n    propSetHandlers: {}\n  };\n\n  function addDefs(defs) {\n    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n      var def = defs_1[_i];\n\n      if (!isAdded[def.id]) {\n        isAdded[def.id] = true;\n        addDefs(def.deps);\n        hooks = combineHooks(hooks, def);\n      }\n    }\n  }\n\n  if (pluginDefs) {\n    addDefs(pluginDefs);\n  }\n\n  addDefs(globalDefs);\n  return hooks;\n}\n\nfunction buildBuildPluginHooks() {\n  var currentOverrideDefs = [];\n  var currentGlobalDefs = [];\n  var currentHooks;\n  return function (overrideDefs, globalDefs) {\n    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n      currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n    }\n\n    currentOverrideDefs = overrideDefs;\n    currentGlobalDefs = globalDefs;\n    return currentHooks;\n  };\n}\n\nfunction combineHooks(hooks0, hooks1) {\n  return {\n    reducers: hooks0.reducers.concat(hooks1.reducers),\n    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n    contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n    eventRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.eventRefiners), hooks1.eventRefiners),\n    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n    eventSourceRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n    views: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.views), hooks1.views),\n    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n    themeClasses: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.themeClasses), hooks1.themeClasses),\n    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n    initialView: hooks0.initialView || hooks1.initialView,\n    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n    optionChangeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n    contentTypeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n    listenerRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n    optionRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.optionRefiners), hooks1.optionRefiners),\n    propSetHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n  };\n}\n\nvar StandardTheme = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(StandardTheme, _super);\n\n  function StandardTheme() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StandardTheme;\n}(Theme);\n\nStandardTheme.prototype.classes = {\n  root: 'fc-theme-standard',\n  tableCellShaded: 'fc-cell-shaded',\n  buttonGroup: 'fc-button-group',\n  button: 'fc-button fc-button-primary',\n  buttonActive: 'fc-button-active'\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n  close: 'fc-icon-x',\n  prev: 'fc-icon-chevron-left',\n  next: 'fc-icon-chevron-right',\n  prevYear: 'fc-icon-chevrons-left',\n  nextYear: 'fc-icon-chevrons-right'\n};\nStandardTheme.prototype.rtlIconClasses = {\n  prev: 'fc-icon-chevron-right',\n  next: 'fc-icon-chevron-left',\n  prevYear: 'fc-icon-chevrons-right',\n  nextYear: 'fc-icon-chevrons-left'\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n  var hash = {};\n  var viewType;\n\n  for (viewType in defaultConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  for (viewType in overrideConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  return hash;\n}\n\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  if (hash[viewType]) {\n    return hash[viewType];\n  }\n\n  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n\n  if (viewDef) {\n    hash[viewType] = viewDef;\n  }\n\n  return viewDef;\n}\n\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  var defaultConfig = defaultConfigs[viewType];\n  var overrideConfig = overrideConfigs[viewType];\n\n  var queryProp = function queryProp(name) {\n    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n  };\n\n  var theComponent = queryProp('component');\n  var superType = queryProp('superType');\n  var superDef = null;\n\n  if (superType) {\n    if (superType === viewType) {\n      throw new Error('Can\\'t have a custom view type that references itself');\n    }\n\n    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  if (!theComponent && superDef) {\n    theComponent = superDef.component;\n  }\n\n  if (!theComponent) {\n    return null; // don't throw a warning, might be settings for a single-unit view\n  }\n\n  return {\n    type: viewType,\n    component: theComponent,\n    defaults: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n    overrides: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n  };\n}\n/* eslint max-classes-per-file: off */\n// NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n\n\nvar RenderHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(RenderHook, _super);\n\n  function RenderHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n\n    _this.handleRootEl = function (el) {\n      setRef(_this.rootElRef, el);\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    };\n\n    return _this;\n  }\n\n  RenderHook.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var hookProps = props.hookProps;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: props.didMount,\n      willUnmount: props.willUnmount,\n      elRef: this.handleRootEl\n    }, function (rootElRef) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentHook, {\n        hookProps: hookProps,\n        content: props.content,\n        defaultContent: props.defaultContent,\n        backupElRef: _this.rootElRef\n      }, function (innerElRef, innerContent) {\n        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n      });\n    });\n  };\n\n  return RenderHook;\n}(BaseComponent); // TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\n\n\nvar CustomContentRenderContext = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createContext)(0);\n\nfunction ContentHook(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(CustomContentRenderContext.Consumer, null, function (renderId) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentHookInner, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      renderId: renderId\n    }, props));\n  });\n}\n\n_c2 = ContentHook;\n\nvar ContentHookInner = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ContentHookInner, _super);\n\n  function ContentHookInner() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.innerElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  ContentHookInner.prototype.render = function () {\n    return this.props.children(this.innerElRef, this.renderInnerContent());\n  };\n\n  ContentHookInner.prototype.componentDidMount = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentDidUpdate = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentWillUnmount = function () {\n    if (this.customContentInfo && this.customContentInfo.destroy) {\n      this.customContentInfo.destroy();\n    }\n  };\n\n  ContentHookInner.prototype.renderInnerContent = function () {\n    var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n\n    var innerContent = this.getInnerContent();\n    var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)\n\n    if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n      // clearing old value\n      if (customContentInfo) {\n        if (customContentInfo.destroy) {\n          customContentInfo.destroy();\n        }\n\n        customContentInfo = this.customContentInfo = null;\n      } // assigning new value\n\n\n      if (meta.contentKey) {\n        customContentInfo = this.customContentInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          contentKey: meta.contentKey,\n          contentVal: innerContent[meta.contentKey]\n        }, meta.buildLifecycleFuncs());\n      } // updating\n\n    } else if (customContentInfo) {\n      customContentInfo.contentVal = innerContent[meta.contentKey];\n    }\n\n    return customContentInfo ? [] // signal that something was specified\n    : innerContent; // assume a [p]react vdom node. use it\n  };\n\n  ContentHookInner.prototype.getInnerContent = function () {\n    var props = this.props;\n    var innerContent = normalizeContent(props.content, props.hookProps);\n\n    if (innerContent === undefined) {\n      // use the default\n      innerContent = normalizeContent(props.defaultContent, props.hookProps);\n    }\n\n    return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n  };\n\n  ContentHookInner.prototype.getContentMeta = function (innerContent) {\n    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n    var contentKey = '';\n    var buildLifecycleFuncs = null;\n\n    if (innerContent) {\n      // allowed to be null, for convenience to caller\n      for (var searchKey in contentTypeHandlers) {\n        if (innerContent[searchKey] !== undefined) {\n          contentKey = searchKey;\n          buildLifecycleFuncs = contentTypeHandlers[searchKey];\n          break;\n        }\n      }\n    }\n\n    return {\n      contentKey: contentKey,\n      buildLifecycleFuncs: buildLifecycleFuncs\n    };\n  };\n\n  ContentHookInner.prototype.updateCustomContent = function () {\n    if (this.customContentInfo) {\n      // for non-[p]react\n      this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n      this.customContentInfo.contentVal);\n    }\n  };\n\n  return ContentHookInner;\n}(BaseComponent);\n\nvar MountHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MountHook, _super);\n\n  function MountHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, rootEl);\n      }\n    };\n\n    return _this;\n  }\n\n  MountHook.prototype.render = function () {\n    return this.props.children(this.handleRootEl);\n  };\n\n  MountHook.prototype.componentDidMount = function () {\n    var callback = this.props.didMount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  MountHook.prototype.componentWillUnmount = function () {\n    var callback = this.props.willUnmount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  return MountHook;\n}(BaseComponent);\n\nfunction buildClassNameNormalizer() {\n  var currentGenerator;\n  var currentHookProps;\n  var currentClassNames = [];\n  return function (generator, hookProps) {\n    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n      currentGenerator = generator;\n      currentHookProps = hookProps;\n      currentClassNames = normalizeClassNames(generator, hookProps);\n    }\n\n    return currentClassNames;\n  };\n}\n\nfunction normalizeClassNames(classNames, hookProps) {\n  if (typeof classNames === 'function') {\n    classNames = classNames(hookProps);\n  }\n\n  return parseClassNames(classNames);\n}\n\nfunction normalizeContent(input, hookProps) {\n  if (typeof input === 'function') {\n    return input(hookProps, _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement); // give the function the vdom-creation func\n  }\n\n  return input;\n}\n\nvar ViewRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ViewRoot, _super);\n\n  function ViewRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  ViewRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = {\n      view: context.viewApi\n    };\n    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.viewDidMount,\n      willUnmount: options.viewWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames));\n    });\n  };\n\n  return ViewRoot;\n}(BaseComponent);\n\nfunction parseViewConfigs(inputs) {\n  return mapHash(inputs, parseViewConfig);\n}\n\nfunction parseViewConfig(input) {\n  var rawOptions = typeof input === 'function' ? {\n    component: input\n  } : input;\n  var component = rawOptions.component;\n\n  if (rawOptions.content) {\n    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?\n  }\n\n  return {\n    superType: rawOptions.type,\n    component: component,\n    rawOptions: rawOptions\n  };\n}\n\nfunction createViewHookComponent(options) {\n  return function (viewProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, function (context) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewRoot, {\n        viewSpec: context.viewSpec\n      }, function (viewElRef, viewClassNames) {\n        var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, viewProps), {\n          nextDayThreshold: context.options.nextDayThreshold\n        });\n\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.classNames,\n          content: options.content,\n          didMount: options.didMount,\n          willUnmount: options.willUnmount,\n          elRef: viewElRef\n        }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n          return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: viewClassNames.concat(customClassNames).join(' '),\n            ref: rootElRef\n          }, innerContent);\n        });\n      });\n    });\n  };\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var defaultConfigs = parseViewConfigs(defaultInputs);\n  var overrideConfigs = parseViewConfigs(optionOverrides.views);\n  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n  return mapHash(viewDefs, function (viewDef) {\n    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n  });\n}\n\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n  var duration = null;\n  var durationUnit = '';\n  var singleUnit = '';\n  var singleUnitOverrides = {};\n\n  if (durationInput) {\n    duration = createDurationCached(durationInput);\n\n    if (duration) {\n      // valid?\n      var denom = greatestDurationDenominator(duration);\n      durationUnit = denom.unit;\n\n      if (denom.value === 1) {\n        singleUnit = durationUnit;\n        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n      }\n    }\n  }\n\n  var queryButtonText = function queryButtonText(optionsSubset) {\n    var buttonTextMap = optionsSubset.buttonText || {};\n    var buttonTextKey = viewDef.defaults.buttonTextKey;\n\n    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n      return buttonTextMap[buttonTextKey];\n    }\n\n    if (buttonTextMap[viewDef.type] != null) {\n      return buttonTextMap[viewDef.type];\n    }\n\n    if (buttonTextMap[singleUnit] != null) {\n      return buttonTextMap[singleUnit];\n    }\n\n    return null;\n  };\n\n  var queryButtonTitle = function queryButtonTitle(optionsSubset) {\n    var buttonHints = optionsSubset.buttonHints || {};\n    var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n\n    if (buttonKey != null && buttonHints[buttonKey] != null) {\n      return buttonHints[buttonKey];\n    }\n\n    if (buttonHints[viewDef.type] != null) {\n      return buttonHints[viewDef.type];\n    }\n\n    if (buttonHints[singleUnit] != null) {\n      return buttonHints[singleUnit];\n    }\n\n    return null;\n  };\n\n  return {\n    type: viewDef.type,\n    component: viewDef.component,\n    duration: duration,\n    durationUnit: durationUnit,\n    singleUnit: singleUnit,\n    optionDefaults: viewDef.defaults,\n    optionOverrides: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, singleUnitOverrides), viewDef.overrides),\n    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n    viewDef.overrides.buttonText,\n    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n    // not DRY\n    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS) // will eventually fall back to buttonText\n\n  };\n} // hack to get memoization working\n\n\nvar durationInputMap = {};\n\nfunction createDurationCached(durationInput) {\n  var json = JSON.stringify(durationInput);\n  var res = durationInputMap[json];\n\n  if (res === undefined) {\n    res = createDuration(durationInput);\n    durationInputMap[json] = res;\n  }\n\n  return res;\n}\n\nvar DateProfileGenerator = function () {\n  function DateProfileGenerator(props) {\n    this.props = props;\n    this.nowDate = getNow(props.nowInput, props.dateEnv);\n    this.initHiddenDays();\n  }\n  /* Date Range Computation\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n\n\n  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(prevDate, -1, forceToValid);\n  }; // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n\n\n  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(nextDate, 1, forceToValid);\n  }; // Builds a structure holding dates/ranges for rendering around the given date.\n  // Optional direction param indicates whether the date is being incremented/decremented\n  // from its previous value. decremented = -1, incremented = 1 (default).\n\n\n  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n    if (forceToValid === void 0) {\n      forceToValid = true;\n    }\n\n    var props = this.props;\n    var validRange;\n    var currentInfo;\n    var isRangeAllDay;\n    var renderRange;\n    var activeRange;\n    var isValid;\n    validRange = this.buildValidRange();\n    validRange = this.trimHiddenDays(validRange);\n\n    if (forceToValid) {\n      currentDate = constrainMarkerToRange(currentDate, validRange);\n    }\n\n    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n    renderRange = this.trimHiddenDays(renderRange);\n    activeRange = renderRange;\n\n    if (!props.showNonCurrentDates) {\n      activeRange = intersectRanges(activeRange, currentInfo.range);\n    }\n\n    activeRange = this.adjustActiveRange(activeRange);\n    activeRange = intersectRanges(activeRange, validRange); // might return null\n    // it's invalid if the originally requested date is not contained,\n    // or if the range is completely outside of the valid range.\n\n    isValid = rangesIntersect(currentInfo.range, validRange);\n    return {\n      // constraint for where prev/next operations can go and where events can be dragged/resized to.\n      // an object with optional start and end properties.\n      validRange: validRange,\n      // range the view is formally responsible for.\n      // for example, a month view might have 1st-31st, excluding padded dates\n      currentRange: currentInfo.range,\n      // name of largest unit being displayed, like \"month\" or \"week\"\n      currentRangeUnit: currentInfo.unit,\n      isRangeAllDay: isRangeAllDay,\n      // dates that display events and accept drag-n-drop\n      // will be `null` if no dates accept events\n      activeRange: activeRange,\n      // date range with a rendered skeleton\n      // includes not-active days that need some sort of DOM\n      renderRange: renderRange,\n      // Duration object that denotes the first visible time of any given day\n      slotMinTime: props.slotMinTime,\n      // Duration object that denotes the exclusive visible end time of any given day\n      slotMaxTime: props.slotMaxTime,\n      isValid: isValid,\n      // how far the current date will move for a prev/next operation\n      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^\n\n    };\n  }; // Builds an object with optional start/end properties.\n  // Indicates the minimum/maximum dates to display.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildValidRange = function () {\n    var input = this.props.validRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n    return this.refineRange(simpleInput) || {\n      start: null,\n      end: null\n    }; // completely open-ended\n  }; // Builds a structure with info about the \"current\" range, the range that is\n  // highlighted as being the current month for example.\n  // See build() for a description of `direction`.\n  // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n\n\n  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n    var props = this.props;\n    var duration = null;\n    var unit = null;\n    var range = null;\n    var dayCount;\n\n    if (props.duration) {\n      duration = props.duration;\n      unit = props.durationUnit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    } else if (dayCount = this.props.dayCount) {\n      unit = 'day';\n      range = this.buildRangeFromDayCount(date, direction, dayCount);\n    } else if (range = this.buildCustomVisibleRange(date)) {\n      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n    } else {\n      duration = this.getFallbackDuration();\n      unit = greatestDurationDenominator(duration).unit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    }\n\n    return {\n      duration: duration,\n      unit: unit,\n      range: range\n    };\n  };\n\n  DateProfileGenerator.prototype.getFallbackDuration = function () {\n    return createDuration({\n      day: 1\n    });\n  }; // Returns a new activeRange to have time values (un-ambiguate)\n  // slotMinTime or slotMaxTime causes the range to expand.\n\n\n  DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        usesMinMaxTime = _a.usesMinMaxTime,\n        slotMinTime = _a.slotMinTime,\n        slotMaxTime = _a.slotMaxTime;\n    var start = range.start,\n        end = range.end;\n\n    if (usesMinMaxTime) {\n      // expand active range if slotMinTime is negative (why not when positive?)\n      if (asRoughDays(slotMinTime) < 0) {\n        start = startOfDay(start); // necessary?\n\n        start = dateEnv.add(start, slotMinTime);\n      } // expand active range if slotMaxTime is beyond one day (why not when negative?)\n\n\n      if (asRoughDays(slotMaxTime) > 1) {\n        end = startOfDay(end); // necessary?\n\n        end = addDays(end, -1);\n        end = dateEnv.add(end, slotMaxTime);\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds the \"current\" range when it is specified as an explicit duration.\n  // `unit` is the already-computed greatestDurationDenominator unit of duration.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var start;\n    var end;\n    var res; // compute what the alignment should be\n\n    if (!dateAlignment) {\n      var dateIncrement = this.props.dateIncrement;\n\n      if (dateIncrement) {\n        // use the smaller of the two units\n        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n          dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n        } else {\n          dateAlignment = unit;\n        }\n      } else {\n        dateAlignment = unit;\n      }\n    } // if the view displays a single day or smaller\n\n\n    if (asRoughDays(duration) <= 1) {\n      if (this.isHiddenDay(start)) {\n        start = this.skipHiddenDays(start, direction);\n        start = startOfDay(start);\n      }\n    }\n\n    function computeRes() {\n      start = dateEnv.startOf(date, dateAlignment);\n      end = dateEnv.add(start, duration);\n      res = {\n        start: start,\n        end: end\n      };\n    }\n\n    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days\n\n    if (!this.trimHiddenDays(res)) {\n      date = this.skipHiddenDays(date, direction);\n      computeRes();\n    }\n\n    return res;\n  }; // Builds the \"current\" range when a dayCount is specified.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var runningCount = 0;\n    var start = date;\n    var end;\n\n    if (dateAlignment) {\n      start = dateEnv.startOf(start, dateAlignment);\n    }\n\n    start = startOfDay(start);\n    start = this.skipHiddenDays(start, direction);\n    end = start;\n\n    do {\n      end = addDays(end, 1);\n\n      if (!this.isHiddenDay(end)) {\n        runningCount += 1;\n      }\n    } while (runningCount < dayCount);\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds a normalized range object for the \"visible\" range,\n  // which is a way to define the currentRange and activeRange at the same time.\n\n\n  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n    var props = this.props;\n    var input = props.visibleRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n    var range = this.refineRange(simpleInput);\n\n    if (range && (range.start == null || range.end == null)) {\n      return null;\n    }\n\n    return range;\n  }; // Computes the range that will represent the element/cells for *rendering*,\n  // but which may have voided days/times.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    return currentRange;\n  }; // Compute the duration value that should be added/substracted to the current date\n  // when a prev/next operation happens.\n\n\n  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n    var dateIncrement = this.props.dateIncrement;\n    var customAlignment;\n\n    if (dateIncrement) {\n      return dateIncrement;\n    }\n\n    if (customAlignment = this.props.dateAlignment) {\n      return createDuration(1, customAlignment);\n    }\n\n    if (fallback) {\n      return fallback;\n    }\n\n    return createDuration({\n      days: 1\n    });\n  };\n\n  DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n    if (rangeInput) {\n      var range = parseRange(rangeInput, this.props.dateEnv);\n\n      if (range) {\n        range = computeVisibleDayRange(range);\n      }\n\n      return range;\n    }\n\n    return null;\n  };\n  /* Hidden Days\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Initializes internal variables related to calculating hidden days-of-week\n\n\n  DateProfileGenerator.prototype.initHiddenDays = function () {\n    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n\n    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n    var dayCnt = 0;\n    var i;\n\n    if (this.props.weekends === false) {\n      hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n    }\n\n    for (i = 0; i < 7; i += 1) {\n      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n        dayCnt += 1;\n      }\n    }\n\n    if (!dayCnt) {\n      throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n    }\n\n    this.isHiddenDayHash = isHiddenDayHash;\n  }; // Remove days from the beginning and end of the range that are computed as hidden.\n  // If the whole range is trimmed off, returns null\n\n\n  DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n    var start = range.start,\n        end = range.end;\n\n    if (start) {\n      start = this.skipHiddenDays(start);\n    }\n\n    if (end) {\n      end = this.skipHiddenDays(end, -1, true);\n    }\n\n    if (start == null || end == null || start < end) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    return null;\n  }; // Is the current day hidden?\n  // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n\n\n  DateProfileGenerator.prototype.isHiddenDay = function (day) {\n    if (day instanceof Date) {\n      day = day.getUTCDay();\n    }\n\n    return this.isHiddenDayHash[day];\n  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.\n  // DOES NOT CONSIDER validRange!\n  // If the initial value of `date` is not a hidden day, don't do anything.\n  // Pass `isExclusive` as `true` if you are dealing with an end date.\n  // `inc` defaults to `1` (increment one day forward each time)\n\n\n  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n    if (inc === void 0) {\n      inc = 1;\n    }\n\n    if (isExclusive === void 0) {\n      isExclusive = false;\n    }\n\n    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n      date = addDays(date, inc);\n    }\n\n    return date;\n  };\n\n  return DateProfileGenerator;\n}();\n\nfunction reduceViewType(viewType, action) {\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      viewType = action.viewType;\n  }\n\n  return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'SET_OPTION':\n      return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n\n    default:\n      return dynamicOptionOverrides;\n  }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n  var dp;\n\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return dateProfileGenerator.build(action.dateMarker || currentDate);\n\n    case 'CHANGE_DATE':\n      return dateProfileGenerator.build(action.dateMarker);\n\n    case 'PREV':\n      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n\n    case 'NEXT':\n      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n  }\n\n  return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null;\n  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\n\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  switch (action.type) {\n    case 'ADD_EVENT_SOURCES':\n      // already parsed\n      return addSources(eventSources, action.sources, activeRange, context);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return removeSource(eventSources, action.sourceId);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return fetchDirtySources(eventSources, activeRange, context);\n      }\n\n      return eventSources;\n\n    case 'FETCH_EVENT_SOURCES':\n      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n\n    case 'RECEIVE_EVENTS':\n    case 'RECEIVE_EVENT_ERROR':\n      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return {};\n\n    default:\n      return eventSources;\n  }\n}\n\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\n\nfunction computeEventSourcesLoading(eventSources) {\n  for (var sourceId in eventSources) {\n    if (eventSources[sourceId].isFetching) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n  var hash = {};\n\n  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n    var source = sources_1[_i];\n    hash[source.sourceId] = source;\n  }\n\n  if (fetchRange) {\n    hash = fetchDirtySources(hash, fetchRange, context);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventSourceHash), hash);\n}\n\nfunction removeSource(eventSourceHash, sourceId) {\n  return filterHash(eventSourceHash, function (eventSource) {\n    return eventSource.sourceId !== sourceId;\n  });\n}\n\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n    return isSourceDirty(eventSource, fetchRange, context);\n  }), fetchRange, false, context);\n}\n\nfunction isSourceDirty(eventSource, fetchRange, context) {\n  if (!doesSourceNeedRange(eventSource, context)) {\n    return !eventSource.latestFetchId;\n  }\n\n  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\n\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n  var nextSources = {};\n\n  for (var sourceId in prevSources) {\n    var source = prevSources[sourceId];\n\n    if (sourceIdHash[sourceId]) {\n      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n    } else {\n      nextSources[sourceId] = source;\n    }\n  }\n\n  return nextSources;\n}\n\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n  var options = context.options,\n      calendarApi = context.calendarApi;\n  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n  var fetchId = guid();\n  sourceDef.fetch({\n    eventSource: eventSource,\n    range: fetchRange,\n    isRefetch: isRefetch,\n    context: context\n  }, function (res) {\n    var rawEvents = res.rawEvents;\n\n    if (options.eventSourceSuccess) {\n      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    if (eventSource.success) {\n      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENTS',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawEvents: rawEvents\n    });\n  }, function (error) {\n    console.warn(error.message, error);\n\n    if (options.eventSourceFailure) {\n      options.eventSourceFailure.call(calendarApi, error);\n    }\n\n    if (eventSource.failure) {\n      eventSource.failure(error);\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENT_ERROR',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventSource), {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n  var _a;\n\n  var eventSource = sourceHash[sourceId];\n\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, sourceHash), (_a = {}, _a[sourceId] = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventSource), {\n      isFetching: false,\n      fetchRange: fetchRange\n    }), _a));\n  }\n\n  return sourceHash;\n}\n\nfunction excludeStaticSources(eventSources, context) {\n  return filterHash(eventSources, function (eventSource) {\n    return doesSourceNeedRange(eventSource, context);\n  });\n}\n\nfunction parseInitialSources(rawOptions, context) {\n  var refiners = buildEventSourceRefiners(context);\n  var rawSources = [].concat(rawOptions.eventSources || []);\n  var sources = []; // parsed\n\n  if (rawOptions.initialEvents) {\n    rawSources.unshift(rawOptions.initialEvents);\n  }\n\n  if (rawOptions.events) {\n    rawSources.unshift(rawOptions.events);\n  }\n\n  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n    var rawSource = rawSources_1[_i];\n    var source = parseEventSource(rawSource, context, refiners);\n\n    if (source) {\n      sources.push(source);\n    }\n  }\n\n  return sources;\n}\n\nfunction doesSourceNeedRange(eventSource, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n  return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n  switch (action.type) {\n    case 'RECEIVE_EVENTS':\n      // raw\n      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n\n    case 'ADD_EVENTS':\n      // already parsed, but not expanded\n      return addEvent(eventStore, action.eventStore, // new ones\n      dateProfile ? dateProfile.activeRange : null, context);\n\n    case 'RESET_EVENTS':\n      return action.eventStore;\n\n    case 'MERGE_EVENTS':\n      // already parsed and expanded\n      return mergeEventStores(eventStore, action.eventStore);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return expandRecurring(eventStore, dateProfile.activeRange, context);\n      }\n\n      return eventStore;\n\n    case 'REMOVE_EVENTS':\n      return excludeSubEventStore(eventStore, action.eventStore);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return excludeEventsBySourceId(eventStore, action.sourceId);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return filterEventStoreDefs(eventStore, function (eventDef) {\n        return !eventDef.sourceId // only keep events with no source id\n        ;\n      });\n\n    case 'REMOVE_ALL_EVENTS':\n      return createEmptyEventStore();\n\n    default:\n      return eventStore;\n  }\n}\n\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n  ) {\n    var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n\n    if (fetchRange) {\n      subset = expandRecurring(subset, fetchRange, context);\n    }\n\n    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n  }\n\n  return eventStore;\n}\n\nfunction transformRawEvents(rawEvents, eventSource, context) {\n  var calEachTransform = context.options.eventDataTransform;\n  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n\n  if (sourceEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n  }\n\n  if (calEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n  }\n\n  return rawEvents;\n}\n\nfunction transformEachRawEvent(rawEvents, func) {\n  var refinedEvents;\n\n  if (!func) {\n    refinedEvents = rawEvents;\n  } else {\n    refinedEvents = [];\n\n    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n      var rawEvent = rawEvents_1[_i];\n      var refinedEvent = func(rawEvent);\n\n      if (refinedEvent) {\n        refinedEvents.push(refinedEvent);\n      } else if (refinedEvent == null) {\n        refinedEvents.push(rawEvent);\n      } // if a different falsy value, do nothing\n\n    }\n  }\n\n  return refinedEvents;\n}\n\nfunction addEvent(eventStore, subset, expandRange, context) {\n  if (expandRange) {\n    subset = expandRecurring(subset, expandRange, context);\n  }\n\n  return mergeEventStores(eventStore, subset);\n}\n\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n  var defs = eventStore.defs;\n  var instances = mapHash(eventStore.instances, function (instance) {\n    var def = defs[instance.defId];\n\n    if (def.allDay || def.recurringDef) {\n      return instance; // isn't dependent on timezone\n    }\n\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, instance), {\n      range: {\n        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n      },\n      forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n      forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n    });\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n  return filterEventStoreDefs(eventStore, function (eventDef) {\n    return eventDef.sourceId !== sourceId;\n  });\n} // QUESTION: why not just return instances? do a general object-property-exclusion util\n\n\nfunction excludeInstances(eventStore, removals) {\n  return {\n    defs: eventStore.defs,\n    instances: filterHash(eventStore.instances, function (instance) {\n      return !removals[instance.instanceId];\n    })\n  };\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n  switch (action.type) {\n    case 'UNSELECT_DATES':\n      return null;\n\n    case 'SELECT_DATES':\n      return action.selection;\n\n    default:\n      return currentSelection;\n  }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n  switch (action.type) {\n    case 'UNSELECT_EVENT':\n      return '';\n\n    case 'SELECT_EVENT':\n      return action.eventInstanceId;\n\n    default:\n      return currentInstanceId;\n  }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n  var newDrag;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_DRAG':\n      return null;\n\n    case 'SET_EVENT_DRAG':\n      newDrag = action.state;\n      return {\n        affectedEvents: newDrag.affectedEvents,\n        mutatedEvents: newDrag.mutatedEvents,\n        isEvent: newDrag.isEvent\n      };\n\n    default:\n      return currentDrag;\n  }\n}\n\nfunction reduceEventResize(currentResize, action) {\n  var newResize;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_RESIZE':\n      return null;\n\n    case 'SET_EVENT_RESIZE':\n      newResize = action.state;\n      return {\n        affectedEvents: newResize.affectedEvents,\n        mutatedEvents: newResize.mutatedEvents,\n        isEvent: newResize.isEvent\n      };\n\n    default:\n      return currentResize;\n  }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n  var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n  return {\n    header: header,\n    footer: footer\n  };\n}\n\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var sectionWidgets = {};\n  var viewsWithButtons = [];\n  var hasTitle = false;\n\n  for (var sectionName in sectionStrHash) {\n    var sectionStr = sectionStrHash[sectionName];\n    var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n    sectionWidgets[sectionName] = sectionRes.widgets;\n    viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);\n    hasTitle = hasTitle || sectionRes.hasTitle;\n  }\n\n  return {\n    sectionWidgets: sectionWidgets,\n    viewsWithButtons: viewsWithButtons,\n    hasTitle: hasTitle\n  };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\n\n\nfunction parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined\ncalendarOptionOverrides, // overrides only!, unrefined :(\ntheme, viewSpecs, calendarApi) {\n  var isRtl = calendarOptions.direction === 'rtl';\n  var calendarCustomButtons = calendarOptions.customButtons || {};\n  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n  var calendarButtonText = calendarOptions.buttonText || {};\n  var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n  var calendarButtonHints = calendarOptions.buttonHints || {};\n  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n  var viewsWithButtons = [];\n  var hasTitle = false;\n  var widgets = sectionSubstrs.map(function (buttonGroupStr) {\n    return buttonGroupStr.split(',').map(function (buttonName) {\n      if (buttonName === 'title') {\n        hasTitle = true;\n        return {\n          buttonName: buttonName\n        };\n      }\n\n      var customButtonProps;\n      var viewSpec;\n      var buttonClick;\n      var buttonIcon; // only one of these will be set\n\n      var buttonText; // \"\n\n      var buttonHint; // ^ for the title=\"\" attribute, for accessibility\n\n      if (customButtonProps = calendarCustomButtons[buttonName]) {\n        buttonClick = function buttonClick(ev) {\n          if (customButtonProps.click) {\n            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n          }\n        };\n\n        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n        buttonHint = customButtonProps.hint || customButtonProps.text;\n      } else if (viewSpec = viewSpecs[buttonName]) {\n        viewsWithButtons.push(buttonName);\n\n        buttonClick = function buttonClick() {\n          calendarApi.changeView(buttonName);\n        };\n\n        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n        var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n        buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName\n        textFallback);\n      } else if (calendarApi[buttonName]) {\n        // a calendarApi method\n        buttonClick = function buttonClick() {\n          calendarApi[buttonName]();\n        };\n\n        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n\n        if (buttonName === 'prevYear' || buttonName === 'nextYear') {\n          var prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';\n          buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [calendarButtonText.year || 'year', 'year'], calendarButtonText[buttonName]);\n        } else {\n          buttonHint = function buttonHint(navUnit) {\n            return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [calendarButtonText[navUnit] || navUnit, navUnit], calendarButtonText[buttonName]);\n          };\n        }\n      }\n\n      return {\n        buttonName: buttonName,\n        buttonClick: buttonClick,\n        buttonIcon: buttonIcon,\n        buttonText: buttonText,\n        buttonHint: buttonHint\n      };\n    });\n  });\n  return {\n    widgets: widgets,\n    viewsWithButtons: viewsWithButtons,\n    hasTitle: hasTitle\n  };\n}\n\nvar eventSourceDef$2 = {\n  ignoreRange: true,\n  parseMeta: function parseMeta(refined) {\n    if (Array.isArray(refined.events)) {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success) {\n    success({\n      rawEvents: arg.eventSource.meta\n    });\n  }\n};\nvar arrayEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$2]\n});\nvar eventSourceDef$1 = {\n  parseMeta: function parseMeta(refined) {\n    if (typeof refined.events === 'function') {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var dateEnv = arg.context.dateEnv;\n    var func = arg.eventSource.meta;\n    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n      success({\n        rawEvents: rawEvents\n      }); // needs an object response\n    }, failure);\n  }\n};\nvar funcEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$1]\n});\n\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n  method = method.toUpperCase();\n  var body = null;\n\n  if (method === 'GET') {\n    url = injectQueryStringParams(url, params);\n  } else {\n    body = encodeParams(params);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (method !== 'GET') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 400) {\n      var parsed = false;\n      var res = void 0;\n\n      try {\n        res = JSON.parse(xhr.responseText);\n        parsed = true;\n      } catch (err) {// will handle parsed=false\n      }\n\n      if (parsed) {\n        successCallback(res, xhr);\n      } else {\n        failureCallback('Failure parsing JSON', xhr);\n      }\n    } else {\n      failureCallback('Request failed', xhr);\n    }\n  };\n\n  xhr.onerror = function () {\n    failureCallback('Request failed', xhr);\n  };\n\n  xhr.send(body);\n}\n\nfunction injectQueryStringParams(url, params) {\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);\n}\n\nfunction encodeParams(params) {\n  var parts = [];\n\n  for (var key in params) {\n    parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n\n  return parts.join('&');\n}\n\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n  method: String,\n  extraParams: identity,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String\n};\nvar eventSourceDef = {\n  parseMeta: function parseMeta(refined) {\n    if (refined.url && (refined.format === 'json' || !refined.format)) {\n      return {\n        url: refined.url,\n        format: 'json',\n        method: (refined.method || 'GET').toUpperCase(),\n        extraParams: refined.extraParams,\n        startParam: refined.startParam,\n        endParam: refined.endParam,\n        timeZoneParam: refined.timeZoneParam\n      };\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var meta = arg.eventSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.context);\n    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n      success({\n        rawEvents: rawEvents,\n        xhr: xhr\n      });\n    }, function (errorMessage, xhr) {\n      failure({\n        message: errorMessage,\n        xhr: xhr\n      });\n    });\n  }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n  eventSourceDefs: [eventSourceDef]\n});\n\nfunction buildRequestParams(meta, range, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n  startParam = meta.startParam;\n\n  if (startParam == null) {\n    startParam = options.startParam;\n  }\n\n  endParam = meta.endParam;\n\n  if (endParam == null) {\n    endParam = options.endParam;\n  }\n\n  timeZoneParam = meta.timeZoneParam;\n\n  if (timeZoneParam == null) {\n    timeZoneParam = options.timeZoneParam;\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(params, customRequestParams);\n\n  params[startParam] = dateEnv.formatIso(range.start);\n  params[endParam] = dateEnv.formatIso(range.end);\n\n  if (dateEnv.timeZone !== 'local') {\n    params[timeZoneParam] = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nvar SIMPLE_RECURRING_REFINERS = {\n  daysOfWeek: identity,\n  startTime: createDuration,\n  endTime: createDuration,\n  duration: createDuration,\n  startRecur: identity,\n  endRecur: identity\n};\nvar recurring = {\n  parse: function parse(refined, dateEnv) {\n    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n      var recurringData = {\n        daysOfWeek: refined.daysOfWeek || null,\n        startTime: refined.startTime || null,\n        endTime: refined.endTime || null,\n        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n      };\n      var duration = void 0;\n\n      if (refined.duration) {\n        duration = refined.duration;\n      }\n\n      if (!duration && refined.startTime && refined.endTime) {\n        duration = subtractDurations(refined.endTime, refined.startTime);\n      }\n\n      return {\n        allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n        duration: duration,\n        typeData: recurringData // doesn't need endTime anymore but oh well\n\n      };\n    }\n\n    return null;\n  },\n  expand: function expand(typeData, framingRange, dateEnv) {\n    var clippedFramingRange = intersectRanges(framingRange, {\n      start: typeData.startRecur,\n      end: typeData.endRecur\n    });\n\n    if (clippedFramingRange) {\n      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n    }\n\n    return [];\n  }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n  recurringTypes: [recurring],\n  eventRefiners: SIMPLE_RECURRING_REFINERS\n});\n\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n  var dayMarker = startOfDay(framingRange.start);\n  var endMarker = framingRange.end;\n  var instanceStarts = [];\n\n  while (dayMarker < endMarker) {\n    var instanceStart // if everyday, or this particular day-of-week\n    = void 0; // if everyday, or this particular day-of-week\n\n    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n      if (startTime) {\n        instanceStart = dateEnv.add(dayMarker, startTime);\n      } else {\n        instanceStart = dayMarker;\n      }\n\n      instanceStarts.push(instanceStart);\n    }\n\n    dayMarker = addDays(dayMarker, 1);\n  }\n\n  return instanceStarts;\n}\n\nvar changeHandlerPlugin = createPlugin({\n  optionChangeHandlers: {\n    events: function events(_events, context) {\n      handleEventSources([_events], context);\n    },\n    eventSources: handleEventSources\n  }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\n\nfunction handleEventSources(inputs, context) {\n  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n  var newInputs = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputFound = false;\n\n    for (var i = 0; i < unfoundSources.length; i += 1) {\n      if (unfoundSources[i]._raw === input) {\n        unfoundSources.splice(i, 1); // delete\n\n        inputFound = true;\n        break;\n      }\n    }\n\n    if (!inputFound) {\n      newInputs.push(input);\n    }\n  }\n\n  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n    var unfoundSource = unfoundSources_1[_a];\n    context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: unfoundSource.sourceId\n    });\n  }\n\n  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n    var newInput = newInputs_1[_b];\n    context.calendarApi.addEventSource(newInput);\n  }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n  context.emitter.trigger('datesSet', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n    view: context.viewApi\n  }));\n}\n\nfunction handleEventStore(eventStore, context) {\n  var emitter = context.emitter;\n\n  if (emitter.hasHandlers('eventsSet')) {\n    emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n  }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\n\n\nvar globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({\n  isLoadingFuncs: [function (state) {\n    return computeEventSourcesLoading(state.eventSources);\n  }],\n  contentTypeHandlers: {\n    html: buildHtmlRenderer,\n    domNodes: buildDomNodeRenderer\n  },\n  propSetHandlers: {\n    dateProfile: handleDateProfile,\n    eventStore: handleEventStore\n  }\n})];\n\nfunction buildHtmlRenderer() {\n  var currentEl = null;\n  var currentHtml = '';\n\n  function render(el, html) {\n    if (el !== currentEl || html !== currentHtml) {\n      el.innerHTML = html;\n    }\n\n    currentEl = el;\n    currentHtml = html;\n  }\n\n  function destroy() {\n    currentEl.innerHTML = '';\n    currentEl = null;\n    currentHtml = '';\n  }\n\n  return {\n    render: render,\n    destroy: destroy\n  };\n}\n\nfunction buildDomNodeRenderer() {\n  var currentEl = null;\n  var currentDomNodes = [];\n\n  function render(el, domNodes) {\n    var newDomNodes = Array.prototype.slice.call(domNodes);\n\n    if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {\n      // append first, remove second (for scroll resetting)\n      for (var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++) {\n        var newNode = newDomNodes_1[_i];\n        el.appendChild(newNode);\n      }\n\n      destroy();\n    }\n\n    currentEl = el;\n    currentDomNodes = newDomNodes;\n  }\n\n  function destroy() {\n    currentDomNodes.forEach(removeElement);\n    currentDomNodes = [];\n    currentEl = null;\n  }\n\n  return {\n    render: render,\n    destroy: destroy\n  };\n}\n\nvar DelayedRunner = function () {\n  function DelayedRunner(drainedOption) {\n    this.drainedOption = drainedOption;\n    this.isRunning = false;\n    this.isDirty = false;\n    this.pauseDepths = {};\n    this.timeoutId = 0;\n  }\n\n  DelayedRunner.prototype.request = function (delay) {\n    this.isDirty = true;\n\n    if (!this.isPaused()) {\n      this.clearTimeout();\n\n      if (delay == null) {\n        this.tryDrain();\n      } else {\n        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce\n        this.tryDrain.bind(this), delay);\n      }\n    }\n  };\n\n  DelayedRunner.prototype.pause = function (scope) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n    this.clearTimeout();\n  };\n\n  DelayedRunner.prototype.resume = function (scope, force) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n\n    if (scope in pauseDepths) {\n      if (force) {\n        delete pauseDepths[scope];\n      } else {\n        pauseDepths[scope] -= 1;\n        var depth = pauseDepths[scope];\n\n        if (depth <= 0) {\n          delete pauseDepths[scope];\n        }\n      }\n\n      this.tryDrain();\n    }\n  };\n\n  DelayedRunner.prototype.isPaused = function () {\n    return Object.keys(this.pauseDepths).length;\n  };\n\n  DelayedRunner.prototype.tryDrain = function () {\n    if (!this.isRunning && !this.isPaused()) {\n      this.isRunning = true;\n\n      while (this.isDirty) {\n        this.isDirty = false;\n        this.drained(); // might set isDirty to true again\n      }\n\n      this.isRunning = false;\n    }\n  };\n\n  DelayedRunner.prototype.clear = function () {\n    this.clearTimeout();\n    this.isDirty = false;\n    this.pauseDepths = {};\n  };\n\n  DelayedRunner.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = 0;\n    }\n  };\n\n  DelayedRunner.prototype.drained = function () {\n    if (this.drainedOption) {\n      this.drainedOption();\n    }\n  };\n\n  return DelayedRunner;\n}();\n\nvar TaskRunner = function () {\n  function TaskRunner(runTaskOption, drainedOption) {\n    this.runTaskOption = runTaskOption;\n    this.drainedOption = drainedOption;\n    this.queue = [];\n    this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n  }\n\n  TaskRunner.prototype.request = function (task, delay) {\n    this.queue.push(task);\n    this.delayedRunner.request(delay);\n  };\n\n  TaskRunner.prototype.pause = function (scope) {\n    this.delayedRunner.pause(scope);\n  };\n\n  TaskRunner.prototype.resume = function (scope, force) {\n    this.delayedRunner.resume(scope, force);\n  };\n\n  TaskRunner.prototype.drain = function () {\n    var queue = this.queue;\n\n    while (queue.length) {\n      var completedTasks = [];\n      var task = void 0;\n\n      while (task = queue.shift()) {\n        this.runTask(task);\n        completedTasks.push(task);\n      }\n\n      this.drained(completedTasks);\n    } // keep going, in case new tasks were added in the drained handler\n\n  };\n\n  TaskRunner.prototype.runTask = function (task) {\n    if (this.runTaskOption) {\n      this.runTaskOption(task);\n    }\n  };\n\n  TaskRunner.prototype.drained = function (completedTasks) {\n    if (this.drainedOption) {\n      this.drainedOption(completedTasks);\n    }\n  };\n\n  return TaskRunner;\n}(); // Computes what the title at the top of the calendarApi should be for this view\n\n\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n\n  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n    range = dateProfile.currentRange;\n  } else {\n    // for day units or smaller, use the actual day range\n    range = dateProfile.activeRange;\n  }\n\n  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n    isEndExclusive: dateProfile.isRangeAllDay,\n    defaultSeparator: viewOptions.titleRangeSeparator\n  });\n} // Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\n\nfunction buildTitleFormat(dateProfile) {\n  var currentRangeUnit = dateProfile.currentRangeUnit;\n\n  if (currentRangeUnit === 'year') {\n    return {\n      year: 'numeric'\n    };\n  }\n\n  if (currentRangeUnit === 'month') {\n    return {\n      year: 'numeric',\n      month: 'long'\n    }; // like \"September 2014\"\n  }\n\n  var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n\n  if (days !== null && days > 1) {\n    // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n    return {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    };\n  } // one day. longer, like \"September 9 2014\"\n\n\n  return {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  };\n} // in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\n\n\nvar CalendarDataManager = function () {\n  function CalendarDataManager(props) {\n    var _this = this;\n\n    this.computeOptionsData = memoize(this._computeOptionsData);\n    this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n    this.organizeRawLocales = memoize(organizeRawLocales);\n    this.buildLocale = memoize(buildLocale);\n    this.buildPluginHooks = buildBuildPluginHooks();\n    this.buildDateEnv = memoize(buildDateEnv);\n    this.buildTheme = memoize(buildTheme);\n    this.parseToolbars = memoize(parseToolbars);\n    this.buildViewSpecs = memoize(buildViewSpecs);\n    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n    this.buildViewApi = memoize(buildViewApi);\n    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n    this.buildEventUiBases = memoize(buildEventUiBases);\n    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n    this.buildTitle = memoize(buildTitle);\n    this.emitter = new Emitter();\n    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n    this.currentCalendarOptionsInput = {};\n    this.currentCalendarOptionsRefined = {};\n    this.currentViewOptionsInput = {};\n    this.currentViewOptionsRefined = {};\n    this.currentCalendarOptionsRefiners = {};\n\n    this.getCurrentData = function () {\n      return _this.data;\n    };\n\n    this.dispatch = function (action) {\n      _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n\n    };\n\n    this.props = props;\n    this.actionRunner.pause();\n    var dynamicOptionOverrides = {};\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    this.emitter.setThisContext(props.calendarApi);\n    this.emitter.setOptions(currentViewData.options);\n    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n\n    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }; // needs to be after setThisContext\n\n    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback(calendarContext);\n    } // NOT DRY\n\n\n    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n    var initialState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      eventSources: eventSources,\n      eventUiBases: {},\n      eventStore: createEmptyEventStore(),\n      renderableEventStore: createEmptyEventStore(),\n      dateSelection: null,\n      eventSelection: '',\n      eventDrag: null,\n      eventResize: null,\n      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, calendarContext), initialState);\n\n    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n      var reducer = _c[_b];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(initialState, reducer(null, null, contextAndState));\n    }\n\n    if (computeIsLoading(initialState, calendarContext)) {\n      this.emitter.trigger('loading', true); // NOT DRY\n    }\n\n    this.state = initialState;\n    this.updateData();\n    this.actionRunner.resume();\n  }\n\n  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n    var props = this.props;\n    props.optionOverrides = append ? (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, props.optionOverrides), optionOverrides) : optionOverrides;\n    this.actionRunner.request({\n      type: 'NOTHING'\n    });\n  };\n\n  CalendarDataManager.prototype._handleAction = function (action) {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        emitter = _a.emitter;\n\n    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = reduceViewType(state.currentViewType, action);\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    emitter.setThisContext(props.calendarApi);\n    emitter.setOptions(currentViewData.options);\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: emitter,\n      getCurrentData: this.getCurrentData\n    };\n    var currentDate = state.currentDate,\n        dateProfile = state.dateProfile;\n\n    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n      // hack\n      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n    }\n\n    currentDate = reduceCurrentDate(currentDate, action);\n    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n\n    if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n    action.type === 'NEXT' || // \"\n    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n    var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n\n    var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state\n    eventStore;\n\n    var _b = this.buildViewUiProps(calendarContext),\n        eventUiSingleBase = _b.eventUiSingleBase,\n        selectionConfig = _b.selectionConfig; // will memoize obj\n\n\n    var eventUiBySource = this.buildEventUiBySource(eventSources);\n    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n    var newState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      eventSources: eventSources,\n      eventStore: eventStore,\n      renderableEventStore: renderableEventStore,\n      selectionConfig: selectionConfig,\n      eventUiBases: eventUiBases,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      dateSelection: reduceDateSelection(state.dateSelection, action),\n      eventSelection: reduceSelectedEvent(state.eventSelection, action),\n      eventDrag: reduceEventDrag(state.eventDrag, action),\n      eventResize: reduceEventResize(state.eventResize, action)\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, calendarContext), newState);\n\n    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n      var reducer = _c[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n\n    }\n\n    var wasLoading = computeIsLoading(state, calendarContext);\n    var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system\n\n    if (!wasLoading && isLoading) {\n      emitter.trigger('loading', true);\n    } else if (wasLoading && !isLoading) {\n      emitter.trigger('loading', false);\n    }\n\n    this.state = newState;\n\n    if (props.onAction) {\n      props.onAction(action);\n    }\n  };\n\n  CalendarDataManager.prototype.updateData = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var oldData = this.data;\n    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n\n    var data = this.data = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }, optionsData), currentViewData), state);\n\n    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n    var oldCalendarOptions = oldData && oldData.calendarOptions;\n    var newCalendarOptions = optionsData.calendarOptions;\n\n    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n        // hack\n        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n      }\n\n      for (var optionName in changeHandlers) {\n        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n          changeHandlers[optionName](newCalendarOptions[optionName], data);\n        }\n      }\n    }\n\n    if (props.onData) {\n      props.onData(data);\n    }\n  };\n\n  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n    // TODO: blacklist options that are handled by optionChangeHandlers\n    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        pluginHooks = _a.pluginHooks,\n        localeDefaults = _a.localeDefaults,\n        availableLocaleData = _a.availableLocaleData,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    var theme = this.buildTheme(refinedOptions, pluginHooks);\n    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n    return {\n      calendarOptions: refinedOptions,\n      pluginHooks: pluginHooks,\n      dateEnv: dateEnv,\n      viewSpecs: viewSpecs,\n      theme: theme,\n      toolbarConfig: toolbarConfig,\n      localeDefaults: localeDefaults,\n      availableRawLocales: availableLocaleData.map\n    };\n  }; // always called from behind a memoizer\n\n\n  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),\n        locales = _a.locales,\n        locale = _a.locale;\n\n    var availableLocaleData = this.organizeRawLocales(locales);\n    var availableRawLocales = availableLocaleData.map;\n    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n\n    var refiners = this.currentCalendarOptionsRefiners = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var extra = {};\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);\n    var refined = {};\n    var currentRaw = this.currentCalendarOptionsInput;\n    var currentRefined = this.currentCalendarOptionsRefined;\n    var anyChanges = false;\n\n    for (var optionName in raw) {\n      if (optionName !== 'plugins') {\n        // because plugins is special-cased\n        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n          refined[optionName] = currentRefined[optionName];\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n          anyChanges = true;\n        } else {\n          extra[optionName] = currentRaw[optionName];\n        }\n      }\n    }\n\n    if (anyChanges) {\n      this.currentCalendarOptionsInput = raw;\n      this.currentCalendarOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentCalendarOptionsInput,\n      refinedOptions: this.currentCalendarOptionsRefined,\n      pluginHooks: pluginHooks,\n      availableLocaleData: availableLocaleData,\n      localeDefaults: localeDefaults,\n      extra: extra\n    };\n  };\n\n  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n    var viewSpec = optionsData.viewSpecs[viewType];\n\n    if (!viewSpec) {\n      throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n    }\n\n    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateProfileGenerator = this.buildDateProfileGenerator({\n      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n      duration: viewSpec.duration,\n      durationUnit: viewSpec.durationUnit,\n      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n      dateEnv: optionsData.dateEnv,\n      calendarApi: this.props.calendarApi,\n      slotMinTime: refinedOptions.slotMinTime,\n      slotMaxTime: refinedOptions.slotMaxTime,\n      showNonCurrentDates: refinedOptions.showNonCurrentDates,\n      dayCount: refinedOptions.dayCount,\n      dateAlignment: refinedOptions.dateAlignment,\n      dateIncrement: refinedOptions.dateIncrement,\n      hiddenDays: refinedOptions.hiddenDays,\n      weekends: refinedOptions.weekends,\n      nowInput: refinedOptions.now,\n      validRangeInput: refinedOptions.validRange,\n      visibleRangeInput: refinedOptions.visibleRange,\n      monthMode: refinedOptions.monthMode,\n      fixedWeekCount: refinedOptions.fixedWeekCount\n    });\n    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n    return {\n      viewSpec: viewSpec,\n      options: refinedOptions,\n      dateProfileGenerator: dateProfileGenerator,\n      viewApi: viewApi\n    };\n  };\n\n  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);\n\n    var refiners = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var refined = {};\n    var currentRaw = this.currentViewOptionsInput;\n    var currentRefined = this.currentViewOptionsRefined;\n    var anyChanges = false;\n    var extra = {};\n\n    for (var optionName in raw) {\n      if (raw[optionName] === currentRaw[optionName]) {\n        refined[optionName] = currentRefined[optionName];\n      } else {\n        if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n          if (optionName in this.currentCalendarOptionsRefined) {\n            // might be an \"extra\" prop\n            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n          }\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n        } else {\n          extra[optionName] = raw[optionName];\n        }\n\n        anyChanges = true;\n      }\n    }\n\n    if (anyChanges) {\n      this.currentViewOptionsInput = raw;\n      this.currentViewOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentViewOptionsInput,\n      refinedOptions: this.currentViewOptionsRefined,\n      extra: extra\n    };\n  };\n\n  return CalendarDataManager;\n}();\n\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n  return new DateEnv({\n    calendarSystem: 'gregory',\n    timeZone: timeZone,\n    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n    locale: locale,\n    weekNumberCalculation: weekNumberCalculation,\n    firstDay: firstDay,\n    weekText: weekText,\n    cmdFormatter: pluginHooks.cmdFormatter,\n    defaultSeparator: defaultSeparator\n  });\n}\n\nfunction buildTheme(options, pluginHooks) {\n  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n  return new ThemeClass(options);\n}\n\nfunction buildDateProfileGenerator(props) {\n  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n  return new DateProfileGeneratorClass(props);\n}\n\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n  return new ViewApi(type, getCurrentData, dateEnv);\n}\n\nfunction buildEventUiBySource(eventSources) {\n  return mapHash(eventSources, function (eventSource) {\n    return eventSource.ui;\n  });\n}\n\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n  var eventUiBases = {\n    '': eventUiSingleBase\n  };\n\n  for (var defId in eventDefs) {\n    var def = eventDefs[defId];\n\n    if (def.sourceId && eventUiBySource[def.sourceId]) {\n      eventUiBases[defId] = eventUiBySource[def.sourceId];\n    }\n  }\n\n  return eventUiBases;\n}\n\nfunction buildViewUiProps(calendarContext) {\n  var options = calendarContext.options;\n  return {\n    eventUiSingleBase: createEventUi({\n      display: options.eventDisplay,\n      editable: options.editable,\n      startEditable: options.eventStartEditable,\n      durationEditable: options.eventDurationEditable,\n      constraint: options.eventConstraint,\n      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n      allow: options.eventAllow,\n      backgroundColor: options.eventBackgroundColor,\n      borderColor: options.eventBorderColor,\n      textColor: options.eventTextColor,\n      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this\n\n    }, calendarContext),\n    selectionConfig: createEventUi({\n      constraint: options.selectConstraint,\n      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n      allow: options.selectAllow\n    }, calendarContext)\n  };\n}\n\nfunction computeIsLoading(state, context) {\n  for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {\n    var isLoadingFunc = _a[_i];\n\n    if (isLoadingFunc(state)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction parseContextBusinessHours(calendarContext) {\n  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\n\nfunction warnUnknownOptions(options, viewName) {\n  for (var optionName in options) {\n    console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : ''));\n  }\n} // TODO: move this to react plugin?\n\n\nvar CalendarDataProvider = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(CalendarDataProvider, _super);\n\n  function CalendarDataProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleData = function (data) {\n      if (!_this.dataManager) {\n        // still within initial run, before assignment in constructor\n        // eslint-disable-next-line react/no-direct-mutation-state\n        _this.state = data; // can't use setState yet\n      } else {\n        _this.setState(data);\n      }\n    };\n\n    _this.dataManager = new CalendarDataManager({\n      optionOverrides: props.optionOverrides,\n      calendarApi: props.calendarApi,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  CalendarDataProvider.prototype.render = function () {\n    return this.props.children(this.state);\n  };\n\n  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n    var newOptionOverrides = this.props.optionOverrides;\n\n    if (newOptionOverrides !== prevProps.optionOverrides) {\n      // prevent recursive handleData\n      this.dataManager.resetOptions(newOptionOverrides);\n    }\n  };\n\n  return CalendarDataProvider;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Component); // HELPERS\n\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\n\n\nfunction sliceEvents(props, allDay) {\n  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nvar NamedTimeZoneImpl = function () {\n  function NamedTimeZoneImpl(timeZoneName) {\n    this.timeZoneName = timeZoneName;\n  }\n\n  return NamedTimeZoneImpl;\n}();\n\nvar SegHierarchy = function () {\n  function SegHierarchy() {\n    // settings\n    this.strictOrder = false;\n    this.allowReslicing = false;\n    this.maxCoord = -1; // -1 means no max\n\n    this.maxStackCnt = -1; // -1 means no max\n\n    this.levelCoords = []; // ordered\n\n    this.entriesByLevel = []; // parallel with levelCoords\n\n    this.stackCnts = {}; // TODO: use better technique!?\n  }\n\n  SegHierarchy.prototype.addSegs = function (inputs) {\n    var hiddenEntries = [];\n\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n      var input = inputs_1[_i];\n      this.insertEntry(input, hiddenEntries);\n    }\n\n    return hiddenEntries;\n  };\n\n  SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {\n    var insertion = this.findInsertion(entry);\n\n    if (this.isInsertionValid(insertion, entry)) {\n      this.insertEntryAt(entry, insertion);\n      return 1;\n    }\n\n    return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n  };\n\n  SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {\n    return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n  }; // returns number of new entries inserted\n\n\n  SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    if (this.allowReslicing && insertion.touchingEntry) {\n      return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {\n    var partCnt = 0;\n    var splitHiddenEntries = [];\n    var entrySpan = entry.span;\n    var barrierSpan = barrier.span;\n\n    if (entrySpan.start < barrierSpan.start) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: entrySpan.start,\n          end: barrierSpan.start\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (entrySpan.end > barrierSpan.end) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: barrierSpan.end,\n          end: entrySpan.end\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (partCnt) {\n      hiddenEntries.push.apply(hiddenEntries, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([{\n        index: entry.index,\n        thickness: entry.thickness,\n        span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect\n\n      }], splitHiddenEntries));\n      return partCnt;\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    if (insertion.lateral === -1) {\n      // create a new level\n      insertAt(levelCoords, insertion.level, insertion.levelCoord);\n      insertAt(entriesByLevel, insertion.level, [entry]);\n    } else {\n      // insert into existing level\n      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n    }\n\n    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n  };\n\n  SegHierarchy.prototype.findInsertion = function (newEntry) {\n    var _a = this,\n        levelCoords = _a.levelCoords,\n        entriesByLevel = _a.entriesByLevel,\n        strictOrder = _a.strictOrder,\n        stackCnts = _a.stackCnts;\n\n    var levelCnt = levelCoords.length;\n    var candidateCoord = 0;\n    var touchingLevel = -1;\n    var touchingLateral = -1;\n    var touchingEntry = null;\n    var stackCnt = 0;\n\n    for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {\n      var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.\n      // if strictOrder, keep finding more lateral intersections.\n\n      if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n        break;\n      }\n\n      var trackingEntries = entriesByLevel[trackingLevel];\n      var trackingEntry = void 0;\n      var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n\n      var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n\n      while ( // loop through entries that horizontally intersect\n      (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n      trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n      ) {\n        var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?\n\n        if (trackingEntryBottom > candidateCoord) {\n          candidateCoord = trackingEntryBottom;\n          touchingEntry = trackingEntry;\n          touchingLevel = trackingLevel;\n          touchingLateral = lateralIndex;\n        } // butts up against top of candidate? (will happen if just intersected as well)\n\n\n        if (trackingEntryBottom === candidateCoord) {\n          // accumulate the highest possible stackCnt of the trackingEntries that butt up\n          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n        }\n\n        lateralIndex += 1;\n      }\n    } // the destination level will be after touchingEntry's level. find it\n\n\n    var destLevel = 0;\n\n    if (touchingEntry) {\n      destLevel = touchingLevel + 1;\n\n      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {\n        destLevel += 1;\n      }\n    } // if adding to an existing level, find where to insert\n\n\n    var destLateral = -1;\n\n    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n    }\n\n    return {\n      touchingLevel: touchingLevel,\n      touchingLateral: touchingLateral,\n      touchingEntry: touchingEntry,\n      stackCnt: stackCnt,\n      levelCoord: candidateCoord,\n      level: destLevel,\n      lateral: destLateral\n    };\n  }; // sorted by levelCoord (lowest to highest)\n\n\n  SegHierarchy.prototype.toRects = function () {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    var levelCnt = entriesByLevel.length;\n    var rects = [];\n\n    for (var level = 0; level < levelCnt; level += 1) {\n      var entries = entriesByLevel[level];\n      var levelCoord = levelCoords[level];\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n        rects.push((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, entry), {\n          levelCoord: levelCoord\n        }));\n      }\n    }\n\n    return rects;\n  };\n\n  return SegHierarchy;\n}();\n\nfunction getEntrySpanEnd(entry) {\n  return entry.span.end;\n}\n\nfunction buildEntryKey(entry) {\n  return entry.index + ':' + entry.span.start;\n} // returns groups with entries sorted by input order\n\n\nfunction groupIntersectingEntries(entries) {\n  var merges = [];\n\n  for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {\n    var entry = entries_2[_i];\n    var filteredMerges = [];\n    var hungryMerge = {\n      span: entry.span,\n      entries: [entry]\n    };\n\n    for (var _a = 0, merges_1 = merges; _a < merges_1.length; _a++) {\n      var merge = merges_1[_a];\n\n      if (intersectSpans(merge.span, hungryMerge.span)) {\n        hungryMerge = {\n          entries: merge.entries.concat(hungryMerge.entries),\n          span: joinSpans(merge.span, hungryMerge.span)\n        };\n      } else {\n        filteredMerges.push(merge);\n      }\n    }\n\n    filteredMerges.push(hungryMerge);\n    merges = filteredMerges;\n  }\n\n  return merges;\n}\n\nfunction joinSpans(span0, span1) {\n  return {\n    start: Math.min(span0.start, span1.start),\n    end: Math.max(span0.end, span1.end)\n  };\n}\n\nfunction intersectSpans(span0, span1) {\n  var start = Math.max(span0.start, span1.start);\n  var end = Math.min(span0.end, span1.end);\n\n  if (start < end) {\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  return null;\n} // general util\n// ---------------------------------------------------------------------------------------------------------------------\n\n\nfunction insertAt(arr, index, item) {\n  arr.splice(index, 0, item);\n}\n\nfunction binarySearch(a, searchVal, getItemVal) {\n  var startIndex = 0;\n  var endIndex = a.length; // exclusive\n\n  if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n    // no items OR before first item\n    return [0, 0];\n  }\n\n  if (searchVal > getItemVal(a[endIndex - 1])) {\n    // after last item\n    return [endIndex, 0];\n  }\n\n  while (startIndex < endIndex) {\n    var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n    var middleVal = getItemVal(a[middleIndex]);\n\n    if (searchVal < middleVal) {\n      endIndex = middleIndex;\n    } else if (searchVal > middleVal) {\n      startIndex = middleIndex + 1;\n    } else {\n      // equal!\n      return [middleIndex, 1];\n    }\n  }\n\n  return [startIndex, 0];\n}\n\nvar Interaction = function () {\n  function Interaction(settings) {\n    this.component = settings.component;\n    this.isHitComboAllowed = settings.isHitComboAllowed || null;\n  }\n\n  Interaction.prototype.destroy = function () {};\n\n  return Interaction;\n}();\n\nfunction parseInteractionSettings(component, input) {\n  return {\n    component: component,\n    el: input.el,\n    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n    isHitComboAllowed: input.isHitComboAllowed || null\n  };\n}\n\nfunction interactionSettingsToStore(settings) {\n  var _a;\n\n  return _a = {}, _a[settings.component.uid] = settings, _a;\n} // global state\n\n\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\n\nvar ElementDragging = function () {\n  function ElementDragging(el, selector) {\n    this.emitter = new Emitter();\n  }\n\n  ElementDragging.prototype.destroy = function () {};\n\n  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional\n  };\n\n  return ElementDragging;\n}(); // TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\n\n\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\n\nvar DRAG_META_REFINERS = {\n  startTime: createDuration,\n  duration: createDuration,\n  create: Boolean,\n  sourceId: String\n};\n\nfunction parseDragMeta(raw) {\n  var _a = refineProps(raw, DRAG_META_REFINERS),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  return {\n    startTime: refined.startTime || null,\n    duration: refined.duration || null,\n    create: refined.create != null ? refined.create : true,\n    sourceId: refined.sourceId,\n    leftoverProps: extra\n  };\n}\n\nvar ToolbarSection = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ToolbarSection, _super);\n\n  function ToolbarSection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarSection.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.widgetGroups.map(function (widgetGroup) {\n      return _this.renderWidgetGroup(widgetGroup);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['div', {\n      className: 'fc-toolbar-chunk'\n    }], children));\n  };\n\n  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n    var props = this.props;\n    var theme = this.context.theme;\n    var children = [];\n    var isOnlyButtons = true;\n\n    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n      var widget = widgetGroup_1[_i];\n      var buttonName = widget.buttonName,\n          buttonClick = widget.buttonClick,\n          buttonText = widget.buttonText,\n          buttonIcon = widget.buttonIcon,\n          buttonHint = widget.buttonHint;\n\n      if (buttonName === 'title') {\n        isOnlyButtons = false;\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"h2\", {\n          className: \"fc-toolbar-title\",\n          id: props.titleId\n        }, props.title));\n      } else {\n        var isPressed = buttonName === props.activeButton;\n        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n        var buttonClasses = [\"fc-\" + buttonName + \"-button\", theme.getClass('button')];\n\n        if (isPressed) {\n          buttonClasses.push(theme.getClass('buttonActive'));\n        }\n\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", {\n          type: \"button\",\n          title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,\n          disabled: isDisabled,\n          \"aria-pressed\": isPressed,\n          className: buttonClasses.join(' '),\n          onClick: buttonClick\n        }, buttonText || (buttonIcon ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n          className: buttonIcon\n        }) : '')));\n      }\n    }\n\n    if (children.length > 1) {\n      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n      return _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['div', {\n        className: groupClassName\n      }], children));\n    }\n\n    return children[0];\n  };\n\n  return ToolbarSection;\n}(BaseComponent);\n\nvar Toolbar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Toolbar, _super);\n\n  function Toolbar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Toolbar.prototype.render = function () {\n    var _a = this.props,\n        model = _a.model,\n        extraClassName = _a.extraClassName;\n    var forceLtr = false;\n    var startContent;\n    var endContent;\n    var sectionWidgets = model.sectionWidgets;\n    var centerContent = sectionWidgets.center;\n\n    if (sectionWidgets.left) {\n      forceLtr = true;\n      startContent = sectionWidgets.left;\n    } else {\n      startContent = sectionWidgets.start;\n    }\n\n    if (sectionWidgets.right) {\n      forceLtr = true;\n      endContent = sectionWidgets.right;\n    } else {\n      endContent = sectionWidgets.end;\n    }\n\n    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: classNames.join(' ')\n    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n  };\n\n  Toolbar.prototype.renderSection = function (key, widgetGroups) {\n    var props = this.props;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ToolbarSection, {\n      key: key,\n      widgetGroups: widgetGroups,\n      title: props.title,\n      navUnit: props.navUnit,\n      activeButton: props.activeButton,\n      isTodayEnabled: props.isTodayEnabled,\n      isPrevEnabled: props.isPrevEnabled,\n      isNextEnabled: props.isNextEnabled,\n      titleId: props.titleId\n    });\n  };\n\n  return Toolbar;\n}(BaseComponent); // TODO: do function component?\n\n\nvar ViewContainer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ViewContainer, _super);\n\n  function ViewContainer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      availableWidth: null\n    };\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n\n      _this.updateAvailableWidth();\n    };\n\n    _this.handleResize = function () {\n      _this.updateAvailableWidth();\n    };\n\n    return _this;\n  }\n\n  ViewContainer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var aspectRatio = props.aspectRatio;\n    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n    : 'fc-view-harness-passive' // let the view do the height\n    ];\n    var height = '';\n    var paddingBottom = '';\n\n    if (aspectRatio) {\n      if (state.availableWidth !== null) {\n        height = state.availableWidth / aspectRatio;\n      } else {\n        // while waiting to know availableWidth, we can't set height to *zero*\n        // because will cause lots of unnecessary scrollbars within scrollgrid.\n        // BETTER: don't start rendering ANYTHING yet until we know container width\n        // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n        paddingBottom = 1 / aspectRatio * 100 + \"%\";\n      }\n    } else {\n      height = props.height || '';\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      \"aria-labelledby\": props.labeledById,\n      ref: this.handleEl,\n      className: classNames.join(' '),\n      style: {\n        height: height,\n        paddingBottom: paddingBottom\n      }\n    }, props.children);\n  };\n\n  ViewContainer.prototype.componentDidMount = function () {\n    this.context.addResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.updateAvailableWidth = function () {\n    if (this.el && // needed. but why?\n    this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n    ) {\n      this.setState({\n        availableWidth: this.el.offsetWidth\n      });\n    }\n  };\n\n  return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\n\n\nvar EventClicking = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventClicking, _super);\n\n  function EventClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handleSegClick = function (ev, segEl) {\n      var component = _this.component;\n      var context = component.context;\n      var seg = getElSeg(segEl);\n\n      if (seg && // might be the <div> surrounding the more link\n      component.isValidSegDownEl(ev.target)) {\n        // our way to simulate a link click for elements that can't be <a> tags\n        // grab before trigger fired in case trigger trashes DOM thru rerendering\n        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n        context.emitter.trigger('eventClick', {\n          el: segEl,\n          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n\n        if (url && !ev.defaultPrevented) {\n          window.location.href = url;\n        }\n      }\n    };\n\n    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n    _this.handleSegClick);\n    return _this;\n  }\n\n  return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\n\n\nvar EventHovering = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventHovering, _super);\n\n  function EventHovering(settings) {\n    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n\n\n    _this.handleEventElRemove = function (el) {\n      if (el === _this.currentSegEl) {\n        _this.handleSegLeave(null, _this.currentSegEl);\n      }\n    };\n\n    _this.handleSegEnter = function (ev, segEl) {\n      if (getElSeg(segEl)) {\n        // TODO: better way to make sure not hovering over more+ link or its wrapper\n        _this.currentSegEl = segEl;\n\n        _this.triggerEvent('eventMouseEnter', ev, segEl);\n      }\n    };\n\n    _this.handleSegLeave = function (ev, segEl) {\n      if (_this.currentSegEl) {\n        _this.currentSegEl = null;\n\n        _this.triggerEvent('eventMouseLeave', ev, segEl);\n      }\n    };\n\n    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n    _this.handleSegEnter, _this.handleSegLeave);\n    return _this;\n  }\n\n  EventHovering.prototype.destroy = function () {\n    this.removeHoverListeners();\n  };\n\n  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n    var component = this.component;\n    var context = component.context;\n    var seg = getElSeg(segEl);\n\n    if (!ev || component.isValidSegDownEl(ev.target)) {\n      context.emitter.trigger(publicEvName, {\n        el: segEl,\n        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    }\n  };\n\n  return EventHovering;\n}(Interaction);\n\nvar CalendarContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(CalendarContent, _super);\n\n  function CalendarContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildViewContext = memoize(buildViewContext);\n    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n    _this.buildToolbarProps = memoize(buildToolbarProps);\n    _this.headerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.footerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.interactionsStore = {}; // eslint-disable-next-line\n\n    _this.state = {\n      viewLabelId: getUniqueDomId()\n    }; // Component Registration\n    // -----------------------------------------------------------------------------------------------------------------\n\n    _this.registerInteractiveComponent = function (component, settingsInput) {\n      var settings = parseInteractionSettings(component, settingsInput);\n      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];\n      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n      var interactions = interactionClasses.map(function (TheInteractionClass) {\n        return new TheInteractionClass(settings);\n      });\n      _this.interactionsStore[component.uid] = interactions;\n      interactionSettingsStore[component.uid] = settings;\n    };\n\n    _this.unregisterInteractiveComponent = function (component) {\n      for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.destroy();\n      }\n\n      delete _this.interactionsStore[component.uid];\n      delete interactionSettingsStore[component.uid];\n    }; // Resizing\n    // -----------------------------------------------------------------------------------------------------------------\n\n\n    _this.resizeRunner = new DelayedRunner(function () {\n      _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n\n\n      _this.props.emitter.trigger('windowResize', {\n        view: _this.props.viewApi\n      });\n    });\n\n    _this.handleWindowResize = function (ev) {\n      var options = _this.props.options;\n\n      if (options.handleWindowResize && ev.target === window // avoid jqui events\n      ) {\n        _this.resizeRunner.request(options.windowResizeDelay);\n      }\n    };\n\n    return _this;\n  }\n  /*\n  renders INSIDE of an outer div\n  */\n\n\n  CalendarContent.prototype.render = function () {\n    var props = this.props;\n    var toolbarConfig = props.toolbarConfig,\n        options = props.options;\n    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n    props.viewTitle);\n    var viewVGrow = false;\n    var viewHeight = '';\n    var viewAspectRatio;\n\n    if (props.isHeightAuto || props.forPrint) {\n      viewHeight = '';\n    } else if (options.height != null) {\n      viewVGrow = true;\n    } else if (options.contentHeight != null) {\n      viewHeight = options.contentHeight;\n    } else {\n      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n    }\n\n    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n    var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Provider, {\n      value: viewContext\n    }, toolbarConfig.header && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      ref: this.headerRef,\n      extraClassName: \"fc-header-toolbar\",\n      model: toolbarConfig.header,\n      titleId: viewLabelId\n    }, toolbarProps)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContainer, {\n      liquid: viewVGrow,\n      height: viewHeight,\n      aspectRatio: viewAspectRatio,\n      labeledById: viewLabelId\n    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      ref: this.footerRef,\n      extraClassName: \"fc-footer-toolbar\",\n      model: toolbarConfig.footer,\n      titleId: \"\"\n    }, toolbarProps)));\n  };\n\n  CalendarContent.prototype.componentDidMount = function () {\n    var props = this.props;\n    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {\n      return new CalendarInteractionClass(props);\n    });\n    window.addEventListener('resize', this.handleWindowResize);\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      propSetHandlers[propName](props[propName], props);\n    }\n  };\n\n  CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n    var props = this.props;\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      if (props[propName] !== prevProps[propName]) {\n        propSetHandlers[propName](props[propName], props);\n      }\n    }\n  };\n\n  CalendarContent.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.resizeRunner.clear();\n\n    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n      var interaction = _a[_i];\n      interaction.destroy();\n    }\n\n    this.props.emitter.trigger('_unmount');\n  };\n\n  CalendarContent.prototype.buildAppendContent = function () {\n    var props = this.props;\n    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {\n      return buildAppendContent(props);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}], children));\n  };\n\n  CalendarContent.prototype.renderView = function (props) {\n    var pluginHooks = props.pluginHooks;\n    var viewSpec = props.viewSpec;\n    var viewProps = {\n      dateProfile: props.dateProfile,\n      businessHours: props.businessHours,\n      eventStore: props.renderableEventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isHeightAuto: props.isHeightAuto,\n      forPrint: props.forPrint\n    };\n    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n      var transformer = transformers_1[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(viewProps, transformer.transform(viewProps, props));\n    }\n\n    var ViewComponent = viewSpec.component;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewComponent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, viewProps));\n  };\n\n  return CalendarContent;\n}(PureComponent);\n\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n\n  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n  return {\n    title: title,\n    activeButton: viewSpec.type,\n    navUnit: viewSpec.singleUnit,\n    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n    isPrevEnabled: prevInfo.isValid,\n    isNextEnabled: nextInfo.isValid\n  };\n} // Plugin\n// -----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildViewPropTransformers(theClasses) {\n  return theClasses.map(function (TheClass) {\n    return new TheClass();\n  });\n}\n\nvar CalendarRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(CalendarRoot, _super);\n\n  function CalendarRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      forPrint: false\n    };\n\n    _this.handleBeforePrint = function () {\n      _this.setState({\n        forPrint: true\n      });\n    };\n\n    _this.handleAfterPrint = function () {\n      _this.setState({\n        forPrint: false\n      });\n    };\n\n    return _this;\n  }\n\n  CalendarRoot.prototype.render = function () {\n    var props = this.props;\n    var options = props.options;\n    var forPrint = this.state.forPrint;\n    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n    var height = !isHeightAuto && options.height != null ? options.height : '';\n    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', \"fc-direction-\" + options.direction, props.theme.getClass('root')];\n\n    if (!getCanVGrowWithinCell()) {\n      classNames.push('fc-liquid-hack');\n    }\n\n    return props.children(classNames, height, isHeightAuto, forPrint);\n  };\n\n  CalendarRoot.prototype.componentDidMount = function () {\n    var emitter = this.props.emitter;\n    emitter.on('_beforeprint', this.handleBeforePrint);\n    emitter.on('_afterprint', this.handleAfterPrint);\n  };\n\n  CalendarRoot.prototype.componentWillUnmount = function () {\n    var emitter = this.props.emitter;\n    emitter.off('_beforeprint', this.handleBeforePrint);\n    emitter.off('_afterprint', this.handleAfterPrint);\n  };\n\n  return CalendarRoot;\n}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined\n\n\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n  // if more than one week row, or if there are a lot of columns with not much space,\n  // put just the day numbers will be in each cell\n  if (!datesRepDistinctDays || dayCnt > 10) {\n    return createFormatter({\n      weekday: 'short'\n    }); // \"Sat\"\n  }\n\n  if (dayCnt > 1) {\n    return createFormatter({\n      weekday: 'short',\n      month: 'numeric',\n      day: 'numeric',\n      omitCommas: true\n    }); // \"Sat 11/12\"\n  }\n\n  return createFormatter({\n    weekday: 'long'\n  }); // \"Saturday\"\n}\n\nvar CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n\nfunction renderInner$1(hookProps) {\n  return hookProps.text;\n}\n\nvar TableDateCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableDateCell, _super);\n\n  function TableDateCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDateCell.prototype.render = function () {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        theme = _a.theme,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink\n\n    var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      date: dateEnv.toDate(date),\n      view: viewApi\n    }, props.extraHookProps), {\n      text: text\n    }), dayMeta);\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        ref: rootElRef,\n        role: \"columnheader\",\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, !dayMeta.isDisabled && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        ref: innerElRef,\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')\n      }, navLinkAttrs), innerContent)));\n    });\n  };\n\n  return TableDateCell;\n}(BaseComponent);\n\nvar WEEKDAY_FORMAT = createFormatter({\n  weekday: 'long'\n});\n\nvar TableDowCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableDowCell, _super);\n\n  function TableDowCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDowCell.prototype.render = function () {\n    var props = this.props;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        viewApi = _a.viewApi,\n        options = _a.options;\n    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n\n    var dateMeta = {\n      dow: props.dow,\n      isDisabled: false,\n      isFuture: false,\n      isPast: false,\n      isToday: false,\n      isOther: false\n    };\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n    var text = dateEnv.format(date, props.dayHeaderFormat);\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      // TODO: make this public?\n      date: date\n    }, dateMeta), {\n      view: viewApi\n    }), props.extraHookProps), {\n      text: text\n    });\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        ref: rootElRef,\n        role: \"columnheader\",\n        className: classNames.concat(customClassNames).join(' '),\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", {\n        \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT),\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return TableDowCell;\n}(BaseComponent);\n\nvar NowTimer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(NowTimer, _super);\n\n  function NowTimer(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n    _this.initialNowQueriedMs = new Date().valueOf();\n    _this.state = _this.computeTiming().currentState;\n    return _this;\n  }\n\n  NowTimer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return props.children(state.nowDate, state.todayRange);\n  };\n\n  NowTimer.prototype.componentDidMount = function () {\n    this.setTimeout();\n  };\n\n  NowTimer.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.unit !== this.props.unit) {\n      this.clearTimeout();\n      this.setTimeout();\n    }\n  };\n\n  NowTimer.prototype.componentWillUnmount = function () {\n    this.clearTimeout();\n  };\n\n  NowTimer.prototype.computeTiming = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n    // ensure no longer than a day\n\n    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n    return {\n      currentState: {\n        nowDate: currentUnitStart,\n        todayRange: buildDayRange(currentUnitStart)\n      },\n      nextState: {\n        nowDate: nextUnitStart,\n        todayRange: buildDayRange(nextUnitStart)\n      },\n      waitMs: waitMs\n    };\n  };\n\n  NowTimer.prototype.setTimeout = function () {\n    var _this = this;\n\n    var _a = this.computeTiming(),\n        nextState = _a.nextState,\n        waitMs = _a.waitMs;\n\n    this.timeoutId = setTimeout(function () {\n      _this.setState(nextState, function () {\n        _this.setTimeout();\n      });\n    }, waitMs);\n  };\n\n  NowTimer.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  };\n\n  NowTimer.contextType = ViewContextType;\n  return NowTimer;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nfunction buildDayRange(date) {\n  var start = startOfDay(date);\n  var end = addDays(start, 1);\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DayHeader = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayHeader, _super);\n\n  function DayHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    return _this;\n  }\n\n  DayHeader.prototype.render = function () {\n    var context = this.context;\n    var _a = this.props,\n        dates = _a.dates,\n        dateProfile = _a.dateProfile,\n        datesRepDistinctDays = _a.datesRepDistinctDays,\n        renderIntro = _a.renderIntro;\n    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n        role: \"row\"\n      }, renderIntro && renderIntro('day'), dates.map(function (date) {\n        return datesRepDistinctDays ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDateCell, {\n          key: date.toISOString(),\n          date: date,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          colCnt: dates.length,\n          dayHeaderFormat: dayHeaderFormat\n        }) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDowCell, {\n          key: date.getUTCDay(),\n          dow: date.getUTCDay(),\n          dayHeaderFormat: dayHeaderFormat\n        });\n      }));\n    });\n  };\n\n  return DayHeader;\n}(BaseComponent);\n\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nvar DaySeriesModel = function () {\n  function DaySeriesModel(range, dateProfileGenerator) {\n    var date = range.start;\n    var end = range.end;\n    var indices = [];\n    var dates = [];\n    var dayIndex = -1;\n\n    while (date < end) {\n      // loop each day from start to end\n      if (dateProfileGenerator.isHiddenDay(date)) {\n        indices.push(dayIndex + 0.5); // mark that it's between indices\n      } else {\n        dayIndex += 1;\n        indices.push(dayIndex);\n        dates.push(date);\n      }\n\n      date = addDays(date, 1);\n    }\n\n    this.dates = dates;\n    this.indices = indices;\n    this.cnt = dates.length;\n  }\n\n  DaySeriesModel.prototype.sliceRange = function (range) {\n    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n\n    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n\n    var clippedFirstIndex = Math.max(0, firstIndex);\n    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices\n\n    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n\n    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n\n    if (clippedFirstIndex <= clippedLastIndex) {\n      return {\n        firstIndex: clippedFirstIndex,\n        lastIndex: clippedLastIndex,\n        isStart: firstIndex === clippedFirstIndex,\n        isEnd: lastIndex === clippedLastIndex\n      };\n    }\n\n    return null;\n  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n  // If before the first offset, returns a negative number.\n  // If after the last offset, returns an offset past the last cell offset.\n  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\n\n  DaySeriesModel.prototype.getDateDayIndex = function (date) {\n    var indices = this.indices;\n    var dayOffset = Math.floor(diffDays(this.dates[0], date));\n\n    if (dayOffset < 0) {\n      return indices[0] - 1;\n    }\n\n    if (dayOffset >= indices.length) {\n      return indices[indices.length - 1] + 1;\n    }\n\n    return indices[dayOffset];\n  };\n\n  return DaySeriesModel;\n}();\n\nvar DayTableModel = function () {\n  function DayTableModel(daySeries, breakOnWeeks) {\n    var dates = daySeries.dates;\n    var daysPerRow;\n    var firstDay;\n    var rowCnt;\n\n    if (breakOnWeeks) {\n      // count columns until the day-of-week repeats\n      firstDay = dates[0].getUTCDay();\n\n      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n        if (dates[daysPerRow].getUTCDay() === firstDay) {\n          break;\n        }\n      }\n\n      rowCnt = Math.ceil(dates.length / daysPerRow);\n    } else {\n      rowCnt = 1;\n      daysPerRow = dates.length;\n    }\n\n    this.rowCnt = rowCnt;\n    this.colCnt = daysPerRow;\n    this.daySeries = daySeries;\n    this.cells = this.buildCells();\n    this.headerDates = this.buildHeaderDates();\n  }\n\n  DayTableModel.prototype.buildCells = function () {\n    var rows = [];\n\n    for (var row = 0; row < this.rowCnt; row += 1) {\n      var cells = [];\n\n      for (var col = 0; col < this.colCnt; col += 1) {\n        cells.push(this.buildCell(row, col));\n      }\n\n      rows.push(cells);\n    }\n\n    return rows;\n  };\n\n  DayTableModel.prototype.buildCell = function (row, col) {\n    var date = this.daySeries.dates[row * this.colCnt + col];\n    return {\n      key: date.toISOString(),\n      date: date\n    };\n  };\n\n  DayTableModel.prototype.buildHeaderDates = function () {\n    var dates = [];\n\n    for (var col = 0; col < this.colCnt; col += 1) {\n      dates.push(this.cells[0][col].date);\n    }\n\n    return dates;\n  };\n\n  DayTableModel.prototype.sliceRange = function (range) {\n    var colCnt = this.colCnt;\n    var seriesSeg = this.daySeries.sliceRange(range);\n    var segs = [];\n\n    if (seriesSeg) {\n      var firstIndex = seriesSeg.firstIndex,\n          lastIndex = seriesSeg.lastIndex;\n      var index = firstIndex;\n\n      while (index <= lastIndex) {\n        var row = Math.floor(index / colCnt);\n        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n        segs.push({\n          row: row,\n          firstCol: index % colCnt,\n          lastCol: (nextIndex - 1) % colCnt,\n          isStart: seriesSeg.isStart && index === firstIndex,\n          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n        });\n        index = nextIndex;\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTableModel;\n}();\n\nvar Slicer = function () {\n  function Slicer() {\n    this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n    this.sliceDateSelection = memoize(this._sliceDateSpan);\n    this.sliceEventStore = memoize(this._sliceEventStore);\n    this.sliceEventDrag = memoize(this._sliceInteraction);\n    this.sliceEventResize = memoize(this._sliceInteraction);\n    this.forceDayIfListItem = false; // hack\n  }\n\n  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    var eventUiBases = props.eventUiBases;\n    var eventSegs = this.sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n    return {\n      dateSelectionSegs: this.sliceDateSelection.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([props.dateSelection, eventUiBases, context], extraArgs)),\n      businessHourSegs: this.sliceBusinessHours.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n      fgEventSegs: eventSegs.fg,\n      bgEventSegs: eventSegs.bg,\n      eventDrag: this.sliceEventDrag.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventResize: this.sliceEventResize.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventSelection: props.eventSelection\n    }; // TODO: give interactionSegs?\n  };\n\n  Slicer.prototype.sliceNowDate = function ( // does not memoize\n  date, context) {\n    var extraArgs = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      extraArgs[_i - 2] = arguments[_i];\n    }\n\n    return this._sliceDateSpan.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([{\n      range: {\n        start: date,\n        end: addMs(date, 1)\n      },\n      allDay: false\n    }, {}, context], extraArgs));\n  };\n\n  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!businessHours) {\n      return [];\n    }\n\n    return this._sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;\n  };\n\n  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (eventStore) {\n      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n      return {\n        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n      };\n    }\n\n    return {\n      bg: [],\n      fg: []\n    };\n  };\n\n  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!interaction) {\n      return null;\n    }\n\n    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n    return {\n      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n      affectedInstances: interaction.affectedEvents.instances,\n      isEvent: interaction.isEvent\n    };\n  };\n\n  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n    var extraArgs = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      extraArgs[_i - 3] = arguments[_i];\n    }\n\n    if (!dateSpan) {\n      return [];\n    }\n\n    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([dateSpan.range], extraArgs));\n\n    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n      var seg = segs_1[_a];\n      seg.eventRange = eventRange;\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n\n    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n      dateRange = {\n        start: dateRange.start,\n        end: addDays(dateRange.start, 1)\n      };\n    }\n\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([dateRange], extraArgs));\n\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      seg.eventRange = eventRange;\n      seg.isStart = eventRange.isStart && seg.isStart;\n      seg.isEnd = eventRange.isEnd && seg.isEnd;\n    }\n\n    return segs;\n  };\n\n  return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\n\n\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n  var range = dateProfile.activeRange;\n\n  if (isComponentAllDay) {\n    return range;\n  }\n\n  return {\n    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day\n\n  };\n} // high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionValid(interaction, dateProfile, context) {\n  var instances = interaction.mutatedEvents.instances;\n\n  for (var instanceId in instances) {\n    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n      return false;\n    }\n  }\n\n  return isNewPropsValid({\n    eventDrag: interaction\n  }, context); // HACK: the eventDrag props is used for ALL interactions\n}\n\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n    return false;\n  }\n\n  return isNewPropsValid({\n    dateSelection: dateSelection\n  }, context);\n}\n\nfunction isNewPropsValid(newProps, context) {\n  var calendarState = context.getCurrentData();\n\n  var props = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n    businessHours: calendarState.businessHours,\n    dateSelection: '',\n    eventStore: calendarState.eventStore,\n    eventUiBases: calendarState.eventUiBases,\n    eventSelection: '',\n    eventDrag: null,\n    eventResize: null\n  }, newProps);\n\n  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\n\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n  if (dateSpanMeta === void 0) {\n    dateSpanMeta = {};\n  }\n\n  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  return true;\n} // Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var currentState = context.getCurrentData();\n  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n\n  var subjectEventStore = interaction.mutatedEvents;\n  var subjectDefs = subjectEventStore.defs;\n  var subjectInstances = subjectEventStore.instances;\n  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n    '': currentState.selectionConfig\n  });\n\n  if (filterConfig) {\n    subjectConfigs = mapHash(subjectConfigs, filterConfig);\n  } // exclude the subject events. TODO: exclude defs too?\n\n\n  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n  var otherDefs = otherEventStore.defs;\n  var otherInstances = otherEventStore.instances;\n  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n\n  for (var subjectInstanceId in subjectInstances) {\n    var subjectInstance = subjectInstances[subjectInstanceId];\n    var subjectRange = subjectInstance.range;\n    var subjectConfig = subjectConfigs[subjectInstance.defId];\n    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint\n\n    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n      return false;\n    } // overlap\n\n\n    var eventOverlap = context.options.eventOverlap;\n    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n\n    for (var otherInstanceId in otherInstances) {\n      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate\n\n      if (rangesIntersect(subjectRange, otherInstance.range)) {\n        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a \"real\" event\n\n        if (otherOverlap === false && interaction.isEvent) {\n          return false;\n        }\n\n        if (subjectConfig.overlap === false) {\n          return false;\n        }\n\n        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n        new EventApi(context, subjectDef, subjectInstance))) {\n          return false;\n        }\n      }\n    } // allow (a function)\n\n\n    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n\n    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n      var subjectAllow = _a[_i];\n\n      var subjectDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dateSpanMeta), {\n        range: subjectInstance.range,\n        allDay: subjectDef.allDay\n      });\n\n      var origDef = calendarEventStore.defs[subjectDef.defId];\n      var origInstance = calendarEventStore.instances[subjectInstanceId];\n      var eventApi = void 0;\n\n      if (origDef) {\n        // was previously in the calendar\n        eventApi = new EventApi(context, origDef, origInstance);\n      } else {\n        // was an external event\n        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n      }\n\n      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var relevantEventStore = state.eventStore;\n  var relevantDefs = relevantEventStore.defs;\n  var relevantInstances = relevantEventStore.instances;\n  var selection = state.dateSelection;\n  var selectionRange = selection.range;\n  var selectionConfig = context.getCurrentData().selectionConfig;\n\n  if (filterConfig) {\n    selectionConfig = filterConfig(selectionConfig);\n  } // constraint\n\n\n  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n    return false;\n  } // overlap\n\n\n  var selectOverlap = context.options.selectOverlap;\n  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n\n  for (var relevantInstanceId in relevantInstances) {\n    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate\n\n    if (rangesIntersect(selectionRange, relevantInstance.range)) {\n      if (selectionConfig.overlap === false) {\n        return false;\n      }\n\n      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n        return false;\n      }\n    }\n  } // allow (a function)\n\n\n  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n    var selectionAllow = _a[_i];\n\n    var fullDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dateSpanMeta), selection);\n\n    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n      return false;\n    }\n  }\n\n  return true;\n} // Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n    var constraint = constraints_1[_i];\n\n    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext) {\n  if (constraint === 'businessHours') {\n    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n  }\n\n  if (typeof constraint === 'string') {\n    // an group ID\n    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n      return eventDef.groupId === constraint;\n    }));\n  }\n\n  if (typeof constraint === 'object' && constraint) {\n    // non-null object\n    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n  }\n\n  return []; // if it's false\n} // TODO: move to event-store file?\n\n\nfunction eventStoreToRanges(eventStore) {\n  var instances = eventStore.instances;\n  var ranges = [];\n\n  for (var instanceId in instances) {\n    ranges.push(instances[instanceId].range);\n  }\n\n  return ranges;\n} // TODO: move to geom file?\n\n\nfunction anyRangesContainRange(outerRanges, innerRange) {\n  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n    var outerRange = outerRanges_1[_i];\n\n    if (rangeContainsRange(outerRange, innerRange)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n\nvar Scroller = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Scroller, _super);\n\n  function Scroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  Scroller.prototype.render = function () {\n    var props = this.props;\n    var liquid = props.liquid,\n        liquidIsAbsolute = props.liquidIsAbsolute;\n    var isAbsolute = liquid && liquidIsAbsolute;\n    var className = ['fc-scroller'];\n\n    if (liquid) {\n      if (liquidIsAbsolute) {\n        className.push('fc-scroller-liquid-absolute');\n      } else {\n        className.push('fc-scroller-liquid');\n      }\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      ref: this.handleEl,\n      className: className.join(' '),\n      style: {\n        overflowX: props.overflowX,\n        overflowY: props.overflowY,\n        left: isAbsolute && -(props.overcomeLeft || 0) || '',\n        right: isAbsolute && -(props.overcomeRight || 0) || '',\n        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n        maxHeight: props.maxHeight || ''\n      }\n    }, props.children);\n  };\n\n  Scroller.prototype.needsXScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return false;\n    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().width > realClientWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.needsYScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return false;\n    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().height > realClientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.getXScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return 0;\n    }\n\n    return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  Scroller.prototype.getYScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return 0;\n    }\n\n    return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\n\n\nvar RefMap = function () {\n  function RefMap(masterCallback) {\n    var _this = this;\n\n    this.masterCallback = masterCallback;\n    this.currentMap = {};\n    this.depths = {};\n    this.callbackMap = {};\n\n    this.handleValue = function (val, key) {\n      var _a = _this,\n          depths = _a.depths,\n          currentMap = _a.currentMap;\n      var removed = false;\n      var added = false;\n\n      if (val !== null) {\n        // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n        removed = key in currentMap;\n        currentMap[key] = val;\n        depths[key] = (depths[key] || 0) + 1;\n        added = true;\n      } else {\n        depths[key] -= 1;\n\n        if (!depths[key]) {\n          delete currentMap[key];\n          delete _this.callbackMap[key];\n          removed = true;\n        }\n      }\n\n      if (_this.masterCallback) {\n        if (removed) {\n          _this.masterCallback(null, String(key));\n        }\n\n        if (added) {\n          _this.masterCallback(val, String(key));\n        }\n      }\n    };\n  }\n\n  RefMap.prototype.createRef = function (key) {\n    var _this = this;\n\n    var refCallback = this.callbackMap[key];\n\n    if (!refCallback) {\n      refCallback = this.callbackMap[key] = function (val) {\n        _this.handleValue(val, String(key));\n      };\n    }\n\n    return refCallback;\n  }; // TODO: check callers that don't care about order. should use getAll instead\n  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n\n\n  RefMap.prototype.collect = function (startIndex, endIndex, step) {\n    return collectFromHash(this.currentMap, startIndex, endIndex, step);\n  };\n\n  RefMap.prototype.getAll = function () {\n    return hashValuesToArray(this.currentMap);\n  };\n\n  return RefMap;\n}();\n\nfunction computeShrinkWidth(chunkEls) {\n  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n  var largestWidth = 0;\n\n  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n    var shrinkCell = shrinkCells_1[_i];\n    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n  }\n\n  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\n\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\n\nfunction getAllowYScrolling(props, sectionConfig) {\n  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n} // TODO: ONLY use `arg`. force out internal function to use same API\n\n\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n  var expandRows = arg.expandRows;\n  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)('table', {\n    role: 'presentation',\n    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),\n    style: {\n      minWidth: arg.tableMinWidth,\n      width: arg.clientWidth,\n      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height\n\n    }\n  }, arg.tableColGroupNode, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? 'thead' : 'tbody', {\n    role: 'presentation'\n  }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n  return content;\n}\n\nfunction isColPropsEqual(cols0, cols1) {\n  return isArraysEqual(cols0, cols1, isPropsEqual);\n}\n\nfunction renderMicroColGroup(cols, shrinkWidth) {\n  var colNodes = [];\n  /*\n  for ColProps with spans, it would have been great to make a single <col span=\"\">\n  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n  SOLUTION: making individual <col> elements makes Chrome behave.\n  */\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var colProps = cols_1[_i];\n    var span = colProps.span || 1;\n\n    for (var i = 0; i < span; i += 1) {\n      colNodes.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"col\", {\n        style: {\n          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n          minWidth: colProps.minWidth || ''\n        }\n      }));\n    }\n  }\n\n  return _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['colgroup', {}], colNodes));\n}\n\nfunction sanitizeShrinkWidth(shrinkWidth) {\n  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n  4 accounts for 2 2-pixel borders. TODO: better solution? */\n  return shrinkWidth == null ? 4 : shrinkWidth;\n}\n\nfunction hasShrinkWidth(cols) {\n  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n    var col = cols_2[_i];\n\n    if (col.width === 'shrink') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScrollGridClassNames(liquid, context) {\n  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];\n\n  if (liquid) {\n    classNames.push('fc-scrollgrid-liquid');\n  }\n\n  return classNames;\n}\n\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n  var classNames = ['fc-scrollgrid-section', \"fc-scrollgrid-section-\" + sectionConfig.type, sectionConfig.className // used?\n  ];\n\n  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n    classNames.push('fc-scrollgrid-section-liquid');\n  }\n\n  if (sectionConfig.isSticky) {\n    classNames.push('fc-scrollgrid-section-sticky');\n  }\n\n  return classNames;\n}\n\nfunction renderScrollShim(arg) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-scrollgrid-sticky-shim\",\n    style: {\n      width: arg.clientWidth,\n      minWidth: arg.tableMinWidth\n    }\n  });\n}\n\nfunction getStickyHeaderDates(options) {\n  var stickyHeaderDates = options.stickyHeaderDates;\n\n  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyHeaderDates;\n}\n\nfunction getStickyFooterScrollbar(options) {\n  var stickyFooterScrollbar = options.stickyFooterScrollbar;\n\n  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyFooterScrollbar;\n}\n\nvar SimpleScrollGrid = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(SimpleScrollGrid, _super);\n\n  function SimpleScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processCols = memoize(function (a) {\n      return a;\n    }, isColPropsEqual); // so we get same `cols` props every time\n    // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.renderMicroColGroup = memoize(renderMicroColGroup);\n    _this.scrollerRefs = new RefMap();\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.state = {\n      shrinkWidth: null,\n      forceYScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {}\n    }; // TODO: can do a really simple print-view. dont need to join rows\n\n    _this.handleSizing = function () {\n      _this.setState((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        shrinkWidth: _this.computeShrinkWidth()\n      }, _this.computeScrollerDims()));\n    };\n\n    return _this;\n  }\n\n  SimpleScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var sectionConfigs = props.sections || [];\n    var cols = this.processCols(props.cols);\n    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    if (props.collapsibleWidth) {\n      classNames.push('fc-scrollgrid-collapsible');\n    } // TODO: make DRY\n\n\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n      configI += 1;\n    } // firefox bug: when setting height on table and there is a thead or tfoot,\n    // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n    // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n    // if so, use a simpler dom structure, jam everything into a lone tbody.\n\n\n    var isBuggy = !getCanVGrowWithinCell();\n    var roleAttrs = {\n      role: 'rowgroup'\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)('table', {\n      role: 'grid',\n      className: classNames.join(' '),\n      style: {\n        height: props.height\n      }\n    }, Boolean(!isBuggy && headSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['tfoot', roleAttrs], footSectionNodes)), isBuggy && _vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));\n  };\n\n  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode, isHeader) {\n    if ('outerContent' in sectionConfig) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n      key: sectionConfig.key,\n      role: \"presentation\",\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n  };\n\n  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n    if ('outerContent' in chunkConfig) {\n      return chunkConfig.outerContent;\n    }\n\n    var props = this.props;\n    var _a = this.state,\n        forceYScrollbars = _a.forceYScrollbars,\n        scrollerClientWidths = _a.scrollerClientWidths,\n        scrollerClientHeights = _a.scrollerClientHeights;\n    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n\n    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?\n    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n\n    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n    var sectionKey = sectionConfig.key;\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: '',\n      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n      expandRows: sectionConfig.expandRows,\n      syncRowHeights: false,\n      rowSyncHeights: [],\n      reportRowHeightChange: function reportRowHeightChange() {}\n    }, isHeader);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? 'th' : 'td', {\n      ref: chunkConfig.elRef,\n      role: 'presentation'\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: \"fc-scroller-harness\" + (isLiquid ? ' fc-scroller-harness-liquid' : '')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(Scroller, {\n      ref: this.scrollerRefs.createRef(sectionKey),\n      elRef: this.scrollerElRefs.createRef(sectionKey),\n      overflowY: overflowY,\n      overflowX: !props.liquid ? 'visible' : 'hidden'\n      /* natural height? */\n      ,\n      maxHeight: sectionConfig.maxHeight,\n      liquid: isLiquid,\n      liquidIsAbsolute // because its within a harness\n      : true\n    }, content)));\n  };\n\n  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var section = getSectionByKey(this.props.sections, key);\n\n    if (section) {\n      setRef(section.chunk.scrollerElRef, scrollerEl);\n    }\n  };\n\n  SimpleScrollGrid.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.componentDidUpdate = function () {\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing();\n  };\n\n  SimpleScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n  };\n\n  SimpleScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this,\n        scrollerRefs = _a.scrollerRefs,\n        scrollerElRefs = _a.scrollerElRefs;\n\n    var forceYScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionKey in scrollerRefs.currentMap) {\n      var scroller = scrollerRefs.currentMap[sectionKey];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {\n      var section = _b[_i];\n      var sectionKey = section.key;\n      var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n\n      if (scrollerEl) {\n        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n\n        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n        : 0));\n        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  return SimpleScrollGrid;\n}(BaseComponent);\n\nSimpleScrollGrid.addStateEquality({\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction getSectionByKey(sections, key) {\n  for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {\n    var section = sections_1[_i];\n\n    if (section.key === key) {\n      return section;\n    }\n  }\n\n  return null;\n}\n\nvar EventRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventRoot, _super);\n\n  function EventRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  EventRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var seg = props.seg;\n    var eventRange = seg.eventRange;\n    var ui = eventRange.ui;\n    var hookProps = {\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      view: context.viewApi,\n      timeText: props.timeText,\n      textColor: ui.textColor,\n      backgroundColor: ui.backgroundColor,\n      borderColor: ui.borderColor,\n      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n      isStart: Boolean(seg.isStart),\n      isEnd: Boolean(seg.isEnd),\n      isPast: Boolean(props.isPast),\n      isFuture: Boolean(props.isFuture),\n      isToday: Boolean(props.isToday),\n      isSelected: Boolean(props.isSelected),\n      isDragging: Boolean(props.isDragging),\n      isResizing: Boolean(props.isResizing)\n    };\n    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.eventClassNames,\n      content: options.eventContent,\n      defaultContent: props.defaultContent,\n      didMount: options.eventDidMount,\n      willUnmount: options.eventWillUnmount,\n      elRef: this.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n    });\n  };\n\n  EventRoot.prototype.componentDidMount = function () {\n    setElSeg(this.elRef.current, this.props.seg);\n  };\n  /*\n  need to re-assign seg to the element if seg changes, even if the element is the same\n  */\n\n\n  EventRoot.prototype.componentDidUpdate = function (prevProps) {\n    var seg = this.props.seg;\n\n    if (seg !== prevProps.seg) {\n      setElSeg(this.elRef.current, seg);\n    }\n  };\n\n  return EventRoot;\n}(BaseComponent); // should not be a purecomponent\n\n\nvar StandardEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(StandardEvent, _super);\n\n  function StandardEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StandardEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventRoot, {\n      seg: seg,\n      timeText: timeText,\n      disableDragging: props.disableDragging,\n      disableResizing: props.disableResizing,\n      defaultContent: props.defaultContent || renderInnerContent$1,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        className: props.extraClassNames.concat(classNames).join(' '),\n        style: {\n          borderColor: hookProps.borderColor,\n          backgroundColor: hookProps.backgroundColor\n        },\n        ref: rootElRef\n      }, getSegAnchorAttrs(seg, context)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-main\",\n        ref: innerElRef,\n        style: {\n          color: hookProps.textColor\n        }\n      }, innerContent), hookProps.isStartResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-start\"\n      }), hookProps.isEndResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-end\"\n      }));\n    });\n  };\n\n  return StandardEvent;\n}(BaseComponent);\n\nfunction renderInnerContent$1(innerProps) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-main-frame\"\n  }, innerProps.timeText && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-title-container\"\n  }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-title fc-sticky\"\n  }, innerProps.event.title || (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xA0\"))));\n}\n\nvar NowIndicatorRoot = function NowIndicatorRoot(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var options = context.options;\n    var hookProps = {\n      isAxis: props.isAxis,\n      date: context.dateEnv.toDate(props.date),\n      view: context.viewApi\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.nowIndicatorClassNames,\n      content: options.nowIndicatorContent,\n      didMount: options.nowIndicatorDidMount,\n      willUnmount: options.nowIndicatorWillUnmount\n    }, props.children);\n  });\n};\n\n_c3 = NowIndicatorRoot;\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\n\nvar DayCellContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayCellContent, _super);\n\n  function DayCellContent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayCellContent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = refineDayCellHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentHook, {\n      hookProps: hookProps,\n      content: options.dayCellContent,\n      defaultContent: props.defaultContent\n    }, props.children);\n  };\n\n  return DayCellContent;\n}(BaseComponent);\n\nfunction refineDayCellHookProps(raw) {\n  var date = raw.date,\n      dateEnv = raw.dateEnv;\n  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n    date: dateEnv.toDate(date),\n    view: raw.viewApi\n  }, dayMeta), {\n    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''\n  }), raw.extraProps);\n}\n\nvar DayCellRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayCellRoot, _super);\n\n  function DayCellRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  DayCellRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = this.refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n    : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n    var dataAttrs = hookProps.isDisabled ? {} : {\n      'data-date': formatDayString(props.date)\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.dayCellDidMount,\n      willUnmount: options.dayCellWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n    });\n  };\n\n  return DayCellRoot;\n}(BaseComponent);\n\nfunction renderFill(fillType) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-\" + fillType\n  });\n}\n\nvar BgEvent = function BgEvent(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventRoot, {\n    defaultContent: renderInnerContent,\n    seg: props.seg\n    /* uselesss i think */\n    ,\n    timeText: \"\",\n    disableDragging: true,\n    disableResizing: true,\n    isDragging: false,\n    isResizing: false,\n    isDateSelecting: false,\n    isSelected: false,\n    isPast: props.isPast,\n    isFuture: props.isFuture,\n    isToday: props.isToday\n  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      ref: rootElRef,\n      className: ['fc-bg-event'].concat(classNames).join(' '),\n      style: {\n        backgroundColor: hookProps.backgroundColor\n      }\n    }, innerContent);\n  });\n};\n\n_c4 = BgEvent;\n\nfunction renderInnerContent(props) {\n  var title = props.event.title;\n  return title && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, props.event.title);\n}\n\nvar WeekNumberRoot = function WeekNumberRoot(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var date = props.date;\n    var format = options.weekNumberFormat || props.defaultFormat;\n    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n\n    var text = dateEnv.format(date, format);\n    var hookProps = {\n      num: num,\n      text: text,\n      date: date\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.weekNumberClassNames,\n      content: options.weekNumberContent,\n      defaultContent: renderInner,\n      didMount: options.weekNumberDidMount,\n      willUnmount: options.weekNumberWillUnmount\n    }, props.children);\n  });\n};\n\n_c5 = WeekNumberRoot;\n\nfunction renderInner(innerProps) {\n  return innerProps.text;\n}\n\nvar PADDING_FROM_VIEWPORT = 10;\n\nvar Popover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      titleId: getUniqueDomId()\n    };\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMouseDown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      var target = getEventTargetViaRoot(ev);\n\n      if (!_this.rootEl.contains(target)) {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleDocumentKeyDown = function (ev) {\n      if (ev.key === 'Escape') {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var _a = this.context,\n        theme = _a.theme,\n        options = _a.options;\n\n    var _b = this,\n        props = _b.props,\n        state = _b.state;\n\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createPortal)((0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      id: props.id,\n      className: classNames.join(' '),\n      \"aria-labelledby\": state.titleId\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n      className: \"fc-popover-title\",\n      id: state.titleId\n    }, props.title), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      title: options.closeHint,\n      onClick: this.handleCloseClick\n    })), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children)), props.parentEl);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMouseDown);\n    document.addEventListener('keydown', this.handleDocumentKeyDown);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n    document.removeEventListener('keydown', this.handleDocumentKeyDown);\n  };\n\n  Popover.prototype.updateSize = function () {\n    var isRtl = this.context.isRtl;\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        alignGridTop = _a.alignGridTop;\n    var rootEl = this.rootEl;\n    var alignmentRect = computeClippedClientRect(alignmentEl);\n\n    if (alignmentRect) {\n      var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport\n\n      var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n      var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain\n\n      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n      var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n      applyStyle(rootEl, {\n        top: popoverTop - origin_1.top,\n        left: popoverLeft - origin_1.left\n      });\n    }\n  };\n\n  return Popover;\n}(BaseComponent);\n\nvar MorePopover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          useEventCenter: false\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var startDate = props.startDate,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile;\n    var title = dateEnv.format(startDate, options.dayPopoverFormat);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellRoot, {\n      date: startDate,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.handleRootEl\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(Popover, {\n        elRef: rootElRef,\n        id: props.id,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs\n        /* TODO: make these time-based when not whole-day? */\n        ,\n        parentEl: props.parentEl,\n        alignmentEl: props.alignmentEl,\n        alignGridTop: props.alignGridTop,\n        onClose: props.onClose\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellContent, {\n        date: startDate,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n          className: \"fc-more-popover-misc\",\n          ref: innerElRef\n        }, innerContent);\n      }), props.children);\n    });\n  };\n\n  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var _a = this,\n        rootEl = _a.rootEl,\n        props = _a.props;\n\n    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n      return {\n        dateProfile: props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          allDay: true,\n          range: {\n            start: props.startDate,\n            end: props.endDate\n          }\n        }, props.extraDateSpan),\n        dayEl: rootEl,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1 // important when comparing with hits from other components\n\n      };\n    }\n\n    return null;\n  };\n\n  return MorePopover;\n}(DateComponent);\n\nvar MoreLinkRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MoreLinkRoot, _super);\n\n  function MoreLinkRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.linkElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.state = {\n      isPopoverOpen: false,\n      popoverId: getUniqueDomId()\n    };\n\n    _this.handleClick = function (ev) {\n      var _a = _this,\n          props = _a.props,\n          context = _a.context;\n      var moreLinkClick = context.options.moreLinkClick;\n      var date = computeRange(props).start;\n\n      function buildPublicSeg(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new EventApi(context, def, instance),\n          start: context.dateEnv.toDate(range.start),\n          end: context.dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof moreLinkClick === 'function') {\n        moreLinkClick = moreLinkClick({\n          date: date,\n          allDay: Boolean(props.allDayDate),\n          allSegs: props.allSegs.map(buildPublicSeg),\n          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n      }\n\n      if (!moreLinkClick || moreLinkClick === 'popover') {\n        _this.setState({\n          isPopoverOpen: true\n        });\n      } else if (typeof moreLinkClick === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(date, moreLinkClick);\n      }\n    };\n\n    _this.handlePopoverClose = function () {\n      _this.setState({\n        isPopoverOpen: false\n      });\n    };\n\n    return _this;\n  }\n\n  MoreLinkRoot.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, function (context) {\n      var viewApi = context.viewApi,\n          options = context.options,\n          calendarApi = context.calendarApi;\n      var moreLinkText = options.moreLinkText;\n      var moreCnt = props.moreCnt;\n      var range = computeRange(props);\n      var text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals\n      ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText;\n      var title = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);\n      var hookProps = {\n        num: moreCnt,\n        shortText: \"+\" + moreCnt,\n        text: text,\n        view: viewApi\n      };\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Boolean(props.moreCnt) && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderHook, {\n        elRef: _this.linkElRef,\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: props.defaultContent || renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : '');\n      }), state.isPopoverOpen && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_0__.createElement)(MorePopover, {\n        id: state.popoverId,\n        startDate: range.start,\n        endDate: range.end,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraDateSpan: props.extraDateSpan,\n        parentEl: _this.parentEl,\n        alignmentEl: props.alignmentElRef.current,\n        alignGridTop: props.alignGridTop,\n        onClose: _this.handlePopoverClose\n      }, props.popoverContent()));\n    });\n  };\n\n  MoreLinkRoot.prototype.componentDidMount = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.componentDidUpdate = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.updateParentEl = function () {\n    if (this.linkElRef.current) {\n      this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');\n    }\n  };\n\n  return MoreLinkRoot;\n}(BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nfunction computeRange(props) {\n  if (props.allDayDate) {\n    return {\n      start: props.allDayDate,\n      end: addDays(props.allDayDate, 1)\n    };\n  }\n\n  var hiddenSegs = props.hiddenSegs;\n  return {\n    start: computeEarliestSegStart(hiddenSegs),\n    end: computeLatestSegEnd(hiddenSegs)\n  };\n}\n\nfunction computeEarliestSegStart(segs) {\n  return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\n\nfunction pickEarliestStart(seg0, seg1) {\n  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\n\nfunction computeLatestSegEnd(segs) {\n  return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\n\nfunction pickLatestEnd(seg0, seg1) {\n  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n} // exports\n// --------------------------------------------------------------------------------------------------\n\n\nvar version = '5.10.1'; // important to type it, so .d.ts has generic string\n\n\n\nvar _c2, _c3, _c4, _c5;\n\n$RefreshReg$(_c2, \"ContentHook\");\n$RefreshReg$(_c3, \"NowIndicatorRoot\");\n$RefreshReg$(_c4, \"BgEvent\");\n$RefreshReg$(_c5, \"WeekNumberRoot\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtDQUdBO0FBQ0E7O0FBQ0EsSUFBSVMsY0FBYyxHQUFrQixZQUFZO0FBQzVDLFdBQVNBLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDQyxtQkFBakMsRUFBc0Q7QUFDbEQsU0FBS0QsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkJBLG1CQUEzQjtBQUNIOztBQUNERixFQUFBQSxjQUFjLENBQUNHLFNBQWYsQ0FBeUJDLE1BQXpCLEdBQWtDLFlBQVk7QUFDMUMsU0FBS0gsT0FBTCxDQUFhSSxRQUFiLENBQXNCO0FBQ2xCQyxNQUFBQSxJQUFJLEVBQUUscUJBRFk7QUFFbEJDLE1BQUFBLFFBQVEsRUFBRSxLQUFLTCxtQkFBTCxDQUF5Qks7QUFGakIsS0FBdEI7QUFJSCxHQUxEOztBQU1BUCxFQUFBQSxjQUFjLENBQUNHLFNBQWYsQ0FBeUJLLE9BQXpCLEdBQW1DLFlBQVk7QUFDM0MsU0FBS1AsT0FBTCxDQUFhSSxRQUFiLENBQXNCO0FBQ2xCQyxNQUFBQSxJQUFJLEVBQUUscUJBRFk7QUFFbEJHLE1BQUFBLFNBQVMsRUFBRSxDQUFDLEtBQUtQLG1CQUFMLENBQXlCSyxRQUExQixDQUZPO0FBR2xCRyxNQUFBQSxTQUFTLEVBQUU7QUFITyxLQUF0QjtBQUtILEdBTkQ7O0FBT0FDLEVB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Qy9CLFNBQU9ELElBQUksQ0FBQy82QyxVQUFMLENBQWdCaG1CLEtBQWhCLENBQXNCdUUsR0FBdEIsR0FBNEJ5OEQsSUFBSSxDQUFDaDdDLFVBQUwsQ0FBZ0JobUIsS0FBaEIsQ0FBc0J1RSxHQUFsRCxHQUF3RHc4RCxJQUF4RCxHQUErREMsSUFBdEU7QUFDSCxFQUVEO0FBQ0E7OztBQUNBLElBQUlFLE9BQU8sR0FBRyxRQUFkLEVBQXdCOztBQUV4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcz81NWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjEwLjFcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIxIEFkYW0gU2hhd1xuKi9cbmltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBDb21wb25lbnQsIGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGNyZWF0ZVBvcnRhbCB9IGZyb20gJy4vdmRvbS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Zkb20uanMnO1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIEV2ZW50U291cmNlQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlQXBpKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICB9XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxuICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRXZlbnRTb3VyY2VBcGk7XG59KCkpO1xuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxufVxuLy8gUXVlcnlpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgLy8gcmVhbGx5IGJhZCBmYWxsYmFjayBmb3IgSUVcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSk7XG4gICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG1ldGhvZCA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBtZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4vLyBUT0RPOiBhY2NlcHQgdGhlIGRvY3VtZW50XG5mdW5jdGlvbiBmaW5kRWxlbWVudHMoY29udGFpbmVyLCBzZWxlY3Rvcikge1xuICAgIHZhciBjb250YWluZXJzID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbY29udGFpbmVyXSA6IGNvbnRhaW5lcjtcbiAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRhaW5lcnNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKG1hdGNoZXNbal0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gb25seSBxdWVyaWVzIGRpcmVjdCBjaGlsZCBlbGVtZW50cyAvLyBUT0RPOiByZW5hbWUgdG8gZmluZERpcmVjdENoaWxkcmVuIVxuZnVuY3Rpb24gZmluZERpcmVjdENoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnQ7XG4gICAgdmFyIGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuOyAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsO1xuICAgIH1cbn1cbi8vIEV2ZW50IEhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpZiBpbnRlcmNlcHRpbmcgYnViYmxlZCBldmVudHMgYXQgdGhlIGRvY3VtZW50L3dpbmRvdy9ib2R5IGxldmVsLFxuLy8gYW5kIHdhbnQgdG8gc2VlIG9yaWdpbmF0aW5nIGVsZW1lbnQgKHRoZSAndGFyZ2V0JyksIHVzZSB0aGlzIHV0aWwgaW5zdGVhZFxuLy8gb2YgYGV2LnRhcmdldGAgYmVjYXVzZSBpdCBnb2VzIHdpdGhpbiB3ZWItY29tcG9uZW50IGJvdW5kYXJpZXMuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBldi5jb21wb3NlZFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGV2KVswXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXYudGFyZ2V0O1xufVxuLy8gU2hhZG93IERPTSBjb25zdWRlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0RWxSb290KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xufVxuLy8gVW5pcXVlIElEIGZvciBET00gYXR0cmlidXRlXG52YXIgZ3VpZCQxID0gMDtcbmZ1bmN0aW9uIGdldFVuaXF1ZURvbUlkKCkge1xuICAgIGd1aWQkMSArPSAxO1xuICAgIHJldHVybiAnZmMtZG9tLScgKyBndWlkJDE7XG59XG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xufVxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG1hdGNoZWRDaGlsZCA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgc2VsZWN0b3IpO1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHZhciBhdHRhY2hlZEhhbmRsZXIgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb250YWluZXIsIHNlbGVjdG9yLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSkge1xuICAgIHZhciBjdXJyZW50TWF0Y2hlZENoaWxkO1xuICAgIHJldHVybiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHNlbGVjdG9yLCBmdW5jdGlvbiAobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkICE9PSBjdXJyZW50TWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbWF0Y2hlZENoaWxkO1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgdmFyIHJlYWxPbk1vdXNlTGVhdmVfMSA9IGZ1bmN0aW9uIChtb3VzZUxlYXZlRXYpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiBfX2Fzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxudmFyIGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy11bnNlbGVjdGFibGUnKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIHZhciBzcGVjcyA9IFtdO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIHZhciBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgYXJnLCBpbmRleCkgeyByZXR1cm4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKTsgfSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbi8qIE51bWJlciBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XG59XG4vKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcbiAgICB2YXIgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcbiAgICB2YXIgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcbiAgICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XG4gICAgfVxuICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXG4gICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xufVxuXG52YXIgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgdmFyIG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgdmFyIG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICB2YXIgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIHZhciB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgdmFyIG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgdmFyIGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIHZhciBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICB2YXIgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgdmFyIGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZDogZGVmSWQsXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICAgIH07XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XG4gICAgdmFyIGRlc3QgPSB7fTtcbiAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHByb3BPYmpzW2ldW25hbWVfMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVfMV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXzFdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAodmFyIGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lXzIgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV8yXSA9IHByb3BzW25hbWVfMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgdmFyIG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFfMVtfaV07XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGJ1aWxkSGFzaEZyb21BcnJheShhLCBmdW5jKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHR1cGxlID0gZnVuYyhhW2ldLCBpKTtcbiAgICAgICAgaGFzaFt0dXBsZVswXV0gPSB0dXBsZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGlmIChvYmowID09PSBvYmoxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzKSB7XG4gICAgaWYgKGVxdWFsaXR5RnVuY3MgPT09IHZvaWQgMCkgeyBlcXVhbGl0eUZ1bmNzID0ge307IH1cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yICh2YXIga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cbiAgICB2YXIgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICB2YXIgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXk7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3MsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZjsgfSk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBkZWYucmVjdXJyaW5nRGVmLmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdGFydHNfMSA9IHN0YXJ0czsgX2kgPCBzdGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICB2YXIgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIHZhciBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG52YXIgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xudmFyIFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoKF9hID0ge30sIF9hW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddID0gaW5wdXQsIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIHZhciBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgdmFyIHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICB2YXIgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXG5mdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lKSB7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cbiAgICB2YXIgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xuICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XG4vLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcbi8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXG5mdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XG59XG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvKSB7XG4gICAgaWYgKGRvSXNvID09PSB2b2lkIDApIHsgZG9Jc28gPSBmYWxzZTsgfVxuICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW5zLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiR01UXCIgKyBzaWduICsgaG91cnMgKyAobWlucyA/IFwiOlwiICsgcGFkU3RhcnQobWlucywgMikgOiAnJyk7XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGEwLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgY3VycmVudEFyZ3M7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBcmdzKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJncywgbmV3QXJncykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPYmpBcmcod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmc7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmcpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKF90aGlzLCBuZXdBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1Byb3BzRXF1YWwoY3VycmVudEFyZywgbmV3QXJnKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmNhbGwoX3RoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnU2V0cyA9IFtdO1xuICAgIHZhciBjdXJyZW50UmVzdWx0cyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnU2V0cykge1xuICAgICAgICB2YXIgY3VycmVudExlbiA9IGN1cnJlbnRBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdTZXRzW2ldLCBuZXdBcmdTZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2UoLy8gdXNlZD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIHZhciBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnSGFzaCkge1xuICAgICAgICB2YXIgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnSGFzaFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdIYXNoW2tleV0sIG5ld0FyZ0hhc2hba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzSGFzaFtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoO1xuICAgICAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2g7XG4gICAgICAgIHJldHVybiBuZXdSZXNIYXNoO1xuICAgIH07XG59XG5cbnZhciBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbnZhciBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyA9IHtcbiAgICB0aW1lWm9uZU5hbWU6IDcsXG4gICAgZXJhOiA2LFxuICAgIHllYXI6IDUsXG4gICAgbW9udGg6IDQsXG4gICAgZGF5OiAyLFxuICAgIHdlZWtkYXk6IDIsXG4gICAgaG91cjogMSxcbiAgICBtaW51dGU6IDEsXG4gICAgc2Vjb25kOiAxLFxufTtcbnZhciBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG52YXIgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG52YXIgTVVMVElfU1BBQ0VfUkUgPSAvXFxzKy9nO1xudmFyIExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG52YXIgVVRDX1JFID0gL1VUQ3xHTVQvO1xudmFyIE5hdGl2ZUZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXRpdmVGb3JtYXR0ZXIoZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHN0YW5kYXJkRGF0ZVByb3BzID0ge307XG4gICAgICAgIHZhciBleHRlbmRlZFNldHRpbmdzID0ge307XG4gICAgICAgIHZhciBzZXZlcml0eSA9IDA7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWVfMSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXzFdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXzFdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVfMV0sIHNldmVyaXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFuZGFyZERhdGVQcm9wcyA9IHN0YW5kYXJkRGF0ZVByb3BzO1xuICAgICAgICB0aGlzLmV4dGVuZGVkU2V0dGluZ3MgPSBleHRlbmRlZFNldHRpbmdzO1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyA9IG1lbW9pemUoYnVpbGRGb3JtYXR0aW5nRnVuYyk7XG4gICAgfVxuICAgIE5hdGl2ZUZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH07XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YW5kYXJkRGF0ZVByb3BzID0gX2Euc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgPSBfYS5leHRlbmRlZFNldHRpbmdzO1xuICAgICAgICB2YXIgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIHZhciBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgdmFyIHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIHZhciBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIHZhciBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICB2YXIgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH07XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5nZXRMYXJnZXN0VW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmF0aXZlRm9ybWF0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhbmRhcmREYXRlUHJvcENudCA9IE9iamVjdC5rZXlzKHN0YW5kYXJkRGF0ZVByb3BzKS5sZW5ndGg7XG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDEgJiYgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpKTsgfTtcbiAgICB9XG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDAgJiYgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGZvcm1hdFdlZWtOdW1iZXIoY29udGV4dC5jb21wdXRlV2Vla051bWJlcihkYXRlLm1hcmtlciksIGNvbnRleHQud2Vla1RleHQsIGNvbnRleHQud2Vla1RleHRMb25nLCBjb250ZXh0LmxvY2FsZSwgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKSk7IH07XG4gICAgfVxuICAgIHJldHVybiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICBzdGFuZGFyZERhdGVQcm9wcyA9IF9fYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcbiAgICBleHRlbmRlZFNldHRpbmdzID0gX19hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgdmFyIG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgdmFyIHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICB2YXIgemVyb1Byb3BzID0gX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICAgICAgZGVsZXRlIHplcm9Qcm9wcy5taW51dGU7IC8vIHNlY29uZHMgYW5kIG1zIHdlcmUgYWxyZWFkeSBjb25zaWRlcmVkIGluIHNhbml0aXplU2V0dGluZ3NcbiAgICAgICAgemVyb0Zvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCB6ZXJvUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IGRhdGUubWFya2VyO1xuICAgICAgICB2YXIgZm9ybWF0O1xuICAgICAgICBpZiAoemVyb0Zvcm1hdCAmJiAhbWFya2VyLmdldFVUQ01pbnV0ZXMoKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gemVyb0Zvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IG5vcm1hbEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGZvcm1hdC5mb3JtYXQobWFya2VyKTtcbiAgICAgICAgcmV0dXJuIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncykge1xuICAgIC8vIGRlYWwgd2l0aCBhIGJyb3dzZXIgaW5jb25zaXN0ZW5jeSB3aGVyZSBmb3JtYXR0aW5nIHRoZSB0aW1lem9uZVxuICAgIC8vIHJlcXVpcmVzIHRoYXQgdGhlIGhvdXIvbWludXRlIGJlIHByZXNlbnQuXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSkge1xuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLmhvdXIpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLmhvdXIgPSAnMi1kaWdpdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5taW51dGUpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmx5IHN1cHBvcnQgc2hvcnQgdGltZXpvbmUgbmFtZXNcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnbG9uZycpIHtcbiAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID0gJ3Nob3J0JztcbiAgICB9XG4gICAgLy8gaWYgcmVxdWVzdGluZyB0byBkaXNwbGF5IHNlY29uZHMsIE1VU1QgZGlzcGxheSBtaW51dGVzXG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUgJiYgKHN0YW5kYXJkRGF0ZVByb3BzLnNlY29uZCB8fCBzdGFuZGFyZERhdGVQcm9wcy5taWxsaXNlY29uZCkpIHtcbiAgICAgICAgZGVsZXRlIGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGU7XG4gICAgfVxufVxuZnVuY3Rpb24gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICBzID0gcy5yZXBsYWNlKExUUl9SRSwgJycpOyAvLyByZW1vdmUgbGVmdC10by1yaWdodCBjb250cm9sIGNoYXJzLiBkbyBmaXJzdC4gZ29vZCBmb3Igb3RoZXIgcmVnZXhlc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcyA9IGluamVjdFR6b1N0cihzLCAoY29udGV4dC50aW1lWm9uZSA9PT0gJ1VUQycgfHwgZGF0ZS50aW1lWm9uZU9mZnNldCA9PSBudWxsKSA/XG4gICAgICAgICAgICAnVVRDJyA6IC8vIGltcG9ydGFudCB0byBub3JtYWxpemUgZm9yIElFLCB3aGljaCBkb2VzIFwiR01UXCJcbiAgICAgICAgICAgIGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdENvbW1hcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKENPTU1BX1JFLCAnJykudHJpbSgpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCc6MDAnLCAnJyk7IC8vIHplcm9Gb3JtYXQgZG9lc24ndCBhbHdheXMgYWNoaWV2ZSB0aGlzXG4gICAgfVxuICAgIC8vIF4gZG8gYW55dGhpbmcgdGhhdCBtaWdodCBjcmVhdGUgYWRqYWNlbnQgc3BhY2VzIGJlZm9yZSB0aGlzIHBvaW50LFxuICAgIC8vIGJlY2F1c2UgTUVSSURJRU1fUkUgbGlrZXMgdG8gZWF0IHVwIGxvYWRpbmcgc3BhY2VzXG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICduYXJyb3cnKSB7IC8vIGEvcFxuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTAsIG0xKSB7IHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ3Nob3J0JykgeyAvLyBhbS9wbVxuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTAsIG0xKSB7IHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpICsgXCJtXCI7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCkgeyByZXR1cm4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKTsgfSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIHZhciByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gXCIgXCIgKyB0em9TdHI7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcGFydHMucHVzaCgnICcpO1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xuICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cbiAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG4vLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXG4vLyAwID0gZXhhY3RseSB0aGUgc2FtZVxuLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4vLyBhbmQgYmlnZ2VyXG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcbiAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xuICAgIHZhciBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKG5hbWVfMiBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXzJdIDw9IGJpZ2dlc3RVbml0KSB7XG4gICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXzJdID0gb3B0aW9uc1tuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICB2YXIgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICB2YXIgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIHZhciBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICB2YXIgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICB2YXIgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICB2YXIgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIHZhciBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbnZhciBDbWRGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ21kRm9ybWF0dGVyKGNtZFN0cikge1xuICAgICAgICB0aGlzLmNtZFN0ciA9IGNtZFN0cjtcbiAgICB9XG4gICAgQ21kRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIENtZEZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBDbWRGb3JtYXR0ZXI7XG59KCkpO1xuXG52YXIgRnVuY0Zvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5jRm9ybWF0dGVyKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgRnVuY0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICBGdW5jRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmNGb3JtYXR0ZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgbmF2TGlua0RheUNsaWNrOiBpZGVudGl0eSxcbiAgICBuYXZMaW5rV2Vla0NsaWNrOiBpZGVudGl0eSxcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgYm9vdHN0cmFwRm9udEF3ZXNvbWU6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkljb25zOiBpZGVudGl0eSxcbiAgICBjdXN0b21CdXR0b25zOiBpZGVudGl0eSxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgbmV4dERheVRocmVzaG9sZDogY3JlYXRlRHVyYXRpb24sXG4gICAgc2Nyb2xsVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgc2Nyb2xsVGltZVJlc2V0OiBCb29sZWFuLFxuICAgIHNsb3RNaW5UaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbG90TWF4VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIHNsb3REdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc25hcER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBoZWFkZXJUb29sYmFyOiBpZGVudGl0eSxcbiAgICBmb290ZXJUb29sYmFyOiBpZGVudGl0eSxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBCb29sZWFuLFxuICAgIGRheUhlYWRlcnM6IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZGF5SGVhZGVyQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZGF5Q2VsbENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBpbml0aWFsVmlldzogU3RyaW5nLFxuICAgIGFzcGVjdFJhdGlvOiBOdW1iZXIsXG4gICAgd2Vla2VuZHM6IEJvb2xlYW4sXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICB2aWV3Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgdmlld0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICB2aWV3V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvcjogQm9vbGVhbixcbiAgICBub3dJbmRpY2F0b3JDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JDb250ZW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IEJvb2xlYW4sXG4gICAgbGF6eUZldGNoaW5nOiBCb29sZWFuLFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZTogU3RyaW5nLFxuICAgIGxvY2FsZXM6IGlkZW50aXR5LFxuICAgIGxvY2FsZTogaWRlbnRpdHksXG4gICAgdGhlbWVTeXN0ZW06IFN0cmluZyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IE51bWJlcixcbiAgICBkcmFnU2Nyb2xsOiBCb29sZWFuLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RBdXRvOiBCb29sZWFuLFxuICAgIGRyb3BBY2NlcHQ6IGlkZW50aXR5LFxuICAgIGV2ZW50T3JkZXI6IHBhcnNlRmllbGRTcGVjcyxcbiAgICBldmVudE9yZGVyU3RyaWN0OiBCb29sZWFuLFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogQm9vbGVhbixcbiAgICB3aW5kb3dSZXNpemVEZWxheTogTnVtYmVyLFxuICAgIGxvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IE51bWJlcixcbiAgICBleHBhbmRSb3dzOiBCb29sZWFuLFxuICAgIGhlaWdodDogaWRlbnRpdHksXG4gICAgY29udGVudEhlaWdodDogaWRlbnRpdHksXG4gICAgZGlyZWN0aW9uOiBTdHJpbmcsXG4gICAgd2Vla051bWJlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBCb29sZWFuLFxuICAgIGRpc3BsYXlFdmVudFRpbWU6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50RW5kOiBCb29sZWFuLFxuICAgIHdlZWtUZXh0OiBTdHJpbmcsXG4gICAgd2Vla1RleHRMb25nOiBTdHJpbmcsXG4gICAgcHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZzogQm9vbGVhbixcbiAgICBidXNpbmVzc0hvdXJzOiBpZGVudGl0eSxcbiAgICBpbml0aWFsRGF0ZTogaWRlbnRpdHksXG4gICAgbm93OiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIHN0aWNreUhlYWRlckRhdGVzOiBpZGVudGl0eSxcbiAgICBzdGlja3lGb290ZXJTY3JvbGxiYXI6IGlkZW50aXR5LFxuICAgIHZpZXdIZWlnaHQ6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgZXZlbnRTb3VyY2VGYWlsdXJlOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZVN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlzcGxheTogU3RyaW5nLFxuICAgIGV2ZW50U3RhcnRFZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudER1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZXZlbnRPdmVybGFwOiBpZGVudGl0eSxcbiAgICBldmVudENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWxsb3c6IGlkZW50aXR5LFxuICAgIGV2ZW50QmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRCb3JkZXJDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50VGV4dENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZXZlbnRDb250ZW50OiBpZGVudGl0eSxcbiAgICBldmVudERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBldmVudFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RDb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RPdmVybGFwOiBpZGVudGl0eSxcbiAgICBzZWxlY3RBbGxvdzogaWRlbnRpdHksXG4gICAgZHJvcHBhYmxlOiBCb29sZWFuLFxuICAgIHVuc2VsZWN0Q2FuY2VsOiBTdHJpbmcsXG4gICAgc2xvdExhYmVsRm9ybWF0OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZUNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ29udGVudDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsQ29udGVudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlNYXhFdmVudHM6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50Um93czogaWRlbnRpdHksXG4gICAgZGF5TWluV2lkdGg6IE51bWJlcixcbiAgICBzbG90TGFiZWxJbnRlcnZhbDogY3JlYXRlRHVyYXRpb24sXG4gICAgYWxsRGF5VGV4dDogU3RyaW5nLFxuICAgIGFsbERheUNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGFsbERheUNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGFsbERheURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBhbGxEYXlXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2xvdE1pbldpZHRoOiBOdW1iZXIsXG4gICAgbmF2TGlua3M6IEJvb2xlYW4sXG4gICAgZXZlbnRUaW1lRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgcmVyZW5kZXJEZWxheTogTnVtYmVyLFxuICAgIG1vcmVMaW5rVGV4dDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIHNlbGVjdGFibGU6IEJvb2xlYW4sXG4gICAgc2VsZWN0TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgc2VsZWN0TWlycm9yOiBCb29sZWFuLFxuICAgIGV2ZW50TWF4U3RhY2s6IE51bWJlcixcbiAgICBldmVudE1pbkhlaWdodDogTnVtYmVyLFxuICAgIGV2ZW50TWluV2lkdGg6IE51bWJlcixcbiAgICBldmVudFNob3J0SGVpZ2h0OiBOdW1iZXIsXG4gICAgc2xvdEV2ZW50T3ZlcmxhcDogQm9vbGVhbixcbiAgICBwbHVnaW5zOiBpZGVudGl0eSxcbiAgICBmaXJzdERheTogTnVtYmVyLFxuICAgIGRheUNvdW50OiBOdW1iZXIsXG4gICAgZGF0ZUFsaWdubWVudDogU3RyaW5nLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhpZGRlbkRheXM6IGlkZW50aXR5LFxuICAgIG1vbnRoTW9kZTogQm9vbGVhbixcbiAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcbiAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxuICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcbiAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxuICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcbiAgICB2aWV3SGludDogaWRlbnRpdHksXG4gICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIGNsb3NlSGludDogU3RyaW5nLFxuICAgIHRpbWVIaW50OiBTdHJpbmcsXG4gICAgZXZlbnRIaW50OiBTdHJpbmcsXG4gICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxufTtcbi8vIGRvIE5PVCBnaXZlIGEgdHlwZSBoZXJlLiBuZWVkIGB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNgIHRvIGdpdmUgcmVhbCByZXN1bHRzLlxuLy8gcmF3IHZhbHVlcy5cbnZhciBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG59O1xuLy8gY2FsZW5kYXIgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBidXR0b25UZXh0OiBpZGVudGl0eSxcbiAgICBidXR0b25IaW50czogaWRlbnRpdHksXG4gICAgdmlld3M6IGlkZW50aXR5LFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxFdmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRTb3VyY2VzOiBpZGVudGl0eSxcbn07XG52YXIgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMgPSB7XG4gICAgaGVhZGVyVG9vbGJhcjogaXNCb29sQ29tcGxleEVxdWFsLFxuICAgIGZvb3RlclRvb2xiYXI6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc0Jvb2xDb21wbGV4RXF1YWwsXG4gICAgYnV0dG9uSGludHM6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgICBidXR0b25JY29uczogaXNCb29sQ29tcGxleEVxdWFsLFxufTtcbmZ1bmN0aW9uIGlzQm9vbENvbXBsZXhFcXVhbChhLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiKSB7IC8vIGJvdGggbm9uLW51bGwgb2JqZWN0c1xuICAgICAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVklFV19PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNvbXBvbmVudDogaWRlbnRpdHksXG4gICAgYnV0dG9uVGV4dDogU3RyaW5nLFxuICAgIGJ1dHRvblRleHRLZXk6IFN0cmluZyxcbiAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSxcbiAgICB1c2VzTWluTWF4VGltZTogQm9vbGVhbixcbiAgICBjbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBjb250ZW50OiBpZGVudGl0eSxcbiAgICBkaWRNb3VudDogaWRlbnRpdHksXG4gICAgd2lsbFVubW91bnQ6IGlkZW50aXR5LFxufTtcbi8vIHV0aWwgZnVuY3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpO1xufVxuZnVuY3Rpb24gcmVmaW5lUHJvcHMoaW5wdXQsIHJlZmluZXJzKSB7XG4gICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiByZWZpbmVycykge1xuICAgICAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XG4gICAgICAgICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmaW5lZDogcmVmaW5lZCwgZXh0cmE6IGV4dHJhIH07XG59XG5mdW5jdGlvbiBpZGVudGl0eShyYXcpIHtcbiAgICByZXR1cm4gcmF3O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIHZhciBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgdmFyIGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50ID0gcmF3RXZlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMpO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKSB7XG4gICAgaWYgKGV2ZW50U3RvcmUgPT09IHZvaWQgMCkgeyBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IH1cbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWZfMSA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICB2YXIgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAobG9va0RlZikgeyByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZl8xLCBsb29rRGVmKTsgfSk7XG4gICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWZfMS5kZWZJZF0gPSBkZWZfMTtcbiAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xufVxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH07XG59XG5mdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogX19hc3NpZ24oX19hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxuICAgICAgICBpbnN0YW5jZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICB2YXIgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICB2YXIgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICk7IH0pO1xuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXIsIHN1Yikge1xuICAgIHZhciBkZWZzID0gbWFzdGVyLmRlZnMsIGluc3RhbmNlcyA9IG1hc3Rlci5pbnN0YW5jZXM7XG4gICAgdmFyIGZpbHRlcmVkRGVmcyA9IHt9O1xuICAgIHZhciBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xuICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0LCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhpbnB1dCwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhbaW5wdXRdLCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lcyhyYXcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmF3LnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcbi8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xuLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXG52YXIgRVZFTlRfVUlfUkVGSU5FUlMgPSB7XG4gICAgZGlzcGxheTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBjb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBvdmVybGFwOiBpZGVudGl0eSxcbiAgICBhbGxvdzogaWRlbnRpdHksXG4gICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICB0ZXh0Q29sb3I6IFN0cmluZyxcbn07XG52YXIgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIHZhciBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbnZhciBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuLFxufTtcbnZhciBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG52YXIgRVZFTlRfUkVGSU5FUlMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzKSB7XG4gICAgaWYgKHJlZmluZXJzID09PSB2b2lkIDApIHsgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7IH1cbiAgICB2YXIgX2EgPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgdmFyIGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dC5kYXRlRW52LCBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XG4gICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXG4gICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxuICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIHZhciBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpIHtcbiAgICBpZiAocmVmaW5lcnMgPT09IHZvaWQgMCkgeyByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KTsgfVxuICAgIHJldHVybiByZWZpbmVQcm9wcyhyYXcsIHJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzKTtcbn1cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZnVuY3Rpb24gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcbiAgICAgICAgZGVmSWQ6IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgaGFzRW5kOiBoYXNFbmQsXG4gICAgICAgIGludGVyYWN0aXZlOiByZWZpbmVkLmludGVyYWN0aXZlLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogX19hc3NpZ24oX19hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXJBZGRlciA9IF9hW19pXTtcbiAgICAgICAgX19hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50QXBpIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gICAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgdmFyIGFsbERheSA9IHJlZmluZWQuYWxsRGF5O1xuICAgIHZhciBzdGFydE1ldGE7XG4gICAgdmFyIHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICB2YXIgaGFzRW5kID0gZmFsc2U7XG4gICAgdmFyIGVuZE1ldGE7XG4gICAgdmFyIGVuZE1hcmtlciA9IG51bGw7XG4gICAgdmFyIHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlO1xuICAgIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE1ldGEubWFya2VyO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZWZpbmVkLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZCk7XG4gICAgfVxuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoZW5kTWV0YSkge1xuICAgICAgICBlbmRNYXJrZXIgPSBlbmRNZXRhLm1hcmtlcjtcbiAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gc3RhcnRPZkRheShlbmRNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE1hcmtlcikge1xuICAgICAgICBoYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgaGFzRW5kID0gY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgZW5kTWFya2VyID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICBoYXNFbmQ6IGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZSkge1xuICAgIHZhciBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMTtcbiAgICB2YXIgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgaWYgKG5leHREYXlUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBuZXh0RGF5VGhyZXNob2xkID0gY3JlYXRlRHVyYXRpb24oMCk7IH1cbiAgICB2YXIgc3RhcnREYXkgPSBudWxsO1xuICAgIHZhciBlbmREYXkgPSBudWxsO1xuICAgIGlmICh0aW1lZFJhbmdlLmVuZCkge1xuICAgICAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKTtcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZWRSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG59XG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMTtcbn1cbmZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGxhcmdlVW5pdCkge1xuICAgIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgdmFyIGludmVydGVkUmFuZ2VzID0gW107XG4gICAgdmFyIHN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0ZVJhbmdlO1xuICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0OiBzdGFydCwgZW5kOiBjb25zdHJhaW50UmFuZ2UuZW5kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXM7XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIHJhbmdlMC5zdGFydC52YWx1ZU9mKCkgLSByYW5nZTEuc3RhcnQudmFsdWVPZigpOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuZnVuY3Rpb24gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2UwLnN0YXJ0LCBlbmQgPSByYW5nZTAuZW5kO1xuICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XG4gICAgaWYgKHJhbmdlMS5zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UxLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShNYXRoLm1heChzdGFydC52YWx1ZU9mKCksIHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2UxLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlMS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShNYXRoLm1pbihlbmQudmFsdWVPZigpLCByYW5nZTEuZW5kLnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JhbmdlO1xufVxuZnVuY3Rpb24gcmFuZ2VzRXF1YWwocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuc3RhcnQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuc3RhcnQudmFsdWVPZigpKSAmJlxuICAgICAgICAocmFuZ2UwLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuZW5kLnZhbHVlT2YoKSkgPT09IChyYW5nZTEuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5lbmQudmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLmVuZCA9PT0gbnVsbCB8fCByYW5nZTEuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UwLmVuZCA+IHJhbmdlMS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlMC5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTEuZW5kID09PSBudWxsIHx8IHJhbmdlMC5zdGFydCA8IHJhbmdlMS5lbmQpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpIHtcbiAgICByZXR1cm4gKG91dGVyUmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSkgJiZcbiAgICAgICAgKG91dGVyUmFuZ2UuZW5kID09PSBudWxsIHx8IChpbm5lclJhbmdlLmVuZCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZCA8PSBvdXRlclJhbmdlLmVuZCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc01hcmtlcihyYW5nZSwgZGF0ZSkge1xuICAgIHJldHVybiAocmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlLmVuZCA9PT0gbnVsbCB8fCBkYXRlIDwgcmFuZ2UuZW5kKTtcbn1cbi8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cbi8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuZnVuY3Rpb24gY29uc3RyYWluTWFya2VyVG9SYW5nZShkYXRlLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsICYmIGRhdGUgPCByYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCAmJiBkYXRlID49IHJhbmdlLmVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocmFuZ2UuZW5kLnZhbHVlT2YoKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICB2YXIgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgdmFyIGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICB2YXIgZGVmQnlHcm91cElkID0ge307XG4gICAgdmFyIGJnUmFuZ2VzID0gW107XG4gICAgdmFyIGZnUmFuZ2VzID0gW107XG4gICAgdmFyIGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBpbnZlcnNlQmdCeUdyb3VwSWQpIHsgLy8gQlkgR1JPVVBcbiAgICAgICAgdmFyIHJhbmdlcyA9IGludmVyc2VCZ0J5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnZlcnRlZFJhbmdlc18xID0gaW52ZXJ0ZWRSYW5nZXM7IF9pIDwgaW52ZXJ0ZWRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgdmFyIHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBpbnZlcnRlZFJhbmdlc18yID0gaW52ZXJ0ZWRSYW5nZXM7IF9hIDwgaW52ZXJ0ZWRSYW5nZXNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMltfYV07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xufVxuZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xufVxuZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgIGVsLmZjU2VnID0gc2VnO1xufVxuZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICByZXR1cm4gZWwuZmNTZWcgfHxcbiAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICAgICAgbnVsbDtcbn1cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcyk7IH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xuICAgIHZhciB1aXMgPSBbXTtcbiAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XG4gICAgfVxuICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcbiAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xuICAgIHZhciBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcbiAgICBvYmpzLnNvcnQoZnVuY3Rpb24gKG9iajAsIG9iajEpIHsgcmV0dXJuIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKTsgfSk7XG4gICAgcmV0dXJuIG9ianMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLl9zZWc7IH0pO1xufVxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIHZhciBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIHZhciByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIHBsdWdpbkhvb2tzID0gY29udGV4dC5wbHVnaW5Ib29rcztcbiAgICB2YXIgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgdWkgPSBfYS51aTtcbiAgICB2YXIgdmFsID0gdWkuc3RhcnRFZGl0YWJsZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHRyYW5zZm9ybWVyc18xID0gdHJhbnNmb3JtZXJzOyBfaSA8IHRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcnNfMVtfaV07XG4gICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XG59XG5mdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcbnN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRpc3BsYXlFdmVudFRpbWUgPSBvcHRpb25zLmRpc3BsYXlFdmVudFRpbWUsIGRpc3BsYXlFdmVudEVuZCA9IG9wdGlvbnMuZGlzcGxheUV2ZW50RW5kO1xuICAgIHZhciBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICB2YXIgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIHZhciBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIHZhciBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICB2YXIgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICB2YXIgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgdmFyIHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPCAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBldmVudFJhbmdlLmRlZi5kZWZJZCArIFwiOlwiICsgZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpO1xuICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICB2YXIgdXJsID0gZGVmLnVybDtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlciwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZXZlbnRJbnRlcmFjdGl2ZSA9IG9wdGlvbnMuZXZlbnRJbnRlcmFjdGl2ZTtcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbnZhciBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIHZhciBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICB2YXIgcmFuZ2UgPSBzcGFuLnJhbmdlO1xuICAgIGlmICghcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xufVxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmZ1bmN0aW9uIHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudikge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpLCBzdGFuZGFyZFByb3BzID0gX2EucmVmaW5lZCwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICB2YXIgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGw7XG4gICAgdmFyIGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsO1xuICAgIHZhciBhbGxEYXkgPSBzdGFuZGFyZFByb3BzLmFsbERheTtcbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgYWxsRGF5ID0gKHN0YXJ0TWV0YSAmJiBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheTogYWxsRGF5IH0sIGV4dHJhKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNwYW5zRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHJhbmdlc0VxdWFsKHNwYW4wLnJhbmdlLCBzcGFuMS5yYW5nZSkgJiZcbiAgICAgICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICAgICAgaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpO1xufVxuLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbmZ1bmN0aW9uIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmFuZ2UnICYmIHByb3BOYW1lICE9PSAnYWxsRGF5Jykge1xuICAgICAgICAgICAgaWYgKHNwYW4wW3Byb3BOYW1lXSAhPT0gc3BhbjFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFyZSB0aGVyZSBhbnkgcHJvcHMgdGhhdCBzcGFuMCBoYXMgdGhhdCBzcGFuMSBET0VTTidUIGhhdmU/XG4gICAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjApIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWU6IG9taXRUaW1lIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dCk7XG4gICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYocmVzLnJlZmluZWQsIHJlcy5leHRyYSwgJycsIC8vIHNvdXJjZUlkXG4gICAgZGF0ZVNwYW4uYWxsRGF5LCB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignc2VsZWN0JywgX19hc3NpZ24oX19hc3NpZ24oe30sIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzZWxlY3Rpb24sIGNvbnRleHQpKSwgeyBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCd1bnNlbGVjdCcsIHtcbiAgICAgICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZGF0ZVNwYW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU3BhblRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIF9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVNwYW5BcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbi8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cbi8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5mdW5jdGlvbiBnZXREZWZhdWx0RXZlbnRFbmQoYWxsRGF5LCBtYXJrZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZW5kID0gbWFya2VyO1xuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpO1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgdmFyIGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXG4gICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICB9XG4gICAgdmFyIGNvcHkgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50RGVmLnVpKSwgc3RhbmRhcmRQcm9wcy51aSkgfSk7XG4gICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgY29weS5leHRlbmRlZFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBhcHBsaWVyID0gX2FbX2ldO1xuICAgICAgICBhcHBsaWVyKGNvcHksIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG4gICAgICAgIGNvcHkuaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG5ldmVudENvbmZpZywgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudjtcbiAgICB2YXIgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xuICAgIHZhciBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xuICAgIHZhciBjb3B5ID0gX19hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIG5vIHB1YmxpYyB0eXBlcyB5ZXQuIHdoZW4gdGhlcmUgYXJlLCBleHBvcnQgZnJvbTpcbi8vIGltcG9ydCB7fSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG52YXIgVmlld0FwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBnZXRDdXJyZW50RGF0YTtcbiAgICAgICAgdGhpcy5kYXRlRW52ID0gZGF0ZUVudjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImNhbGVuZGFyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVFbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImN1cnJlbnRTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiY3VycmVudEVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld0FwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5vcHRpb25zW25hbWVdOyAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdBcGk7XG59KCkpO1xuXG52YXIgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBmb3JtYXQ6IFN0cmluZyxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgLy8gZm9yIGFueSBuZXR3b3JrLXJlbGF0ZWQgc291cmNlc1xuICAgIHN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGZhaWx1cmU6IGlkZW50aXR5LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjb250ZXh0LCByZWZpbmVycykge1xuICAgIGlmIChyZWZpbmVycyA9PT0gdm9pZCAwKSB7IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpOyB9XG4gICAgdmFyIHJhd09iajtcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmF3T2JqID0geyB1cmw6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmIHJhdykgeyAvLyBub3QgbnVsbFxuICAgICAgICByYXdPYmogPSByYXc7XG4gICAgfVxuICAgIGlmIChyYXdPYmopIHtcbiAgICAgICAgdmFyIF9hID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB2YXIgbWV0YVJlcyA9IGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWV0YVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGF0ZXN0RmV0Y2hJZDogJycsXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxsRGF5OiByZWZpbmVkLmRlZmF1bHRBbGxEYXksXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiByZWZpbmVkLmV2ZW50RGF0YVRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZWZpbmVkLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVmaW5lZC5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBndWlkKCksXG4gICAgICAgICAgICAgICAgc291cmNlRGVmSWQ6IG1ldGFSZXMuc291cmNlRGVmSWQsXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YVJlcy5tZXRhLFxuICAgICAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IGV4dHJhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VSZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlTWV0YShyYXcsIGNvbnRleHQpIHtcbiAgICB2YXIgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIGZvciAodmFyIGkgPSBkZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7IC8vIGxhdGVyLWFkZGVkIHBsdWdpbnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICB2YXIgbWV0YSA9IGRlZi5wYXJzZU1ldGEocmF3KTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZURlZklkOiBpLCBtZXRhOiBtZXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zLCBkYXRlRW52KSB7XG4gICAgdmFyIGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlO1xuICAgIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuICAgIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG59XG5mdW5jdGlvbiBnZXROb3cobm93SW5wdXQsIGRhdGVFbnYpIHtcbiAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKTtcbiAgICB9XG4gICAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dCk7XG59XG5cbnZhciBDYWxlbmRhckFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxlbmRhckFwaSgpIHtcbiAgICB9XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FsZW5kYXJBcGkucHJvdG90eXBlLCBcInZpZXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9IC8vIGZvciBwdWJsaWMgQVBJXG4gICAgICAgICxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5iYXRjaFJlbmRlcmluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpO1xuICAgIH07XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRBdmFpbGFibGVMb2NhbGVDb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5hdmFpbGFibGVSYXdMb2NhbGVzKTtcbiAgICB9O1xuICAgIC8vIFRyaWdnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXI7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsaXN0ZW5lciBuYW1lICdcIiArIGhhbmRsZXJOYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlcikudHJpZ2dlci5hcHBseShfYSwgX19zcHJlYWRBcnJheShbaGFuZGxlck5hbWVdLCBhcmdzKSk7XG4gICAgfTtcbiAgICAvLyBWaWV3XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlLnN0YXJ0ICYmIGRhdGVPclJhbmdlLmVuZCkgeyAvLyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlOiB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6ICd2aXNpYmxlUmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IGRhdGVPclJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24gKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLCB2aWV3U3BlY3MgPSBfYS52aWV3U3BlY3MsIHRvb2xiYXJDb25maWcgPSBfYS50b29sYmFyQ29uZmlnO1xuICAgICAgICB2YXIgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgc3BlYztcbiAgICAgICAgZm9yICh2YXIgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIEN1cnJlbnQgRGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnTkVYVCcgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogZ2V0Tm93KHN0YXRlLmNhbGVuZGFyT3B0aW9ucy5ub3csIHN0YXRlLmRhdGVFbnYpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nb3RvRGF0ZSA9IGZ1bmN0aW9uICh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmb3IgZXh0ZXJuYWwgQVBJXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICB9O1xuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmZvcm1hdERhdGUgPSBmdW5jdGlvbiAoZCwgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xuICAgIH07XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChkMCwgZDEsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKGQsIG9taXRUaW1lKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZTogb21pdFRpbWUgfSk7XG4gICAgfTtcbiAgICAvLyBEYXRlIFNlbGVjdGlvbiAvIEV2ZW50IFNlbGVjdGlvbiAvIERheUNsaWNrXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gICAgLy8gTk9URTogYXJncyB3ZXJlIGNoYW5nZWQgZnJvbSB2M1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0ZU9yT2JqLCBlbmREYXRlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JbnB1dDtcbiAgICAgICAgaWYgKGVuZERhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRhdGVPck9iai5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihzZWxlY3Rpb25JbnB1dCwgc3RhdGUuZGF0ZUVudiwgY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyAvLyB0aHJvdyBwYXJzZSBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHB1YmxpYyBtZXRob2RcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHVibGljIEV2ZW50cyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50QXBpKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZXZlbnRJbnB1dC5fZGVmO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRJbnB1dC5faW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghY3VycmVudERhdGEuZXZlbnRTdG9yZS5kZWZzW2RlZi5kZWZJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfSksIC8vIFRPRE86IGJldHRlciB1dGlsIGZvciB0d28gYXJncz9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChldmVudElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudElucHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBoYXNoVmFsdWVzVG9BcnJheShzdGF0ZS5ldmVudFNvdXJjZXMpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZUlucHV0ICE9IG51bGwpIHsgLy8gYW4gSUQuIGFjY2VwdHMgYSBudW1iZXIgdG9vXG4gICAgICAgICAgICB2YXIgc291cmNlQXBpID0gdGhpcy5nZXRFdmVudFNvdXJjZUJ5SWQoc291cmNlSW5wdXQpOyAvLyBUT0RPOiB1c2UgYW4gaW50ZXJuYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghc291cmNlQXBpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXFxcIlwiICsgc291cmNlSW5wdXQgKyBcIlxcXCJcIik7IC8vIFRPRE86IHRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoc3RhdGUsIHR1cGxlLmRlZiwgdHVwbGUuZGVmLnJlY3VycmluZ0RlZiA/IG51bGwgOiB0dXBsZS5pbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChuZXdFdmVudEFwaSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRBcGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudHJpZ2dlckV2ZW50QWRkID0gZnVuY3Rpb24gKGV2ZW50QXBpKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRFdmVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgX2EgPSBzdGF0ZS5ldmVudFN0b3JlLCBkZWZzID0gX2EuZGVmcywgaW5zdGFuY2VzID0gX2EuaW5zdGFuY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGVmSWQgPT09IGRlZi5kZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRTJyB9KTtcbiAgICB9O1xuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgdmFyIHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgIGlkID0gU3RyaW5nKGlkKTtcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUhhc2hbc291cmNlSWRdLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlQXBpKSB7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghc3RhdGUuZXZlbnRTb3VyY2VzW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHNvdXJjZUlucHV0LCBzdGF0ZSk7XG4gICAgICAgIGlmIChldmVudFNvdXJjZSkgeyAvLyBUT0RPOiBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogW2V2ZW50U291cmNlXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLCBpc1JlZmV0Y2g6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvLyBTY3JvbGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zY3JvbGxUb1RpbWUgPSBmdW5jdGlvbiAodGltZUlucHV0KSB7XG4gICAgICAgIHZhciB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWU6IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckFwaTtcbn0oKSk7XG5cbnZhciBFdmVudEFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcbiAgICBmdW5jdGlvbiBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgLypcbiAgICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICAgKi9cbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0UHJvcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YXIgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpID0gKF9iID0ge30sIF9iW25hbWVdID0gdmFsLCBfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aTogdWkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHNldCBwcm9wICdcIiArIG5hbWUgKyBcIicuIFVzZSBzZXRFeHRlbmRlZFByb3AgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFeHRlbmRlZFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEVuZCA9IGZ1bmN0aW9uIChlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiB7IGhhc0VuZDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldERhdGVzID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSwgZW5kRGVsdGE6IGVuZERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBtZWFucyBcImNsZWFyIHRoZSBlbmRcIlxuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlRW5kID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZURhdGVzID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRBbGxEYXkgPSBmdW5jdGlvbiAoYWxsRGF5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IGFsbERheSB9O1xuICAgICAgICB2YXIgbWFpbnRhaW5EdXJhdGlvbiA9IG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgaWYgKG1haW50YWluRHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFpbnRhaW5EdXJhdGlvbiA9IHRoaXMuX2NvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gbWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5yYW5nZS5lbmQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmVfMSA9IGNvbnRleHRfMS5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmU7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlXzEsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0XzEpO1xuICAgICAgICAgICAgdmFyIG9sZEV2ZW50ID0gbmV3IEV2ZW50QXBpKGNvbnRleHRfMSwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBvbGRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgY29udGV4dF8xLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmVfMSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIHZhciBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpO1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdGhpcy5fZGVmLnNvdXJjZUlkO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydFN0clwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZW5kU3RyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYucHVibGljSWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImdyb3VwSWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxEYXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudGl0bGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZGlzcGxheVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmRpc3BsYXkgfHwgJ2F1dG8nOyB9IC8vIGJhZC4ganVzdCBub3JtYWxpemUgdGhlIHR5cGUgZWFybGllclxuICAgICAgICAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInN0YXJ0RWRpdGFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJkdXJhdGlvbkVkaXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcIm92ZXJsYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxvd1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImJvcmRlckNvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XG4gICAgICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImV4dGVuZGVkUHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICB2YXIgdWkgPSBkZWYudWk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXJ0U3RyID0gX2Euc3RhcnRTdHIsIGVuZFN0ciA9IF9hLmVuZFN0cjtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBpZiAoZGVmLnRpdGxlKSB7XG4gICAgICAgICAgICByZXMudGl0bGUgPSBkZWYudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0U3RyKSB7XG4gICAgICAgICAgICByZXMuc3RhcnQgPSBzdGFydFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kU3RyKSB7XG4gICAgICAgICAgICByZXMuZW5kID0gZW5kU3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucHVibGljSWQpIHtcbiAgICAgICAgICAgIHJlcy5pZCA9IGRlZi5wdWJsaWNJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgIHJlcy5ncm91cElkID0gZGVmLmdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51cmwpIHtcbiAgICAgICAgICAgIHJlcy51cmwgPSBkZWYudXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ICYmIHVpLmRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmVzLmRpc3BsYXkgPSB1aS5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgcmVjdXJyaW5nLWV2ZW50IHByb3BlcnRpZXM/Pz9cbiAgICAgICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUNvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgPT09IHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICByZXMuY29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodWkuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJhY2tncm91bmRDb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5ib3JkZXJDb2xvciA9IHVpLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aS50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIHJlcy50ZXh0Q29sb3IgPSB1aS50ZXh0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZi5leHRlbmRlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBfX2Fzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGxhaW5PYmplY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEFwaTtcbn0oKSk7XG5mdW5jdGlvbiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiAoX2EgPSB7fSwgX2FbZGVmLmRlZklkXSA9IGRlZiwgX2EpLFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICAgICAgICA/IChfYiA9IHt9LCBfYltpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlLCBfYikgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBldmVudEFwaXMgPSBbXTtcbiAgICB2YXIgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAodmFyIGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRBcGlzO1xufVxuXG52YXIgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbnZhciBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSgpIHtcbiAgICB9XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlclllYXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlck1vbnRoID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9O1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJEYXkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuYXJyYXlUb01hcmtlciA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUubWFya2VyVG9BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcik7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW07XG59KCkpO1xucmVnaXN0ZXJDYWxlbmRhclN5c3RlbSgnZ3JlZ29yeScsIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtKTtcblxudmFyIElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoXCIwLlwiICsgbVsxMl0pICogMTAwMCA6IDApKTtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IChtWzE1XSA9PT0gJy0nID8gLTEgOiAxKSAqIChOdW1iZXIobVsxNl0gfHwgMCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogdGltZVpvbmVPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgRGF0ZUVudiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlRW52KHNldHRpbmdzKSB7XG4gICAgICAgIHZhciB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgdmFyIGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVOb3dNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxuICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTWFya2VyTWV0YSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcGFyc2Uocyk7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtlciA9IHBhcnRzLm1hcmtlcjtcbiAgICAgICAgdmFyIGZvcmNlZFR6byA9IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIobWFya2VyLnZhbHVlT2YoKSAtIHBhcnRzLnRpbWVab25lT2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcmtlcjogbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6bzogZm9yY2VkVHpvIH07XG4gICAgfTtcbiAgICAvLyBBY2Nlc3NvcnNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRZZWFyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG1hcmtlcik7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRNb250aCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobWFya2VyKTtcbiAgICB9O1xuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdIC09IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gLT0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmFkZFllYXJzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRNb250aHMgPSBmdW5jdGlvbiAobWFya2VyLCBuKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVZZWFycyA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIGNhbGVuZGFyU3lzdGVtID0gdGhpcy5jYWxlbmRhclN5c3RlbTtcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVNb250aHMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIFJhbmdlIC8gRHVyYXRpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS5ncmVhdGVzdFdob2xlVW5pdCA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZkhvdXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNvdW50RHVyYXRpb25zQmV0d2VlbiA9IGZ1bmN0aW9uIChtMCwgbTEsIGQpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKGQueWVhcnMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLm1vbnRocykge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaE1vbnRocyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5kYXlzKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKTtcbiAgICB9O1xuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2YgPSBmdW5jdGlvbiAobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZZZWFyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuc3RhcnRPZk1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZXZWVrID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8vIFdlZWsgTnVtYmVyXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY29tcHV0ZVdlZWtOdW1iZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoe1xuICAgICAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgICB9LCB0aGlzLCBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXRJc28gPSBmdW5jdGlvbiAobWFya2VyLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICB9O1xuICAgIC8vIFRpbWVab25lXG4gICAgRGF0ZUVudi5wcm90b3R5cGUudGltZXN0YW1wVG9NYXJrZXIgPSBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5vZmZzZXRGb3JNYXJrZXIgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpOyAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIENvbnZlcnNpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS50b0RhdGUgPSBmdW5jdGlvbiAobSwgZm9yY2VkVHpvKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpOyAvLyBtYWtlIHN1cmUgaXQncyBhIGNvcHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUVudjtcbn0oKSk7XG5cbnZhciBnbG9iYWxMb2NhbGVzID0gW107XG5cbnZhciBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG52YXIgUkFXX0VOX0xPQ0FMRSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5OiBmdW5jdGlvbiAoYnV0dG9uVGV4dCwgdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICA/ICdUb2RheSdcbiAgICAgICAgICAgICAgICA6IFwiVGhpcyBcIiArIGJ1dHRvblRleHQ7XG4gICAgICAgIH0sXG4gICAgfSwgdmlld0hpbnQ6ICckMCB2aWV3JywgbmF2TGlua0hpbnQ6ICdHbyB0byAkMCcsIG1vcmVMaW5rSGludDogZnVuY3Rpb24gKGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBcIlNob3cgXCIgKyBldmVudENudCArIFwiIG1vcmUgZXZlbnRcIiArIChldmVudENudCA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9IH0pO1xuZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlcykge1xuICAgIHZhciBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nO1xuICAgIHZhciBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKTtcbiAgICB2YXIgcmF3TG9jYWxlTWFwID0ge1xuICAgICAgICBlbjogUkFXX0VOX0xPQ0FMRSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgYWxsUmF3TG9jYWxlc18xID0gYWxsUmF3TG9jYWxlczsgX2kgPCBhbGxSYXdMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdMb2NhbGUgPSBhbGxSYXdMb2NhbGVzXzFbX2ldO1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGU6IGRlZmF1bHRDb2RlLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XG59XG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnLCBhdmFpbGFibGUpIHtcbiAgICB2YXIgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgIHZhciByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFO1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgdmFyIHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpIHtcbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbTUlOSU1BTF9SQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgZGVsZXRlIG1lcmdlZC5jb2RlOyAvLyBkb24ndCB3YW50IHRoaXMgcGFydCBvZiB0aGUgb3B0aW9uc1xuICAgIHZhciB3ZWVrID0gbWVyZ2VkLndlZWs7XG4gICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVBcmc6IGNvZGVBcmcsXG4gICAgICAgIGNvZGVzOiBjb2RlcyxcbiAgICAgICAgd2Vlazogd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGRhdGVFbnYgPSBidWlsZERhdGVFbnYkMShvcHRpb25zKTtcbiAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIHZhciBkYXRlTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShkYXRlSW5wdXQpO1xuICAgIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkVHpvOiBkYXRlTWV0YS5mb3JjZWRUem8sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgdmFyIHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICB2YXIgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEoc2V0dGluZ3MpIHtcbiAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KF9fYXNzaWduKF9fYXNzaWduKHsgdGltZVpvbmU6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLnRpbWVab25lLCBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknIH0sIHNldHRpbmdzKSwgeyBsb2NhbGU6IGxvY2FsZSB9KSk7XG59XG5cbnZhciBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgdmFyIHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChyYXdEZWYpIHsgcmV0dXJuIHJhd0RlZi5kYXlzT2ZXZWVrOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcChmdW5jdGlvbiAocmF3RGVmKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpOyB9KTtcbiAgICByZXR1cm4gcmF3RGVmcztcbn1cblxuZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICB9O1xuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICAgIH07XG59XG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgICB9O1xufVxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgICB9O1xufVxuXG52YXIgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIHZhciBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxudmFyIEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IC8vIGZvciBwdXJlY29tcG9uZW50cy4gVE9ETzoga2VlcCBlbHNld2hlcmVcbnZhciBTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGxpdHRlcigpIHtcbiAgICAgICAgdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzID0gbWVtb2l6ZSh0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc3BsaXRFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zcGxpdEluZGl2aWR1YWxVaSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbmRpdmlkdWFsVWkpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSB7fTsgLy8gVE9ETzogdHlwZXNjcmlwdCBwcm90ZWN0aW9uXG4gICAgfVxuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5zcGxpdFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgIHZhciBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xuICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICB2YXIgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcbiAgICAgICAgdmFyIGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XG4gICAgICAgIHZhciBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICB2YXIgc3BsaXRQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIGZ1bmN0aW9uIChpbmZvLCBrZXkpIHsgcmV0dXJuIF90aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KTsgfSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgdmFyIGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgdmFyIGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdERhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgIHZhciBkYXRlU3BhbnMgPSB7fTtcbiAgICAgICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9nZXRLZXlzRm9yRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTdG9yZS5kZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIF90aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZik7IH0pO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZGVmS2V5cykge1xuICAgICAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcywgaW5zdGFuY2VzID0gZXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgICAgIHZhciBzcGxpdFN0b3JlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmRlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBkZWZLZXlzW2luc3RhbmNlLmRlZklkXTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdFN0b3Jlc1trZXldKSB7IC8vIG11c3QgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRTdG9yZXM7XG4gICAgfTtcbiAgICBTcGxpdHRlci5wcm90b3R5cGUuX3NwbGl0SW5kaXZpZHVhbFVpID0gZnVuY3Rpb24gKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICB2YXIgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRIYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV1bZGVmSWRdID0gZXZlbnRVaUJhc2VzW2RlZklkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0SGFzaGVzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIHZhciBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFN0b3Jlc18xID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLCB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSk7XG4gICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgIHZhciBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xuICAgICAgICAgICAgdmFyIG11dGF0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpO1xuICAgICAgICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdGF0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0YXRlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNfMVtrZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFmZmVjdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG11dGF0ZWRTdG9yZXNfMSkge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNwbGl0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgdmFyIGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICB2YXIgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgX19hc3NpZ24oc3R1ZmYsIGluZGl2aWR1YWxVaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHVmZjtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZGF0ZVByb2ZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksXG4gICAgICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNUb2RheTogQm9vbGVhbih0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcbiAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1kYXknLFxuICAgICAgICBcImZjLWRheS1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIFwiZmMtc2xvdC1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxudmFyIERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xudmFyIFdFRUtfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ2xvbmcnIH0pO1xuZnVuY3Rpb24gYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZU1hcmtlciwgdmlld1R5cGUsIGlzVGFiYmFibGUpIHtcbiAgICBpZiAodmlld1R5cGUgPT09IHZvaWQgMCkgeyB2aWV3VHlwZSA9ICdkYXknOyB9XG4gICAgaWYgKGlzVGFiYmFibGUgPT09IHZvaWQgMCkgeyBpc1RhYmJhYmxlID0gdHJ1ZTsgfVxuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgdmFyIGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICB2YXIgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIHZhciBoYW5kbGVJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IHZpZXdUeXBlID09PSAnZGF5JyA/IG9wdGlvbnMubmF2TGlua0RheUNsaWNrIDpcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gb3B0aW9ucy5uYXZMaW5rV2Vla0NsaWNrIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWN0aW9uLmNhbGwoY2FsZW5kYXJBcGksIGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLnpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHRpdGxlOiBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5uYXZMaW5rSGludCwgW2RhdGVTdHIsIHpvbmVkRGF0ZV0sIGRhdGVTdHIpLCAnZGF0YS1uYXZsaW5rJzogJycgfSwgKGlzVGFiYmFibGVcbiAgICAgICAgICAgID8gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlSW50ZXJhY3Rpb24pXG4gICAgICAgICAgICA6IHsgb25DbGljazogaGFuZGxlSW50ZXJhY3Rpb24gfSkpO1xuICAgIH1cbiAgICByZXR1cm4geyAnYXJpYS1sYWJlbCc6IGRhdGVTdHIgfTtcbn1cblxudmFyIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgIHZhciBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IC0xMDAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgICB9KTtcbiAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcbiAgICB2YXIgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICB2YXIgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIF9zY3JvbGxiYXJXaWR0aHM7XG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB2YXIgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gV0FSTklORzogd2lsbCBpbmNsdWRlIGJvcmRlclxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICB5OiBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbCwgZ2V0UGFkZGluZykge1xuICAgIGlmIChnZXRQYWRkaW5nID09PSB2b2lkIDApIHsgZ2V0UGFkZGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpOyAvLyBpbmNsdWRlcyBib3JkZXIhXG4gICAgdmFyIHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0O1xuICAgIHZhciBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJMZWZ0LFxuICAgICAgICBib3JkZXJSaWdodDogYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcDogYm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJCb3R0b206IGJvcmRlckJvdHRvbSxcbiAgICAgICAgc2Nyb2xsYmFyQm90dG9tOiBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZywgZG9Gcm9tV2luZG93Vmlld3BvcnQpIHtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nID09PSB2b2lkIDApIHsgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2U7IH1cbiAgICB2YXIgb3V0ZXJSZWN0ID0gZG9Gcm9tV2luZG93Vmlld3BvcnQgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNvbXB1dGVSZWN0KGVsKTtcbiAgICB2YXIgZWRnZXMgPSBjb21wdXRlRWRnZXMoZWwsIGdvV2l0aGluUGFkZGluZyk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbGVmdDogb3V0ZXJSZWN0LmxlZnQgKyBlZGdlcy5ib3JkZXJMZWZ0ICsgZWRnZXMuc2Nyb2xsYmFyTGVmdCxcbiAgICAgICAgcmlnaHQ6IG91dGVyUmVjdC5yaWdodCAtIGVkZ2VzLmJvcmRlclJpZ2h0IC0gZWRnZXMuc2Nyb2xsYmFyUmlnaHQsXG4gICAgICAgIHRvcDogb3V0ZXJSZWN0LnRvcCArIGVkZ2VzLmJvcmRlclRvcCxcbiAgICAgICAgYm90dG9tOiBvdXRlclJlY3QuYm90dG9tIC0gZWRnZXMuYm9yZGVyQm90dG9tIC0gZWRnZXMuc2Nyb2xsYmFyQm90dG9tLFxuICAgIH07XG4gICAgaWYgKGdvV2l0aGluUGFkZGluZykge1xuICAgICAgICByZXMubGVmdCArPSBlZGdlcy5wYWRkaW5nTGVmdDtcbiAgICAgICAgcmVzLnJpZ2h0IC09IGVkZ2VzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVzLnRvcCArPSBlZGdlcy5wYWRkaW5nVG9wO1xuICAgICAgICByZXMuYm90dG9tIC09IGVkZ2VzLnBhZGRpbmdCb3R0b207XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21wdXRlUmVjdChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGVsKSB7XG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCk7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNsaXBwaW5nUGFyZW50c18xID0gY2xpcHBpbmdQYXJlbnRzOyBfaSA8IGNsaXBwaW5nUGFyZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNfMVtfaV07XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGNvbXB1dGVWTWFyZ2lucyhlbCk7XG59XG5mdW5jdGlvbiBjb21wdXRlVk1hcmdpbnMoZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApICtcbiAgICAgICAgcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luQm90dG9tLCAxMCk7XG59XG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG4vLyBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXG4vLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbi8vIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxuLy8gaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICB9XG59XG5cbnZhciBFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldFRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKHRoaXNDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgRW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoZWRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV0gfHwgW107XG4gICAgICAgIHZhciBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2EgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19hXTtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMuaGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtaXR0ZXI7XG59KCkpO1xuZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcbiAgICAgICAgLnB1c2goaGFuZGxlcik7XG59XG5mdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcbiAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYyAhPT0gaGFuZGxlcjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxuICAgIH1cbn1cblxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xudmFyIFBvc2l0aW9uQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICAgIHZhciBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuYnVpbGRFbEhvcml6b250YWxzID0gZnVuY3Rpb24gKG9yaWdpbkNsaWVudExlZnQpIHtcbiAgICAgICAgdmFyIGxlZnRzID0gW107XG4gICAgICAgIHZhciByaWdodHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZWxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9O1xuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxWZXJ0aWNhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50VG9wKSB7XG4gICAgICAgIHZhciB0b3BzID0gW107XG4gICAgICAgIHZhciBib3R0b21zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmxlZnRUb0luZGV4ID0gZnVuY3Rpb24gKGxlZnRQb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBsZWZ0cyA9IF9hLmxlZnRzLCByaWdodHMgPSBfYS5yaWdodHM7XG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS50b3BUb0luZGV4ID0gZnVuY3Rpb24gKHRvcFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvcHMgPSBfYS50b3BzLCBib3R0b21zID0gX2EuYm90dG9tcztcbiAgICAgICAgdmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgIH07XG4gICAgcmV0dXJuIFBvc2l0aW9uQ2FjaGU7XG59KCkpO1xuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG52YXIgU2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKCk7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxIb3Jpem9udGFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxDb250cm9sbGVyO1xufSgpKTtcbnZhciBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFNjcm9sbENvbnRyb2xsZXI7XG59KFNjcm9sbENvbnRyb2xsZXIpKTtcbnZhciBXaW5kb3dTY3JvbGxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U2Nyb2xsQ29udHJvbGxlcjtcbn0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhlbWUoY2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIHZhciBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIHZhciBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBfX2Fzc2lnbih7fSwgdGhpcy5pY29uQ2xhc3Nlcyk7XG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGljb25PdmVycmlkZUhhc2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRJY29uQ2xhc3MgPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSwgaXNSdGwpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBUaGVtZTtcbn0oKSk7XG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xuXG52YXIgU2Nyb2xsUmVzcG9uZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gX19hc3NpZ24oe30sIF90aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgX3RoaXMuZHJhaW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW1pdHRlci5vbignX3Njcm9sbFJlcXVlc3QnLCB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7XG4gICAgfVxuICAgIFNjcm9sbFJlc3BvbmRlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS5maXJlSW5pdGlhbFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLmRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbFJlc3BvbmRlcjtcbn0oKSk7XG5cbnZhciBWaWV3Q29udGV4dFR5cGUgPSBjcmVhdGVDb250ZXh0KHt9KTsgLy8gZm9yIENvbXBvbmVudHNcbmZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQodmlld1NwZWMsIHZpZXdBcGksIHZpZXdPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgZGF0ZUVudiwgdGhlbWUsIHBsdWdpbkhvb2tzLCBkaXNwYXRjaCwgZ2V0Q3VycmVudERhdGEsIGVtaXR0ZXIsIGNhbGVuZGFyQXBpLCByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgcGx1Z2luSG9va3M6IHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICAgIGdldEN1cnJlbnREYXRhOiBnZXRDdXJyZW50RGF0YSxcbiAgICAgICAgY2FsZW5kYXJBcGk6IGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYzogdmlld1NwZWMsXG4gICAgICAgIHZpZXdBcGk6IHZpZXdBcGksXG4gICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBkYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcjogZnVuY3Rpb24gKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG52YXIgUHVyZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHVyZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGdldFVuZXF1YWxQcm9wcyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpLCBnZXRVbmVxdWFsUHJvcHMobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb21wYXJlT2Jqcyh0aGlzLnByb3BzLCBuZXh0UHJvcHMsIHRoaXMucHJvcEVxdWFsaXR5KSB8fFxuICAgICAgICAgICAgIWNvbXBhcmVPYmpzKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSwgdGhpcy5zdGF0ZUVxdWFsaXR5KTtcbiAgICB9O1xuICAgIFB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG4gICAgUHVyZUNvbXBvbmVudC5hZGRTdGF0ZUVxdWFsaXR5ID0gYWRkU3RhdGVFcXVhbGl0eTtcbiAgICBQdXJlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBQdXJlQ29tcG9uZW50O1xufShDb21wb25lbnQpKTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xudmFyIEJhc2VDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBCYXNlQ29tcG9uZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBhZGRQcm9wc0VxdWFsaXR5KHByb3BFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5wcm9wRXF1YWxpdHkpO1xuICAgIF9fYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaDtcbn1cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkoc3RhdGVFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5KTtcbiAgICBfX2Fzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG4vKlxuYW4gSU5URVJBQ1RBQkxFIGRhdGUgY29tcG9uZW50XG5cblBVUlBPU0VTOlxuLSBob29rIHVwIHRvIGZnLCBmaWxsLCBhbmQgbWlycm9yIHJlbmRlcmVyc1xuLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXG4qL1xudmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVpZCA9IGd1aWQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIHNob3VsZCBiZSBhYnN0cmFjdFxuICAgIH07XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNWYWxpZFNlZ0Rvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWREYXRlRG93bkVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDb21wb25lbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZWFzaWVyIHdheSB0byBhZGQgbmV3IGhvb2tzPyBuZWVkIHRvIHVwZGF0ZSBhIG1pbGxpb24gdGhpbmdzXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczogaW5wdXQuY29udGVudFR5cGVIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XG4gICAgdmFyIGlzQWRkZWQgPSB7fTtcbiAgICB2YXIgaG9va3MgPSB7XG4gICAgICAgIHJlZHVjZXJzOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10sXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3czoge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczoge30sXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZWZzXzEgPSBkZWZzOyBfaSA8IGRlZnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFpc0FkZGVkW2RlZi5pZF0pIHtcbiAgICAgICAgICAgICAgICBpc0FkZGVkW2RlZi5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIHZhciBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMpLCBob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyksXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSwgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAuY29udGVudFR5cGVIYW5kbGVycyksIGhvb2tzMS5jb250ZW50VHlwZUhhbmRsZXJzKSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxuICAgICAgICBvcHRpb25SZWZpbmVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25SZWZpbmVycyksIGhvb2tzMS5vcHRpb25SZWZpbmVycyksXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xufShUaGVtZSkpO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgdmFyIHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICB2YXIgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIHZhciBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgdmFyIHF1ZXJ5UHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTsgfTtcbiAgICB2YXIgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICB2YXIgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICB2YXIgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSkpLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgICAgIG92ZXJyaWRlczogX19hc3NpZ24oX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG4vLyBOT1RFOiBpbiBKU1gsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB0aGlzIGNsYXNzIHdpdGggPEhvb2tQcm9wcz4gYXJnLiBvdGhlcndpc2UsIHdpbGwgZGVmYXVsdCB0byBhbnk/Pz9cbnZhciBSZW5kZXJIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJIb29rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlckhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSBwcm9wcy5ob29rUHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3VudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGRpZE1vdW50OiBwcm9wcy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IHByb3BzLndpbGxVbm1vdW50LCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZikgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNvbnRlbnQ6IHByb3BzLmNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCwgYmFja3VwRWxSZWY6IF90aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lcywgaG9va1Byb3BzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KTsgfSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVySG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuLy8gVE9ETzogcmVuYW1lIHRvIGJlIGFib3V0IGZ1bmN0aW9uLCBub3QgZGVmYXVsdC4gdXNlIGluIGFib3ZlIHR5cGVcbi8vIGZvciBmb3JjaW5nIHJlcmVuZGVyIG9mIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlIENvbnRlbnRIb29rXG52YXIgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuZnVuY3Rpb24gQ29udGVudEhvb2socHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChyZW5kZXJJZCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2tJbm5lciwgX19hc3NpZ24oeyByZW5kZXJJZDogcmVuZGVySWQgfSwgcHJvcHMpKSk7IH0pKTtcbn1cbnZhciBDb250ZW50SG9va0lubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250ZW50SG9va0lubmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRlbnRIb29rSW5uZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbm5lckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmlubmVyRWxSZWYsIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCkpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ3VzdG9tQ29udGVudCgpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21Db250ZW50SW5mbyAmJiB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm87IC8vIG9ubHkgcG9wdWxhdGVkIGlmIHVzaW5nIG5vbi1bcF1yZWFjdCBub2RlKHMpXG4gICAgICAgIHZhciBpbm5lckNvbnRlbnQgPSB0aGlzLmdldElubmVyQ29udGVudCgpO1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuZ2V0Q29udGVudE1ldGEoaW5uZXJDb250ZW50KTtcbiAgICAgICAgLy8gaW5pdGlhbCBydW4sIG9yIGNvbnRlbnQtdHlwZSBjaGFuZ2luZz8gKGZyb20gdnVlIC0+IHJlYWN0IGZvciBleGFtcGxlKVxuICAgICAgICBpZiAoIWN1c3RvbUNvbnRlbnRJbmZvIHx8IGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRLZXkgIT09IG1ldGEuY29udGVudEtleSkge1xuICAgICAgICAgICAgLy8gY2xlYXJpbmcgb2xkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3NpZ25pbmcgbmV3IHZhbHVlXG4gICAgICAgICAgICBpZiAobWV0YS5jb250ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvID0gX19hc3NpZ24oeyBjb250ZW50S2V5OiBtZXRhLmNvbnRlbnRLZXksIGNvbnRlbnRWYWw6IGlubmVyQ29udGVudFttZXRhLmNvbnRlbnRLZXldIH0sIG1ldGEuYnVpbGRMaWZlY3ljbGVGdW5jcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0aW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRWYWwgPSBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VzdG9tQ29udGVudEluZm9cbiAgICAgICAgICAgID8gW10gLy8gc2lnbmFsIHRoYXQgc29tZXRoaW5nIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIDogaW5uZXJDb250ZW50OyAvLyBhc3N1bWUgYSBbcF1yZWFjdCB2ZG9tIG5vZGUuIHVzZSBpdFxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuZ2V0SW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5jb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50ID09PSB1bmRlZmluZWQpIHsgLy8gdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50KHByb3BzLmRlZmF1bHRDb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbm5lckNvbnRlbnQgPT0gbnVsbCA/IG51bGwgOiBpbm5lckNvbnRlbnQ7IC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgKGJldHRlciBmb3IgUmVhY3QpXG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5nZXRDb250ZW50TWV0YSA9IGZ1bmN0aW9uIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGFuZGxlcnMgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3MuY29udGVudFR5cGVIYW5kbGVycztcbiAgICAgICAgdmFyIGNvbnRlbnRLZXkgPSAnJztcbiAgICAgICAgdmFyIGJ1aWxkTGlmZWN5Y2xlRnVuY3MgPSBudWxsO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7IC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgZm9yIGNvbnZlbmllbmNlIHRvIGNhbGxlclxuICAgICAgICAgICAgZm9yICh2YXIgc2VhcmNoS2V5IGluIGNvbnRlbnRUeXBlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50W3NlYXJjaEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50S2V5ID0gc2VhcmNoS2V5O1xuICAgICAgICAgICAgICAgICAgICBidWlsZExpZmVjeWNsZUZ1bmNzID0gY29udGVudFR5cGVIYW5kbGVyc1tzZWFyY2hLZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29udGVudEtleTogY29udGVudEtleSwgYnVpbGRMaWZlY3ljbGVGdW5jczogYnVpbGRMaWZlY3ljbGVGdW5jcyB9O1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUudXBkYXRlQ3VzdG9tQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8pIHsgLy8gZm9yIG5vbi1bcF1yZWFjdFxuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5yZW5kZXIodGhpcy5pbm5lckVsUmVmLmN1cnJlbnQgfHwgdGhpcy5wcm9wcy5iYWNrdXBFbFJlZi5jdXJyZW50LCAvLyB0aGUgZWxlbWVudCB0byByZW5kZXIgaW50b1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbnRlbnRIb29rSW5uZXI7XG59KEJhc2VDb21wb25lbnQpKTtcbnZhciBNb3VudEhvb2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vdW50SG9vaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VudEhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAocm9vdEVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIHJvb3RFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW91bnRIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaGFuZGxlUm9vdEVsKTtcbiAgICB9O1xuICAgIE1vdW50SG9vay5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMucHJvcHMuZGlkTW91bnQ7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucHJvcHMuaG9va1Byb3BzKSwgeyBlbDogdGhpcy5yb290RWwgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb3VudEhvb2sucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzLndpbGxVbm1vdW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmhvb2tQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vdW50SG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCkge1xuICAgIHZhciBjdXJyZW50R2VuZXJhdG9yO1xuICAgIHZhciBjdXJyZW50SG9va1Byb3BzO1xuICAgIHZhciBjdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZ2VuZXJhdG9yLCBob29rUHJvcHMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va1Byb3BzIHx8ICFpc1Byb3BzRXF1YWwoY3VycmVudEhvb2tQcm9wcywgaG9va1Byb3BzKSB8fCBnZW5lcmF0b3IgIT09IGN1cnJlbnRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICBjdXJyZW50SG9va1Byb3BzID0gaG9va1Byb3BzO1xuICAgICAgICAgICAgY3VycmVudENsYXNzTmFtZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKGdlbmVyYXRvciwgaG9va1Byb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENsYXNzTmFtZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcywgaG9va1Byb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKGhvb2tQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUNsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGlucHV0LCBob29rUHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbnB1dChob29rUHJvcHMsIGNyZWF0ZUVsZW1lbnQpOyAvLyBnaXZlIHRoZSBmdW5jdGlvbiB0aGUgdmRvbS1jcmVhdGlvbiBmdW5jXG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxudmFyIFZpZXdSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3Um9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3Um9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9O1xuICAgICAgICB2YXIgY3VzdG9tQ2xhc3NOYW1lcyA9IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBob29rUHJvcHMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCwgZWxSZWY6IHByb3BzLmVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgW1wiZmMtXCIgKyBwcm9wcy52aWV3U3BlYy50eXBlICsgXCItdmlld1wiLCAnZmMtdmlldyddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Um9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xuICAgIHZhciByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgICAgICBpbnB1dDtcbiAgICB2YXIgY29tcG9uZW50ID0gcmF3T3B0aW9ucy5jb21wb25lbnQ7XG4gICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBlclR5cGU6IHJhd09wdGlvbnMudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIHJhd09wdGlvbnM6IHJhd09wdGlvbnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXdQcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgZnVuY3Rpb24gKHZpZXdFbFJlZiwgdmlld0NsYXNzTmFtZXMpIHtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5jbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCwgZWxSZWY6IHZpZXdFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH0pKTsgfSkpOyB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcbiAgICB2YXIgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpO1xuICAgIHZhciB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgZnVuY3Rpb24gKHZpZXdEZWYpIHsgcmV0dXJuIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTsgfSk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIHZhciBkdXJhdGlvbklucHV0ID0gdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbjtcbiAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xuICAgIHZhciBkdXJhdGlvblVuaXQgPSAnJztcbiAgICB2YXIgc2luZ2xlVW5pdCA9ICcnO1xuICAgIHZhciBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgdmFyIGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XG4gICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVlcnlCdXR0b25UZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnNTdWJzZXQpIHtcbiAgICAgICAgdmFyIGJ1dHRvblRleHRNYXAgPSBvcHRpb25zU3Vic2V0LmJ1dHRvblRleHQgfHwge307XG4gICAgICAgIHZhciBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xuICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIHF1ZXJ5QnV0dG9uVGl0bGUgPSBmdW5jdGlvbiAob3B0aW9uc1N1YnNldCkge1xuICAgICAgICB2YXIgYnV0dG9uSGludHMgPSBvcHRpb25zU3Vic2V0LmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgICAgICB2YXIgYnV0dG9uS2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5OyAvLyB1c2Ugc2FtZSBrZXkgYXMgdGV4dFxuICAgICAgICBpZiAoYnV0dG9uS2V5ICE9IG51bGwgJiYgYnV0dG9uSGludHNbYnV0dG9uS2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbYnV0dG9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdDogZHVyYXRpb25Vbml0LFxuICAgICAgICBzaW5nbGVVbml0OiBzaW5nbGVVbml0LFxuICAgICAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcbiAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXG4gICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcbiAgICAgICAgLy8gbm90IERSWVxuICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXG4gICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXG4gICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxuICAgIH07XG59XG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG52YXIgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XG4gICAgdmFyIHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLm5vd0RhdGUgPSBnZXROb3cocHJvcHMubm93SW5wdXQsIHByb3BzLmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgfVxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgcHJldkRhdGUgPSBkYXRlRW52LnN1YnRyYWN0KGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQocHJldkRhdGUsIC0xLCBmb3JjZVRvVmFsaWQpO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLnByb3BzLmRhdGVFbnY7XG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGRhdGVFbnYuYWRkKGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQobmV4dERhdGUsIDEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkID09PSB2b2lkIDApIHsgZm9yY2VUb1ZhbGlkID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdmFsaWRSYW5nZTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xuICAgICAgICB2YXIgaXNSYW5nZUFsbERheTtcbiAgICAgICAgdmFyIHJlbmRlclJhbmdlO1xuICAgICAgICB2YXIgYWN0aXZlUmFuZ2U7XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRSYW5nZSk7XG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gY29uc3RyYWluTWFya2VyVG9SYW5nZShjdXJyZW50RGF0ZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZm8gPSB0aGlzLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyhjdXJyZW50RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby5yYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IHJlbmRlclJhbmdlO1xuICAgICAgICBpZiAoIXByb3BzLnNob3dOb25DdXJyZW50RGF0ZXMpIHtcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCBjdXJyZW50SW5mby5yYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUmFuZ2UgPSB0aGlzLmFkanVzdEFjdGl2ZVJhbmdlKGFjdGl2ZVJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIHZhbGlkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICAgIGlzVmFsaWQgPSByYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhbGlkUmFuZ2U6IHZhbGlkUmFuZ2UsXG4gICAgICAgICAgICAvLyByYW5nZSB0aGUgdmlldyBpcyBmb3JtYWxseSByZXNwb25zaWJsZSBmb3IuXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogY3VycmVudEluZm8ucmFuZ2UsXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuICAgICAgICAgICAgaXNSYW5nZUFsbERheTogaXNSYW5nZUFsbERheSxcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2U6IGFjdGl2ZVJhbmdlLFxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgcmVuZGVyUmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRWYWxpZFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgcmFuZ2UgPSBudWxsO1xuICAgICAgICB2YXIgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG4gICAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB1c2VzTWluTWF4VGltZSA9IF9hLnVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSA9IF9hLnNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSA9IF9hLnNsb3RNYXhUaW1lO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbUR1cmF0aW9uID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgPSBfYS5kYXRlQWxpZ25tZW50O1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxuICAgICAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSW5jcmVtZW50ID0gdGhpcy5wcm9wcy5kYXRlSW5jcmVtZW50O1xuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZGF0ZUluY3JlbWVudCkudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZUFsaWdubWVudCA9IF9hLmRhdGVBbGlnbm1lbnQ7XG4gICAgICAgIHZhciBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlO1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy52aXNpYmxlUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZERhdGVJbmNyZW1lbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnQgPSB0aGlzLnByb3BzLmRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUucmVmaW5lUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VJbnB1dCkge1xuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmluaXRIaWRkZW5EYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGlkZGVuRGF5cyA9IHRoaXMucHJvcHMuaGlkZGVuRGF5cyB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cbiAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG4gICAgICAgIHZhciBkYXlDbnQgPSAwO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2Vla2VuZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gaGlkZGVuRGF5cy5pbmRleE9mKGkpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBkYXlDbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRheUNudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpZGRlbkRheXMnKTsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcbiAgICB9O1xuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xuICAgIH07XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxuICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHZvaWQgMCkgeyBpc0V4Y2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIChfYSA9IHt9LCBfYVthY3Rpb24ub3B0aW9uTmFtZV0gPSBhY3Rpb24ucmF3T3B0aW9uVmFsdWUsIF9hKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9pIDwgc291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19pXTtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7IHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQ7IH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCk7IH0pLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIGNhbGVuZGFyQXBpID0gY29udGV4dC5jYWxlbmRhckFwaTtcbiAgICB2YXIgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdO1xuICAgIHZhciBmZXRjaElkID0gZ3VpZCgpO1xuICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgIGV2ZW50U291cmNlOiBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaDogaXNSZWZldGNoLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIH0sIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50cyA9IHJlcy5yYXdFdmVudHM7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZDogZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHM6IHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiB0cnVlLCBsYXRlc3RGZXRjaElkOiBmZXRjaElkIH0pO1xufVxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2gsIHNvdXJjZUlkLCBmZXRjaElkLCBmZXRjaFJhbmdlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzb3VyY2VIYXNoKSwgKF9hID0ge30sIF9hW3NvdXJjZUlkXSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UgfSksIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpOyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICB2YXIgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgcmF3U291cmNlc18xID0gcmF3U291cmNlczsgX2kgPCByYXdTb3VyY2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdTb3VyY2UgPSByYXdTb3VyY2VzXzFbX2ldO1xuICAgICAgICB2YXIgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGV2ZW50RGVmKSB7IHJldHVybiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcbiAgICAgICAgICAgICk7IH0pO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcbiAgICApIHtcbiAgICAgICAgdmFyIHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xuICAgIHZhciBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0V2ZW50cztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICB2YXIgcmVmaW5lZEV2ZW50cztcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgICAgIHZhciByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmVmaW5lZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmUsIHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoZXhwYW5kUmFuZ2UpIHtcbiAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBzdWJzZXQpO1xufVxuZnVuY3Rpb24gcmV6b25lRXZlbnRTdG9yZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcbiAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlOyAvLyBpc24ndCBkZXBlbmRlbnQgb24gdGltZXpvbmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmczogZGVmcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkOyB9KTtcbn1cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTsgfSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbikge1xuICAgIHZhciBuZXdEcmFnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERyYWc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24pIHtcbiAgICB2YXIgbmV3UmVzaXplO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdSZXNpemUuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc2l6ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgdmFyIGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHJldHVybiB7IGhlYWRlcjogaGVhZGVyLCBmb290ZXI6IGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIHZhciB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgdmFyIGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIHZhciBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2guYXBwbHkodmlld3NXaXRoQnV0dG9ucywgc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0czogc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnM6IHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlOiBoYXNUaXRsZSB9O1xufVxuLypcbkJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcbiovXG5mdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxuY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXG50aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcbiAgICB2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIHZhciBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIHZhciB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKGZ1bmN0aW9uIChidXR0b25Hcm91cFN0cikgeyByZXR1cm4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lOiBidXR0b25OYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xuICAgICAgICB2YXIgdmlld1NwZWM7XG4gICAgICAgIHZhciBidXR0b25DbGljaztcbiAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XG4gICAgICAgIHZhciBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICB2YXIgYnV0dG9uSGludDtcbiAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgdmFyIHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxuICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmdW5jdGlvbiAobmF2VW5pdCkgeyByZXR1cm4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxuICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2s6IGJ1dHRvbkNsaWNrLCBidXR0b25JY29uOiBidXR0b25JY29uLCBidXR0b25UZXh0OiBidXR0b25UZXh0LCBidXR0b25IaW50OiBidXR0b25IaW50IH07XG4gICAgfSkpOyB9KTtcbiAgICByZXR1cm4geyB3aWRnZXRzOiB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zOiB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZTogaGFzVGl0bGUgfTtcbn1cblxudmFyIGV2ZW50U291cmNlRGVmJDIgPSB7XG4gICAgaWdub3JlUmFuZ2U6IHRydWUsXG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzKSB7XG4gICAgICAgIHN1Y2Nlc3Moe1xuICAgICAgICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxudmFyIGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGFyZy5jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCBmdW5jdGlvbiAocmF3RXZlbnRzKSB7XG4gICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMgfSk7IC8vIG5lZWRzIGFuIG9iamVjdCByZXNwb25zZVxuICAgICAgICB9LCBmYWlsdXJlKTtcbiAgICB9LFxufTtcbnZhciBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxufSk7XG5cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCA9IGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGFuZGxlIHBhcnNlZD1mYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhyZXMsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XG4gICAgfTtcbiAgICB4aHIuc2VuZChib2R5KTtcbn1cbmZ1bmN0aW9uIGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybCArXG4gICAgICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJicpO1xufVxuXG52YXIgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxudmFyIGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgIHZhciBtZXRhID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMsIGZ1bmN0aW9uIChyYXdFdmVudHMsIHhocikge1xuICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgeGhyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKHsgbWVzc2FnZTogZXJyb3JNZXNzYWdlLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KTtcbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBzdGFydFBhcmFtO1xuICAgIHZhciBlbmRQYXJhbTtcbiAgICB2YXIgdGltZVpvbmVQYXJhbTtcbiAgICB2YXIgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICBfX2Fzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG52YXIgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcbiAgICBlbmRSZWN1cjogaWRlbnRpdHksXG59O1xuXG52YXIgcmVjdXJyaW5nID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiAocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgdmFyIHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbiAodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICB2YXIgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xudmFyIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIHZhciBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICB2YXIgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQgXG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgPSB2b2lkIDA7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxudmFyIGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgICAgIGV2ZW50czogZnVuY3Rpb24gKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIHZhciB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIHZhciBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgIHZhciBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCB1bmZvdW5kU291cmNlc18xID0gdW5mb3VuZFNvdXJjZXM7IF9hIDwgdW5mb3VuZFNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHVuZm91bmRTb3VyY2UgPSB1bmZvdW5kU291cmNlc18xW19hXTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgbmV3SW5wdXRzXzEgPSBuZXdJbnB1dHM7IF9iIDwgbmV3SW5wdXRzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dCA9IG5ld0lucHV0c18xW19iXTtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpKSwgeyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlcjtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG52YXIgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAgICAgICBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyk7IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGh0bWw6IGJ1aWxkSHRtbFJlbmRlcmVyLFxuICAgICAgICAgICAgZG9tTm9kZXM6IGJ1aWxkRG9tTm9kZVJlbmRlcmVyLFxuICAgICAgICB9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuZnVuY3Rpb24gYnVpbGRIdG1sUmVuZGVyZXIoKSB7XG4gICAgdmFyIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRIdG1sID0gJyc7XG4gICAgZnVuY3Rpb24gcmVuZGVyKGVsLCBodG1sKSB7XG4gICAgICAgIGlmIChlbCAhPT0gY3VycmVudEVsIHx8IGh0bWwgIT09IGN1cnJlbnRIdG1sKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRFbCA9IGVsO1xuICAgICAgICBjdXJyZW50SHRtbCA9IGh0bWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGN1cnJlbnRFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgY3VycmVudEh0bWwgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyOiByZW5kZXIsIGRlc3Ryb3k6IGRlc3Ryb3kgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRG9tTm9kZVJlbmRlcmVyKCkge1xuICAgIHZhciBjdXJyZW50RWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RG9tTm9kZXMgPSBbXTtcbiAgICBmdW5jdGlvbiByZW5kZXIoZWwsIGRvbU5vZGVzKSB7XG4gICAgICAgIHZhciBuZXdEb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvbU5vZGVzKTtcbiAgICAgICAgaWYgKGVsICE9PSBjdXJyZW50RWwgfHwgIWlzQXJyYXlzRXF1YWwoY3VycmVudERvbU5vZGVzLCBuZXdEb21Ob2RlcykpIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBmaXJzdCwgcmVtb3ZlIHNlY29uZCAoZm9yIHNjcm9sbCByZXNldHRpbmcpXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0RvbU5vZGVzXzEgPSBuZXdEb21Ob2RlczsgX2kgPCBuZXdEb21Ob2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3RG9tTm9kZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEVsID0gZWw7XG4gICAgICAgIGN1cnJlbnREb21Ob2RlcyA9IG5ld0RvbU5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjdXJyZW50RG9tTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcbiAgICAgICAgY3VycmVudERvbU5vZGVzID0gW107XG4gICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlcjogcmVuZGVyLCBkZXN0cm95OiBkZXN0cm95IH07XG59XG5cbnZhciBEZWxheWVkUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5ZWRSdW5uZXIoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS50cnlEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiAhdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkKCk7IC8vIG1pZ2h0IHNldCBpc0RpcnR5IHRvIHRydWUgYWdhaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmRyYWluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXllZFJ1bm5lcjtcbn0oKSk7XG5cbnZhciBUYXNrUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tSdW5uZXIocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucGF1c2Uoc2NvcGUpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICB2YXIgdGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUuZHJhaW5lZCA9IGZ1bmN0aW9uIChjb21wbGV0ZWRUYXNrcykge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFza1J1bm5lcjtcbn0oKSk7XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIHZhciByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH07IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG4gICAgfVxuICAgIHZhciBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbn1cblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xudmFyIENhbGVuZGFyRGF0YU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJEYXRhTWFuYWdlcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZU9wdGlvbnNEYXRhKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcbiAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcbiAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRhdGE7IH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcbiAgICAgICAgdmFyIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZTogY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGU6IGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2VyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2NbX2JdO1xuICAgICAgICAgICAgX19hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IGFwcGVuZFxuICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzKSwgb3B0aW9uT3ZlcnJpZGVzKSA6IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUuX2hhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgZW1pdHRlciA9IF9hLmVtaXR0ZXI7XG4gICAgICAgIHZhciBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICB2YXIgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBzdGF0ZS5jdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgPSBzdGF0ZS5kYXRlUHJvZmlsZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgdmFyIHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLCBldmVudFVpU2luZ2xlQmFzZSA9IF9iLmV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgPSBfYi5zZWxlY3Rpb25Db25maWc7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgdmFyIGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGU6IGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlZHVjZXIgPSBfY1tfaV07XG4gICAgICAgICAgICBfX2Fzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICB2YXIgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgdmFyIG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLl9jb21wdXRlT3B0aW9uc0RhdGEgPSBmdW5jdGlvbiAob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyA9IF9hLnBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cyA9IF9hLmxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhID0gX2EuYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIHZhciB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XG4gICAgICAgIHZhciB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCBvcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICAgICAgdmlld1NwZWNzOiB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnOiB0b29sYmFyQ29uZmlnLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHM6IGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgX2EgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKSwgbG9jYWxlcyA9IF9hLmxvY2FsZXMsIGxvY2FsZSA9IF9hLmxvY2FsZTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcDtcbiAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9ucztcbiAgICAgICAgdmFyIHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKTtcbiAgICAgICAgdmFyIHJlZmluZXJzID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIHZhciBleHRyYSA9IHt9O1xuICAgICAgICB2YXIgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25OYW1lICE9PSAncGx1Z2lucycpIHsgLy8gYmVjYXVzZSBwbHVnaW5zIGlzIHNwZWNpYWwtY2FzZWRcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGE6IGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0czogbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aWV3VHlwZSBcXFwiXCIgKyB2aWV3VHlwZSArIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgbW9udGhNb2RlOiByZWZpbmVkT3B0aW9ucy5tb250aE1vZGUsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIHsgdmlld1NwZWM6IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpOiB2aWV3QXBpIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Vmlld09wdGlvbnMgPSBmdW5jdGlvbiAodmlld1NwZWMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIHZhciByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByZWZpbmVycyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgVklFV19PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICB2YXIgcmVmaW5lZCA9IHt9O1xuICAgICAgICB2YXIgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQ7XG4gICAgICAgIHZhciBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dHJhID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgaW4gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCkgeyAvLyBtaWdodCBiZSBhbiBcImV4dHJhXCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckRhdGFNYW5hZ2VyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudih0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xuICAgIHZhciBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICAgIGZpcnN0RGF5OiBmaXJzdERheSxcbiAgICAgICAgd2Vla1RleHQ6IHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICB2YXIgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICB2YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gZXZlbnRTb3VyY2UudWk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XG4gICAgdmFyIGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjYWxlbmRhckNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpc0xvYWRpbmdGdW5jID0gX2FbX2ldO1xuICAgICAgICBpZiAoaXNMb2FkaW5nRnVuYyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQub3B0aW9ucy5idXNpbmVzc0hvdXJzLCBjYWxlbmRhckNvbnRleHQpO1xufVxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnMsIHZpZXdOYW1lKSB7XG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gb3B0aW9uICdcIiArIG9wdGlvbk5hbWUgKyBcIidcIiArXG4gICAgICAgICAgICAodmlld05hbWUgPyBcIiBmb3IgdmlldyAnXCIgKyB2aWV3TmFtZSArIFwiJ1wiIDogJycpKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IG1vdmUgdGhpcyB0byByZWFjdCBwbHVnaW4/XG52YXIgQ2FsZW5kYXJEYXRhUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGVuZGFyRGF0YVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyRGF0YVByb3ZpZGVyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGF0YU1hbmFnZXIpIHsgLy8gc3RpbGwgd2l0aGluIGluaXRpYWwgcnVuLCBiZWZvcmUgYXNzaWdubWVudCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaXJlY3QtbXV0YXRpb24tc3RhdGVcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IGRhdGE7IC8vIGNhbid0IHVzZSBzZXRTdGF0ZSB5ZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kYXRhTWFuYWdlciA9IG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlczogcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgb25EYXRhOiBfdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYWxlbmRhckRhdGFQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25PdmVycmlkZXMgPSB0aGlzLnByb3BzLm9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgaWYgKG5ld09wdGlvbk92ZXJyaWRlcyAhPT0gcHJldlByb3BzLm9wdGlvbk92ZXJyaWRlcykgeyAvLyBwcmV2ZW50IHJlY3Vyc2l2ZSBoYW5kbGVEYXRhXG4gICAgICAgICAgICB0aGlzLmRhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhuZXdPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRhUHJvdmlkZXI7XG59KENvbXBvbmVudCkpO1xuXG4vLyBIRUxQRVJTXG4vKlxuaWYgbmV4dERheVRocmVzaG9sZCBpcyBzcGVjaWZpZWQsIHNsaWNpbmcgaXMgZG9uZSBpbiBhbiBhbGwtZGF5IGZhc2hpb24uXG55b3UgY2FuIGdldCBuZXh0RGF5VGhyZXNob2xkIGZyb20gY29udGV4dC5uZXh0RGF5VGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudHMocHJvcHMsIGFsbERheSkge1xuICAgIHJldHVybiBzbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBwcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgYWxsRGF5ID8gcHJvcHMubmV4dERheVRocmVzaG9sZCA6IG51bGwpLmZnO1xufVxuXG52YXIgTmFtZWRUaW1lWm9uZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZWRUaW1lWm9uZUltcGw7XG59KCkpO1xuXG52YXIgU2VnSGllcmFyY2h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBoaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KGlucHV0LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuRW50cmllcztcbiAgICB9O1xuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIGluc2VydGlvbiA9IHRoaXMuZmluZEluc2VydGlvbihlbnRyeSk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmlzSW5zZXJ0aW9uVmFsaWQgPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgZW50cnkudGhpY2tuZXNzIDw9IHRoaXMubWF4Q29vcmQpICYmXG4gICAgICAgICAgICAodGhpcy5tYXhTdGFja0NudCA9PT0gLTEgfHwgaW5zZXJ0aW9uLnN0YWNrQ250IDwgdGhpcy5tYXhTdGFja0NudCk7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIG51bWJlciBvZiBuZXcgZW50cmllcyBpbnNlcnRlZFxuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbiA9IGZ1bmN0aW9uIChpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEVudHJ5KGVudHJ5LCBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnNwbGl0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIHBhcnRDbnQgPSAwO1xuICAgICAgICB2YXIgc3BsaXRIaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIHZhciBlbnRyeVNwYW4gPSBlbnRyeS5zcGFuO1xuICAgICAgICB2YXIgYmFycmllclNwYW4gPSBiYXJyaWVyLnNwYW47XG4gICAgICAgIGlmIChlbnRyeVNwYW4uc3RhcnQgPCBiYXJyaWVyU3Bhbi5zdGFydCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBzcGxpdEhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICAgICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBiYXJyaWVyU3Bhbi5lbmQsIGVuZDogZW50cnlTcGFuLmVuZCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydENudCkge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoLmFwcGx5KGhpZGRlbkVudHJpZXMsIF9fc3ByZWFkQXJyYXkoW3tcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogaW50ZXJzZWN0U3BhbnMoYmFycmllclNwYW4sIGVudHJ5U3BhbiksIC8vIGd1YXJhbnRlZWQgdG8gaW50ZXJzZWN0XG4gICAgICAgICAgICAgICAgfV0sIHNwbGl0SGlkZGVuRW50cmllcykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRDbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmluc2VydEVudHJ5QXQgPSBmdW5jdGlvbiAoZW50cnksIGluc2VydGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5maW5kSW5zZXJ0aW9uID0gZnVuY3Rpb24gKG5ld0VudHJ5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyID0gX2Euc3RyaWN0T3JkZXIsIHN0YWNrQ250cyA9IF9hLnN0YWNrQ250cztcbiAgICAgICAgdmFyIGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICB2YXIgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICB2YXIgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICB2YXIgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIHZhciB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yICh2YXIgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdDb29yZCA9IGxldmVsQ29vcmRzW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgcGFzdCB0aGUgcGxhY2VkIGVudHJ5LCB3ZSBoYXZlIGZvdW5kIGEgZ29vZCBlbXB0eSBzcGFjZSBhbmQgY2FuIHN0b3AuXG4gICAgICAgICAgICAvLyBpZiBzdHJpY3RPcmRlciwga2VlcCBmaW5kaW5nIG1vcmUgbGF0ZXJhbCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICAgICAgaWYgKCFzdHJpY3RPcmRlciAmJiB0cmFja2luZ0Nvb3JkID49IGNhbmRpZGF0ZUNvb3JkICsgbmV3RW50cnkudGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXMgPSBiaW5hcnlTZWFyY2godHJhY2tpbmdFbnRyaWVzLCBuZXdFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpOyAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICAgICAgICB2YXIgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB0cmFja2luZ0VudHJ5LnNwYW4uc3RhcnQgPCBuZXdFbnRyeS5zcGFuLmVuZCAvLyBhbmQgbm90IGVudGlyZWx5IHBhc3QgbmV3RW50cnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRyYWNraW5nRW50cnkudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICB2YXIgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgdmFyIGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWw6IHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWw6IHRvdWNoaW5nTGF0ZXJhbCxcbiAgICAgICAgICAgIHRvdWNoaW5nRW50cnk6IHRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzdGFja0NudDogc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnRvUmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHM7XG4gICAgICAgIHZhciBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgICAgICB2YXIgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19pXTtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCBlbnRyeSksIHsgbGV2ZWxDb29yZDogbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlZ0hpZXJhcmNoeTtcbn0oKSk7XG5mdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XG59XG5mdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcbn1cbi8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcbmZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XG4gICAgdmFyIG1lcmdlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18yID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMltfaV07XG4gICAgICAgIHZhciBmaWx0ZXJlZE1lcmdlcyA9IFtdO1xuICAgICAgICB2YXIgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICBzcGFuOiBlbnRyeS5zcGFuLFxuICAgICAgICAgICAgZW50cmllczogW2VudHJ5XSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBtZXJnZXNfMSA9IG1lcmdlczsgX2EgPCBtZXJnZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IG1lcmdlc18xW19hXTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xuICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcbiAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZXM7XG59XG5mdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XG4gICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBnZW5lcmFsIHV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xuICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICB2YXIgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXG4gICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXG4gICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xuICAgIH1cbiAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XG4gICAgICAgIHZhciBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcbiAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcbn1cblxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gSW50ZXJhY3Rpb247XG59KCkpO1xuZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVtzZXR0aW5ncy5jb21wb25lbnQudWlkXSA9IHNldHRpbmdzLFxuICAgICAgICBfYTtcbn1cbi8vIGdsb2JhbCBzdGF0ZVxudmFyIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbnZhciBFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudERyYWdnaW5nKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvck5lZWRzUmV2ZXJ0ID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9O1xuICAgIEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnREcmFnZ2luZztcbn0oKSk7XG5cbi8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBpbiBmYXZvciBvZiBvcHRpb25zIHN5c3RlbSxcbi8vIHRobyBpdCdzIHJlYWxseSBlYXN5IHRvIGFjY2VzcyB0aGlzIGdsb2JhbGx5IHJhdGhlciB0aGFuIHBhc3MgdGhydSBvcHRpb25zLlxudmFyIGNvbmZpZyA9IHt9O1xuXG4vKlxuSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxub250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXG4qL1xudmFyIERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG52YXIgVG9vbGJhclNlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvb2xiYXJTZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJTZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXJTZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcChmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHsgcmV0dXJuIF90aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKTsgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfV0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBUb29sYmFyU2VjdGlvbi5wcm90b3R5cGUucmVuZGVyV2lkZ2V0R3JvdXAgPSBmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jb250ZXh0LnRoZW1lO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHdpZGdldEdyb3VwXzEgPSB3aWRnZXRHcm91cDsgX2kgPCB3aWRnZXRHcm91cF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHdpZGdldEdyb3VwXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbk5hbWUgPSB3aWRnZXQuYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2sgPSB3aWRnZXQuYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQgPSB3aWRnZXQuYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiA9IHdpZGdldC5idXR0b25JY29uLCBidXR0b25IaW50ID0gd2lkZ2V0LmJ1dHRvbkhpbnQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJmYy10b29sYmFyLXRpdGxlXCIsIGlkOiBwcm9wcy50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQcmVzc2VkID0gYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uO1xuICAgICAgICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcyA9IFtcImZjLVwiICsgYnV0dG9uTmFtZSArIFwiLWJ1dHRvblwiLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiB0eXBlb2YgYnV0dG9uSGludCA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkhpbnQocHJvcHMubmF2VW5pdCkgOiBidXR0b25IaW50LCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgXCJhcmlhLXByZXNzZWRcIjogaXNQcmVzc2VkLCBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiBidXR0b25DbGljayB9LCBidXR0b25UZXh0IHx8IChidXR0b25JY29uID8gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkljb24gfSkgOiAnJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwQ2xhc3NOYW1lID0gKGlzT25seUJ1dHRvbnMgJiYgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFsnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH1dLCBjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyU2VjdGlvbjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVG9vbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9vbGJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbW9kZWwgPSBfYS5tb2RlbCwgZXh0cmFDbGFzc05hbWUgPSBfYS5leHRyYUNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFydENvbnRlbnQ7XG4gICAgICAgIHZhciBlbmRDb250ZW50O1xuICAgICAgICB2YXIgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgdmFyIGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChrZXksIHdpZGdldEdyb3Vwcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZG8gZnVuY3Rpb24gY29tcG9uZW50P1xudmFyIFZpZXdDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpZXdDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gcHJvcHMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXZpZXctaGFybmVzcycsXG4gICAgICAgICAgICAoYXNwZWN0UmF0aW8gfHwgcHJvcHMubGlxdWlkIHx8IHByb3BzLmhlaWdodClcbiAgICAgICAgICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHQgPSAnJztcbiAgICAgICAgdmFyIHBhZGRpbmdCb3R0b20gPSAnJztcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzdGF0ZS5hdmFpbGFibGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2lsbCBjYXVzZSBsb3RzIG9mIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMgd2l0aGluIHNjcm9sbGdyaWQuXG4gICAgICAgICAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9ICgxIC8gYXNwZWN0UmF0aW8pICogMTAwICsgXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBoZWlnaHQsIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVBdmFpbGFibGVXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xudmFyIEV2ZW50Q2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50Q2xpY2tpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRDbGlja2luZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2sgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIHZhciBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2spO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFdmVudENsaWNraW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbnZhciBFdmVudEhvdmVyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVudEhvdmVyaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50SG92ZXJpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICBfdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IF90aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIF90aGlzLmN1cnJlbnRTZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0VudGVyID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdFbnRlciwgX3RoaXMuaGFuZGxlU2VnTGVhdmUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudEhvdmVyaW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG52YXIgQ2FsZW5kYXJDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxlbmRhckNvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dCk7XG4gICAgICAgIF90aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBfdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICBfdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuZm9vdGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KTtcbiAgICAgICAgICAgIHZhciBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcbiAgICAgICAgICAgICAgICBFdmVudENsaWNraW5nLFxuICAgICAgICAgICAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uQ2xhc3NlcyA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdChfdGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUludGVyYWN0aW9uQ2xhc3MpIHsgcmV0dXJuIG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignd2luZG93UmVzaXplJywgeyB2aWV3OiBfdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaGFuZGxlV2luZG93UmVzaXplID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLnByb3BzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHByb3BzLnRvb2xiYXJDb25maWcsIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zO1xuICAgICAgICB2YXIgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICB2YXIgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIHZhciB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICB2YXIgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIsIHsgdmFsdWU6IHZpZXdDb250ZXh0IH0sXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBfX2Fzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGxpcXVpZDogdmlld1ZHcm93LCBoZWlnaHQ6IHZpZXdIZWlnaHQsIGFzcGVjdFJhdGlvOiB2aWV3QXNwZWN0UmF0aW8sIGxhYmVsZWRCeUlkOiB2aWV3TGFiZWxJZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmZvb3RlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBfX2Fzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSB7IHJldHVybiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKTsgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPT0gcHJldlByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyLmNsZWFyKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5idWlsZEFwcGVuZENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcChmdW5jdGlvbiAoYnVpbGRBcHBlbmRDb250ZW50KSB7IHJldHVybiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtGcmFnbWVudCwge31dLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBwcm9wcy52aWV3U3BlYztcbiAgICAgICAgdmFyIHZpZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxuICAgICAgICAgICAgaXNIZWlnaHRBdXRvOiBwcm9wcy5pc0hlaWdodEF1dG8sXG4gICAgICAgICAgICBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMocGx1Z2luSG9va3Mudmlld1Byb3BzVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgICAgIF9fYXNzaWduKHZpZXdQcm9wcywgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVmlld0NvbXBvbmVudCA9IHZpZXdTcGVjLmNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb21wb25lbnQsIF9fYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJDb250ZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBidWlsZFRvb2xiYXJQcm9wcyh2aWV3U3BlYywgZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBjdXJyZW50RGF0ZSwgbm93LCB0aXRsZSkge1xuICAgIC8vIGRvbid0IGZvcmNlIGFueSBkYXRlLXByb2ZpbGVzIHRvIHZhbGlkIGRhdGUgcHJvZmlsZXMgKHRoZSBgZmFsc2VgKSBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIGl0J3MgaW52YWxpZFxuICAgIHZhciB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3csIHVuZGVmaW5lZCwgZmFsc2UpOyAvLyBUT0RPOiBuZWVkIGB1bmRlZmluZWRgIG9yIGVsc2UgSU5GSU5JVEUgTE9PUCBmb3Igc29tZSByZWFzb25cbiAgICB2YXIgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgdmFyIG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUNsYXNzKSB7IHJldHVybiBuZXcgVGhlQ2xhc3MoKTsgfSk7XG59XG5cbnZhciBDYWxlbmRhclJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGVuZGFyUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhclJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZvclByaW50OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVBZnRlclByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICAgICAgdmFyIGZvclByaW50ID0gdGhpcy5zdGF0ZS5mb3JQcmludDtcbiAgICAgICAgdmFyIGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgXCJmYy1kaXJlY3Rpb24tXCIgKyBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgICAgIHByb3BzLnRoZW1lLmdldENsYXNzKCdyb290JyksXG4gICAgICAgIF07XG4gICAgICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KTtcbiAgICB9O1xuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5wcm9wcy5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVtaXR0ZXIgPSB0aGlzLnByb3BzLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vZmYoJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhclJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXlDbnQpIHtcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICAgIGlmICghZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgZGF5Q250ID4gMTApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSk7IC8vIFwiU2F0XCJcbiAgICB9XG4gICAgaWYgKGRheUNudCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnLCBvbWl0Q29tbWFzOiB0cnVlIH0pOyAvLyBcIlNhdCAxMS8xMlwiXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7IC8vIFwiU2F0dXJkYXlcIlxufVxuXG52YXIgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5mdW5jdGlvbiByZW5kZXJJbm5lciQxKGhvb2tQcm9wcykge1xuICAgIHJldHVybiBob29rUHJvcHMudGV4dDtcbn1cblxudmFyIFRhYmxlRGF0ZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlRGF0ZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEYXRlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZURhdGVDZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaTtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICAvLyBpZiBjb2xDbnQgaXMgMSwgd2UgYXJlIGFscmVhZHkgaW4gYSBkYXktdmlldyBhbmQgZG9uJ3QgbmVlZCBhIG5hdmxpbmtcbiAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9ICghZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF0ZSlcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIHZhciBob29rUHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhSG9va1Byb3BzKSwgeyB0ZXh0OiB0ZXh0IH0pLCBkYXlNZXRhKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXIkMSwgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCBfX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCByb2xlOiBcImNvbHVtbmhlYWRlclwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgXCJkYXRhLWRhdGVcIjogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCwgY29sU3BhbjogcHJvcHMuY29sU3BhbiB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCkpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEYXRlQ2VsbDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgV0VFS0RBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7XG52YXIgVGFibGVEb3dDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZURvd0NlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEb3dDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlRG93Q2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaSwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIHZhciBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF0ZU1ldGEsIHRoZW1lKSwgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFIb29rUHJvcHMpLCB7IHRleHQ6IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyJDEsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGhcIiwgX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgXCJhcmlhLWxhYmVsXCI6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZURvd0NlbGw7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIE5vd1RpbWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3dUaW1lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3dUaW1lcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTm93VGltZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMudW5pdCAhPT0gdGhpcy5wcm9wcy51bml0KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wdXRlVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xuICAgICAgICB2YXIgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xuICAgICAgICB2YXIgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcbiAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIHdhaXRNczogd2FpdE1zLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLCBuZXh0U3RhdGUgPSBfYS5uZXh0U3RhdGUsIHdhaXRNcyA9IF9hLndhaXRNcztcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB3YWl0TXMpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gTm93VGltZXI7XG59KENvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xufVxuXG52YXIgRGF5SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5SGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUhlYWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZXMgPSBfYS5kYXRlcywgZGF0ZVByb2ZpbGUgPSBfYS5kYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMgPSBfYS5kYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gPSBfYS5yZW5kZXJJbnRybztcbiAgICAgICAgdmFyIGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCBmdW5jdGlvbiAobm93RGF0ZSwgdG9kYXlSYW5nZSkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcbiAgICAgICAgICAgIGRhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpOyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5SGVhZGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbnZhciBEYXlTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXlTZXJpZXNNb2RlbChyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgdmFyIGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgRGF5U2VyaWVzTW9kZWwucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG4gICAgICAgIHZhciBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xuICAgICAgICB2YXIgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgICBEYXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzWzBdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgIH07XG4gICAgcmV0dXJuIERheVNlcmllc01vZGVsO1xufSgpKTtcblxudmFyIERheVRhYmxlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICB2YXIgZGF0ZXMgPSBkYXlTZXJpZXMuZGF0ZXM7XG4gICAgICAgIHZhciBkYXlzUGVyUm93O1xuICAgICAgICB2YXIgZmlyc3REYXk7XG4gICAgICAgIHZhciByb3dDbnQ7XG4gICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XG4gICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcbiAgICB9XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZENlbGwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZEhlYWRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcbiAgICAgICAgdmFyIHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgc2VncyA9IFtdO1xuICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IHNlcmllc1NlZy5maXJzdEluZGV4LCBsYXN0SW5kZXggPSBzZXJpZXNTZWcubGFzdEluZGV4O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZU1vZGVsO1xufSgpKTtcblxudmFyIFNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZXIoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRVaUJhc2VzID0gcHJvcHMuZXZlbnRVaUJhc2VzO1xuICAgICAgICB2YXIgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW3Byb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50VWlCYXNlcywgY29udGV4dF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW3Byb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZS5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VOb3dEYXRlID0gZnVuY3Rpb24gKC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbi5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFt7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgY29udGV4dF0sIGV4dHJhQXJncykpO1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW2V4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkXSwgZXh0cmFBcmdzKSkuYmc7XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtkYXRlU3Bhbi5yYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9hIDwgc2Vnc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfYV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudFJhbmdlc18xID0gZXZlbnRSYW5nZXM7IF9pIDwgZXZlbnRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gZXZlbnRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSB7XG4gICAgICAgIHZhciBkYXRlUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAvLyBoYWNrIHRvIG1ha2UgbXVsdGktZGF5IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBmb3JjZS1kaXNwbGF5ZWQgYXMgbGlzdC1pdGVtcyB0byB0YWtlIHVwIG9ubHkgb25lIGRheVxuICAgICAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW2RhdGVSYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMltfaV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlcjtcbn0oKSk7XG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XG4gICAgfTtcbn1cblxuLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZXMgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLmluc3RhbmNlcztcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgdmFyIHByb3BzID0gX19hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiAnJywgZXZlbnREcmFnOiBudWxsLCBldmVudFJlc2l6ZTogbnVsbCB9LCBuZXdQcm9wcyk7XG4gICAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoZGF0ZVNwYW5NZXRhID09PSB2b2lkIDApIHsgZGF0ZVNwYW5NZXRhID0ge307IH1cbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIHZhciBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgdmFyIHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICB2YXIgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIHZhciBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAodmFyIHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICB2YXIgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICB2YXIgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIHZhciBldmVudE92ZXJsYXAgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRPdmVybGFwO1xuICAgICAgICB2YXIgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKHZhciBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEFwaShjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICB2YXIgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJqZWN0Q29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0QWxsb3cgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgc3ViamVjdERhdGVTcGFuID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHsgcmFuZ2U6IHN1YmplY3RJbnN0YW5jZS5yYW5nZSwgYWxsRGF5OiBzdWJqZWN0RGVmLmFsbERheSB9KTtcbiAgICAgICAgICAgIHZhciBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICB2YXIgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgdmFyIHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIHZhciByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgdmFyIHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIHZhciBzZWxlY3Rpb25Db25maWcgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuc2VsZWN0aW9uQ29uZmlnO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIHZhciBzZWxlY3RPdmVybGFwID0gY29udGV4dC5vcHRpb25zLnNlbGVjdE92ZXJsYXA7XG4gICAgdmFyIHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcbiAgICBmb3IgKHZhciByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xuICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNlbGVjdGlvbkNvbmZpZy5hbGxvd3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25BbGxvdyA9IF9hW19pXTtcbiAgICAgICAgdmFyIGZ1bGxEYXRlU3BhbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgY29uc3RyYWludHNfMSA9IGNvbnN0cmFpbnRzOyBfaSA8IGNvbnN0cmFpbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNfMVtfaV07XG4gICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xub3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXG5idXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG5jb250ZXh0KSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludDsgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2Vcbn1cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgdmFyIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG91dGVyUmFuZ2VzXzEgPSBvdXRlclJhbmdlczsgX2kgPCBvdXRlclJhbmdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb3V0ZXJSYW5nZSA9IG91dGVyUmFuZ2VzXzFbX2ldO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY3JvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGxpcXVpZCA9IHByb3BzLmxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSA9IHByb3BzLmxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XG4gICAgICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLm5lZWRzWFNjcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5uZWVkc1lTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WVNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xudmFyIFJlZk1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZNYXAobWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayA9IG1hc3RlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgZGVwdGhzID0gX2EuZGVwdGhzLCBjdXJyZW50TWFwID0gX2EuY3VycmVudE1hcDtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFJlZk1hcC5wcm90b3R5cGUuY3JlYXRlUmVmID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVZhbHVlKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmQ2FsbGJhY2s7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAgIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAgIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICAgIFJlZk1hcC5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdEZyb21IYXNoKHRoaXMuY3VycmVudE1hcCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApO1xuICAgIH07XG4gICAgUmVmTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZk1hcDtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xuICAgIHZhciBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xuICAgIHZhciBsYXJnZXN0V2lkdGggPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgc2hyaW5rQ2VsbHNfMSA9IHNocmlua0NlbGxzOyBfaSA8IHNocmlua0NlbGxzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzaHJpbmtDZWxsID0gc2hyaW5rQ2VsbHNfMVtfaV07XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICB2YXIgZXhwYW5kUm93cyA9IGFyZy5leHBhbmRSb3dzO1xuICAgIHZhciBjb250ZW50ID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjaHVua0NvbmZpZy5jb250ZW50KGFyZykgOlxuICAgICAgICBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgY2h1bmtDb25maWcudGFibGVDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkNvbmZpZy5zeW5jUm93SGVpZ2h0cyA/ICdmYy1zY3JvbGxncmlkLXN5bmMtdGFibGUnIDogJycsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFyZy50YWJsZUNvbEdyb3VwTm9kZSwgY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aGVhZCcgOiAndGJvZHknLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2h1bmtDb25maWcucm93Q29udGVudChhcmcpXG4gICAgICAgICAgICA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMCwgY29sczEpIHtcbiAgICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbCk7XG59XG5mdW5jdGlvbiByZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHNocmlua1dpZHRoKSB7XG4gICAgdmFyIGNvbE5vZGVzID0gW107XG4gICAgLypcbiAgICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gICAgSE9XRVZFUiwgQ2hyb21lIHdhcyBnZXR0aW5nIG1lc3NpbmcgdXAgZGlzdHJpYnV0aW5nIHRoZSB3aWR0aCB0byA8dGQ+Lzx0aD4gZWxlbWVudHMgd2l0aCBjb2xzcGFucy5cbiAgICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgICAqL1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sc18xID0gY29sczsgX2kgPCBjb2xzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb2xQcm9wcyA9IGNvbHNfMVtfaV07XG4gICAgICAgIHZhciBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sTm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiY29sXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ2NvbGdyb3VwJywge31dLCBjb2xOb2RlcykpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHNfMiA9IGNvbHM7IF9pIDwgY29sc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sID0gY29sc18yW19pXTtcbiAgICAgICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZCwgY29udGV4dCkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgXTtcbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1saXF1aWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3cpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgICAgIFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLVwiICsgc2VjdGlvbkNvbmZpZy50eXBlLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcztcbiAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5zdGlja3lGb290ZXJTY3JvbGxiYXI7XG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XG59XG5cbnZhciBTaW1wbGVTY3JvbGxHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW1wbGVTY3JvbGxHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVNjcm9sbEdyaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9jZXNzQ29scyA9IG1lbW9pemUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH0sIGlzQ29sUHJvcHNFcXVhbCk7IC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG4gICAgICAgIC8vIHl1Y2t5IHRvIG1lbW9pemUgVk5vZGVzLCBidXQgbXVjaCBtb3JlIGVmZmljaWVudCBmb3IgY29uc3VtZXJzXG4gICAgICAgIF90aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICBfdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcChfdGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGNhbiBkbyBhIHJlYWxseSBzaW1wbGUgcHJpbnQtdmlldy4gZG9udCBuZWVkIHRvIGpvaW4gcm93c1xuICAgICAgICBfdGhpcy5oYW5kbGVTaXppbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfX2Fzc2lnbih7IHNocmlua1dpZHRoOiBfdGhpcy5jb21wdXRlU2hyaW5rV2lkdGgoKSB9LCBfdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcbiAgICAgICAgdmFyIGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xuICAgICAgICB2YXIgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgICAgICB2YXIgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgY29uZmlnSSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50Q29uZmlnO1xuICAgICAgICB2YXIgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB2YXIgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB2YXIgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxuICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxuICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cbiAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXG4gICAgICAgIHZhciBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgICAgICB2YXIgcm9sZUF0dHJzID0geyByb2xlOiAncm93Z3JvdXAnIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdncmlkJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZTogeyBoZWlnaHQ6IHByb3BzLmhlaWdodCB9LFxuICAgICAgICB9LCBCb29sZWFuKCFpc0J1Z2d5ICYmIGhlYWRTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ3RoZWFkJywgcm9sZUF0dHJzXSwgaGVhZFNlY3Rpb25Ob2RlcykpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ3Rib2R5Jywgcm9sZUF0dHJzXSwgYm9keVNlY3Rpb25Ob2RlcykpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ3Rmb290Jywgcm9sZUF0dHJzXSwgZm9vdFNlY3Rpb25Ob2RlcykpLCBpc0J1Z2d5ICYmIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbJ3Rib2R5Jywgcm9sZUF0dHJzXSwgaGVhZFNlY3Rpb25Ob2RlcyksIGJvZHlTZWN0aW9uTm9kZXMpLCBmb290U2VjdGlvbk5vZGVzKSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5IH0sIHNlY3Rpb25Db25maWcub3V0ZXJDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5LCByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJykgfSwgdGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBzZWN0aW9uQ29uZmlnLmNodW5rLCBpc0hlYWRlcikpKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLnJlbmRlckNodW5rVGQgPSBmdW5jdGlvbiAoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGNodW5rQ29uZmlnLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gY2h1bmtDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0NvbmZpZy5vdXRlckNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgZm9yY2VZU2Nyb2xsYmFycyA9IF9hLmZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzID0gX2Euc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IF9hLnNjcm9sbGVyQ2xpZW50SGVpZ2h0cztcbiAgICAgICAgdmFyIG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIFRPRE86IGRvIGxhemlseS4gZG8gaW4gc2VjdGlvbiBjb25maWc/XG4gICAgICAgIHZhciBpc0xpcXVpZCA9IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpO1xuICAgICAgICAvLyBmb3IgYCFwcm9wcy5saXF1aWRgIC0gaXMgV0hPTEUgc2Nyb2xsZ3JpZCBuYXR1cmFsIGhlaWdodD9cbiAgICAgICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgICAgICB2YXIgb3ZlcmZsb3dZID0gIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgICAgICAgICAgICFuZWVkc1lTY3JvbGxpbmcgPyAnaGlkZGVuJyA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJztcbiAgICAgICAgdmFyIHNlY3Rpb25LZXkgPSBzZWN0aW9uQ29uZmlnLmtleTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIHtcbiAgICAgICAgICAgIHRhYmxlQ29sR3JvdXBOb2RlOiBtaWNyb0NvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgIHRhYmxlTWluV2lkdGg6ICcnLFxuICAgICAgICAgICAgY2xpZW50V2lkdGg6ICghcHJvcHMuY29sbGFwc2libGVXaWR0aCAmJiBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkKSA/IHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQgPyBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgZXhwYW5kUm93czogc2VjdGlvbkNvbmZpZy5leHBhbmRSb3dzLFxuICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IGZhbHNlLFxuICAgICAgICAgICAgcm93U3luY0hlaWdodHM6IFtdLFxuICAgICAgICAgICAgcmVwb3J0Um93SGVpZ2h0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIH0sIGlzSGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGgnIDogJ3RkJywge1xuICAgICAgICAgICAgcmVmOiBjaHVua0NvbmZpZy5lbFJlZixcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGVyLWhhcm5lc3NcIiArIChpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJycpIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IHJlZjogdGhpcy5zY3JvbGxlclJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBlbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIG92ZXJmbG93WTogb3ZlcmZsb3dZLCBvdmVyZmxvd1g6ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi8sIG1heEhlaWdodDogc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQsIGxpcXVpZDogaXNMaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgLy8gYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzc1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9LCBjb250ZW50KSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuX2hhbmRsZVNjcm9sbGVyRWwgPSBmdW5jdGlvbiAoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogbmVlZCBiZXR0ZXIgc29sdXRpb24gd2hlbiBzdGF0ZSBjb250YWlucyBub24tc2l6aW5nIHRoaW5nc1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXB1dGVTaHJpbmtXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgICAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICAgICAgICA6IDA7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJEaW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc2Nyb2xsZXJSZWZzID0gX2Euc2Nyb2xsZXJSZWZzLCBzY3JvbGxlckVsUmVmcyA9IF9hLnNjcm9sbGVyRWxSZWZzO1xuICAgICAgICB2YXIgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlO1xuICAgICAgICB2YXIgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSB7fTtcbiAgICAgICAgdmFyIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBzZWN0aW9uS2V5IGluIHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5uZWVkc1lTY3JvbGxpbmcoKSkge1xuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSB0aGlzLnByb3BzLnNlY3Rpb25zOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBfYltfaV07XG4gICAgICAgICAgICB2YXIgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgdmFyIHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFyczogZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHM6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNpbXBsZVNjcm9sbEdyaWQ7XG59KEJhc2VDb21wb25lbnQpKTtcblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlY3Rpb25zXzEgPSBzZWN0aW9uczsgX2kgPCBzZWN0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHNlY3Rpb25zXzFbX2ldO1xuICAgICAgICBpZiAoc2VjdGlvbi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBFdmVudFJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50Um9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudFJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV2ZW50Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWcgPSBwcm9wcy5zZWc7XG4gICAgICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgIHZhciB1aSA9IGV2ZW50UmFuZ2UudWk7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcpLFxuICAgICAgICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICAgICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgICAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKHByb3BzLmlzRnV0dXJlKSxcbiAgICAgICAgICAgIGlzVG9kYXk6IEJvb2xlYW4ocHJvcHMuaXNUb2RheSksXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZyksXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFuZGFyZENsYXNzTmFtZXMgPSBnZXRFdmVudENsYXNzTmFtZXMoaG9va1Byb3BzKS5jb25jYXQodWkuY2xhc3NOYW1lcyk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCwgZWxSZWY6IHRoaXMuZWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIHN0YW5kYXJkQ2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKTsgfSkpO1xuICAgIH07XG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLnNlZyk7XG4gICAgfTtcbiAgICAvKlxuICAgIG5lZWQgdG8gcmUtYXNzaWduIHNlZyB0byB0aGUgZWxlbWVudCBpZiBzZWcgY2hhbmdlcywgZXZlbiBpZiB0aGUgZWxlbWVudCBpcyB0aGUgc2FtZVxuICAgICovXG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBzZWcgPSB0aGlzLnByb3BzLnNlZztcbiAgICAgICAgaWYgKHNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCBzZWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIHNob3VsZCBub3QgYmUgYSBwdXJlY29tcG9uZW50XG52YXIgU3RhbmRhcmRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhbmRhcmRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0YW5kYXJkRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWcgPSBwcm9wcy5zZWc7XG4gICAgICAgIHZhciB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgdmFyIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Um9vdCwgeyBzZWc6IHNlZywgdGltZVRleHQ6IHRpbWVUZXh0LCBkaXNhYmxlRHJhZ2dpbmc6IHByb3BzLmRpc2FibGVEcmFnZ2luZywgZGlzYWJsZVJlc2l6aW5nOiBwcm9wcy5kaXNhYmxlUmVzaXppbmcsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJJbm5lckNvbnRlbnQkMSwgaXNEcmFnZ2luZzogcHJvcHMuaXNEcmFnZ2luZywgaXNSZXNpemluZzogcHJvcHMuaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBwcm9wcy5pc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IHByb3BzLmlzU2VsZWN0ZWQsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXkgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogcHJvcHMuZXh0cmFDbGFzc05hbWVzLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhvb2tQcm9wcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCByZWY6IHJvb3RFbFJlZiB9LCBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpblwiLCByZWY6IGlubmVyRWxSZWYsIHN0eWxlOiB7IGNvbG9yOiBob29rUHJvcHMudGV4dENvbG9yIH0gfSwgaW5uZXJDb250ZW50KSxcbiAgICAgICAgICAgIGhvb2tQcm9wcy5pc1N0YXJ0UmVzaXphYmxlICYmXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItc3RhcnRcIiB9KSxcbiAgICAgICAgICAgIGhvb2tQcm9wcy5pc0VuZFJlc2l6YWJsZSAmJlxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLWVuZFwiIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGFuZGFyZEV2ZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG52YXIgTm93SW5kaWNhdG9yUm9vdCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpO1xufSkpOyB9O1xuXG52YXIgREFZX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyBkYXk6ICdudW1lcmljJyB9KTtcbnZhciBEYXlDZWxsQ29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5Q2VsbENvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5Q2VsbENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRGF5Q2VsbENvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gcmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVByb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY29udGVudDogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5Q2VsbENvbnRlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlZmluZURheUNlbGxIb29rUHJvcHMocmF3KSB7XG4gICAgdmFyIGRhdGUgPSByYXcuZGF0ZSwgZGF0ZUVudiA9IHJhdy5kYXRlRW52O1xuICAgIHZhciBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIHJhdy5kYXRlUHJvZmlsZSk7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGRheU51bWJlclRleHQ6IHJhdy5zaG93RGF5TnVtYmVyID8gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgREFZX05VTV9GT1JNQVQpIDogJycgfSksIHJhdy5leHRyYVByb3BzKTtcbn1cblxudmFyIERheUNlbGxSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlDZWxsUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlDZWxsUm9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZmluZUhvb2tQcm9wcyA9IG1lbW9pemVPYmpBcmcocmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyk7XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlDZWxsUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB0aGlzLnJlZmluZUhvb2tQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVByb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gZ2V0RGF5Q2xhc3NOYW1lcyhob29rUHJvcHMsIGNvbnRleHQudGhlbWUpLmNvbmNhdChob29rUHJvcHMuaXNEaXNhYmxlZFxuICAgICAgICAgICAgPyBbXSAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcbiAgICAgICAgICAgIDogdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGhvb2tQcm9wcykpO1xuICAgICAgICB2YXIgZGF0YUF0dHJzID0gaG9va1Byb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcocHJvcHMuZGF0ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3VudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50LCBlbFJlZjogcHJvcHMuZWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZikgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMsIGhvb2tQcm9wcy5pc0Rpc2FibGVkKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUNlbGxSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtXCIgKyBmaWxsVHlwZSB9KSk7XG59XG52YXIgQmdFdmVudCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRSb290LCB7IGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogcHJvcHMuc2VnIC8qIHVzZWxlc3NzIGkgdGhpbmsgKi8sIHRpbWVUZXh0OiBcIlwiLCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWJnLWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgIH0gfSwgaW5uZXJDb250ZW50KSk7IH0pKTsgfTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIHZhciB0aXRsZSA9IHByb3BzLmV2ZW50LnRpdGxlO1xuICAgIHJldHVybiB0aXRsZSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHByb3BzLmV2ZW50LnRpdGxlKSk7XG59XG5cbnZhciBXZWVrTnVtYmVyUm9vdCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkYXRlID0gcHJvcHMuZGF0ZTtcbiAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXQ7XG4gICAgdmFyIG51bSA9IGRhdGVFbnYuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZSk7IC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIHZhciBob29rUHJvcHMgPSB7IG51bTogbnVtLCB0ZXh0OiB0ZXh0LCBkYXRlOiBkYXRlIH07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lciwgZGlkTW91bnQ6IG9wdGlvbnMud2Vla051bWJlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyV2lsbFVubW91bnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn0pKTsgfTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0O1xufVxuXG52YXIgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG52YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9wb3ZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3BvdmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IGVsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gICAgICAgIF90aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5yb290RWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbkNsb3NlID0gX3RoaXMucHJvcHMub25DbG9zZTtcbiAgICAgICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCB0aGVtZSA9IF9hLnRoZW1lLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIF9iID0gdGhpcywgcHJvcHMgPSBfYi5wcm9wcywgc3RhdGUgPSBfYi5zdGF0ZTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtcG9wb3ZlcicsXG4gICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxuICAgICAgICBdLmNvbmNhdChwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oeyBpZDogcHJvcHMuaWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMuZXh0cmFBdHRycywgeyByZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0pLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtcG9wb3Zlci10aXRsZVwiLCBpZDogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy50aXRsZSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJyksIHRpdGxlOiBvcHRpb25zLmNsb3NlSGludCwgb25DbGljazogdGhpcy5oYW5kbGVDbG9zZUNsaWNrIH0pKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpIH0sIHByb3BzLmNoaWxkcmVuKSksIHByb3BzLnBhcmVudEVsKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNSdGwgPSB0aGlzLmNvbnRleHQuaXNSdGw7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGFsaWdubWVudEVsID0gX2EuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCA9IF9hLmFsaWduR3JpZFRvcDtcbiAgICAgICAgdmFyIHJvb3RFbCA9IHRoaXMucm9vdEVsO1xuICAgICAgICB2YXIgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgdmFyIHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgdmFyIHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5fMSA9IHJvb3RFbC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHJvb3RFbCwge1xuICAgICAgICAgICAgICAgIHRvcDogcG9wb3ZlclRvcCAtIG9yaWdpbl8xLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3BvdmVyTGVmdCAtIG9yaWdpbl8xLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBvcG92ZXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIE1vcmVQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb3JlUG9wb3ZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3JlUG9wb3ZlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChyb290RWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vcmVQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGRhdGVFbnYgPSBfYS5kYXRlRW52O1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgc3RhcnREYXRlID0gcHJvcHMuc3RhcnREYXRlLCB0b2RheVJhbmdlID0gcHJvcHMudG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbFJvb3QsIHsgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBkYXlDbGFzc05hbWVzLCBkYXRhQXR0cnMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFBvcG92ZXIsIHsgZWxSZWY6IHJvb3RFbFJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZGF5Q2xhc3NOYW1lcyksIGV4dHJhQXR0cnM6IGRhdGFBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KERheUNlbGxDb250ZW50LCB7IGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLW1vcmUtcG9wb3Zlci1taXNjXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbikpOyB9KSk7XG4gICAgfTtcbiAgICBNb3JlUG9wb3Zlci5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcm9vdEVsID0gX2Eucm9vdEVsLCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxuICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogX19hc3NpZ24oeyBhbGxEYXk6IHRydWUsIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE1vcmVQb3BvdmVyO1xufShEYXRlQ29tcG9uZW50KSk7XG5cbnZhciBNb3JlTGlua1Jvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vcmVMaW5rUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3JlTGlua1Jvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBtb3JlTGlua0NsaWNrID0gY29udGV4dC5vcHRpb25zLm1vcmVMaW5rQ2xpY2s7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGNvbXB1dGVSYW5nZShwcm9wcykuc3RhcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZFB1YmxpY1NlZyhzZWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBzZWcuZXZlbnRSYW5nZSwgZGVmID0gX2EuZGVmLCBpbnN0YW5jZSA9IF9hLmluc3RhbmNlLCByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb3JlTGlua0NsaWNrID0gbW9yZUxpbmtDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGFsbERheTogQm9vbGVhbihwcm9wcy5hbGxEYXlEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VnczogcHJvcHMuYWxsU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vcmVMaW5rQ2xpY2sgfHwgbW9yZUxpbmtDbGljayA9PT0gJ3BvcG92ZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdmlld0FwaSA9IGNvbnRleHQudmlld0FwaSwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgY2FsZW5kYXJBcGkgPSBjb250ZXh0LmNhbGVuZGFyQXBpO1xuICAgICAgICAgICAgdmFyIG1vcmVMaW5rVGV4dCA9IG9wdGlvbnMubW9yZUxpbmtUZXh0O1xuICAgICAgICAgICAgdmFyIG1vcmVDbnQgPSBwcm9wcy5tb3JlQ250O1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcbiAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxuICAgICAgICAgICAgICAgIDogXCIrXCIgKyBtb3JlQ250ICsgXCIgXCIgKyBtb3JlTGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5tb3JlTGlua0hpbnQsIFttb3JlQ250XSwgdGV4dCk7XG4gICAgICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IFwiK1wiICsgbW9yZUNudCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIEJvb2xlYW4ocHJvcHMubW9yZUNudCkgJiYgKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBlbFJlZjogX3RoaXMubGlua0VsUmVmLCBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5tb3JlTGlua0NsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMubW9yZUxpbmtDb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgWydmYy1tb3JlLWxpbmsnXS5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgX3RoaXMuaGFuZGxlQ2xpY2ssIHRpdGxlLCBzdGF0ZS5pc1BvcG92ZXJPcGVuLCBzdGF0ZS5pc1BvcG92ZXJPcGVuID8gc3RhdGUucG9wb3ZlcklkIDogJycpOyB9KSksXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAoY3JlYXRlRWxlbWVudChNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IF90aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IF90aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSB9LCBwcm9wcy5wb3BvdmVyQ29udGVudCgpKSkpKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9O1xuICAgIE1vcmVMaW5rUm9vdC5wcm90b3R5cGUudXBkYXRlUGFyZW50RWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtFbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWxSZWYuY3VycmVudCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vcmVMaW5rUm9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGlkZGVuU2VncyA9IHByb3BzLmhpZGRlblNlZ3M7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpLFxuICAgICAgICBlbmQ6IGNvbXB1dGVMYXRlc3RTZWdFbmQoaGlkZGVuU2VncyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0VhcmxpZXN0U3RhcnQpLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG59XG5mdW5jdGlvbiBwaWNrRWFybGllc3RTdGFydChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA8IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA/IHNlZzAgOiBzZWcxO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxhdGVzdFNlZ0VuZChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tMYXRlc3RFbmQpLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gcGlja0xhdGVzdEVuZChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPiBzZWcxLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID8gc2VnMCA6IHNlZzE7XG59XG5cbi8vIGV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdmVyc2lvbiA9ICc1LjEwLjEnOyAvLyBpbXBvcnRhbnQgdG8gdHlwZSBpdCwgc28gLmQudHMgaGFzIGdlbmVyaWMgc3RyaW5nXG5cbmV4cG9ydCB7IEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBCQVNFX09QVElPTl9SRUZJTkVSUywgQmFzZUNvbXBvbmVudCwgQmdFdmVudCwgQ2FsZW5kYXJBcGksIENhbGVuZGFyQ29udGVudCwgQ2FsZW5kYXJEYXRhTWFuYWdlciwgQ2FsZW5kYXJEYXRhUHJvdmlkZXIsIENhbGVuZGFyUm9vdCwgQ29udGVudEhvb2ssIEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LCBEYXRlQ29tcG9uZW50LCBEYXRlRW52LCBEYXRlUHJvZmlsZUdlbmVyYXRvciwgRGF5Q2VsbENvbnRlbnQsIERheUNlbGxSb290LCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBEZWxheWVkUnVubmVyLCBFbGVtZW50RHJhZ2dpbmcsIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLCBFbWl0dGVyLCBFdmVudEFwaSwgRXZlbnRSb290LCBFdmVudFNvdXJjZUFwaSwgSW50ZXJhY3Rpb24sIE1vcmVMaW5rUm9vdCwgTW91bnRIb29rLCBOYW1lZFRpbWVab25lSW1wbCwgTm93SW5kaWNhdG9yUm9vdCwgTm93VGltZXIsIFBvc2l0aW9uQ2FjaGUsIFJlZk1hcCwgUmVuZGVySG9vaywgU2Nyb2xsQ29udHJvbGxlciwgU2Nyb2xsUmVzcG9uZGVyLCBTY3JvbGxlciwgU2VnSGllcmFyY2h5LCBTaW1wbGVTY3JvbGxHcmlkLCBTbGljZXIsIFNwbGl0dGVyLCBTdGFuZGFyZEV2ZW50LCBUYWJsZURhdGVDZWxsLCBUYWJsZURvd0NlbGwsIFRoZW1lLCBWaWV3QXBpLCBWaWV3Q29udGV4dFR5cGUsIFZpZXdSb290LCBXZWVrTnVtYmVyUm9vdCwgV2luZG93U2Nyb2xsQ29udHJvbGxlciwgYWRkRGF5cywgYWRkRHVyYXRpb25zLCBhZGRNcywgYWRkV2Vla3MsIGFsbG93Q29udGV4dE1lbnUsIGFsbG93U2VsZWN0aW9uLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlLCBhcHBseVN0eWxlLCBhcHBseVN0eWxlUHJvcCwgYXNDbGVhbkRheXMsIGFzUm91Z2hNaW51dGVzLCBhc1JvdWdoTXMsIGFzUm91Z2hTZWNvbmRzLCBiaW5hcnlTZWFyY2gsIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciwgYnVpbGRFbnRyeUtleSwgYnVpbGRFdmVudEFwaXMsIGJ1aWxkRXZlbnRSYW5nZUtleSwgYnVpbGRIYXNoRnJvbUFycmF5LCBidWlsZElzb1N0cmluZywgYnVpbGROYXZMaW5rQXR0cnMsIGJ1aWxkU2VnQ29tcGFyZU9iaiwgYnVpbGRTZWdUaW1lVGV4dCwgY29sbGVjdEZyb21IYXNoLCBjb21iaW5lRXZlbnRVaXMsIGNvbXBhcmVCeUZpZWxkU3BlYywgY29tcGFyZUJ5RmllbGRTcGVjcywgY29tcGFyZU51bWJlcnMsIGNvbXBhcmVPYmpzLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCwgY29tcHV0ZUVkZ2VzLCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQsIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zLCBjb21wdXRlSW5uZXJSZWN0LCBjb21wdXRlUmVjdCwgY29tcHV0ZVNlZ0RyYWdnYWJsZSwgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSwgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlLCBjb21wdXRlU2hyaW5rV2lkdGgsIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCwgY29tcHV0ZVZpc2libGVEYXlSYW5nZSwgY29uZmlnLCBjb25zdHJhaW5Qb2ludCwgY3JlYXRlQXJpYUNsaWNrQXR0cnMsIGNyZWF0ZUR1cmF0aW9uLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIGNyZWF0ZUV2ZW50SW5zdGFuY2UsIGNyZWF0ZUV2ZW50VWksIGNyZWF0ZUZvcm1hdHRlciwgY3JlYXRlUGx1Z2luLCBkaWZmRGF0ZXMsIGRpZmZEYXlBbmRUaW1lLCBkaWZmRGF5cywgZGlmZlBvaW50cywgZGlmZldlZWtzLCBkaWZmV2hvbGVEYXlzLCBkaWZmV2hvbGVXZWVrcywgZGlzYWJsZUN1cnNvciwgZWxlbWVudENsb3Nlc3QsIGVsZW1lbnRNYXRjaGVzLCBlbmFibGVDdXJzb3IsIGV2ZW50VHVwbGVUb1N0b3JlLCBmaWx0ZXJFdmVudFN0b3JlRGVmcywgZmlsdGVySGFzaCwgZmluZERpcmVjdENoaWxkcmVuLCBmaW5kRWxlbWVudHMsIGZsZXhpYmxlQ29tcGFyZSwgZm9ybWF0RGF0ZSwgZm9ybWF0RGF5U3RyaW5nLCBmb3JtYXRJc29UaW1lU3RyaW5nLCBmb3JtYXRSYW5nZSwgZ2V0QWxsb3dZU2Nyb2xsaW5nLCBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwsIGdldENsaXBwaW5nUGFyZW50cywgZ2V0RGF0ZU1ldGEsIGdldERheUNsYXNzTmFtZXMsIGdldERlZmF1bHRFdmVudEVuZCwgZ2V0RWxSb290LCBnZXRFbFNlZywgZ2V0RW50cnlTcGFuRW5kLCBnZXRFdmVudENsYXNzTmFtZXMsIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCwgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQsIGdldFJlY3RDZW50ZXIsIGdldFJlbGV2YW50RXZlbnRzLCBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcywgZ2V0U2Nyb2xsYmFyV2lkdGhzLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCwgZ2V0U2VnQW5jaG9yQXR0cnMsIGdldFNlZ01ldGEsIGdldFNsb3RDbGFzc05hbWVzLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIGdldFN0aWNreUhlYWRlckRhdGVzLCBnZXRVbmVxdWFsUHJvcHMsIGdldFVuaXF1ZURvbUlkLCBnbG9iYWxMb2NhbGVzLCBnbG9iYWxQbHVnaW5zLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcywgZ3VpZCwgaGFzQmdSZW5kZXJpbmcsIGhhc1Nocmlua1dpZHRoLCBpZGVudGl0eSwgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSwgaW50ZXJzZWN0UmFuZ2VzLCBpbnRlcnNlY3RSZWN0cywgaW50ZXJzZWN0U3BhbnMsIGlzQXJyYXlzRXF1YWwsIGlzQ29sUHJvcHNFcXVhbCwgaXNEYXRlU2VsZWN0aW9uVmFsaWQsIGlzRGF0ZVNwYW5zRXF1YWwsIGlzSW50LCBpc0ludGVyYWN0aW9uVmFsaWQsIGlzTXVsdGlEYXlSYW5nZSwgaXNQcm9wc0VxdWFsLCBpc1Byb3BzVmFsaWQsIGlzVmFsaWREYXRlLCBqb2luU3BhbnMsIGxpc3RlbkJ5U2VsZWN0b3IsIG1hcEhhc2gsIG1lbW9pemUsIG1lbW9pemVBcnJheWxpa2UsIG1lbW9pemVIYXNobGlrZSwgbWVtb2l6ZU9iakFyZywgbWVyZ2VFdmVudFN0b3JlcywgbXVsdGlwbHlEdXJhdGlvbiwgcGFkU3RhcnQsIHBhcnNlQnVzaW5lc3NIb3VycywgcGFyc2VDbGFzc05hbWVzLCBwYXJzZURyYWdNZXRhLCBwYXJzZUV2ZW50RGVmLCBwYXJzZUZpZWxkU3BlY3MsIHBhcnNlIGFzIHBhcnNlTWFya2VyLCBwb2ludEluc2lkZVJlY3QsIHByZXZlbnRDb250ZXh0TWVudSwgcHJldmVudERlZmF1bHQsIHByZXZlbnRTZWxlY3Rpb24sIHJhbmdlQ29udGFpbnNNYXJrZXIsIHJhbmdlQ29udGFpbnNSYW5nZSwgcmFuZ2VzRXF1YWwsIHJhbmdlc0ludGVyc2VjdCwgcmVmaW5lRXZlbnREZWYsIHJlZmluZVByb3BzLCByZW1vdmVFbGVtZW50LCByZW1vdmVFeGFjdCwgcmVuZGVyQ2h1bmtDb250ZW50LCByZW5kZXJGaWxsLCByZW5kZXJNaWNyb0NvbEdyb3VwLCByZW5kZXJTY3JvbGxTaGltLCByZXF1ZXN0SnNvbiwgc2FuaXRpemVTaHJpbmtXaWR0aCwgc2V0RWxTZWcsIHNldFJlZiwgc2xpY2VFdmVudFN0b3JlLCBzbGljZUV2ZW50cywgc29ydEV2ZW50U2Vncywgc3RhcnRPZkRheSwgdHJhbnNsYXRlUmVjdCwgdHJpZ2dlckRhdGVTZWxlY3QsIHVucHJvbWlzaWZ5LCB2ZXJzaW9uLCB3aGVuVHJhbnNpdGlvbkRvbmUsIHdob2xlRGl2aWRlRHVyYXRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiX19zcHJlYWRBcnJheSIsIl9fZXh0ZW5kcyIsImNyZWF0ZUNvbnRleHQiLCJDb21wb25lbnQiLCJjcmVhdGVSZWYiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJjcmVhdGVQb3J0YWwiLCJFdmVudFNvdXJjZUFwaSIsImNvbnRleHQiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicHJvdG90eXBlIiwicmVtb3ZlIiwiZGlzcGF0Y2giLCJ0eXBlIiwic291cmNlSWQiLCJyZWZldGNoIiwic291cmNlSWRzIiwiaXNSZWZldGNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJwdWJsaWNJZCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtZXRhIiwidXJsIiwiZm9ybWF0IiwicmVtb3ZlRWxlbWVudCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZWxlbWVudENsb3Nlc3QiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiZWxlbWVudE1hdGNoZXMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJtZXRob2QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJjYWxsIiwiZmluZEVsZW1lbnRzIiwiY29udGFpbmVyIiwiY29udGFpbmVycyIsIkhUTUxFbGVtZW50IiwiYWxsTWF0Y2hlcyIsImkiLCJsZW5ndGgiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaiIsInB1c2giLCJmaW5kRGlyZWN0Q2hpbGRyZW4iLCJwYXJlbnQiLCJwYXJlbnRzIiwiY2hpbGROb2RlcyIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwiUElYRUxfUFJPUF9SRSIsImFwcGx5U3R5bGUiLCJwcm9wcyIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJuYW1lIiwidmFsIiwic3R5bGUiLCJ0ZXN0IiwiZ2V0RXZlbnRUYXJnZXRWaWFSb290IiwiZXYiLCJfYSIsIl9iIiwiY29tcG9zZWRQYXRoIiwidGFyZ2V0IiwiZ2V0RWxSb290IiwiZ2V0Um9vdE5vZGUiLCJndWlkJDEiLCJnZXRVbmlxdWVEb21JZCIsInByZXZlbnREZWZhdWx0IiwiYnVpbGREZWxlZ2F0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJtYXRjaGVkQ2hpbGQiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiZXZlbnRUeXBlIiwiYXR0YWNoZWRIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsImN1cnJlbnRNYXRjaGVkQ2hpbGQiLCJtb3VzZU92ZXJFdiIsInJlYWxPbk1vdXNlTGVhdmVfMSIsIm1vdXNlTGVhdmVFdiIsInRyYW5zaXRpb25FdmVudE5hbWVzIiwid2hlblRyYW5zaXRpb25Eb25lIiwiY2FsbGJhY2siLCJyZWFsQ2FsbGJhY2siLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwiY3JlYXRlQXJpYUNsaWNrQXR0cnMiLCJvbkNsaWNrIiwiY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMiLCJ0YWJJbmRleCIsIm9uS2V5RG93biIsImtleSIsImd1aWROdW1iZXIiLCJndWlkIiwiU3RyaW5nIiwiZGlzYWJsZUN1cnNvciIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJlbmFibGVDdXJzb3IiLCJwcmV2ZW50U2VsZWN0aW9uIiwiYWxsb3dTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJhbGxvd0NvbnRleHRNZW51IiwicGFyc2VGaWVsZFNwZWNzIiwiaW5wdXQiLCJzcGVjcyIsInRva2VucyIsInRva2VuIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJjaGFyQXQiLCJmaWVsZCIsInN1YnN0cmluZyIsIm9yZGVyIiwiZnVuYyIsImNvbXBhcmVCeUZpZWxkU3BlY3MiLCJvYmowIiwib2JqMSIsImZpZWxkU3BlY3MiLCJjbXAiLCJjb21wYXJlQnlGaWVsZFNwZWMiLCJmaWVsZFNwZWMiLCJmbGV4aWJsZUNvbXBhcmUiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJwYWRTdGFydCIsImxlbiIsInMiLCJzdWJzdHIiLCJmb3JtYXRXaXRoT3JkaW5hbHMiLCJmb3JtYXR0ZXIiLCJhcmdzIiwiZmFsbGJhY2tUZXh0IiwiYXBwbHkiLCJyZWR1Y2UiLCJzdHIiLCJhcmciLCJpbmRleCIsInJlcGxhY2UiLCJjb21wYXJlTnVtYmVycyIsImlzSW50IiwibiIsImNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCIsImNlbGxFbCIsImFsbFdpZHRoRWwiLCJxdWVyeVNlbGVjdG9yIiwiY29udGVudFdpZHRoRWwiLCJFcnJvciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiREFZX0lEUyIsImFkZFdlZWtzIiwibSIsImRhdGVUb1V0Y0FycmF5IiwiYXJyYXlUb1V0Y0RhdGUiLCJhZGREYXlzIiwiYWRkTXMiLCJkaWZmV2Vla3MiLCJtMCIsIm0xIiwiZGlmZkRheXMiLCJ2YWx1ZU9mIiwiZGlmZkhvdXJzIiwiZGlmZk1pbnV0ZXMiLCJkaWZmU2Vjb25kcyIsImRpZmZEYXlBbmRUaW1lIiwibTBkYXkiLCJzdGFydE9mRGF5IiwibTFkYXkiLCJ5ZWFycyIsIm1vbnRocyIsImRheXMiLCJNYXRoIiwicm91bmQiLCJtaWxsaXNlY29uZHMiLCJkaWZmV2hvbGVXZWVrcyIsImQiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsInkiLCJ3Iiwid2Vla09mR2l2ZW5ZZWFyIiwibmV4dFciLCJtaW4iLCJ5ZWFyIiwiZmlyc3RXZWVrU3RhcnQiLCJmaXJzdFdlZWtPZmZzZXQiLCJkYXlTdGFydCIsImZsb29yIiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXRlVG9Mb2NhbEFycmF5IiwiZGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImFycmF5VG9Mb2NhbERhdGUiLCJEYXRlIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY29uY2F0IiwiVVRDIiwiaXNWYWxpZERhdGUiLCJpc05hTiIsImNyZWF0ZUV2ZW50SW5zdGFuY2UiLCJkZWZJZCIsInJhbmdlIiwiZm9yY2VkU3RhcnRUem8iLCJmb3JjZWRFbmRUem8iLCJpbnN0YW5jZUlkIiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZVByb3BzIiwicHJvcE9ianMiLCJjb21wbGV4UHJvcHNNYXAiLCJkZXN0IiwibmFtZV8xIiwiY29tcGxleE9ianMiLCJ1bnNoaWZ0IiwidW5kZWZpbmVkIiwibmFtZV8yIiwiZmlsdGVySGFzaCIsImhhc2giLCJmaWx0ZXJlZCIsIm1hcEhhc2giLCJuZXdIYXNoIiwiYXJyYXlUb0hhc2giLCJfaSIsImFfMSIsIml0ZW0iLCJidWlsZEhhc2hGcm9tQXJyYXkiLCJ0dXBsZSIsImhhc2hWYWx1ZXNUb0FycmF5Iiwib2JqIiwiaXNQcm9wc0VxdWFsIiwiZ2V0VW5lcXVhbFByb3BzIiwia2V5cyIsImNvbXBhcmVPYmpzIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsImVxdWFsaXR5RnVuY3MiLCJpc09ialZhbHNFcXVhbCIsInZhbDAiLCJ2YWwxIiwiY29tcGFyYXRvciIsImNvbGxlY3RGcm9tSGFzaCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInN0ZXAiLCJyZXMiLCJwYXJzZVJlY3VycmluZyIsInJlZmluZWQiLCJkZWZhdWx0QWxsRGF5IiwiZGF0ZUVudiIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwicGFyc2UiLCJhbGxEYXkiLCJhbGxEYXlHdWVzcyIsImR1cmF0aW9uIiwidHlwZURhdGEiLCJ0eXBlSWQiLCJleHBhbmRSZWN1cnJpbmciLCJldmVudFN0b3JlIiwiZnJhbWluZ1JhbmdlIiwicGx1Z2luSG9va3MiLCJvcHRpb25zIiwiZGVmcyIsImluc3RhbmNlcyIsImluc3RhbmNlIiwicmVjdXJyaW5nRGVmIiwiZGVmIiwiZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24iLCJkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uIiwic3RhcnRzIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwic3RhcnRzXzEiLCJzdGFydCIsImVuZCIsImV2ZW50RGVmIiwidHlwZURlZiIsIm1hcmtlcnMiLCJleHBhbmQiLCJzdWJ0cmFjdCIsIm1hcCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwiZXhlYyIsInNpZ24iLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91cnMiLCJob3VyIiwibWludXRlcyIsIm1pbnV0ZSIsInNlY29uZHMiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsIm1zIiwid2Vla3MiLCJ3ZWVrIiwic3BlY2lmaWVkV2Vla3MiLCJkdXJhdGlvbnNFcXVhbCIsImQwIiwiZDEiLCJhc0NsZWFuRGF5cyIsImR1ciIsImFkZER1cmF0aW9ucyIsInN1YnRyYWN0RHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFzUm91Z2hZZWFycyIsImFzUm91Z2hEYXlzIiwiYXNSb3VnaE1vbnRocyIsImFzUm91Z2hNcyIsImFzUm91Z2hNaW51dGVzIiwiYXNSb3VnaFNlY29uZHMiLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwibG9jYWxSZXMiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJ2YWx1ZSIsImJ1aWxkSXNvU3RyaW5nIiwidGltZVpvbmVPZmZzZXQiLCJzdHJpcFplcm9UaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRUaW1lWm9uZU9mZnNldCIsImZvcm1hdERheVN0cmluZyIsImZvcm1hdElzb1RpbWVTdHJpbmciLCJkb0lzbyIsImFicyIsIm1pbnMiLCJyZW1vdmVFeGFjdCIsImFycmF5IiwiZXhhY3RWYWwiLCJyZW1vdmVDbnQiLCJzcGxpY2UiLCJpc0FycmF5c0VxdWFsIiwiYTAiLCJhMSIsImVxdWFsaXR5RnVuYyIsIm1lbW9pemUiLCJ3b3JrZXJGdW5jIiwicmVzRXF1YWxpdHkiLCJ0ZWFyZG93bkZ1bmMiLCJjdXJyZW50QXJncyIsImN1cnJlbnRSZXMiLCJuZXdBcmdzIiwiYXJndW1lbnRzIiwibWVtb2l6ZU9iakFyZyIsIl90aGlzIiwiY3VycmVudEFyZyIsIm5ld0FyZyIsIm1lbW9pemVBcnJheWxpa2UiLCJjdXJyZW50QXJnU2V0cyIsImN1cnJlbnRSZXN1bHRzIiwibmV3QXJnU2V0cyIsImN1cnJlbnRMZW4iLCJuZXdMZW4iLCJtZW1vaXplSGFzaGxpa2UiLCJjdXJyZW50QXJnSGFzaCIsImN1cnJlbnRSZXNIYXNoIiwibmV3QXJnSGFzaCIsIm5ld1Jlc0hhc2giLCJFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyIsInNlcGFyYXRvciIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJvbWl0Q29tbWFzIiwiU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMiLCJ0aW1lWm9uZU5hbWUiLCJlcmEiLCJ3ZWVrZGF5IiwiTUVSSURJRU1fUkUiLCJDT01NQV9SRSIsIk1VTFRJX1NQQUNFX1JFIiwiTFRSX1JFIiwiVVRDX1JFIiwiTmF0aXZlRm9ybWF0dGVyIiwiZm9ybWF0U2V0dGluZ3MiLCJzdGFuZGFyZERhdGVQcm9wcyIsImV4dGVuZGVkU2V0dGluZ3MiLCJzZXZlcml0eSIsIm1heCIsImJ1aWxkRm9ybWF0dGluZ0Z1bmMiLCJmb3JtYXRSYW5nZSIsImJldHRlckRlZmF1bHRTZXBhcmF0b3IiLCJkaWZmU2V2ZXJpdHkiLCJjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5IiwiY2FsZW5kYXJTeXN0ZW0iLCJiaWdnZXN0VW5pdEZvclBhcnRpYWwiLCJmdWxsMCIsImZ1bGwxIiwicGFydGlhbERhdGVQcm9wcyIsImNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMiLCJwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMiLCJwYXJ0aWFsMCIsInBhcnRpYWwxIiwiaW5zZXJ0aW9uIiwiZmluZENvbW1vbkluc2VydGlvbiIsImRlZmF1bHRTZXBhcmF0b3IiLCJiZWZvcmUiLCJhZnRlciIsImdldExhcmdlc3RVbml0Iiwic3RhbmRhcmREYXRlUHJvcENudCIsImZvcm1hdFdlZWtOdW1iZXIiLCJjb21wdXRlV2Vla051bWJlciIsIndlZWtUZXh0Iiwid2Vla1RleHRMb25nIiwibG9jYWxlIiwiYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyIsInNhbml0aXplU2V0dGluZ3MiLCJ0aW1lWm9uZSIsIm5vcm1hbEZvcm1hdCIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImNvZGVzIiwiemVyb0Zvcm1hdCIsInplcm9Qcm9wcyIsInBvc3RQcm9jZXNzIiwiaW5qZWN0VHpvU3RyIiwidHJpbSIsInRvTG9jYWxlTG93ZXJDYXNlIiwidHpvU3RyIiwicmVwbGFjZWQiLCJudW0iLCJkaXNwbGF5IiwicGFydHMiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJkaXJlY3Rpb24iLCJyZXZlcnNlIiwiam9pbiIsImNhIiwiZ2V0TWFya2VyWWVhciIsImdldE1hcmtlck1vbnRoIiwiZ2V0TWFya2VyRGF5IiwiYmlnZ2VzdFVuaXQiLCJwYXJ0aWFsT3B0aW9ucyIsImkwIiwiZm91bmQwIiwiaW5kZXhPZiIsImJlZm9yZTAiLCJhZnRlcjAiLCJpMSIsImZvdW5kMSIsImJlZm9yZTEiLCJhZnRlcjEiLCJleHBhbmRab25lZE1hcmtlciIsImRhdGVJbmZvIiwibWFya2VyVG9BcnJheSIsImNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnIiwic3RhcnRJbmZvIiwiZW5kSW5mbyIsImxvY2FsZUNvZGVzIiwiQ21kRm9ybWF0dGVyIiwiY21kU3RyIiwiY21kRm9ybWF0dGVyIiwiRnVuY0Zvcm1hdHRlciIsImNyZWF0ZUZvcm1hdHRlciIsIkJBU0VfT1BUSU9OX1JFRklORVJTIiwibmF2TGlua0RheUNsaWNrIiwiaWRlbnRpdHkiLCJuYXZMaW5rV2Vla0NsaWNrIiwiYm9vdHN0cmFwRm9udEF3ZXNvbWUiLCJidXR0b25JY29ucyIsImN1c3RvbUJ1dHRvbnMiLCJuZXh0RGF5VGhyZXNob2xkIiwic2Nyb2xsVGltZSIsInNjcm9sbFRpbWVSZXNldCIsIkJvb2xlYW4iLCJzbG90TWluVGltZSIsInNsb3RNYXhUaW1lIiwiZGF5UG9wb3ZlckZvcm1hdCIsInNsb3REdXJhdGlvbiIsInNuYXBEdXJhdGlvbiIsImhlYWRlclRvb2xiYXIiLCJmb290ZXJUb29sYmFyIiwiZGVmYXVsdFJhbmdlU2VwYXJhdG9yIiwidGl0bGVSYW5nZVNlcGFyYXRvciIsImZvcmNlRXZlbnREdXJhdGlvbiIsImRheUhlYWRlcnMiLCJkYXlIZWFkZXJGb3JtYXQiLCJkYXlIZWFkZXJDbGFzc05hbWVzIiwiZGF5SGVhZGVyQ29udGVudCIsImRheUhlYWRlckRpZE1vdW50IiwiZGF5SGVhZGVyV2lsbFVubW91bnQiLCJkYXlDZWxsQ2xhc3NOYW1lcyIsImRheUNlbGxDb250ZW50IiwiZGF5Q2VsbERpZE1vdW50IiwiZGF5Q2VsbFdpbGxVbm1vdW50IiwiaW5pdGlhbFZpZXciLCJhc3BlY3RSYXRpbyIsIk51bWJlciIsIndlZWtlbmRzIiwid2Vla051bWJlckNhbGN1bGF0aW9uIiwid2Vla051bWJlcnMiLCJ3ZWVrTnVtYmVyQ2xhc3NOYW1lcyIsIndlZWtOdW1iZXJDb250ZW50Iiwid2Vla051bWJlckRpZE1vdW50Iiwid2Vla051bWJlcldpbGxVbm1vdW50IiwiZWRpdGFibGUiLCJ2aWV3Q2xhc3NOYW1lcyIsInZpZXdEaWRNb3VudCIsInZpZXdXaWxsVW5tb3VudCIsIm5vd0luZGljYXRvciIsIm5vd0luZGljYXRvckNsYXNzTmFtZXMiLCJub3dJbmRpY2F0b3JDb250ZW50Iiwibm93SW5kaWNhdG9yRGlkTW91bnQiLCJub3dJbmRpY2F0b3JXaWxsVW5tb3VudCIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJsYXp5RmV0Y2hpbmciLCJzdGFydFBhcmFtIiwiZW5kUGFyYW0iLCJ0aW1lWm9uZVBhcmFtIiwibG9jYWxlcyIsInRoZW1lU3lzdGVtIiwiZHJhZ1JldmVydER1cmF0aW9uIiwiZHJhZ1Njcm9sbCIsImFsbERheU1haW50YWluRHVyYXRpb24iLCJ1bnNlbGVjdEF1dG8iLCJkcm9wQWNjZXB0IiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJoYW5kbGVXaW5kb3dSZXNpemUiLCJ3aW5kb3dSZXNpemVEZWxheSIsImxvbmdQcmVzc0RlbGF5IiwiZXZlbnREcmFnTWluRGlzdGFuY2UiLCJleHBhbmRSb3dzIiwiaGVpZ2h0IiwiY29udGVudEhlaWdodCIsIndlZWtOdW1iZXJGb3JtYXQiLCJldmVudFJlc2l6YWJsZUZyb21TdGFydCIsImRpc3BsYXlFdmVudFRpbWUiLCJkaXNwbGF5RXZlbnRFbmQiLCJwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nIiwiYnVzaW5lc3NIb3VycyIsImluaXRpYWxEYXRlIiwibm93IiwiZXZlbnREYXRhVHJhbnNmb3JtIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJzdGlja3lGb290ZXJTY3JvbGxiYXIiLCJ2aWV3SGVpZ2h0IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwibW9udGhNb2RlIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwiQkFTRV9PUFRJT05fREVGQVVMVFMiLCJjZW50ZXIiLCJDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyIsImRhdGVzU2V0IiwiZXZlbnRzU2V0IiwiZXZlbnRBZGQiLCJldmVudENoYW5nZSIsImV2ZW50UmVtb3ZlIiwid2luZG93UmVzaXplIiwiZXZlbnRDbGljayIsImV2ZW50TW91c2VFbnRlciIsImV2ZW50TW91c2VMZWF2ZSIsInNlbGVjdCIsInVuc2VsZWN0IiwibG9hZGluZyIsIl91bm1vdW50IiwiX2JlZm9yZXByaW50IiwiX2FmdGVycHJpbnQiLCJfbm9FdmVudERyb3AiLCJfbm9FdmVudFJlc2l6ZSIsIl9yZXNpemUiLCJfc2Nyb2xsUmVxdWVzdCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsImJ1dHRvblRleHQiLCJidXR0b25IaW50cyIsInZpZXdzIiwiaW5pdGlhbEV2ZW50cyIsImV2ZW50cyIsImV2ZW50U291cmNlcyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiaXNCb29sQ29tcGxleEVxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJleHRyYSIsInJhdyIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsImV2ZW50UmVmaW5lcnMiLCJidWlsZEV2ZW50UmVmaW5lcnMiLCJyYXdFdmVudHNfMSIsInJhd0V2ZW50IiwicGFyc2VFdmVudCIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJkZWZfMSIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsInN1YiIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY2xhc3NOYW1lIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzaW5nbGVSZXMiLCJwYXJzZVNpbmdsZSIsImhhc0VuZCIsInVpIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJtZW1iZXJBZGRlciIsImZyZWV6ZSIsInN0YXJ0TWV0YSIsInN0YXJ0TWFya2VyIiwiZW5kTWV0YSIsImVuZE1hcmtlciIsInN0YXJ0SW5wdXQiLCJjcmVhdGVNYXJrZXJNZXRhIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJmb3JjZWRUem8iLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsImNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsImRpZmZEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJsYXJnZVVuaXQiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsInNvcnQiLCJjb21wYXJlUmFuZ2VzIiwicmFuZ2UwIiwicmFuZ2UxIiwiaW50ZXJzZWN0UmFuZ2VzIiwibmV3UmFuZ2UiLCJyYW5nZXNFcXVhbCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsIm91dGVyUmFuZ2UiLCJpbm5lclJhbmdlIiwicmFuZ2VDb250YWluc01hcmtlciIsImNvbnN0cmFpbk1hcmtlclRvUmFuZ2UiLCJzbGljZUV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpbnZlcnNlQmdCeUdyb3VwSWQiLCJpbnZlcnNlQmdCeURlZklkIiwiZGVmQnlHcm91cElkIiwiYmdSYW5nZXMiLCJmZ1JhbmdlcyIsImV2ZW50VWlzIiwiY29tcGlsZUV2ZW50VWlzIiwib3JpZ1JhbmdlIiwibm9ybWFsUmFuZ2UiLCJzbGljZWRSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsImludmVydGVkUmFuZ2VzXzEiLCJpbnZlcnRlZFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXNfMiIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiYyIsIl9zZWciLCJldmVudFJhbmdlIiwiY29tcHV0ZVNlZ0RyYWdnYWJsZSIsInRyYW5zZm9ybWVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXJzXzEiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsImV2ZW50SW5zdGFuY2UiLCJ3aG9sZUV2ZW50U3RhcnQiLCJ3aG9sZUV2ZW50RW5kIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJpc1N0YXJ0RGF5IiwiaXNFbmREYXkiLCJnZXRTZWdNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJzZWdSYW5nZSIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImdldEV2ZW50Q2xhc3NOYW1lcyIsImlzTWlycm9yIiwiaXNEcmFnZ2FibGUiLCJpc1N0YXJ0UmVzaXphYmxlIiwiaXNFbmRSZXNpemFibGUiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzU2VsZWN0ZWQiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJnZXRTZWdBbmNob3JBdHRycyIsImhyZWYiLCJlbWl0dGVyIiwiaGFzSGFuZGxlcnMiLCJ0cmlnZ2VyIiwiZXZlbnQiLCJFdmVudEFwaSIsImpzRXZlbnQiLCJ2aWV3Iiwidmlld0FwaSIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsInN0YW5kYXJkUHJvcHMiLCJpc0RhdGVTcGFuc0VxdWFsIiwic3BhbjAiLCJzcGFuMSIsImlzU3BhblByb3BzRXF1YWwiLCJidWlsZERhdGVTcGFuQXBpIiwiYnVpbGRSYW5nZUFwaSIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJvbWl0VGltZSIsInRvRGF0ZSIsInN0YXJ0U3RyIiwiZm9ybWF0SXNvIiwiZW5kU3RyIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImRhdGVTcGFuIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJvcmlnRXZlbnQiLCJjYWxlbmRhckFwaSIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJnZXREZWZhdWx0RXZlbnRFbmQiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiZXZlbnRDb25maWdCYXNlIiwibXV0YXRpb24iLCJldmVudENvbmZpZ3MiLCJhcHBseU11dGF0aW9uVG9FdmVudERlZiIsImFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UiLCJldmVudENvbmZpZyIsInN0YXJ0RGVsdGEiLCJlbmREZWx0YSIsImNvcHkiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJhcHBsaWVyIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJWaWV3QXBpIiwiZ2V0Q3VycmVudERhdGEiLCJ2aWV3VGl0bGUiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiY3VycmVudFJhbmdlIiwiZ2V0T3B0aW9uIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJsYXRlc3RGZXRjaElkIiwiZmV0Y2hSYW5nZSIsInNvdXJjZURlZklkIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImV2ZW50U291cmNlRGVmcyIsInBhcnNlTWV0YSIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJkYXRlTWFya2VyIiwiZ2V0SW5pdGlhbERhdGUiLCJpbml0aWFsRGF0ZUlucHV0IiwiZ2V0Tm93Iiwibm93SW5wdXQiLCJjcmVhdGVOb3dNYXJrZXIiLCJDYWxlbmRhckFwaSIsImN1cnJlbnREYXRhTWFuYWdlciIsImJhdGNoUmVuZGVyaW5nIiwidXBkYXRlU2l6ZSIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsIm9uIiwiaGFuZGxlck5hbWUiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMiLCJjb25zb2xlIiwid2FybiIsIm9mZiIsImNoYW5nZVZpZXciLCJ2aWV3VHlwZSIsImRhdGVPclJhbmdlIiwiem9vbVRvIiwic3RhdGUiLCJzcGVjIiwidmlld1NwZWNzIiwiZ2V0VW5pdFZpZXdTcGVjIiwidG9vbGJhckNvbmZpZyIsInZpZXdUeXBlcyIsImhlYWRlciIsInZpZXdzV2l0aEJ1dHRvbnMiLCJmb290ZXIiLCJzaW5nbGVVbml0IiwicHJldiIsIm5leHQiLCJwcmV2WWVhciIsImFkZFllYXJzIiwibmV4dFllYXIiLCJ0b2RheSIsImNhbGVuZGFyT3B0aW9ucyIsImdvdG9EYXRlIiwiem9uZWREYXRlSW5wdXQiLCJpbmNyZW1lbnREYXRlIiwiZGVsdGFJbnB1dCIsImRlbHRhIiwiZm9ybWF0RGF0ZSIsInNldHRpbmdzIiwiZGF0ZU9yT2JqIiwiZW5kRGF0ZSIsInNlbGVjdGlvbklucHV0IiwiZGF0ZVNlbGVjdGlvbiIsImFkZEV2ZW50IiwiZXZlbnRJbnB1dCIsInNvdXJjZUlucHV0IiwiX2RlZiIsIl9pbnN0YW5jZSIsImN1cnJlbnREYXRhIiwidHJpZ2dlckV2ZW50QWRkIiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwibmV3RXZlbnRBcGkiLCJldmVudEFwaSIsInJlbGF0ZWRFdmVudHMiLCJyZXZlcnQiLCJldmVudEFwaVRvU3RvcmUiLCJnZXRFdmVudEJ5SWQiLCJnZXRFdmVudHMiLCJidWlsZEV2ZW50QXBpcyIsInJlbW92ZUFsbEV2ZW50cyIsImdldEV2ZW50U291cmNlcyIsInNvdXJjZUhhc2giLCJzb3VyY2VBcGlzIiwiaW50ZXJuYWxJZCIsImFkZEV2ZW50U291cmNlIiwic291cmNlcyIsInJlbW92ZUFsbEV2ZW50U291cmNlcyIsInJlZmV0Y2hFdmVudHMiLCJzY3JvbGxUb1RpbWUiLCJ0aW1lSW5wdXQiLCJ0aW1lIiwiX2NvbnRleHQiLCJzZXRQcm9wIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsImNvbnRleHRfMSIsImV2ZW50U3RvcmVfMSIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJhc1N0b3JlIiwidG9QbGFpbk9iamVjdCIsImNvbGxhcHNlQ29sb3IiLCJjb2xsYXBzZUV4dGVuZGVkUHJvcHMiLCJ0b0pTT04iLCJleGNsdWRlSW5zdGFuY2UiLCJldmVudEFwaXMiLCJleGNsdWRlSW5zdGFuY2VJZCIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsIkRhdGVFbnYiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwidGltZXN0YW1wVG9NYXJrZXIiLCJnZXRZZWFyIiwiYWRkTW9udGhzIiwiZ3JlYXRlc3RXaG9sZVVuaXQiLCJjb3VudER1cmF0aW9uc0JldHdlZW4iLCJkaWZmIiwic3RhcnRPZiIsInN0YXJ0T2ZZZWFyIiwic3RhcnRPZk1vbnRoIiwic3RhcnRPZldlZWsiLCJkYXRlT3B0aW9ucyIsIm9mZnNldEZvck1hcmtlciIsImlzRW5kRXhjbHVzaXZlIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0IiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJnbG9iYWxMb2NhbGVzIiwiTUlOSU1BTF9SQVdfRU5fTE9DQUxFIiwiY29kZSIsImxpc3QiLCJSQVdfRU5fTE9DQUxFIiwiZXZlbnRDbnQiLCJvcmdhbml6ZVJhd0xvY2FsZXMiLCJleHBsaWNpdFJhd0xvY2FsZXMiLCJkZWZhdWx0Q29kZSIsImFsbFJhd0xvY2FsZXMiLCJyYXdMb2NhbGVNYXAiLCJlbiIsImFsbFJhd0xvY2FsZXNfMSIsInJhd0xvY2FsZSIsImJ1aWxkTG9jYWxlIiwiaW5wdXRTaW5ndWxhciIsImF2YWlsYWJsZSIsInBhcnNlTG9jYWxlIiwicXVlcnlMb2NhbGUiLCJjb2RlQXJnIiwicXVlcnlSYXdMb2NhbGUiLCJzaW1wbGVJZCIsInNsaWNlIiwibWVyZ2VkIiwiTnVtYmVyRm9ybWF0IiwiZGF0ZUlucHV0IiwiYnVpbGREYXRlRW52JDEiLCJkYXRlTWV0YSIsIkRFRl9ERUZBVUxUUyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkYXlzT2ZXZWVrIiwicGFyc2VCdXNpbmVzc0hvdXJzIiwicmVmaW5lSW5wdXRzIiwicmF3RGVmcyIsImZpbHRlciIsInJhd0RlZiIsInBvaW50SW5zaWRlUmVjdCIsInBvaW50IiwicmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImludGVyc2VjdFJlY3RzIiwicmVjdDEiLCJyZWN0MiIsInRyYW5zbGF0ZVJlY3QiLCJkZWx0YVgiLCJkZWx0YVkiLCJjb25zdHJhaW5Qb2ludCIsImdldFJlY3RDZW50ZXIiLCJkaWZmUG9pbnRzIiwicG9pbnQxIiwicG9pbnQyIiwiY2FuVkdyb3dXaXRoaW5DZWxsIiwiZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIiwiY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCIsInBvc2l0aW9uIiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJkaXYiLCJwb3NzaWJsZSIsIm9mZnNldEhlaWdodCIsIkVNUFRZX0VWRU5UX1NUT1JFIiwiU3BsaXR0ZXIiLCJnZXRLZXlzRm9yRXZlbnREZWZzIiwiX2dldEtleXNGb3JFdmVudERlZnMiLCJzcGxpdERhdGVTZWxlY3Rpb24iLCJfc3BsaXREYXRlU3BhbiIsInNwbGl0RXZlbnRTdG9yZSIsIl9zcGxpdEV2ZW50U3RvcmUiLCJzcGxpdEluZGl2aWR1YWxVaSIsIl9zcGxpdEluZGl2aWR1YWxVaSIsInNwbGl0RXZlbnREcmFnIiwiX3NwbGl0SW50ZXJhY3Rpb24iLCJzcGxpdEV2ZW50UmVzaXplIiwiZXZlbnRVaUJ1aWxkZXJzIiwic3BsaXRQcm9wcyIsImtleUluZm9zIiwiZ2V0S2V5SW5mbyIsImRlZktleXMiLCJkYXRlU2VsZWN0aW9ucyIsImluZGl2aWR1YWxVaSIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplcyIsImV2ZW50UmVzaXplIiwiaW5mbyIsImJ1aWxkRXZlbnRVaUZvcktleSIsImtleUluZm8iLCJidWlsZEV2ZW50VWkiLCJldmVudFNlbGVjdGlvbiIsImRhdGVTcGFucyIsImdldEtleXNGb3JEYXRlU3BhbiIsImtleXNfMSIsImdldEtleXNGb3JFdmVudERlZiIsInNwbGl0U3RvcmVzIiwiX2MiLCJzcGxpdEhhc2hlcyIsImludGVyYWN0aW9uIiwic3BsaXRTdGF0ZXMiLCJhZmZlY3RlZFN0b3Jlc18xIiwiYWZmZWN0ZWRFdmVudHMiLCJtdXRhdGVkS2V5c0J5RGVmSWQiLCJtdXRhdGVkRXZlbnRzIiwibXV0YXRlZFN0b3Jlc18xIiwicG9wdWxhdGUiLCJpc0V2ZW50IiwiYWxsVWkiLCJldmVudFVpRm9yS2V5IiwiYmFzZVBhcnRzIiwic3R1ZmYiLCJnZXREYXRlTWV0YSIsImlzRGlzYWJsZWQiLCJpc090aGVyIiwiZ2V0RGF5Q2xhc3NOYW1lcyIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJnZXRTbG90Q2xhc3NOYW1lcyIsIkRBWV9GT1JNQVQiLCJXRUVLX0ZPUk1BVCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiaXNUYWJiYWJsZSIsImRhdGVTdHIiLCJ6b25lZERhdGUiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImN1c3RvbUFjdGlvbiIsIl9pc1J0bFNjcm9sbGJhck9uTGVmdCIsImdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0Iiwib3V0ZXJFbCIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImlubmVyRWwiLCJmaXJzdENoaWxkIiwiX3Njcm9sbGJhcldpZHRocyIsImdldFNjcm9sbGJhcldpZHRocyIsImNvbXB1dGVTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwiLCJ4IiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImNvbXB1dGVFZGdlcyIsImdldFBhZGRpbmciLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYmFkU2Nyb2xsYmFyV2lkdGhzIiwic2Nyb2xsYmFyTGVmdFJpZ2h0Iiwic2Nyb2xsYmFyQm90dG9tIiwic2Nyb2xsYmFyTGVmdCIsInNjcm9sbGJhclJpZ2h0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvbXB1dGVJbm5lclJlY3QiLCJnb1dpdGhpblBhZGRpbmciLCJkb0Zyb21XaW5kb3dWaWV3cG9ydCIsIm91dGVyUmVjdCIsImNvbXB1dGVSZWN0IiwiZWRnZXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0IiwiY2xpcHBpbmdQYXJlbnRzIiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2xpcHBpbmdQYXJlbnRzXzEiLCJjbGlwcGluZ1BhcmVudCIsImludGVyc2VjdGlvbiIsImNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zIiwiY29tcHV0ZVZNYXJnaW5zIiwiY29tcHV0ZWQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJ1bnByb21pc2lmeSIsImlzUmVzb2x2ZWQiLCJ3cmFwcGVkU3VjY2VzcyIsIndyYXBwZWRGYWlsdXJlIiwidGhlbiIsIkVtaXR0ZXIiLCJoYW5kbGVycyIsInRoaXNDb250ZXh0Iiwic2V0VGhpc0NvbnRleHQiLCJzZXRPcHRpb25zIiwiYWRkVG9IYXNoIiwicmVtb3ZlRnJvbUhhc2giLCJhdHRhY2hlZEhhbmRsZXJzIiwib3B0aW9uSGFuZGxlciIsImhhbmRsZXJzXzEiLCJQb3NpdGlvbkNhY2hlIiwib3JpZ2luRWwiLCJlbHMiLCJpc0hvcml6b250YWwiLCJpc1ZlcnRpY2FsIiwib3JpZ2luQ2xpZW50UmVjdCIsImJ1aWxkRWxIb3Jpem9udGFscyIsImJ1aWxkRWxWZXJ0aWNhbHMiLCJvcmlnaW5DbGllbnRMZWZ0IiwibGVmdHMiLCJyaWdodHMiLCJvcmlnaW5DbGllbnRUb3AiLCJ0b3BzIiwiYm90dG9tcyIsImxlZnRUb0luZGV4IiwibGVmdFBvc2l0aW9uIiwidG9wVG9JbmRleCIsInRvcFBvc2l0aW9uIiwiZ2V0V2lkdGgiLCJsZWZ0SW5kZXgiLCJnZXRIZWlnaHQiLCJ0b3BJbmRleCIsIlNjcm9sbENvbnRyb2xsZXIiLCJnZXRNYXhTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJnZXRNYXhTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsV2lkdGgiLCJnZXRDbGllbnRXaWR0aCIsImNhblNjcm9sbFZlcnRpY2FsbHkiLCJjYW5TY3JvbGxIb3Jpem9udGFsbHkiLCJjYW5TY3JvbGxVcCIsImdldFNjcm9sbFRvcCIsImNhblNjcm9sbERvd24iLCJjYW5TY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImNhblNjcm9sbFJpZ2h0IiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJfc3VwZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsInNjcm9sbCIsIlRoZW1lIiwiaWNvbk92ZXJyaWRlT3B0aW9uIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwicHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJTY3JvbGxSZXNwb25kZXIiLCJleGVjRnVuYyIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJyZXF1ZXN0IiwicXVldWVkUmVxdWVzdCIsImRyYWluIiwiZmlyZUluaXRpYWxTY3JvbGwiLCJkZXRhY2giLCJ1cGRhdGUiLCJpc0RhdGVzTmV3IiwiVmlld0NvbnRleHRUeXBlIiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJhZGRSZXNpemVIYW5kbGVyIiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImNyZWF0ZVNjcm9sbFJlc3BvbmRlciIsIlB1cmVDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJkZWJ1ZyIsImxvZyIsInByb3BFcXVhbGl0eSIsInN0YXRlRXF1YWxpdHkiLCJhZGRQcm9wc0VxdWFsaXR5IiwiYWRkU3RhdGVFcXVhbGl0eSIsImNvbnRleHRUeXBlIiwiQmFzZUNvbXBvbmVudCIsImNyZWF0ZSIsInNldFJlZiIsInJlZiIsImN1cnJlbnQiLCJEYXRlQ29tcG9uZW50IiwidWlkIiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiY3JlYXRlUGx1Z2luIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNMb2FkaW5nRnVuY3MiLCJjb250ZXh0SW5pdCIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyIsImRhdGVQb2ludFRyYW5zZm9ybXMiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJpc1Byb3BzVmFsaWQiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvbkNoYW5nZUhhbmRsZXJzIiwic2Nyb2xsR3JpZEltcGwiLCJjb250ZW50VHlwZUhhbmRsZXJzIiwibGlzdGVuZXJSZWZpbmVycyIsIm9wdGlvblJlZmluZXJzIiwicHJvcFNldEhhbmRsZXJzIiwiYnVpbGRQbHVnaW5Ib29rcyIsInBsdWdpbkRlZnMiLCJnbG9iYWxEZWZzIiwiaXNBZGRlZCIsImhvb2tzIiwiYWRkRGVmcyIsImRlZnNfMSIsImNvbWJpbmVIb29rcyIsImJ1aWxkQnVpbGRQbHVnaW5Ib29rcyIsImN1cnJlbnRPdmVycmlkZURlZnMiLCJjdXJyZW50R2xvYmFsRGVmcyIsImN1cnJlbnRIb29rcyIsIm92ZXJyaWRlRGVmcyIsImhvb2tzMCIsImhvb2tzMSIsIlN0YW5kYXJkVGhlbWUiLCJyb290IiwidGFibGVDZWxsU2hhZGVkIiwiYnV0dG9uR3JvdXAiLCJidXR0b24iLCJidXR0b25BY3RpdmUiLCJjbG9zZSIsImNvbXBpbGVWaWV3RGVmcyIsImRlZmF1bHRDb25maWdzIiwib3ZlcnJpZGVDb25maWdzIiwiZW5zdXJlVmlld0RlZiIsInZpZXdEZWYiLCJidWlsZFZpZXdEZWYiLCJkZWZhdWx0Q29uZmlnIiwib3ZlcnJpZGVDb25maWciLCJxdWVyeVByb3AiLCJ0aGVDb21wb25lbnQiLCJzdXBlclR5cGUiLCJzdXBlckRlZiIsImRlZmF1bHRzIiwicmF3T3B0aW9ucyIsIm92ZXJyaWRlcyIsIlJlbmRlckhvb2siLCJyb290RWxSZWYiLCJoYW5kbGVSb290RWwiLCJlbFJlZiIsInJlbmRlciIsImhvb2tQcm9wcyIsIk1vdW50SG9vayIsIkNvbnRlbnRIb29rIiwiZGVmYXVsdENvbnRlbnQiLCJiYWNrdXBFbFJlZiIsImlubmVyRWxSZWYiLCJpbm5lckNvbnRlbnQiLCJub3JtYWxpemVDbGFzc05hbWVzIiwiQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQiLCJDb25zdW1lciIsInJlbmRlcklkIiwiQ29udGVudEhvb2tJbm5lciIsInJlbmRlcklubmVyQ29udGVudCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlQ3VzdG9tQ29udGVudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY3VzdG9tQ29udGVudEluZm8iLCJkZXN0cm95IiwiZ2V0SW5uZXJDb250ZW50IiwiZ2V0Q29udGVudE1ldGEiLCJjb250ZW50S2V5IiwiY29udGVudFZhbCIsImJ1aWxkTGlmZWN5Y2xlRnVuY3MiLCJub3JtYWxpemVDb250ZW50Iiwic2VhcmNoS2V5Iiwicm9vdEVsIiwiYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyIiwiY3VycmVudEdlbmVyYXRvciIsImN1cnJlbnRIb29rUHJvcHMiLCJjdXJyZW50Q2xhc3NOYW1lcyIsImdlbmVyYXRvciIsIlZpZXdSb290IiwiY3VzdG9tQ2xhc3NOYW1lcyIsInBhcnNlVmlld0NvbmZpZ3MiLCJpbnB1dHMiLCJwYXJzZVZpZXdDb25maWciLCJjcmVhdGVWaWV3SG9va0NvbXBvbmVudCIsInZpZXdQcm9wcyIsInZpZXdFbFJlZiIsImJ1aWxkVmlld1NwZWNzIiwiZGVmYXVsdElucHV0cyIsIm9wdGlvbk92ZXJyaWRlcyIsImR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJsb2NhbGVEZWZhdWx0cyIsInZpZXdEZWZzIiwiYnVpbGRWaWV3U3BlYyIsImR1cmF0aW9uSW5wdXQiLCJkdXJhdGlvblVuaXQiLCJzaW5nbGVVbml0T3ZlcnJpZGVzIiwiY3JlYXRlRHVyYXRpb25DYWNoZWQiLCJkZW5vbSIsInF1ZXJ5QnV0dG9uVGV4dCIsIm9wdGlvbnNTdWJzZXQiLCJidXR0b25UZXh0TWFwIiwicXVlcnlCdXR0b25UaXRsZSIsImJ1dHRvbktleSIsIm9wdGlvbkRlZmF1bHRzIiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJidXR0b25UaXRsZU92ZXJyaWRlIiwiYnV0dG9uSGludCIsImJ1dHRvblRpdGxlRGVmYXVsdCIsImR1cmF0aW9uSW5wdXRNYXAiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJmb3JjZVRvVmFsaWQiLCJwcmV2RGF0ZSIsImN1cnJlbnRSYW5nZVVuaXQiLCJidWlsZCIsImJ1aWxkTmV4dCIsIm5leHREYXRlIiwiY3VycmVudEluZm8iLCJpc1JhbmdlQWxsRGF5IiwicmVuZGVyUmFuZ2UiLCJpc1ZhbGlkIiwiYnVpbGRWYWxpZFJhbmdlIiwidHJpbUhpZGRlbkRheXMiLCJidWlsZEN1cnJlbnRSYW5nZUluZm8iLCJidWlsZFJlbmRlclJhbmdlIiwiYWRqdXN0QWN0aXZlUmFuZ2UiLCJidWlsZERhdGVJbmNyZW1lbnQiLCJ2YWxpZFJhbmdlSW5wdXQiLCJzaW1wbGVJbnB1dCIsInJlZmluZVJhbmdlIiwiYnVpbGRSYW5nZUZyb21EdXJhdGlvbiIsImJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQiLCJidWlsZEN1c3RvbVZpc2libGVSYW5nZSIsImdldEZhbGxiYWNrRHVyYXRpb24iLCJpc0hpZGRlbkRheSIsInNraXBIaWRkZW5EYXlzIiwiY29tcHV0ZVJlcyIsInJ1bm5pbmdDb3VudCIsInZpc2libGVSYW5nZUlucHV0IiwiZmFsbGJhY2siLCJjdXN0b21BbGlnbm1lbnQiLCJyYW5nZUlucHV0IiwiaXNIaWRkZW5EYXlIYXNoIiwiaW5jIiwiaXNFeGNsdXNpdmUiLCJyZWR1Y2VWaWV3VHlwZSIsInJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJyZWR1Y2VEYXRlUHJvZmlsZSIsImRwIiwiaW5pdEV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJwYXJzZUluaXRpYWxTb3VyY2VzIiwicmVkdWNlRXZlbnRTb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwiZmV0Y2hJZCIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJldmVudFNvdXJjZUhhc2giLCJzb3VyY2VzXzEiLCJzb3VyY2UiLCJpc1NvdXJjZURpcnR5IiwiZG9lc1NvdXJjZU5lZWRSYW5nZSIsInByZXZTb3VyY2VzIiwic291cmNlSWRIYXNoIiwibmV4dFNvdXJjZXMiLCJmZXRjaFNvdXJjZSIsInNvdXJjZURlZiIsImZldGNoIiwieGhyIiwiZXJyb3IiLCJtZXNzYWdlIiwicmF3U291cmNlcyIsInJhd1NvdXJjZXNfMSIsInJhd1NvdXJjZSIsImlnbm9yZVJhbmdlIiwicmVkdWNlRXZlbnRTdG9yZSIsInJlY2VpdmVSYXdFdmVudHMiLCJleGNsdWRlRXZlbnRzQnlTb3VyY2VJZCIsInN1YnNldCIsInRyYW5zZm9ybVJhd0V2ZW50cyIsImNhbEVhY2hUcmFuc2Zvcm0iLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJlZmluZWRFdmVudCIsImV4cGFuZFJhbmdlIiwicmV6b25lRXZlbnRTdG9yZURhdGVzIiwib2xkRGF0ZUVudiIsIm5ld0RhdGVFbnYiLCJleGNsdWRlSW5zdGFuY2VzIiwicmVtb3ZhbHMiLCJyZWR1Y2VEYXRlU2VsZWN0aW9uIiwiY3VycmVudFNlbGVjdGlvbiIsInJlZHVjZVNlbGVjdGVkRXZlbnQiLCJjdXJyZW50SW5zdGFuY2VJZCIsImV2ZW50SW5zdGFuY2VJZCIsInJlZHVjZUV2ZW50RHJhZyIsImN1cnJlbnREcmFnIiwibmV3RHJhZyIsInJlZHVjZUV2ZW50UmVzaXplIiwiY3VycmVudFJlc2l6ZSIsIm5ld1Jlc2l6ZSIsInBhcnNlVG9vbGJhcnMiLCJjYWxlbmRhck9wdGlvbk92ZXJyaWRlcyIsInBhcnNlVG9vbGJhciIsInNlY3Rpb25TdHJIYXNoIiwic2VjdGlvbldpZGdldHMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiY2FsZW5kYXJDdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJjbGljayIsInRleHQiLCJoaW50IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJldmVudFNvdXJjZURlZiQyIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJiaW5kIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwicmVxdWVzdEpzb24iLCJwYXJhbXMiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJ0b1VwcGVyQ2FzZSIsImluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zIiwiZW5jb2RlUGFyYW1zIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsImVyciIsIm9uZXJyb3IiLCJzZW5kIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsImV4dHJhUGFyYW1zIiwiZXZlbnRTb3VyY2VEZWYiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwiZXJyb3JNZXNzYWdlIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwic3RhcnRSZWN1ciIsImVuZFJlY3VyIiwicmVjdXJyaW5nIiwicmVjdXJyaW5nRGF0YSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwibmV3SW5wdXRzIiwiaW5wdXRzXzEiLCJpbnB1dEZvdW5kIiwidW5mb3VuZFNvdXJjZXNfMSIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dHNfMSIsIm5ld0lucHV0IiwiaGFuZGxlRGF0ZVByb2ZpbGUiLCJoYW5kbGVFdmVudFN0b3JlIiwiZ2xvYmFsUGx1Z2lucyIsImh0bWwiLCJidWlsZEh0bWxSZW5kZXJlciIsImRvbU5vZGVzIiwiYnVpbGREb21Ob2RlUmVuZGVyZXIiLCJjdXJyZW50RWwiLCJjdXJyZW50SHRtbCIsImN1cnJlbnREb21Ob2RlcyIsIm5ld0RvbU5vZGVzIiwibmV3RG9tTm9kZXNfMSIsIm5ld05vZGUiLCJEZWxheWVkUnVubmVyIiwiZHJhaW5lZE9wdGlvbiIsImlzUnVubmluZyIsImlzRGlydHkiLCJwYXVzZURlcHRocyIsInRpbWVvdXRJZCIsImRlbGF5IiwiaXNQYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJ0cnlEcmFpbiIsInNldFRpbWVvdXQiLCJwYXVzZSIsInNjb3BlIiwicmVzdW1lIiwiZm9yY2UiLCJkZXB0aCIsImRyYWluZWQiLCJjbGVhciIsIlRhc2tSdW5uZXIiLCJydW5UYXNrT3B0aW9uIiwicXVldWUiLCJkZWxheWVkUnVubmVyIiwidGFzayIsImNvbXBsZXRlZFRhc2tzIiwic2hpZnQiLCJydW5UYXNrIiwiYnVpbGRUaXRsZSIsImJ1aWxkVGl0bGVGb3JtYXQiLCJDYWxlbmRhckRhdGFNYW5hZ2VyIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiX2NvbXB1dGVPcHRpb25zRGF0YSIsImNvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkVGhlbWUiLCJidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRWaWV3QXBpIiwiYnVpbGRWaWV3VWlQcm9wcyIsImJ1aWxkRXZlbnRVaUJ5U291cmNlIiwiYnVpbGRFdmVudFVpQmFzZXMiLCJwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzIiwiYWN0aW9uUnVubmVyIiwiX2hhbmRsZUFjdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRWaWV3T3B0aW9uc0lucHV0IiwiY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCIsImRhdGEiLCJvcHRpb25zRGF0YSIsImN1cnJlbnRWaWV3VHlwZSIsImN1cnJlbnRWaWV3RGF0YSIsImNhbGVuZGFyQ29udGV4dCIsImluaXRpYWxTdGF0ZSIsInJlbmRlcmFibGVFdmVudFN0b3JlIiwic2VsZWN0aW9uQ29uZmlnIiwiY29udGV4dEFuZFN0YXRlIiwicmVkdWNlciIsImNvbXB1dGVJc0xvYWRpbmciLCJyZXNldE9wdGlvbnMiLCJhcHBlbmQiLCJpc0V2ZW50c0xvYWRpbmciLCJldmVudFVpU2luZ2xlQmFzZSIsImV2ZW50VWlCeVNvdXJjZSIsIm5ld1N0YXRlIiwid2FzTG9hZGluZyIsImlzTG9hZGluZyIsIm9uQWN0aW9uIiwib2xkRGF0YSIsImNoYW5nZUhhbmRsZXJzIiwib2xkQ2FsZW5kYXJPcHRpb25zIiwibmV3Q2FsZW5kYXJPcHRpb25zIiwib25EYXRhIiwicHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyIsInJlZmluZWRPcHRpb25zIiwiYXZhaWxhYmxlTG9jYWxlRGF0YSIsIndhcm5Vbmtub3duT3B0aW9ucyIsImN1cnJlbnRSYXciLCJjdXJyZW50UmVmaW5lZCIsImFueUNoYW5nZXMiLCJwcm9jZXNzUmF3Vmlld09wdGlvbnMiLCJleHBsaWNpdExvY2FsZSIsIlRoZW1lQ2xhc3MiLCJEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiaXNMb2FkaW5nRnVuYyIsInZpZXdOYW1lIiwiQ2FsZW5kYXJEYXRhUHJvdmlkZXIiLCJoYW5kbGVEYXRhIiwiZGF0YU1hbmFnZXIiLCJzZXRTdGF0ZSIsInByZXZQcm9wcyIsIm5ld09wdGlvbk92ZXJyaWRlcyIsInNsaWNlRXZlbnRzIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJzdHJpY3RPcmRlciIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJtYXhTdGFja0NudCIsImxldmVsQ29vcmRzIiwiZW50cmllc0J5TGV2ZWwiLCJzdGFja0NudHMiLCJhZGRTZWdzIiwiaGlkZGVuRW50cmllcyIsImluc2VydEVudHJ5IiwiZW50cnkiLCJmaW5kSW5zZXJ0aW9uIiwiaXNJbnNlcnRpb25WYWxpZCIsImluc2VydEVudHJ5QXQiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsInN0YWNrQ250IiwidG91Y2hpbmdFbnRyeSIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwicGFydENudCIsInNwbGl0SGlkZGVuRW50cmllcyIsImVudHJ5U3BhbiIsImJhcnJpZXJTcGFuIiwiaW50ZXJzZWN0U3BhbnMiLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImVudHJpZXNfMSIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImVudHJpZXNfMiIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZXNfMSIsIm1lcmdlIiwiam9pblNwYW5zIiwic2VhcmNoVmFsIiwiZ2V0SXRlbVZhbCIsIm1pZGRsZUluZGV4IiwibWlkZGxlVmFsIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiVG9vbGJhclNlY3Rpb24iLCJ3aWRnZXRHcm91cHMiLCJ3aWRnZXRHcm91cCIsInJlbmRlcldpZGdldEdyb3VwIiwiaXNPbmx5QnV0dG9ucyIsIndpZGdldEdyb3VwXzEiLCJ3aWRnZXQiLCJ0aXRsZUlkIiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwicmVuZGVyU2VjdGlvbiIsIlZpZXdDb250YWluZXIiLCJhdmFpbGFibGVXaWR0aCIsImhhbmRsZUVsIiwidXBkYXRlQXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVSZXNpemUiLCJsaXF1aWQiLCJsYWJlbGVkQnlJZCIsIkV2ZW50Q2xpY2tpbmciLCJoYW5kbGVTZWdDbGljayIsInNlZ0VsIiwiaGFzVXJsQ29udGFpbmVyIiwiZGVmYXVsdFByZXZlbnRlZCIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJDYWxlbmRhckNvbnRlbnQiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiYnVpbGRUb29sYmFyUHJvcHMiLCJoZWFkZXJSZWYiLCJmb290ZXJSZWYiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInZpZXdMYWJlbElkIiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsImxpc3RlbmVyIiwicmVzaXplUnVubmVyIiwidG9vbGJhclByb3BzIiwidmlld1ZHcm93Iiwidmlld0FzcGVjdFJhdGlvIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJ2aWV3Q29udGV4dCIsIlByb3ZpZGVyIiwicmVuZGVyVmlldyIsImJ1aWxkQXBwZW5kQ29udGVudCIsIkNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyIsIlZpZXdDb21wb25lbnQiLCJ0b2RheUluZm8iLCJwcmV2SW5mbyIsIm5leHRJbmZvIiwidGhlQ2xhc3NlcyIsIlRoZUNsYXNzIiwiQ2FsZW5kYXJSb290IiwiaGFuZGxlQmVmb3JlUHJpbnQiLCJoYW5kbGVBZnRlclByaW50IiwiY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0IiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJDTEFTU19OQU1FIiwicmVuZGVySW5uZXIkMSIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwiZXh0cmFIb29rUHJvcHMiLCJyb2xlIiwiY29sU3BhbiIsImV4dHJhRGF0YUF0dHJzIiwiaXNTdGlja3kiLCJXRUVLREFZX0ZPUk1BVCIsIlRhYmxlRG93Q2VsbCIsImV4dHJhQ2xhc3NOYW1lcyIsIk5vd1RpbWVyIiwiaW5pdGlhbE5vd0RhdGUiLCJpbml0aWFsTm93UXVlcmllZE1zIiwiY29tcHV0ZVRpbWluZyIsImN1cnJlbnRTdGF0ZSIsInVucm91bmRlZE5vdyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0Iiwid2FpdE1zIiwiYnVpbGREYXlSYW5nZSIsIkRheUhlYWRlciIsImNyZWF0ZURheUhlYWRlckZvcm1hdHRlciIsImRhdGVzIiwicmVuZGVySW50cm8iLCJleHBsaWNpdEZvcm1hdCIsImRhdGVDbnQiLCJEYXlTZXJpZXNNb2RlbCIsImluZGljZXMiLCJkYXlJbmRleCIsImNudCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY2VpbCIsImRheU9mZnNldCIsIkRheVRhYmxlTW9kZWwiLCJkYXlTZXJpZXMiLCJicmVha09uV2Vla3MiLCJkYXlzUGVyUm93Iiwicm93Q250IiwiY2VsbHMiLCJidWlsZENlbGxzIiwiaGVhZGVyRGF0ZXMiLCJidWlsZEhlYWRlckRhdGVzIiwicm93cyIsInJvdyIsImNvbCIsImJ1aWxkQ2VsbCIsInNlcmllc1NlZyIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsIlNsaWNlciIsInNsaWNlQnVzaW5lc3NIb3VycyIsIl9zbGljZUJ1c2luZXNzSG91cnMiLCJzbGljZURhdGVTZWxlY3Rpb24iLCJfc2xpY2VEYXRlU3BhbiIsIl9zbGljZUV2ZW50U3RvcmUiLCJzbGljZUV2ZW50RHJhZyIsIl9zbGljZUludGVyYWN0aW9uIiwic2xpY2VFdmVudFJlc2l6ZSIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VOb3dEYXRlIiwiY29tcHV0ZUFjdGl2ZVJhbmdlIiwicmFuZ2VSZXMiLCJzbGljZUV2ZW50UmFuZ2VzIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJzZWdzXzEiLCJldmVudFJhbmdlcyIsImV2ZW50UmFuZ2VzXzEiLCJzbGljZUV2ZW50UmFuZ2UiLCJzZWdzXzIiLCJpc0NvbXBvbmVudEFsbERheSIsImlzSW50ZXJhY3Rpb25WYWxpZCIsImlzTmV3UHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiY2FsZW5kYXJTdGF0ZSIsImRhdGVTcGFuTWV0YSIsImZpbHRlckNvbmZpZyIsImlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZCIsInN1YmplY3RFdmVudFN0b3JlIiwic3ViamVjdERlZnMiLCJzdWJqZWN0SW5zdGFuY2VzIiwic3ViamVjdENvbmZpZ3MiLCJvdGhlckV2ZW50U3RvcmUiLCJvdGhlckRlZnMiLCJvdGhlckluc3RhbmNlcyIsIm90aGVyQ29uZmlncyIsInN1YmplY3RJbnN0YW5jZUlkIiwic3ViamVjdEluc3RhbmNlIiwic3ViamVjdFJhbmdlIiwic3ViamVjdENvbmZpZyIsInN1YmplY3REZWYiLCJhbGxDb25zdHJhaW50c1Bhc3MiLCJldmVudE92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvblJhbmdlIiwic2VsZWN0T3ZlcmxhcEZ1bmMiLCJyZWxldmFudEluc3RhbmNlSWQiLCJyZWxldmFudEluc3RhbmNlIiwic2VsZWN0aW9uQWxsb3ciLCJmdWxsRGF0ZVNwYW4iLCJidXNpbmVzc0hvdXJzVW5leHBhbmRlZCIsImNvbnN0cmFpbnRzXzEiLCJhbnlSYW5nZXNDb250YWluUmFuZ2UiLCJjb25zdHJhaW50VG9SYW5nZXMiLCJldmVudFN0b3JlVG9SYW5nZXMiLCJvdXRlclJhbmdlcyIsIm91dGVyUmFuZ2VzXzEiLCJWSVNJQkxFX0hJRERFTl9SRSIsIlNjcm9sbGVyIiwibGlxdWlkSXNBYnNvbHV0ZSIsImlzQWJzb2x1dGUiLCJvdmVyY29tZUxlZnQiLCJvdmVyY29tZVJpZ2h0Iiwib3ZlcmNvbWVCb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXhIZWlnaHQiLCJuZWVkc1hTY3JvbGxpbmciLCJyZWFsQ2xpZW50V2lkdGgiLCJnZXRZU2Nyb2xsYmFyV2lkdGgiLCJjaGlsZEVsIiwibmVlZHNZU2Nyb2xsaW5nIiwicmVhbENsaWVudEhlaWdodCIsImdldFhTY3JvbGxiYXJXaWR0aCIsIlJlZk1hcCIsIm1hc3RlckNhbGxiYWNrIiwiY3VycmVudE1hcCIsImRlcHRocyIsImNhbGxiYWNrTWFwIiwiaGFuZGxlVmFsdWUiLCJyZW1vdmVkIiwiYWRkZWQiLCJyZWZDYWxsYmFjayIsImNvbGxlY3QiLCJnZXRBbGwiLCJjb21wdXRlU2hyaW5rV2lkdGgiLCJjaHVua0VscyIsInNocmlua0NlbGxzIiwibGFyZ2VzdFdpZHRoIiwic2hyaW5rQ2VsbHNfMSIsInNocmlua0NlbGwiLCJnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0Iiwic2VjdGlvbkNvbmZpZyIsImdldEFsbG93WVNjcm9sbGluZyIsInJlbmRlckNodW5rQ29udGVudCIsImNodW5rQ29uZmlnIiwiaXNIZWFkZXIiLCJ0YWJsZUNsYXNzTmFtZSIsInN5bmNSb3dIZWlnaHRzIiwibWluV2lkdGgiLCJ0YWJsZU1pbldpZHRoIiwidGFibGVDb2xHcm91cE5vZGUiLCJyb3dDb250ZW50IiwiaXNDb2xQcm9wc0VxdWFsIiwiY29sczAiLCJjb2xzMSIsInJlbmRlck1pY3JvQ29sR3JvdXAiLCJjb2xzIiwic2hyaW5rV2lkdGgiLCJjb2xOb2RlcyIsImNvbHNfMSIsImNvbFByb3BzIiwic2FuaXRpemVTaHJpbmtXaWR0aCIsImhhc1Nocmlua1dpZHRoIiwiY29sc18yIiwiZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMiLCJnZXRTZWN0aW9uQ2xhc3NOYW1lcyIsIndob2xlVGFibGVWR3JvdyIsInJlbmRlclNjcm9sbFNoaW0iLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsIlNpbXBsZVNjcm9sbEdyaWQiLCJwcm9jZXNzQ29scyIsInNjcm9sbGVyUmVmcyIsInNjcm9sbGVyRWxSZWZzIiwiX2hhbmRsZVNjcm9sbGVyRWwiLCJmb3JjZVlTY3JvbGxiYXJzIiwic2Nyb2xsZXJDbGllbnRXaWR0aHMiLCJzY3JvbGxlckNsaWVudEhlaWdodHMiLCJoYW5kbGVTaXppbmciLCJjb21wdXRlU2Nyb2xsZXJEaW1zIiwic2VjdGlvbkNvbmZpZ3MiLCJzZWN0aW9ucyIsIm1pY3JvQ29sR3JvdXBOb2RlIiwiY29sbGFwc2libGVXaWR0aCIsImNvbmZpZ0NudCIsImNvbmZpZ0kiLCJjdXJyZW50Q29uZmlnIiwiaGVhZFNlY3Rpb25Ob2RlcyIsImJvZHlTZWN0aW9uTm9kZXMiLCJmb290U2VjdGlvbk5vZGVzIiwiaXNCdWdneSIsInJvbGVBdHRycyIsIm91dGVyQ29udGVudCIsInJlbmRlckNodW5rVGQiLCJjaHVuayIsImlzTGlxdWlkIiwic2VjdGlvbktleSIsInJvd1N5bmNIZWlnaHRzIiwicmVwb3J0Um93SGVpZ2h0Q2hhbmdlIiwic2Nyb2xsZXJFbCIsInNlY3Rpb24iLCJnZXRTZWN0aW9uQnlLZXkiLCJzY3JvbGxlckVsUmVmIiwic2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxlciIsImhhcm5lc3NFbCIsInNlY3Rpb25zXzEiLCJFdmVudFJvb3QiLCJ0aW1lVGV4dCIsImRpc2FibGVEcmFnZ2luZyIsImRpc2FibGVSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsInN0YW5kYXJkQ2xhc3NOYW1lcyIsIlN0YW5kYXJkRXZlbnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsInJlbmRlcklubmVyQ29udGVudCQxIiwiaW5uZXJQcm9wcyIsIk5vd0luZGljYXRvclJvb3QiLCJpc0F4aXMiLCJEQVlfTlVNX0ZPUk1BVCIsIkRheUNlbGxDb250ZW50IiwicmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyIsInNob3dEYXlOdW1iZXIiLCJleHRyYVByb3BzIiwiZGF5TnVtYmVyVGV4dCIsIkRheUNlbGxSb290IiwicmVmaW5lSG9va1Byb3BzIiwiZGF0YUF0dHJzIiwicmVuZGVyRmlsbCIsImZpbGxUeXBlIiwiQmdFdmVudCIsIldlZWtOdW1iZXJSb290IiwiZGVmYXVsdEZvcm1hdCIsInJlbmRlcklubmVyIiwiUEFERElOR19GUk9NX1ZJRVdQT1JUIiwiUG9wb3ZlciIsImhhbmRsZURvY3VtZW50TW91c2VEb3duIiwiaGFuZGxlQ2xvc2VDbGljayIsImhhbmRsZURvY3VtZW50S2V5RG93biIsIm9uQ2xvc2UiLCJleHRyYUF0dHJzIiwicGFyZW50RWwiLCJhbGlnbm1lbnRFbCIsImFsaWduR3JpZFRvcCIsImFsaWdubWVudFJlY3QiLCJwb3BvdmVyRGltcyIsInBvcG92ZXJUb3AiLCJwb3BvdmVyTGVmdCIsIm9yaWdpbl8xIiwib2Zmc2V0UGFyZW50IiwiTW9yZVBvcG92ZXIiLCJzdGFydERhdGUiLCJkYXlDbGFzc05hbWVzIiwiZXh0cmFEYXRlU3BhbiIsImRheUVsIiwibGF5ZXIiLCJNb3JlTGlua1Jvb3QiLCJsaW5rRWxSZWYiLCJpc1BvcG92ZXJPcGVuIiwicG9wb3ZlcklkIiwiaGFuZGxlQ2xpY2siLCJjb21wdXRlUmFuZ2UiLCJidWlsZFB1YmxpY1NlZyIsImFsbERheURhdGUiLCJhbGxTZWdzIiwiaGlkZGVuU2VncyIsImhhbmRsZVBvcG92ZXJDbG9zZSIsIm1vcmVDbnQiLCJzaG9ydFRleHQiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiYWxpZ25tZW50RWxSZWYiLCJwb3BvdmVyQ29udGVudCIsInVwZGF0ZVBhcmVudEVsIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJjb21wdXRlTGF0ZXN0U2VnRW5kIiwicGlja0VhcmxpZXN0U3RhcnQiLCJzZWcwIiwic2VnMSIsInBpY2tMYXRlc3RFbmQiLCJ2ZXJzaW9uIiwicGFyc2VNYXJrZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": function() { return /* binding */ Component; },\n/* harmony export */   \"Fragment\": function() { return /* binding */ Fragment; },\n/* harmony export */   \"createContext\": function() { return /* binding */ createContext; },\n/* harmony export */   \"createElement\": function() { return /* binding */ createElement; },\n/* harmony export */   \"createPortal\": function() { return /* binding */ createPortal; },\n/* harmony export */   \"createRef\": function() { return /* binding */ createRef; },\n/* harmony export */   \"flushToDom\": function() { return /* binding */ flushToDom; },\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* binding */ unmountComponentAtNode; }\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === 'undefined') {\n  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n}\n\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushToDom = FullCalendarVDom.flushToDom;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */\n\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxJQUFJLE9BQU9BLGdCQUFQLEtBQTRCLFdBQWhDLEVBQTZDO0FBQ3pDLFFBQU0sSUFBSUMsS0FBSixDQUFVLG9GQUFWLENBQU47QUFDSDs7QUFDRCxJQUFJQyxTQUFTLEdBQUdGLGdCQUFnQixDQUFDRSxTQUFqQztBQUNBLElBQUlDLGFBQWEsR0FBR0gsZ0JBQWdCLENBQUNHLGFBQXJDO0FBQ0EsSUFBSUMsTUFBTSxHQUFHSixnQkFBZ0IsQ0FBQ0ksTUFBOUI7QUFDQSxJQUFJQyxTQUFTLEdBQUdMLGdCQUFnQixDQUFDSyxTQUFqQztBQUNBLElBQUlDLFFBQVEsR0FBR04sZ0JBQWdCLENBQUNNLFFBQWhDO0FBQ0EsSUFBSUMsYUFBYSxHQUFHUCxnQkFBZ0IsQ0FBQ08sYUFBckM7QUFDQSxJQUFJQyxZQUFZLEdBQUdSLGdCQUFnQixDQUFDUSxZQUFwQztBQUNBLElBQUlDLFVBQVUsR0FBR1QsZ0JBQWdCLENBQUNTLFVBQWxDO0FBQ0EsSUFBSUMsc0JBQXNCLEdBQUdWLGdCQUFnQixDQUFDVSxzQkFBOUM7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcz9kMWYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiQGZ1bGxjYWxlbmRhci9jb3JlLXByZWFjdFwiIC8+XG5pZiAodHlwZW9mIEZ1bGxDYWxlbmRhclZEb20gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW1wb3J0IHRoZSB0b3AtbGV2ZWwgZnVsbGNhbGVuZGFyIGxpYiBiZWZvcmUgYXR0ZW1wdGluZyB0byBpbXBvcnQgYSBwbHVnaW4uJyk7XG59XG52YXIgQ29tcG9uZW50ID0gRnVsbENhbGVuZGFyVkRvbS5Db21wb25lbnQ7XG52YXIgY3JlYXRlRWxlbWVudCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlRWxlbWVudDtcbnZhciByZW5kZXIgPSBGdWxsQ2FsZW5kYXJWRG9tLnJlbmRlcjtcbnZhciBjcmVhdGVSZWYgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZVJlZjtcbnZhciBGcmFnbWVudCA9IEZ1bGxDYWxlbmRhclZEb20uRnJhZ21lbnQ7XG52YXIgY3JlYXRlQ29udGV4dCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlQ29udGV4dDtcbnZhciBjcmVhdGVQb3J0YWwgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZVBvcnRhbDtcbnZhciBmbHVzaFRvRG9tID0gRnVsbENhbGVuZGFyVkRvbS5mbHVzaFRvRG9tO1xudmFyIHVubW91bnRDb21wb25lbnRBdE5vZGUgPSBGdWxsQ2FsZW5kYXJWRG9tLnVubW91bnRDb21wb25lbnRBdE5vZGU7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCB7IENvbXBvbmVudCwgRnJhZ21lbnQsIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVBvcnRhbCwgY3JlYXRlUmVmLCBmbHVzaFRvRG9tLCByZW5kZXIsIHVubW91bnRDb21wb25lbnRBdE5vZGUgfTtcbiJdLCJuYW1lcyI6WyJGdWxsQ2FsZW5kYXJWRG9tIiwiRXJyb3IiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hUb0RvbSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DayGridView\": function() { return /* binding */ DayTableView; },\n/* harmony export */   \"DayTable\": function() { return /* binding */ DayTable; },\n/* harmony export */   \"DayTableSlicer\": function() { return /* binding */ DayTableSlicer; },\n/* harmony export */   \"Table\": function() { return /* binding */ Table; },\n/* harmony export */   \"TableView\": function() { return /* binding */ TableView; },\n/* harmony export */   \"buildDayTableModel\": function() { return /* binding */ buildDayTableModel; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyHeaderDates)(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyHeaderDates)(context.options);\n    var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyFooterScrollbar)(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.renderScrollShim\n        }]\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TableCellTop = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildNavLinkAttrs)(this.context, props.date);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return (innerContent || props.forceDayTop) && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-top\",\n        ref: innerElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        id: props.dayNumberId,\n        className: \"fc-daygrid-day-number\"\n      }, navLinkAttrs), innerContent || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xA0\")));\n    });\n  };\n\n  return TableCellTop;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableBlockEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nvar TableListItemEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildSegTimeText)(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventRoot, {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegAnchorAttrs)(props.seg, context)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, innerProps.event.title || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\xA0\")));\n}\n\nvar TableCellMoreLink = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableCellMoreLink, _super);\n\n  function TableCellMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(compileSegs);\n    return _this;\n  }\n\n  TableCellMoreLink.prototype.render = function () {\n    var props = this.props;\n\n    var _a = this.compileSegs(props.singlePlacements),\n        allSegs = _a.allSegs,\n        invisibleSegs = _a.invisibleSegs;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.MoreLinkRoot, {\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      allDayDate: props.allDayDate,\n      moreCnt: props.moreCnt,\n      allSegs: allSegs,\n      hiddenSegs: invisibleSegs,\n      alignmentElRef: props.alignmentElRef,\n      alignGridTop: props.alignGridTop,\n      extraDateSpan: props.extraDateSpan,\n      popoverContent: function popoverContent() {\n        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, allSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-daygrid-event-harness\",\n            key: instanceId,\n            style: {\n              visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, props.todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, props.todayRange))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        ref: rootElRef,\n        className: ['fc-daygrid-more-link'].concat(classNames).join(' '),\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createAriaClickAttrs)(handleClick)), innerContent);\n    });\n  };\n\n  return TableCellMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction compileSegs(singlePlacements) {\n  var allSegs = [];\n  var invisibleSegs = [];\n\n  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {\n    var placement = singlePlacements_1[_i];\n    allSegs.push(placement.seg);\n\n    if (!placement.isVisible) {\n      invisibleSegs.push(placement.seg);\n    }\n  }\n\n  return {\n    allSegs: allSegs,\n    invisibleSegs: invisibleSegs\n  };\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)({\n  week: 'narrow'\n});\n\nvar TableCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.state = {\n      dayNumberId: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getUniqueDomId)()\n    };\n\n    _this.handleRootEl = function (el) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.setRef)(_this.rootElRef, el);\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.setRef)(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _a = this,\n        context = _a.context,\n        props = _a.props,\n        state = _a.state,\n        rootElRef = _a.rootElRef;\n\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var navLinkAttrs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildNavLinkAttrs)(context, date, 'week');\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n        ref: dayElRef,\n        role: \"gridcell\",\n        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {\n        'aria-labelledby': state.dayNumberId\n      } : {}), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WeekNumberRoot, {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          ref: weekElRef,\n          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        dayNumberId: state.dayNumberId,\n        forceDayTop: props.forceDayTop,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-events\",\n        ref: props.fgContentElRef\n      }, props.fgContent, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bottom\",\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableCellMoreLink, {\n        allDayDate: date,\n        singlePlacements: props.singlePlacements,\n        moreCnt: props.moreCnt,\n        alignmentElRef: rootElRef,\n        alignGridTop: !props.showDayNumber,\n        extraDateSpan: props.extraDateSpan,\n        dateProfile: props.dateProfile,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        todayRange: props.todayRange\n      }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bg\"\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n  var hierarchy = new DayGridSegHierarchy();\n  hierarchy.allowReslicing = true;\n  hierarchy.strictOrder = strictOrder;\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    hierarchy.maxCoord = maxContentHeight;\n    hierarchy.hiddenConsumes = true;\n  } else if (typeof dayMaxEvents === 'number') {\n    hierarchy.maxStackCnt = dayMaxEvents;\n  } else if (typeof dayMaxEventRows === 'number') {\n    hierarchy.maxStackCnt = dayMaxEventRows;\n    hierarchy.hiddenConsumes = true;\n  } // create segInputs only for segs with known heights\n\n\n  var segInputs = [];\n  var unknownHeightSegs = [];\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventInstanceHeights[instanceId];\n\n    if (eventHeight != null) {\n      segInputs.push({\n        index: i,\n        thickness: eventHeight,\n        span: {\n          start: seg.firstCol,\n          end: seg.lastCol + 1\n        }\n      });\n    } else {\n      unknownHeightSegs.push(seg);\n    }\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var segRects = hierarchy.toRects();\n\n  var _a = placeRects(segRects, segs, cells),\n      singleColPlacements = _a.singleColPlacements,\n      multiColPlacements = _a.multiColPlacements,\n      leftoverMargins = _a.leftoverMargins;\n\n  var moreCnts = [];\n  var moreMarginTops = []; // add segs with unknown heights\n\n  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {\n    var seg = unknownHeightSegs_1[_i];\n    multiColPlacements[seg.firstCol].push({\n      seg: seg,\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // add the hidden entries\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreCnts.push(0);\n  }\n\n  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {\n    var hiddenEntry = hiddenEntries_1[_b];\n    var seg = segs[hiddenEntry.index];\n    var hiddenSpan = hiddenEntry.span;\n    multiColPlacements[hiddenSpan.start].push({\n      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {\n      moreCnts[col] += 1;\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // deal with leftover margins\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreMarginTops.push(leftoverMargins[col]);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    moreCnts: moreCnts,\n    moreMarginTops: moreMarginTops\n  };\n} // rects ordered by top coord, then left\n\n\nfunction placeRects(allRects, segs, cells) {\n  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n  var singleColPlacements = [];\n  var multiColPlacements = [];\n  var leftoverMargins = [];\n\n  for (var col = 0; col < cells.length; col += 1) {\n    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements\n\n    var singlePlacements = [];\n    var currentHeight = 0;\n    var currentMarginTop = 0;\n\n    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {\n      var rect = rects_1[_i];\n      var seg = segs[rect.index];\n      singlePlacements.push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: true,\n        isAbsolute: false,\n        absoluteTop: rect.levelCoord,\n        marginTop: rect.levelCoord - currentHeight\n      });\n      currentHeight = rect.levelCoord + rect.thickness;\n    } // compute mixed static/absolute segs in multiPlacements\n\n\n    var multiPlacements = [];\n    currentHeight = 0;\n    currentMarginTop = 0;\n\n    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {\n      var rect = rects_2[_a];\n      var seg = segs[rect.index];\n      var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n\n      var isFirstCol = rect.span.start === col;\n      currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n\n      currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n\n      if (isAbsolute) {\n        currentMarginTop += rect.thickness;\n\n        if (isFirstCol) {\n          multiPlacements.push({\n            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: rect.levelCoord,\n            marginTop: 0\n          });\n        }\n      } else if (isFirstCol) {\n        multiPlacements.push({\n          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n          isVisible: true,\n          isAbsolute: false,\n          absoluteTop: rect.levelCoord,\n          marginTop: currentMarginTop // claim the margin\n\n        });\n        currentMarginTop = 0;\n      }\n    }\n\n    singleColPlacements.push(singlePlacements);\n    multiColPlacements.push(multiPlacements);\n    leftoverMargins.push(currentMarginTop);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    leftoverMargins: leftoverMargins\n  };\n}\n\nfunction groupRectsByEachCol(rects, colCnt) {\n  var rectsByEachCol = [];\n\n  for (var col = 0; col < colCnt; col += 1) {\n    rectsByEachCol.push([]);\n  }\n\n  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {\n    var rect = rects_3[_i];\n\n    for (var col = rect.span.start; col < rect.span.end; col += 1) {\n      rectsByEachCol[col].push(rect);\n    }\n  }\n\n  return rectsByEachCol;\n}\n\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n    return seg;\n  }\n\n  var eventRange = seg.eventRange;\n  var origRange = eventRange.range;\n  var slicedRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRanges)(origRange, {\n    start: cells[spanStart].date,\n    end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addDays)(cells[spanEnd - 1].date, 1)\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, seg), {\n    firstCol: spanStart,\n    lastCol: spanEnd - 1,\n    eventRange: {\n      def: eventRange.def,\n      ui: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventRange.ui), {\n        durationEditable: false\n      }),\n      instance: eventRange.instance,\n      range: slicedRange\n    },\n    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n  });\n}\n\nvar DayGridSegHierarchy = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayGridSegHierarchy, _super);\n\n  function DayGridSegHierarchy() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // config\n\n\n    _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space\n\n    _this.forceHidden = {};\n    return _this;\n  }\n\n  DayGridSegHierarchy.prototype.addSegs = function (segInputs) {\n    var _this = this;\n\n    var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n\n    var entriesByLevel = this.entriesByLevel;\n\n    var excludeHidden = function excludeHidden(entry) {\n      return !_this.forceHidden[(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEntryKey)(entry)];\n    }; // remove the forced-hidden segs\n\n\n    for (var level = 0; level < entriesByLevel.length; level += 1) {\n      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n    }\n\n    return hiddenSegs;\n  };\n\n  DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        forceHidden = _a.forceHidden;\n\n    var touchingEntry = insertion.touchingEntry,\n        touchingLevel = insertion.touchingLevel,\n        touchingLateral = insertion.touchingLateral;\n\n    if (this.hiddenConsumes && touchingEntry) {\n      var touchingEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEntryKey)(touchingEntry); // if not already hidden\n\n      if (!forceHidden[touchingEntryId]) {\n        if (this.allowReslicing) {\n          var placeholderEntry = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, touchingEntry), {\n            span: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectSpans)(touchingEntry.span, entry.span)\n          });\n\n          var placeholderEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEntryKey)(placeholderEntry);\n          forceHidden[placeholderEntryId] = true;\n          entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n\n          this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n        } else {\n          forceHidden[touchingEntryId] = true;\n          hiddenEntries.push(touchingEntry);\n        }\n      }\n    }\n\n    return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n  };\n\n  return DayGridSegHierarchy;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.SegHierarchy);\n\nvar TableRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap(); // the <td>\n\n    _this.frameElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap(); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap(); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      eventInstanceHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.sortEventSegs)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),\n        singleColPlacements = _b.singleColPlacements,\n        multiColPlacements = _b.multiColPlacements,\n        moreCnts = _b.moreCnts,\n        moreMarginTops = _b.moreMarginTops;\n\n    var isForcedInvisible = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n      ref: this.rootElRef,\n      role: \"row\"\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n\n      var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers,\n        showWeekNumber: props.showWeekNumbers && col === 0,\n        forceDayTop: props.showWeekNumbers\n        /* even displaying weeknum for row, not necessarily day */\n        ,\n        todayRange: props.todayRange,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        moreCnt: moreCnts[col],\n        moreMarginTop: moreMarginTops[col],\n        singlePlacements: singleColPlacements[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, normalFgNodes), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isPropsEqual)(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    }\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return props.dateSelectionSegs;\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return [];\n  };\n\n  TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {\n        var placement = segPlacements_1[_i];\n        var seg = placement.seg;\n        var instanceId = seg.eventRange.instance.instanceId;\n        var key = instanceId + ':' + col;\n        var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n        var isAbsolute = placement.isAbsolute;\n        var left = '';\n        var right = '';\n\n        if (isAbsolute) {\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        todo: in print view, for multi-day events, don't display title within non-start/end segs\n        */\n\n\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: key,\n          ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n          style: {\n            visibility: isVisible ? '' : 'hidden',\n            marginTop: isAbsolute ? '' : placement.marginTop,\n            top: isAbsolute ? placement.absoluteTop : '',\n            left: left,\n            right: right\n          }\n        }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n          key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventRangeKey)(seg.eventRange),\n          className: \"fc-daygrid-bg-harness\",\n          style: leftRightCss\n        }, fillType === 'bg-event' ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          seg: seg\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.renderFill)(fillType)));\n      }\n    }\n\n    return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (!props.forPrint && props.clientWidth !== null // positioning ready?\n    ) {\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.PositionCache(originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var oldInstanceHeights = this.state.eventInstanceHeights;\n      var newInstanceHeights = this.queryEventInstanceHeights();\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n        // Essentially, once you compute an element's height, never null-out.\n        // TODO: always display all events, as visibility:hidden?\n        eventInstanceHeights: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, oldInstanceHeights), newInstanceHeights),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.queryEventInstanceHeights = function () {\n    var segElMap = this.segHarnessRefs.currentMap;\n    var eventInstanceHeights = {}; // get the max height amongst instance segs\n\n    for (var key in segElMap) {\n      var height = Math.round(segElMap[key].getBoundingClientRect().height);\n      var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n\n      eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n    }\n\n    return eventInstanceHeights;\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nTableRow.addStateEquality({\n  eventInstanceHeights: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n  if (!mirrorSegs.length) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      isVisible: true,\n      isAbsolute: true,\n      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n      marginTop: 0\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(colPlacements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {\n    var placements = colPlacements_1[_i];\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar Table = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByRow);\n    _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByRow);\n    _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByRow);\n    _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByRow);\n    _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitInteractionByRow);\n    _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitInteractionByRow);\n    _this.rowRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap();\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n    ];\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n        role: \"presentation\",\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", {\n        role: \"presentation\"\n      }, props.cells.map(function (cells, row) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n          /* hack */\n          ,\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          forPrint: props.forPrint\n        });\n      }))));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true);\n    this.colPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(positionLeft);\n    var row = rowPositions.topToIndex(positionTop);\n\n    if (row != null && col != null) {\n      var cell = this.props.cells[row][col];\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n          range: this.getCellRange(row, col),\n          allDay: true\n        }, cell.extraDateSpan),\n        dayEl: this.getCellEl(row, col),\n        rect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addDays)(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Slicer);\n\nvar DayTable = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(Table, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({\n      ref: this.tableRef\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  return DayTable;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nvar DayTableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(buildDayTableModel);\n    _this.headerRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayHeader, {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function bodyContent(contentArg) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addWeeks)(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffWeeks)(start, end));\n      end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addWeeks)(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateProfileGenerator);\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n  initialView: 'dayGridMonth',\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJaUQsU0FBUyxHQUFrQixVQUFVQyxNQUFWLEVBQWtCO0FBQzdDSixFQUFBQSxnREFBUyxDQUFDRyxTQUFELEVBQVlDLE1BQVosQ0FBVDs7QUFDQSxXQUFTRCxTQUFULEdBQXFCO0FBQ2pCLFFBQUlFLEtBQUssR0FBR0QsTUFBTSxLQUFLLElBQVgsSUFBbUJBLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhLElBQWIsRUFBbUJDLFNBQW5CLENBQW5CLElBQW9ELElBQWhFOztBQUNBRixJQUFBQSxLQUFLLENBQUNHLFdBQU4sR0FBb0J0RCwrREFBUyxFQUE3QjtBQUNBLFdBQU9tRCxLQUFQO0FBQ0g7O0FBQ0RGLEVBQUFBLFNBQVMsQ0FBQ00sU0FBVixDQUFvQkMsa0JBQXBCLEdBQXlDLFVBQVVDLGdCQUFWLEVBQTRCQyxXQUE1QixFQUF5QztBQUM5RSxRQUFJQyxFQUFFLEdBQUcsSUFBVDtBQUFBLFFBQWVDLEtBQUssR0FBR0QsRUFBRSxDQUFDQyxLQUExQjtBQUFBLFFBQWlDQyxPQUFPLEdBQUdGLEVBQUUsQ0FBQ0UsT0FBOUM7O0FBQ0EsUUFBSUMsUUFBUSxHQUFHLEVBQWY7QUFDQSxRQUFJQyxpQkFBaUIsR0FBRzlELDBFQUFvQixDQUFDNEQsT0FBTyxDQUFDRyxPQUFULENBQTVDOztBQUNBLFFBQUlQLGdCQUFKLEVBQXNCO0FBQ2xCSyxNQUFBQSxRQUFRLENBQUNHLElBQVQsQ0FBYztBQUNWQyxRQUFBQSxJQUFJLEVBQUUsUUFESTtBQUVWQyxRQUFBQSxHQUFHLEVBQUUsUUFGSztBQUdWQyxRQUFBQSxRQUFRLEVBQUVMLGlCQUhBO0FBSVZNLFFBQUFBLEtBQUssRUFBRTtBQUNIQyxVQUFBQSxLQUFLLEVBQUUsS0FBS2hCLFdB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ZUUsSUFBZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5qcz8yYTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjEwLjFcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIxIEFkYW0gU2hhd1xuKi9cbmltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVJlZiwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIGNyZWF0ZUVsZW1lbnQsIFZpZXdSb290LCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIHJlbmRlclNjcm9sbFNoaW0sIERhdGVDb21wb25lbnQsIGJ1aWxkTmF2TGlua0F0dHJzLCBEYXlDZWxsQ29udGVudCwgRnJhZ21lbnQsIEJhc2VDb21wb25lbnQsIGNyZWF0ZUZvcm1hdHRlciwgU3RhbmRhcmRFdmVudCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRSb290LCBnZXRTZWdBbmNob3JBdHRycywgbWVtb2l6ZSwgTW9yZUxpbmtSb290LCBnZXRTZWdNZXRhLCBjcmVhdGVBcmlhQ2xpY2tBdHRycywgZ2V0VW5pcXVlRG9tSWQsIHNldFJlZiwgRGF5Q2VsbFJvb3QsIFdlZWtOdW1iZXJSb290LCBidWlsZEVudHJ5S2V5LCBpbnRlcnNlY3RTcGFucywgU2VnSGllcmFyY2h5LCBpbnRlcnNlY3RSYW5nZXMsIGFkZERheXMsIFJlZk1hcCwgc29ydEV2ZW50U2VncywgaXNQcm9wc0VxdWFsLCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIFBvc2l0aW9uQ2FjaGUsIE5vd1RpbWVyLCBTbGljZXIsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIGFkZFdlZWtzLCBkaWZmV2Vla3MsIERhdGVQcm9maWxlR2VuZXJhdG9yLCBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbic7XG5pbXBvcnQgeyBfX2V4dGVuZHMsIF9fYXNzaWduLCBfX3NwcmVhZEFycmF5IH0gZnJvbSAndHNsaWInO1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cbnZhciBUYWJsZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyU2ltcGxlTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICBUYWJsZVZpZXcucHJvdG90eXBlLnJlbmRlckhTY3JvbGxMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgpIHtcbiAgICAgICAgdmFyIFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYm9keUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVWaWV3O1xufShEYXRlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3MsIHJvd0NudCkge1xuICAgIHZhciBieVJvdyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgYnlSb3dbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XG4gICAgICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuZnVuY3Rpb24gc3BsaXRTZWdzQnlGaXJzdENvbChzZWdzLCBjb2xDbnQpIHtcbiAgICB2YXIgYnlDb2wgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Q29sW2ldID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18yID0gc2VnczsgX2kgPCBzZWdzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzXzJbX2ldO1xuICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcbiAgICB2YXIgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB1aS5zZWdzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxudmFyIFRhYmxlQ2VsbFRvcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsVG9wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGxUb3AucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcHJvcHMuZGF0ZSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGVudCwgeyBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcywgZGVmYXVsdENvbnRlbnQ6IHJlbmRlclRvcElubmVyIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICgoaW5uZXJDb250ZW50IHx8IHByb3BzLmZvcmNlRGF5VG9wKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgcmVmOiBpbm5lckVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IGlkOiBwcm9wcy5kYXlOdW1iZXJJZCwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsVG9wO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0O1xufVxuXG52YXIgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pO1xuZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xuICAgIHZhciBkaXNwbGF5ID0gc2VnLmV2ZW50UmFuZ2UudWkuZGlzcGxheTtcbiAgICByZXR1cm4gZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScgfHwgKGRpc3BsYXkgPT09ICdhdXRvJyAmJlxuICAgICAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgICAgICBzZWcuZmlyc3RDb2wgPT09IHNlZy5sYXN0Q29sICYmIC8vIGNhbid0IGJlIG11bHRpLWRheVxuICAgICAgICBzZWcuaXNTdGFydCAmJiAvLyBcIlxuICAgICAgICBzZWcuaXNFbmQgLy8gXCJcbiAgICApO1xufVxuXG52YXIgVGFibGVCbG9ja0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUJsb2NrRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVCbG9ja0V2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlQmxvY2tFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoU3RhbmRhcmRFdmVudCwgX19hc3NpZ24oe30sIHByb3BzLCB7IGV4dHJhQ2xhc3NOYW1lczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQmxvY2tFdmVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGFibGVMaXN0SXRlbUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUxpc3RJdGVtRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVMaXN0SXRlbUV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlTGlzdEl0ZW1FdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XG4gICAgICAgIHZhciB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQocHJvcHMuc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Um9vdCwgeyBzZWc6IHByb3BzLnNlZywgdGltZVRleHQ6IHRpbWVUZXh0LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXJDb250ZW50LCBpc0RyYWdnaW5nOiBwcm9wcy5pc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogcHJvcHMuaXNTZWxlY3RlZCwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICggLy8gd2UgZG9uJ3QgdXNlIHN0eWxlcyFcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHJlZjogcm9vdEVsUmVmIH0sIGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCkpLCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlTGlzdEl0ZW1FdmVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIiwgc3R5bGU6IHsgYm9yZGVyQ29sb3I6IGlubmVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgaW5uZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfSB9KSxcbiAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbnZhciBUYWJsZUNlbGxNb3JlTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsTW9yZUxpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsTW9yZUxpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbE1vcmVMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyksIGFsbFNlZ3MgPSBfYS5hbGxTZWdzLCBpbnZpc2libGVTZWdzID0gX2EuaW52aXNpYmxlU2VncztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rUm9vdCwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBhbGxTZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2ssIHRpdGxlLCBpc0V4cGFuZGVkLCBwb3BvdmVySWQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1tb3JlLWxpbmsnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCB0aXRsZTogdGl0bGUsIFwiYXJpYS1leHBhbmRlZFwiOiBpc0V4cGFuZGVkLCBcImFyaWEtY29udHJvbHNcIjogcG9wb3ZlcklkIH0sIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUNsaWNrKSksIGlubmVyQ29udGVudCkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsTW9yZUxpbms7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICB2YXIgYWxsU2VncyA9IFtdO1xuICAgIHZhciBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzaW5nbGVQbGFjZW1lbnRzXzEgPSBzaW5nbGVQbGFjZW1lbnRzOyBfaSA8IHNpbmdsZVBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNpbmdsZVBsYWNlbWVudHNfMVtfaV07XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VnczogYWxsU2VncywgaW52aXNpYmxlU2VnczogaW52aXNpYmxlU2VncyB9O1xufVxuXG52YXIgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KTtcbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIHJvb3RFbFJlZiA9IF9hLnJvb3RFbFJlZjtcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgbmF2TGlua0F0dHJzID0gYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxSb290LCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKGRheUVsUmVmLCBkYXlDbGFzc05hbWVzLCByb290RGF0YUF0dHJzLCBpc0Rpc2FibGVkKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIF9fYXNzaWduKHsgcmVmOiBkYXlFbFJlZiwgcm9sZTogXCJncmlkY2VsbFwiLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1kYXknXS5jb25jYXQoZGF5Q2xhc3NOYW1lcywgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKS5qb2luKCcgJykgfSwgcm9vdERhdGFBdHRycywgcHJvcHMuZXh0cmFEYXRhQXR0cnMsIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCByZWY6IHByb3BzLmlubmVyRWxSZWYgLyogZGlmZmVyZW50IGZyb20gaG9vayBzeXN0ZW0hIFJFTkFNRSAqLyB9LFxuICAgICAgICAgICAgICAgIHByb3BzLnNob3dXZWVrTnVtYmVyICYmIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJSb290LCB7IGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uICh3ZWVrRWxSZWYsIHdlZWtDbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IHJlZjogd2Vla0VsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC13ZWVrLW51bWJlciddLmNvbmNhdCh3ZWVrQ2xhc3NOYW1lcykuam9pbignICcpIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCkpOyB9KSksXG4gICAgICAgICAgICAgICAgIWlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsVG9wLCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZGF5TnVtYmVySWQ6IHN0YXRlLmRheU51bWJlcklkLCBmb3JjZURheVRvcDogcHJvcHMuZm9yY2VEYXlUb3AsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9KSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KERhdGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNlZ3MsIC8vIGFzc3VtZWQgYWxyZWFkeSBzb3J0ZWRcbmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzLCBzdHJpY3RPcmRlciwgZXZlbnRJbnN0YW5jZUhlaWdodHMsIG1heENvbnRlbnRIZWlnaHQsIGNlbGxzKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KCk7XG4gICAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZTtcbiAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkge1xuICAgICAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0O1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50Um93cztcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICAgIHZhciBzZWdJbnB1dHMgPSBbXTtcbiAgICB2YXIgdW5rbm93bkhlaWdodFNlZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgdmFyIGV2ZW50SGVpZ2h0ID0gZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF07XG4gICAgICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBldmVudEhlaWdodCxcbiAgICAgICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnLmxhc3RDb2wgKyAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgdmFyIHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKTtcbiAgICB2YXIgX2EgPSBwbGFjZVJlY3RzKHNlZ1JlY3RzLCBzZWdzLCBjZWxscyksIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBfYS5zaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMgPSBfYS5tdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyA9IF9hLmxlZnRvdmVyTWFyZ2lucztcbiAgICB2YXIgbW9yZUNudHMgPSBbXTtcbiAgICB2YXIgbW9yZU1hcmdpblRvcHMgPSBbXTtcbiAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xuICAgIGZvciAodmFyIF9pID0gMCwgdW5rbm93bkhlaWdodFNlZ3NfMSA9IHVua25vd25IZWlnaHRTZWdzOyBfaSA8IHVua25vd25IZWlnaHRTZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSB1bmtub3duSGVpZ2h0U2Vnc18xW19pXTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW3NlZy5maXJzdENvbF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgaGlkZGVuRW50cmllc18xID0gaGlkZGVuRW50cmllczsgX2IgPCBoaWRkZW5FbnRyaWVzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBoaWRkZW5FbnRyeSA9IGhpZGRlbkVudHJpZXNfMVtfYl07XG4gICAgICAgIHZhciBzZWcgPSBzZWdzW2hpZGRlbkVudHJ5LmluZGV4XTtcbiAgICAgICAgdmFyIGhpZGRlblNwYW4gPSBoaWRkZW5FbnRyeS5zcGFuO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbaGlkZGVuU3Bhbi5zdGFydF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBoaWRkZW5TcGFuLnN0YXJ0LCBoaWRkZW5TcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGhpZGRlblNwYW4uc3RhcnQ7IGNvbCA8IGhpZGRlblNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9yZUNudHNbY29sXSArPSAxO1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVhbCB3aXRoIGxlZnRvdmVyIG1hcmdpbnNcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVNYXJnaW5Ub3BzLnB1c2gobGVmdG92ZXJNYXJnaW5zW2NvbF0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHM6IG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHM6IG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wczogbW9yZU1hcmdpblRvcHMgfTtcbn1cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHMsIHNlZ3MsIGNlbGxzKSB7XG4gICAgdmFyIHJlY3RzQnlFYWNoQ29sID0gZ3JvdXBSZWN0c0J5RWFjaENvbChhbGxSZWN0cywgY2VsbHMubGVuZ3RoKTtcbiAgICB2YXIgc2luZ2xlQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBtdWx0aUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbGVmdG92ZXJNYXJnaW5zID0gW107XG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICB2YXIgcmVjdHMgPSByZWN0c0J5RWFjaENvbFtjb2xdO1xuICAgICAgICAvLyBjb21wdXRlIGFsbCBzdGF0aWMgc2VncyBpbiBzaW5nbGVQbGFjZW1lbnRzXG4gICAgICAgIHZhciBzaW5nbGVQbGFjZW1lbnRzID0gW107XG4gICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlY3RzXzEgPSByZWN0czsgX2kgPCByZWN0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSByZWN0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG1peGVkIHN0YXRpYy9hYnNvbHV0ZSBzZWdzIGluIG11bHRpUGxhY2VtZW50c1xuICAgICAgICB2YXIgbXVsdGlQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCByZWN0c18yID0gcmVjdHM7IF9hIDwgcmVjdHNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVjdHNfMltfYV07XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHZhciBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cbiAgICAgICAgICAgIHZhciBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XG4gICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xuICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzOiBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2luczogbGVmdG92ZXJNYXJnaW5zIH07XG59XG5mdW5jdGlvbiBncm91cFJlY3RzQnlFYWNoQ29sKHJlY3RzLCBjb2xDbnQpIHtcbiAgICB2YXIgcmVjdHNCeUVhY2hDb2wgPSBbXTtcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgIHJlY3RzQnlFYWNoQ29sLnB1c2goW10pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlY3RzXzMgPSByZWN0czsgX2kgPCByZWN0c18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmVjdCA9IHJlY3RzXzNbX2ldO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSByZWN0LnNwYW4uc3RhcnQ7IGNvbCA8IHJlY3Quc3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByZWN0c0J5RWFjaENvbFtjb2xdLnB1c2gocmVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sO1xufVxuZnVuY3Rpb24gcmVzbGljZVNlZyhzZWcsIHNwYW5TdGFydCwgc3BhbkVuZCwgY2VsbHMpIHtcbiAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgICAgIHJldHVybiBzZWc7XG4gICAgfVxuICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgdmFyIG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgdmFyIHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxudmFyIERheUdyaWRTZWdIaWVyYXJjaHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheUdyaWRTZWdIaWVyYXJjaHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5R3JpZFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICBfdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICBfdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUdyaWRTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoc2VnSW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoaWRkZW5TZWdzID0gX3N1cGVyLnByb3RvdHlwZS5hZGRTZWdzLmNhbGwodGhpcywgc2VnSW5wdXRzKTtcbiAgICAgICAgdmFyIGVudHJpZXNCeUxldmVsID0gdGhpcy5lbnRyaWVzQnlMZXZlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVIaWRkZW4gPSBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5mb3JjZUhpZGRlbltidWlsZEVudHJ5S2V5KGVudHJ5KV07IH07XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9yY2VkLWhpZGRlbiBzZWdzXG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlblNlZ3M7XG4gICAgfTtcbiAgICBEYXlHcmlkU2VnSGllcmFyY2h5LnByb3RvdHlwZS5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uID0gZnVuY3Rpb24gKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZW50cmllc0J5TGV2ZWwgPSBfYS5lbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gPSBfYS5mb3JjZUhpZGRlbjtcbiAgICAgICAgdmFyIHRvdWNoaW5nRW50cnkgPSBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCA9IGluc2VydGlvbi50b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgPSBpbnNlcnRpb24udG91Y2hpbmdMYXRlcmFsO1xuICAgICAgICBpZiAodGhpcy5oaWRkZW5Db25zdW1lcyAmJiB0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBhbHJlYWR5IGhpZGRlblxuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkocGxhY2Vob2xkZXJFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3BsYWNlaG9sZGVyRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gcGxhY2Vob2xkZXJFbnRyeTsgLy8gcmVwbGFjZSB0b3VjaGluZ0VudHJ5IHdpdGggb3VyIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7IC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbi5jYWxsKHRoaXMsIGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUdyaWRTZWdIaWVyYXJjaHk7XG59KFNlZ0hpZXJhcmNoeSkpO1xuXG52YXIgVGFibGVSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUm93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgX3RoaXMuZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICAgICAgICBfdGhpcy5mZ0VsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICAgICAgICBfdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICB2YXIgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBoaWdobGlnaHRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0SGlnaGxpZ2h0U2VncygpLCBjb2xDbnQpO1xuICAgICAgICB2YXIgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgdmFyIF9iID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyksIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBfYi5zaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMgPSBfYi5tdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzID0gX2IubW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzID0gX2IubW9yZU1hcmdpblRvcHM7XG4gICAgICAgIHZhciBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1pcnJvckZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogX3RoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiBfdGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqLywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXJzLCBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMCwgZm9yY2VEYXlUb3A6IHByb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGV4dHJhSG9va1Byb3BzOiBjZWxsLmV4dHJhSG9va1Byb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiBfdGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBmZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG1pcnJvckZnTm9kZXMpKSksIGJnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpIH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIGN1cnJlbnRQcm9wcykpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldEhpZ2hsaWdodFNlZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0TWlycm9yU2VncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIGV2ZW50U2VsZWN0aW9uID0gdGhpcy5wcm9wcy5ldmVudFNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMTsgLy8gY29sQ250ID09PSAxXG4gICAgICAgIHZhciBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2VnUGxhY2VtZW50c18xID0gc2VnUGxhY2VtZW50czsgX2kgPCBzZWdQbGFjZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNlZ1BsYWNlbWVudHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHBsYWNlbWVudC5zZWc7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbnN0YW5jZUlkICsgJzonICsgY29sO1xuICAgICAgICAgICAgICAgIHZhciBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xuICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleToga2V5LCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBfX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmlsbFNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgdmFyIGlzUnRsID0gdGhpcy5jb250ZXh0LmlzUnRsO1xuICAgICAgICB2YXIgdG9kYXlSYW5nZSA9IHRoaXMucHJvcHMudG9kYXlSYW5nZTtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSA6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtGcmFnbWVudCwge31dLCBub2RlcykpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGZyYW1lRWxSZWZzID0gX2EuZnJhbWVFbFJlZnM7XG4gICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7IHJldHVybiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkSW5zdGFuY2VIZWlnaHRzID0gdGhpcy5zdGF0ZS5ldmVudEluc3RhbmNlSGVpZ2h0cztcbiAgICAgICAgICAgIHZhciBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcbiAgICAgICAgICAgIHZhciBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xuICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb2xkSW5zdGFuY2VIZWlnaHRzKSwgbmV3SW5zdGFuY2VIZWlnaHRzKSxcbiAgICAgICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBsaW1pdEJ5Q29udGVudEhlaWdodCA/IHRoaXMuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcDtcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VIZWlnaHRzID0ge307XG4gICAgICAgIC8vIGdldCB0aGUgbWF4IGhlaWdodCBhbW9uZ3N0IGluc3RhbmNlIHNlZ3NcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNlZ0VsTWFwKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtrZXldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IGtleS5zcGxpdCgnOicpWzBdOyAvLyBkZWNvbnN0cnVjdCBob3cgcmVuZGVyRmdTZWdzIG1ha2VzIHRoZSBrZXlcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdID0gTWF0aC5tYXgoZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gfHwgMCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZUhlaWdodHM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xuICAgICAgICB2YXIgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICB2YXIgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0Q2VsbEVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gZWxNYXBbY2VsbC5rZXldOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZVJvdztcbn0oRGF0ZUNvbXBvbmVudCkpO1xuVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcbiAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XG4gICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHsgcmV0dXJuICh7XG4gICAgICAgIHNlZzogc2VnLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGFic29sdXRlVG9wOiB0b3BzQnlJbnN0YW5jZUlkW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykge1xuICAgIHZhciB0b3BzQnlJbnN0YW5jZUlkID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb2xQbGFjZW1lbnRzXzEgPSBjb2xQbGFjZW1lbnRzOyBfaSA8IGNvbFBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudHMgPSBjb2xQbGFjZW1lbnRzXzFbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBsYWNlbWVudHNfMSA9IHBsYWNlbWVudHM7IF9hIDwgcGxhY2VtZW50c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNfMVtfYV07XG4gICAgICAgICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wc0J5SW5zdGFuY2VJZDtcbn1cblxudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgX3RoaXMucm93UmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogX3RoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGUsIGRheU1heEV2ZW50Um93cyA9IHByb3BzLmRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzID0gcHJvcHMuZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzID0gcHJvcHMuZXhwYW5kUm93cztcbiAgICAgICAgdmFyIHJvd0NudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCByb3dDbnQpO1xuICAgICAgICB2YXIgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KTtcbiAgICAgICAgdmFyIGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgICAgIC8vIFRPRE86IGJlc3QgcGxhY2UgdG8gbm9ybWFsaXplIHRoZXNlIG9wdGlvbnM/XG4gICAgICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcbiAgICAgICAgICAgIGV4cGFuZFJvd3MgPyAnJyA6ICdmYy1kYXlncmlkLWJvZHktbmF0dXJhbCcsIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgZnVuY3Rpb24gKG5vd0RhdGUsIHRvZGF5UmFuZ2UpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtdGFibGVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbHMsIHJvdykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGVSb3csIHsgcmVmOiBfdGhpcy5yb3dSZWZzLmNyZWF0ZVJlZihyb3cpLCBrZXk6IGNlbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbHNbMF0uZGF0ZS50b0lTT1N0cmluZygpIC8qIGJlc3Q/IG9yIHB1dCBrZXkgb24gY2VsbD8gb3IgdXNlIGRpZmYgZm9ybWF0dGVyPyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcm93IC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNlbGxzIChsaWtlIHdoZW4gcmVzb3VyY2UgdmlldyBpcyBsb2FkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLCBzaG93RGF5TnVtYmVyczogcm93Q250ID4gMSwgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgY2VsbHM6IGNlbGxzLCByZW5kZXJJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tyb3ddLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGJnRXZlbnRTZWdzOiBiZ0V2ZW50U2Vnc0J5Um93W3Jvd10uZmlsdGVyKGlzU2VnQWxsRGF5KSAvKiBoYWNrICovLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tyb3ddLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W3Jvd10sIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZUJ5Um93W3Jvd10sIGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfSkpKSkpOyB9KSkpO1xuICAgIH07XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBUYWJsZS5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jb2xsZWN0KCkubWFwKGZ1bmN0aW9uIChyb3dPYmopIHsgcmV0dXJuIHJvd09iai5nZXRDZWxsRWxzKClbMF07IH0pLCAvLyBmaXJzdCBjZWxsIGVsIGluIGVhY2ggcm93LiBUT0RPOiBub3Qgb3B0aW1hbFxuICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgZmFsc2UpO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29sUG9zaXRpb25zID0gX2EuY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgPSBfYS5yb3dQb3NpdGlvbnM7XG4gICAgICAgIHZhciBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgdmFyIHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogX19hc3NpZ24oeyByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLCBhbGxEYXk6IHRydWUgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldENlbGxFbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRDZWxsUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgdmFyIGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KERhdGVDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xufVxuXG52YXIgRGF5VGFibGVTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheVRhYmxlU2xpY2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRhYmxlU2xpY2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZVNsaWNlci5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChkYXRlUmFuZ2UsIGRheVRhYmxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRhYmxlU2xpY2VyO1xufShTbGljZXIpKTtcblxudmFyIERheVRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNsaWNlciA9IG5ldyBEYXlUYWJsZVNsaWNlcigpO1xuICAgICAgICBfdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGUsIF9fYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZTtcbn0oRGF0ZUNvbXBvbmVudCkpO1xuXG52YXIgRGF5VGFibGVWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlUYWJsZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpO1xuICAgICAgICBfdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBfYS5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcbiAgICAgICAgdmFyIGJvZHlDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheVRhYmxlLCB7IHJlZjogX3RoaXMudGFibGVSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgZGF5TWF4RXZlbnRzOiBvcHRpb25zLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBvcHRpb25zLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBvcHRpb25zLndlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiAhcHJvcHMuaXNIZWlnaHRBdXRvLCBoZWFkZXJBbGlnbkVsUmVmOiBfdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7IH07XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZVZpZXc7XG59KFRhYmxlVmlldykpO1xuZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcbn1cblxudmFyIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLnByb3BzLmRhdGVFbnY7XG4gICAgICAgIHZhciByZW5kZXJSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHZhciBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gcmVuZGVyUmFuZ2UuZW5kO1xuICAgICAgICB2YXIgZW5kT2ZXZWVrO1xuICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xuICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSA2IHdlZWtzXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vbnRoTW9kZSAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5maXhlZFdlZWtDb3VudCkge1xuICAgICAgICAgICAgdmFyIHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgICAgICBkaWZmV2Vla3Moc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbn0oRGF0ZVByb2ZpbGVHZW5lcmF0b3IpKTtcblxudmFyIG1haW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICB2aWV3czoge1xuICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRhYmxlVmlldyxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICBtb250aE1vZGU6IHRydWUsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1haW47XG5leHBvcnQgeyBEYXlUYWJsZVZpZXcgYXMgRGF5R3JpZFZpZXcsIERheVRhYmxlLCBEYXlUYWJsZVNsaWNlciwgVGFibGUsIFRhYmxlVmlldywgYnVpbGREYXlUYWJsZU1vZGVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlZiIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiY3JlYXRlRWxlbWVudCIsIlZpZXdSb290IiwiU2ltcGxlU2Nyb2xsR3JpZCIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsInJlbmRlclNjcm9sbFNoaW0iLCJEYXRlQ29tcG9uZW50IiwiYnVpbGROYXZMaW5rQXR0cnMiLCJEYXlDZWxsQ29udGVudCIsIkZyYWdtZW50IiwiQmFzZUNvbXBvbmVudCIsImNyZWF0ZUZvcm1hdHRlciIsIlN0YW5kYXJkRXZlbnQiLCJidWlsZFNlZ1RpbWVUZXh0IiwiRXZlbnRSb290IiwiZ2V0U2VnQW5jaG9yQXR0cnMiLCJtZW1vaXplIiwiTW9yZUxpbmtSb290IiwiZ2V0U2VnTWV0YSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiZ2V0VW5pcXVlRG9tSWQiLCJzZXRSZWYiLCJEYXlDZWxsUm9vdCIsIldlZWtOdW1iZXJSb290IiwiYnVpbGRFbnRyeUtleSIsImludGVyc2VjdFNwYW5zIiwiU2VnSGllcmFyY2h5IiwiaW50ZXJzZWN0UmFuZ2VzIiwiYWRkRGF5cyIsIlJlZk1hcCIsInNvcnRFdmVudFNlZ3MiLCJpc1Byb3BzRXF1YWwiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJCZ0V2ZW50IiwicmVuZGVyRmlsbCIsIlBvc2l0aW9uQ2FjaGUiLCJOb3dUaW1lciIsIlNsaWNlciIsIkRheUhlYWRlciIsIkRheVNlcmllc01vZGVsIiwiRGF5VGFibGVNb2RlbCIsImFkZFdlZWtzIiwiZGlmZldlZWtzIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJjcmVhdGVQbHVnaW4iLCJfX2V4dGVuZHMiLCJfX2Fzc2lnbiIsIl9fc3ByZWFkQXJyYXkiLCJUYWJsZVZpZXciLCJfc3VwZXIiLCJfdGhpcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiaGVhZGVyRWxSZWYiLCJwcm90b3R5cGUiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwiYm9keUNvbnRlbnQiLCJfYSIsInByb3BzIiwiY29udGV4dCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJvcHRpb25zIiwicHVzaCIsInR5cGUiLCJrZXkiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJsaXF1aWQiLCJjb250ZW50Iiwidmlld1NwZWMiLCJyb290RWxSZWYiLCJjbGFzc05hbWVzIiwicmVmIiwiY2xhc3NOYW1lIiwiY29uY2F0Iiwiam9pbiIsImlzSGVpZ2h0QXV0byIsImZvclByaW50IiwiY29sbGFwc2libGVXaWR0aCIsImNvbHMiLCJyZW5kZXJIU2Nyb2xsTGF5b3V0IiwiY29sQ250IiwiZGF5TWluV2lkdGgiLCJTY3JvbGxHcmlkIiwicGx1Z2luSG9va3MiLCJzY3JvbGxHcmlkSW1wbCIsIkVycm9yIiwic3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiY2h1bmtzIiwiY29sR3JvdXBzIiwic3BhbiIsIm1pbldpZHRoIiwic3BsaXRTZWdzQnlSb3ciLCJzZWdzIiwicm93Q250IiwiYnlSb3ciLCJpIiwiX2kiLCJzZWdzXzEiLCJsZW5ndGgiLCJzZWciLCJyb3ciLCJzcGxpdFNlZ3NCeUZpcnN0Q29sIiwiYnlDb2wiLCJzZWdzXzIiLCJmaXJzdENvbCIsInNwbGl0SW50ZXJhY3Rpb25CeVJvdyIsInVpIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50IiwiVGFibGVDZWxsVG9wIiwicmVuZGVyIiwibmF2TGlua0F0dHJzIiwiZGF0ZSIsImRhdGVQcm9maWxlIiwidG9kYXlSYW5nZSIsInNob3dEYXlOdW1iZXIiLCJleHRyYUhvb2tQcm9wcyIsImRlZmF1bHRDb250ZW50IiwicmVuZGVyVG9wSW5uZXIiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50IiwiZm9yY2VEYXlUb3AiLCJpZCIsImRheU51bWJlcklkIiwiZGF5TnVtYmVyVGV4dCIsIkRFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQiLCJob3VyIiwibWludXRlIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsImhhc0xpc3RJdGVtRGlzcGxheSIsImRpc3BsYXkiLCJldmVudFJhbmdlIiwiZGVmIiwiYWxsRGF5IiwibGFzdENvbCIsImlzU3RhcnQiLCJpc0VuZCIsIlRhYmxlQmxvY2tFdmVudCIsImV4dHJhQ2xhc3NOYW1lcyIsImRlZmF1bHRUaW1lRm9ybWF0IiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsImRpc2FibGVSZXNpemluZyIsIlRhYmxlTGlzdEl0ZW1FdmVudCIsInRpbWVGb3JtYXQiLCJldmVudFRpbWVGb3JtYXQiLCJ0aW1lVGV4dCIsInJlbmRlcklubmVyQ29udGVudCIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwiaXNTZWxlY3RlZCIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImlubmVyUHJvcHMiLCJzdHlsZSIsImJvcmRlckNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZXZlbnQiLCJ0aXRsZSIsIlRhYmxlQ2VsbE1vcmVMaW5rIiwiY29tcGlsZVNlZ3MiLCJzaW5nbGVQbGFjZW1lbnRzIiwiYWxsU2VncyIsImludmlzaWJsZVNlZ3MiLCJhbGxEYXlEYXRlIiwibW9yZUNudCIsImhpZGRlblNlZ3MiLCJhbGlnbm1lbnRFbFJlZiIsImFsaWduR3JpZFRvcCIsImV4dHJhRGF0ZVNwYW4iLCJwb3BvdmVyQ29udGVudCIsImlzRm9yY2VkSW52aXNpYmxlIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemUiLCJtYXAiLCJpbnN0YW5jZUlkIiwiaW5zdGFuY2UiLCJ2aXNpYmlsaXR5IiwiZXZlbnRTZWxlY3Rpb24iLCJoYW5kbGVDbGljayIsImlzRXhwYW5kZWQiLCJwb3BvdmVySWQiLCJzaW5nbGVQbGFjZW1lbnRzXzEiLCJwbGFjZW1lbnQiLCJpc1Zpc2libGUiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJUYWJsZUNlbGwiLCJzdGF0ZSIsImhhbmRsZVJvb3RFbCIsImVsIiwiZGF5RWxSZWYiLCJkYXlDbGFzc05hbWVzIiwicm9vdERhdGFBdHRycyIsImlzRGlzYWJsZWQiLCJyb2xlIiwiZXh0cmFEYXRhQXR0cnMiLCJzaG93V2Vla051bWJlciIsImRlZmF1bHRGb3JtYXQiLCJ3ZWVrRWxSZWYiLCJ3ZWVrQ2xhc3NOYW1lcyIsImZnQ29udGVudEVsUmVmIiwiZmdDb250ZW50IiwibWFyZ2luVG9wIiwibW9yZU1hcmdpblRvcCIsImJnQ29udGVudCIsImNvbXB1dGVGZ1NlZ1BsYWNlbWVudCIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsInN0cmljdE9yZGVyIiwiZXZlbnRJbnN0YW5jZUhlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiY2VsbHMiLCJoaWVyYXJjaHkiLCJEYXlHcmlkU2VnSGllcmFyY2h5IiwiYWxsb3dSZXNsaWNpbmciLCJtYXhDb29yZCIsImhpZGRlbkNvbnN1bWVzIiwibWF4U3RhY2tDbnQiLCJzZWdJbnB1dHMiLCJ1bmtub3duSGVpZ2h0U2VncyIsImV2ZW50SGVpZ2h0IiwiaW5kZXgiLCJ0aGlja25lc3MiLCJzdGFydCIsImVuZCIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwic2VnUmVjdHMiLCJ0b1JlY3RzIiwicGxhY2VSZWN0cyIsInNpbmdsZUNvbFBsYWNlbWVudHMiLCJtdWx0aUNvbFBsYWNlbWVudHMiLCJsZWZ0b3Zlck1hcmdpbnMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwidW5rbm93bkhlaWdodFNlZ3NfMSIsImlzQWJzb2x1dGUiLCJhYnNvbHV0ZVRvcCIsImNvbCIsInJlc2xpY2VTZWciLCJfYiIsImhpZGRlbkVudHJpZXNfMSIsImhpZGRlbkVudHJ5IiwiaGlkZGVuU3BhbiIsImFsbFJlY3RzIiwicmVjdHNCeUVhY2hDb2wiLCJncm91cFJlY3RzQnlFYWNoQ29sIiwicmVjdHMiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsInJlY3RzXzEiLCJyZWN0IiwibGV2ZWxDb29yZCIsIm11bHRpUGxhY2VtZW50cyIsInJlY3RzXzIiLCJpc0ZpcnN0Q29sIiwicmVjdHNfMyIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJvcmlnUmFuZ2UiLCJyYW5nZSIsInNsaWNlZFJhbmdlIiwiZHVyYXRpb25FZGl0YWJsZSIsInZhbHVlT2YiLCJmb3JjZUhpZGRlbiIsImNhbGwiLCJlbnRyaWVzQnlMZXZlbCIsImV4Y2x1ZGVIaWRkZW4iLCJlbnRyeSIsImxldmVsIiwiZmlsdGVyIiwiaGFuZGxlSW52YWxpZEluc2VydGlvbiIsImluc2VydGlvbiIsInRvdWNoaW5nRW50cnkiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidG91Y2hpbmdFbnRyeUlkIiwicGxhY2Vob2xkZXJFbnRyeSIsInBsYWNlaG9sZGVyRW50cnlJZCIsInNwbGl0RW50cnkiLCJUYWJsZVJvdyIsImNlbGxFbFJlZnMiLCJmcmFtZUVsUmVmcyIsImZnRWxSZWZzIiwic2VnSGFybmVzc1JlZnMiLCJmcmFtZVBvc2l0aW9ucyIsImJ1c2luZXNzSG91cnNCeUNvbCIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2Vnc0J5Q29sIiwiYmdFdmVudFNlZ3MiLCJoaWdobGlnaHRTZWdzQnlDb2wiLCJnZXRIaWdobGlnaHRTZWdzIiwibWlycm9yU2Vnc0J5Q29sIiwiZ2V0TWlycm9yU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJyZW5kZXJJbnRybyIsImNlbGwiLCJub3JtYWxGZ05vZGVzIiwicmVuZGVyRmdTZWdzIiwibWlycm9yRmdOb2RlcyIsImJ1aWxkTWlycm9yUGxhY2VtZW50cyIsIkJvb2xlYW4iLCJzaG93RGF5TnVtYmVycyIsInNob3dXZWVrTnVtYmVycyIsInJlbmRlckZpbGxTZWdzIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVTaXppbmciLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJjdXJyZW50UHJvcHMiLCJkYXRlU2VsZWN0aW9uU2VncyIsInNlZ1BsYWNlbWVudHMiLCJpc01pcnJvciIsIm5vZGVzIiwic2VnUGxhY2VtZW50c18xIiwibGVmdCIsInJpZ2h0IiwiaXNSdGwiLCJsZWZ0cyIsInJpZ2h0cyIsInRvcCIsImZpbGxUeXBlIiwibGVmdFJpZ2h0Q3NzIiwiaXNFeHRlcm5hbFNpemluZ0NoYW5nZSIsImNsaWVudFdpZHRoIiwiZnJhbWVFbHMiLCJjdXJyZW50TWFwIiwib3JpZ2luRWwiLCJjdXJyZW50Iiwic2V0U3RhdGUiLCJvbGRJbnN0YW5jZUhlaWdodHMiLCJuZXdJbnN0YW5jZUhlaWdodHMiLCJxdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzIiwibGltaXRCeUNvbnRlbnRIZWlnaHQiLCJjb21wdXRlTWF4Q29udGVudEhlaWdodCIsInNlZ0VsTWFwIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic3BsaXQiLCJtYXgiLCJmaXJzdEtleSIsImNlbGxFbCIsImZjQ29udGFpbmVyRWwiLCJib3R0b20iLCJnZXRDZWxsRWxzIiwiZWxNYXAiLCJhZGRTdGF0ZUVxdWFsaXR5IiwibWlycm9yU2VncyIsImNvbFBsYWNlbWVudHMiLCJ0b3BzQnlJbnN0YW5jZUlkIiwiYnVpbGRBYnNvbHV0ZVRvcEhhc2giLCJjb2xQbGFjZW1lbnRzXzEiLCJwbGFjZW1lbnRzIiwicGxhY2VtZW50c18xIiwiVGFibGUiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdEJnRXZlbnRTZWdzIiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MiLCJzcGxpdEV2ZW50RHJhZyIsInNwbGl0RXZlbnRSZXNpemUiLCJyb3dSZWZzIiwicm9vdEVsIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiZXhwYW5kUm93cyIsImJ1c2luZXNzSG91clNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJmZ0V2ZW50U2Vnc0J5Um93IiwiZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyIsImV2ZW50RHJhZ0J5Um93IiwiZXZlbnRSZXNpemVCeVJvdyIsImxpbWl0VmlhQmFsYW5jZWQiLCJ3aWR0aCIsInRhYmxlTWluV2lkdGgiLCJ1bml0Iiwibm93RGF0ZSIsImNsaWVudEhlaWdodCIsImNvbEdyb3VwTm9kZSIsInRvSVNPU3RyaW5nIiwicmVuZGVyUm93SW50cm8iLCJpc1NlZ0FsbERheSIsInByZXBhcmVIaXRzIiwicm93UG9zaXRpb25zIiwiY29sbGVjdCIsInJvd09iaiIsImNvbFBvc2l0aW9ucyIsInF1ZXJ5SGl0IiwicG9zaXRpb25MZWZ0IiwicG9zaXRpb25Ub3AiLCJsZWZ0VG9JbmRleCIsInRvcFRvSW5kZXgiLCJkYXRlU3BhbiIsImdldENlbGxSYW5nZSIsImRheUVsIiwiZ2V0Q2VsbEVsIiwidG9wcyIsImJvdHRvbXMiLCJsYXllciIsIkRheVRhYmxlU2xpY2VyIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VSYW5nZSIsImRhdGVSYW5nZSIsImRheVRhYmxlTW9kZWwiLCJEYXlUYWJsZSIsInNsaWNlciIsInRhYmxlUmVmIiwic2xpY2VQcm9wcyIsIm5leHREYXlUaHJlc2hvbGQiLCJoZWFkZXJBbGlnbkVsUmVmIiwiRGF5VGFibGVWaWV3IiwiYnVpbGREYXlUYWJsZU1vZGVsIiwiaGVhZGVyUmVmIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJoZWFkZXJDb250ZW50IiwiZGF5SGVhZGVycyIsImRhdGVzIiwiaGVhZGVyRGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsImNvbnRlbnRBcmciLCJidXNpbmVzc0hvdXJzIiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsIndlZWtOdW1iZXJzIiwiZGF5U2VyaWVzIiwicmVuZGVyUmFuZ2UiLCJ0ZXN0IiwiY3VycmVudFJhbmdlVW5pdCIsIlRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJidWlsZFJlbmRlclJhbmdlIiwiY3VycmVudFJhbmdlIiwiaXNSYW5nZUFsbERheSIsImRhdGVFbnYiLCJlbmRPZldlZWsiLCJzdGFydE9mV2VlayIsIm1vbnRoTW9kZSIsImZpeGVkV2Vla0NvdW50IiwiY2VpbCIsIm1haW4iLCJpbml0aWFsVmlldyIsInZpZXdzIiwiZGF5R3JpZCIsImNvbXBvbmVudCIsImRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJkYXlHcmlkRGF5IiwiZHVyYXRpb24iLCJkYXlzIiwiZGF5R3JpZFdlZWsiLCJ3ZWVrcyIsImRheUdyaWRNb250aCIsIm1vbnRocyIsIkRheUdyaWRWaWV3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/main.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/main.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom */ \"./node_modules/@fullcalendar/react/dist/vdom.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\nvar FullCalendar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(FullCalendar, _super);\n\n  function FullCalendar() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._calendarApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarApi();\n    return _this;\n  }\n\n  FullCalendar.prototype.render = function () {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarDataProvider, {\n      optionOverrides: this.props,\n      calendarApi: this._calendarApi\n    }, function (data) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarRoot, {\n        options: data.calendarOptions,\n        theme: data.theme,\n        emitter: data.emitter\n      }, function (classNames, height, isHeightAuto, forPrint) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n          className: classNames.join(' '),\n          style: {\n            height: height\n          }\n        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarContent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n          isHeightAuto: isHeightAuto,\n          forPrint: forPrint\n        }, data)));\n      });\n    });\n  };\n\n  FullCalendar.prototype.getApi = function () {\n    return this._calendarApi;\n  };\n\n  return FullCalendar;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FullCalendar); // export all important utils/types\n\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUlPLFlBQVksR0FBa0IsVUFBVUMsTUFBVixFQUFrQjtBQUNoRFAsRUFBQUEsZ0RBQVMsQ0FBQ00sWUFBRCxFQUFlQyxNQUFmLENBQVQ7O0FBQ0EsV0FBU0QsWUFBVCxHQUF3QjtBQUNwQixRQUFJRSxLQUFLLEdBQUdELE1BQU0sS0FBSyxJQUFYLElBQW1CQSxNQUFNLENBQUNFLEtBQVAsQ0FBYSxJQUFiLEVBQW1CQyxTQUFuQixDQUFuQixJQUFvRCxJQUFoRTs7QUFDQUYsSUFBQUEsS0FBSyxDQUFDRyxZQUFOLEdBQXFCLElBQUlULDZEQUFKLEVBQXJCO0FBQ0EsV0FBT00sS0FBUDtBQUNIOztBQUNERixFQUFBQSxZQUFZLENBQUNNLFNBQWIsQ0FBdUJDLE1BQXZCLEdBQWdDLFlBQVk7QUFDeEMsd0JBQVFaLGdEQUFBLENBQW9CRSxzRUFBcEIsRUFBMEM7QUFBRVksTUFBQUEsZUFBZSxFQUFFLEtBQUtDLEtBQXhCO0FBQStCQyxNQUFBQSxXQUFXLEVBQUUsS0FBS047QUFBakQsS0FBMUMsRUFBMkcsVUFBVU8sSUFBVixFQUFnQjtBQUFFLDBCQUFRakIsZ0RBQUEsQ0FBb0JJLDhEQUFwQixFQUFrQztBQUFFYyxRQUFBQSxPQUFPLEVBQUVELElBQUksQ0FBQ0UsZUFBaEI7QUFBaUNDLFFBQUFBLEtBQUssRUFBRUgsSUFBSSxDQUFDRyxLQUE3QztBQUFvREMsUUFBQUEsT0FBTyxFQUFFSixJQUFJLENBQUNJO0FBQWxFLE9BQWxDLEVBQStHLFVBQVVDLFVBQVYsRUFBc0JDLE1BQXRCLEVBQThCQyxZQUE5QixFQUE0Q0MsUUFBNUMsRUFBc0Q7QUFBRSw0QkFBUXpCLGdEQUFBLENBQW9CLEtBQXBCLEVBQTJCO0FBQUUwQixVQUFBQSxTQUFTLEVBQUVKLFVBQVUsQ0FBQ0ssSUFBWCxDQUFnQixHQUFoQixDQUFiO0FBQW1DQyxVQUFBQSxLQUFLLEVBQUU7QUFBRUwsWUFBQUEsTUFBTSxFQUFFQTtBQUFWO0FBQTFDLFNBQTNCLGVBQ3hUdkIsZ0RBQUEsQ0FBb0JHLGlFQUFwQixFQUFxQ0wsK0NBQVEsQ0FBQztBQUFFMEIsVUFBQUEsWUFBWSxFQUFFQSxZQUFoQjtBQUE4QkMsVUFBQUEsUUFBUSxFQUFFQTtBQUF4QyxTQUFELEVBQXFEUixJQUFyRCxDQUE3QyxDQUR3VCxDQUFSO0FBQ25NLE9BRDRCLENBQVI7QUFDZixLQUQ5RyxDQUFSO0FBRUgsR0FIRDs7QUFJQVosRUFBQUEsWUFBWSxDQUFDTSxTQUFiLENBQXVCa0IsTUFBdkIsR0FBZ0MsWUFBWTtBQUN4QyxXQUFPLEtBQUtuQixZQUFaO0FBQ0gsR0FGRDs7QUFHQSxTQUFPTCxZQUFQO0FBQ0gsQ0FmaUMsQ0FlaENMLDRDQWZnQyxDQUFsQzs7QUFnQkEsK0RBQWVLLFlBQWYsR0FDQTs7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uanM/NTM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgJy4vdmRvbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYWxlbmRhckFwaSwgQ2FsZW5kYXJEYXRhUHJvdmlkZXIsIENhbGVuZGFyQ29udGVudCwgQ2FsZW5kYXJSb290IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nO1xudmFyIEZ1bGxDYWxlbmRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVsbENhbGVuZGFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bGxDYWxlbmRhcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jYWxlbmRhckFwaSA9IG5ldyBDYWxlbmRhckFwaSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1bGxDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJEYXRhUHJvdmlkZXIsIHsgb3B0aW9uT3ZlcnJpZGVzOiB0aGlzLnByb3BzLCBjYWxlbmRhckFwaTogdGhpcy5fY2FsZW5kYXJBcGkgfSwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBkYXRhLmNhbGVuZGFyT3B0aW9ucywgdGhlbWU6IGRhdGEudGhlbWUsIGVtaXR0ZXI6IGRhdGEuZW1pdHRlciB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogaGVpZ2h0IH0gfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJDb250ZW50LCBfX2Fzc2lnbih7IGlzSGVpZ2h0QXV0bzogaXNIZWlnaHRBdXRvLCBmb3JQcmludDogZm9yUHJpbnQgfSwgZGF0YSkpKSk7IH0pKTsgfSkpO1xuICAgIH07XG4gICAgRnVsbENhbGVuZGFyLnByb3RvdHlwZS5nZXRBcGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhckFwaTtcbiAgICB9O1xuICAgIHJldHVybiBGdWxsQ2FsZW5kYXI7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0IGRlZmF1bHQgRnVsbENhbGVuZGFyO1xuLy8gZXhwb3J0IGFsbCBpbXBvcnRhbnQgdXRpbHMvdHlwZXNcbmV4cG9ydCAqIGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIl0sIm5hbWVzIjpbIl9fYXNzaWduIiwiX19leHRlbmRzIiwiUmVhY3QiLCJDYWxlbmRhckFwaSIsIkNhbGVuZGFyRGF0YVByb3ZpZGVyIiwiQ2FsZW5kYXJDb250ZW50IiwiQ2FsZW5kYXJSb290IiwiRnVsbENhbGVuZGFyIiwiX3N1cGVyIiwiX3RoaXMiLCJhcHBseSIsImFyZ3VtZW50cyIsIl9jYWxlbmRhckFwaSIsInByb3RvdHlwZSIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJvcHRpb25PdmVycmlkZXMiLCJwcm9wcyIsImNhbGVuZGFyQXBpIiwiZGF0YSIsIm9wdGlvbnMiLCJjYWxlbmRhck9wdGlvbnMiLCJ0aGVtZSIsImVtaXR0ZXIiLCJjbGFzc05hbWVzIiwiaGVpZ2h0IiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjbGFzc05hbWUiLCJqb2luIiwic3R5bGUiLCJnZXRBcGkiLCJDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/vdom.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/vdom.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flushToDom\": function() { return /* binding */ flushToDom; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n(typeof globalThis !== 'undefined' ? globalThis : window).FullCalendarVDom = {\n  Component: react__WEBPACK_IMPORTED_MODULE_0__.Component,\n  createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement,\n  render: react_dom__WEBPACK_IMPORTED_MODULE_1__.render,\n  createRef: react__WEBPACK_IMPORTED_MODULE_0__.createRef,\n  Fragment: react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n  createContext: react__WEBPACK_IMPORTED_MODULE_0__.createContext,\n  createPortal: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal,\n  flushToDom: flushToDom,\n  unmountComponentAtNode: react_dom__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode\n};\nfunction flushToDom() {// always sync from top-level\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLENBQUMsT0FBT0UsVUFBUCxLQUFzQixXQUF0QixHQUFvQ0EsVUFBcEMsR0FBaURDLE1BQWxELEVBQTBEQyxnQkFBMUQsR0FBNkU7QUFDekVDLEVBQUFBLFNBQVMsRUFBRUwsNENBRDhEO0FBRXpFTSxFQUFBQSxhQUFhLEVBQUVOLGdEQUYwRDtBQUd6RU8sRUFBQUEsTUFBTSxFQUFFTiw2Q0FIaUU7QUFJekVPLEVBQUFBLFNBQVMsRUFBRVIsNENBSjhEO0FBS3pFUyxFQUFBQSxRQUFRLEVBQUVULDJDQUwrRDtBQU16RVUsRUFBQUEsYUFBYSxFQUFFVixnREFOMEQ7QUFPekVXLEVBQUFBLFlBQVksRUFBRVYsbURBUDJEO0FBUXpFVyxFQUFBQSxVQUFVLEVBQUVBLFVBUjZEO0FBU3pFQyxFQUFBQSxzQkFBc0IsRUFBRVosNkRBQStCWTtBQVRrQixDQUE3RTtBQVdPLFNBQVNELFVBQVQsR0FBc0IsQ0FDekI7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uanM/NGRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyByZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyByZWFjdERvbSBmcm9tICdyZWFjdC1kb20nO1xuKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB3aW5kb3cpLkZ1bGxDYWxlbmRhclZEb20gPSB7XG4gICAgQ29tcG9uZW50OiByZWFjdC5Db21wb25lbnQsXG4gICAgY3JlYXRlRWxlbWVudDogcmVhY3QuY3JlYXRlRWxlbWVudCxcbiAgICByZW5kZXI6IHJlYWN0RG9tLnJlbmRlcixcbiAgICBjcmVhdGVSZWY6IHJlYWN0LmNyZWF0ZVJlZixcbiAgICBGcmFnbWVudDogcmVhY3QuRnJhZ21lbnQsXG4gICAgY3JlYXRlQ29udGV4dDogcmVhY3QuY3JlYXRlQ29udGV4dCxcbiAgICBjcmVhdGVQb3J0YWw6IHJlYWN0RG9tLmNyZWF0ZVBvcnRhbCxcbiAgICBmbHVzaFRvRG9tOiBmbHVzaFRvRG9tLFxuICAgIHVubW91bnRDb21wb25lbnRBdE5vZGU6IHJlYWN0RG9tLnVubW91bnRDb21wb25lbnRBdE5vZGVcbn07XG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUb0RvbSgpIHtcbiAgICAvLyBhbHdheXMgc3luYyBmcm9tIHRvcC1sZXZlbFxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmRvbS5qcy5tYXAiXSwibmFtZXMiOlsicmVhY3QiLCJyZWFjdERvbSIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJGdWxsQ2FsZW5kYXJWRG9tIiwiQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsInJlbmRlciIsImNyZWF0ZVJlZiIsIkZyYWdtZW50IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVBvcnRhbCIsImZsdXNoVG9Eb20iLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/timegrid/main.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DayTimeCols\": function() { return /* binding */ DayTimeCols; },\n/* harmony export */   \"DayTimeColsSlicer\": function() { return /* binding */ DayTimeColsSlicer; },\n/* harmony export */   \"DayTimeColsView\": function() { return /* binding */ DayTimeColsView; },\n/* harmony export */   \"TimeCols\": function() { return /* binding */ TimeCols; },\n/* harmony export */   \"TimeColsSlatsCoords\": function() { return /* binding */ TimeColsSlatsCoords; },\n/* harmony export */   \"TimeColsView\": function() { return /* binding */ TimeColsView; },\n/* harmony export */   \"buildDayRanges\": function() { return /* binding */ buildDayRanges; },\n/* harmony export */   \"buildSlatMetas\": function() { return /* binding */ buildSlatMetas; },\n/* harmony export */   \"buildTimeColsModel\": function() { return /* binding */ buildTimeColsModel; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n\nvar AllDaySplitter = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(AllDaySplitter, _super);\n\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n\n    return ['timed'];\n  };\n\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n\n    if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.hasBgRendering)(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n\n    return ['allDay'];\n  };\n\n  return AllDaySplitter;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Splitter);\n\nvar DEFAULT_SLAT_LABEL_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\n\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n\n    var dateEnv = context.dateEnv,\n        options = context.options,\n        viewApi = context.viewApi;\n    var labelFormat = // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)(options.slotLabelFormat[0]) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)(options.slotLabelFormat);\n    var hookProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLabelClassNames,\n      content: options.slotLabelContent,\n      defaultContent: renderInnerContent,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-time\": props.isoTimeStr\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n        ref: innerElRef\n      }, innerContent)));\n    });\n  });\n}\n\n_c2 = TimeColsAxisCell;\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nvar TimeBodyAxis = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeBodyAxis, _super);\n\n  function TimeBodyAxis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeBodyAxis.prototype.render = function () {\n    return this.props.slatMetas.map(function (slatMeta) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n        key: slatMeta.key\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColsAxisCell, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, slatMeta)));\n    });\n  };\n\n  return TimeBodyAxis;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n\nvar TimeColsView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColsView, _super);\n\n  function TimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n\n    _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.scrollerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n\n\n    _this.renderHeadAxis = function (rowKey, frameHeight) {\n      if (frameHeight === void 0) {\n        frameHeight = '';\n      }\n\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDays)(range.start, range.end);\n      var navLinkAttrs = dayCnt === 1 ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildNavLinkAttrs)(_this.context, range.start, 'week') : {};\n\n      if (options.weekNumbers && rowKey === 'day') {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WeekNumberRoot, {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"th\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n            style: {\n              height: frameHeight\n            }\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            ref: innerElRef,\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n          }, navLinkAttrs), innerContent)));\n        });\n      }\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n\n\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _a = _this.context,\n          options = _a.options,\n          viewApi = _a.viewApi;\n      var hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (// TODO: make reusable hook. used in list view too\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RenderHook, {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n            style: {\n              height: rowHeight\n            }\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n            ref: innerElRef\n          }, innerContent)));\n        })\n      );\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n\n    return _this;\n  } // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n\n  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var sections = [];\n    var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyHeaderDates)(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    var _this = this;\n\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyHeaderDates)(context.options);\n    var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getStickyFooterScrollbar)(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(arg) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(contentArg) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    var isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: function content(arg) {\n          return (// TODO: make this now-indicator arrow more DRY with TimeColsContent\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n              className: \"fc-timegrid-axis-chunk\"\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n              \"aria-hidden\": true,\n              style: {\n                height: arg.expandRows ? arg.clientHeight : ''\n              }\n            }, arg.tableColGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeBodyAxis, {\n              slatMetas: slatMetas\n            }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n              className: \"fc-timegrid-now-indicator-container\"\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowTimer, {\n              unit: isNowIndicator ? 'minute' : 'day'\n              /* hacky */\n\n            }, function (nowDate) {\n              var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n\n              if (typeof nowIndicatorTop === 'number') {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowIndicatorRoot, {\n                  isAxis: true,\n                  date: nowDate\n                }, function (rootElRef, classNames, innerElRef, innerContent) {\n                  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n                    ref: rootElRef,\n                    className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n                    style: {\n                      top: nowIndicatorTop\n                    }\n                  }, innerContent);\n                });\n              }\n\n              return null;\n            })))\n          );\n        }\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.renderScrollShim\n        }, {\n          key: 'cols',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.renderScrollShim\n        }]\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeColsView.prototype.getAllDayMaxEventProps = function () {\n    var _a = this.context.options,\n        dayMaxEvents = _a.dayMaxEvents,\n        dayMaxEventRows = _a.dayMaxEventRows;\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n\n    return {\n      dayMaxEvents: dayMaxEvents,\n      dayMaxEventRows: dayMaxEventRows\n    };\n  };\n\n  return TimeColsView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\n\nvar TimeColsSlatsCoords = function () {\n  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n\n  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n    var dateProfile = this.dateProfile;\n\n    if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.rangeContainsMarker)(dateProfile.currentRange, date)) {\n      var startOfDayDate = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(date);\n      var timeMs = date.valueOf() - startOfDayDate.valueOf();\n\n      if (timeMs >= (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(dateProfile.slotMinTime) && timeMs < (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(timeMs));\n      }\n    }\n\n    return null;\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\n\n  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(when);\n    }\n\n    return this.computeTimeTop((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(when.valueOf() - startOfDayDate.valueOf()));\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n\n\n  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n    var _a = this,\n        positions = _a.positions,\n        dateProfile = _a.dateProfile;\n\n    var len = positions.els.length; // floating-point value of # of slots covered\n\n    var slatCoverage = (duration.milliseconds - (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(dateProfile.slotMinTime)) / (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(this.slotDuration);\n    var slatIndex;\n    var slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  };\n\n  return TimeColsSlatsCoords;\n}();\n\nvar TimeColsSlatsBody = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColsSlatsBody, _super);\n\n  function TimeColsSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColsSlatsBody.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var slatElRefs = props.slatElRefs;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n      var hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColsAxisCell, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, slatMeta)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": slatMeta.isoTimeStr\n        }, innerContent);\n      }));\n    }));\n  };\n\n  return TimeColsSlatsBody;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\n\nvar TimeColsSlats = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColsSlats, _super);\n\n  function TimeColsSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.slatElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap();\n    return _this;\n  }\n\n  TimeColsSlats.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      ref: this.rootElRef,\n      className: \"fc-timegrid-slots\"\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode\n    /* relies on there only being a single <col> for the axis */\n    , (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  };\n\n  TimeColsSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentDidUpdate = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentWillUnmount = function () {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n\n  TimeColsSlats.prototype.updateSizing = function () {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      var rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  };\n\n  return TimeColsSlats;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n\n  return segsByCol;\n}\n\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TimeColMoreLink = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColMoreLink, _super);\n\n  function TimeColMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  TimeColMoreLink.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.MoreLinkRoot, {\n      allDayDate: null,\n      moreCnt: props.hiddenSegs.length,\n      allSegs: props.hiddenSegs,\n      hiddenSegs: props.hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      defaultContent: renderMoreLinkInner,\n      extraDateSpan: props.extraDateSpan,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      popoverContent: function popoverContent() {\n        return renderPlainFgSegs(props.hiddenSegs, props);\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"a\", {\n        ref: function ref(el) {\n          (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.setRef)(rootElRef, el);\n          (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.setRef)(_this.rootElRef, el);\n        },\n        className: ['fc-timegrid-more-link'].concat(classNames).join(' '),\n        style: {\n          top: props.top,\n          bottom: props.bottom\n        },\n        onClick: handleClick,\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: innerElRef,\n        className: \"fc-timegrid-more-link-inner fc-sticky\"\n      }, innerContent));\n    });\n  };\n\n  return TimeColMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n} // segInputs assumed sorted\n\n\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  var hierarchy = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.SegHierarchy();\n\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenGroups = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.groupIntersectingEntries)(hiddenEntries);\n  var web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n\n  var segRects = webToRects(web);\n  return {\n    segRects: segRects,\n    hiddenGroups: hiddenGroups\n  };\n}\n\nfunction buildWeb(hierarchy) {\n  var entriesByLevel = hierarchy.entriesByLevel;\n  var buildNode = cacheable(function (level, lateral) {\n    return level + ':' + lateral;\n  }, function (level, lateral) {\n    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    var nextLevelRes = buildNodes(siblingRange, buildNode);\n    var entry = entriesByLevel[level][lateral];\n    return [(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\n\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n\n  var level = siblingRange.level,\n      lateralStart = siblingRange.lateralStart,\n      lateralEnd = siblingRange.lateralEnd;\n  var lateral = lateralStart;\n  var pairs = [];\n\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\n\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\n\nfunction extractNode(a) {\n  return a[0];\n}\n\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  var levelCoords = hierarchy.levelCoords,\n      entriesByLevel = hierarchy.entriesByLevel;\n  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  var levelCnt = levelCoords.length;\n  var level = subjectLevel; // skip past levels that are too high up\n\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1) {\n    ;\n  } // do nothing\n\n\n  for (; level < levelCnt; level += 1) {\n    var entries = entriesByLevel[level];\n    var entry = void 0;\n    var searchIndex = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.binarySearch)(entries, subjectEntry.span.start, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getEntrySpanEnd);\n    var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n\n    var lateralEnd = lateralStart;\n\n    while ( // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) && // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n\n    if (lateralStart < lateralEnd) {\n      return {\n        level: level,\n        lateralStart: lateralStart,\n        lateralEnd: lateralEnd\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  var stretchNode = cacheable(function (node, startCoord, prevThickness) {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEntryKey)(node);\n  }, function (node, startCoord, prevThickness) {\n    var nextLevelNodes = node.nextLevelNodes,\n        thickness = node.thickness;\n    var allThickness = thickness + prevThickness;\n    var thicknessFraction = thickness / allThickness;\n    var endCoord;\n    var newChildren = [];\n\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      for (var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++) {\n        var childNode = nextLevelNodes_1[_i];\n\n        if (endCoord === undefined) {\n          var res = stretchNode(childNode, startCoord, allThickness);\n          endCoord = res[0];\n          newChildren.push(res[1]);\n        } else {\n          var res = stretchNode(childNode, endCoord, 0);\n          newChildren.push(res[1]);\n        }\n      }\n    }\n\n    var newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(function (node) {\n    return stretchNode(node, 0, 0)[1];\n  });\n} // not sorted in any particular order\n\n\nfunction webToRects(topLevelNodes) {\n  var rects = [];\n  var processNode = cacheable(function (node, levelCoord, stackDepth) {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEntryKey)(node);\n  }, function (node, levelCoord, stackDepth) {\n    var rect = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, node), {\n      levelCoord: levelCoord,\n      stackDepth: stackDepth,\n      stackForward: 0\n    });\n\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n\n  function processNodes(nodes, levelCoord, stackDepth) {\n    var stackForward = 0;\n\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n      var node = nodes_1[_i];\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n    }\n\n    return stackForward;\n  }\n\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n} // TODO: move to general util\n\n\nfunction cacheable(keyFunc, workFunc) {\n  var cache = {};\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var key = keyFunc.apply(void 0, args);\n    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);\n  };\n}\n\nfunction computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {\n  if (slatCoords === void 0) {\n    slatCoords = null;\n  }\n\n  if (eventMinHeight === void 0) {\n    eventMinHeight = 0;\n  }\n\n  var vcoords = [];\n\n  if (slatCoords) {\n    for (var i = 0; i < segs.length; i += 1) {\n      var seg = segs[i];\n      var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      var spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n\n      });\n    }\n  }\n\n  return vcoords;\n}\n\nfunction computeFgSegPlacements(segs, segVCoords, // might not have for every seg\neventOrderStrict, eventMaxStack) {\n  var segInputs = [];\n  var dumbSegs = []; // segs without coords\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var vcoords = segVCoords[i];\n\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n\n  var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack),\n      segRects = _a.segRects,\n      hiddenGroups = _a.hiddenGroups;\n\n  var segPlacements = [];\n\n  for (var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++) {\n    var segRect = segRects_1[_i];\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect\n    });\n  }\n\n  for (var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++) {\n    var dumbSeg = dumbSegs_1[_b];\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n\n  return {\n    segPlacements: segPlacements,\n    hiddenGroups: hiddenGroups\n  };\n}\n\nvar DEFAULT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\n\nvar TimeColEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColEvent, _super);\n\n  function TimeColEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColEvent.prototype.render = function () {\n    var classNames = ['fc-timegrid-event', 'fc-v-event'];\n\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short');\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  };\n\n  return TimeColEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nvar TimeColMisc = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColMisc, _super);\n\n  function TimeColMisc() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColMisc.prototype.render = function () {\n    var props = this.props;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (innerElRef, innerContent) {\n      return innerContent && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-col-misc\",\n        ref: innerElRef\n      }, innerContent);\n    });\n  };\n\n  return TimeColMisc;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nvar TimeCol = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeCol, _super);\n\n  function TimeCol() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.sortEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.sortEventSegs);\n    return _this;\n  } // TODO: memoize event-placement?\n\n\n  TimeCol.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var isSelectMirror = context.options.selectMirror;\n    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    var interactionAffectedInstances = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayCellRoot, {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (rootElRef, classNames, dataAttrs) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: rootElRef,\n        role: \"gridcell\",\n        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, dataAttrs, props.extraDataAttrs), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-col-frame\"\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-col-bg\"\n      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: \"fc-timegrid-now-indicator-container\"\n      }, _this.renderNowIndicator(props.nowIndicatorSegs)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColMisc, {\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      })));\n    });\n  };\n\n  TimeCol.prototype.renderFgSegs = function (sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var props = this.props;\n\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props);\n    }\n\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n  };\n\n  TimeCol.prototype.renderPositionedFgSegs = function (segs, // if not mirror, needs to be sorted\n  segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var _this = this;\n\n    var _a = this.context.options,\n        eventMaxStack = _a.eventMaxStack,\n        eventShortHeight = _a.eventShortHeight,\n        eventOrderStrict = _a.eventOrderStrict,\n        eventMinHeight = _a.eventMinHeight;\n    var _b = this.props,\n        date = _b.date,\n        slatCoords = _b.slatCoords,\n        eventSelection = _b.eventSelection,\n        todayRange = _b.todayRange,\n        nowDate = _b.nowDate;\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n\n    var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack),\n        segPlacements = _c.segPlacements,\n        hiddenGroups = _c.hiddenGroups;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function (segPlacement) {\n      var seg = segPlacement.seg,\n          rect = segPlacement.rect;\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n      var vStyle = computeSegVStyle(rect && rect.span);\n      var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {\n        left: 0,\n        right: 0\n      };\n      var isInset = Boolean(rect) && rect.stackForward > 0;\n      var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          visibility: isVisible ? '' : 'hidden'\n        }, vStyle), hStyle)\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === eventSelection,\n        isShort: isShort\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, todayRange, nowDate))));\n    }));\n  }; // will already have eventMinHeight applied because segInputs already had it\n\n\n  TimeCol.prototype.renderHiddenGroups = function (hiddenGroups, segs) {\n    var _a = this.props,\n        extraDateSpan = _a.extraDateSpan,\n        dateProfile = _a.dateProfile,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate,\n        eventSelection = _a.eventSelection,\n        eventDrag = _a.eventDrag,\n        eventResize = _a.eventResize;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, hiddenGroups.map(function (hiddenGroup) {\n      var positionCss = computeSegVStyle(hiddenGroup.span);\n      var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColMoreLink, {\n        key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildIsoString)((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeEarliestSegStart)(hiddenSegs)),\n        hiddenSegs: hiddenSegs,\n        top: positionCss.top,\n        bottom: positionCss.bottom,\n        extraDateSpan: extraDateSpan,\n        dateProfile: dateProfile,\n        todayRange: todayRange,\n        nowDate: nowDate,\n        eventSelection: eventSelection,\n        eventDrag: eventDrag,\n        eventResize: eventResize\n      });\n    }));\n  };\n\n  TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n\n    var children = segVCoords.map(function (vcoords, i) {\n      var seg = segs[i];\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventRangeKey)(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: computeSegVStyle(vcoords)\n      }, fillType === 'bg-event' ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        seg: seg\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, props.todayRange, props.nowDate))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.renderFill)(fillType));\n    });\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n  };\n\n  TimeCol.prototype.renderNowIndicator = function (segs) {\n    var _a = this.props,\n        slatCoords = _a.slatCoords,\n        date = _a.date;\n\n    if (!slatCoords) {\n      return null;\n    }\n\n    return segs.map(function (seg, i) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowIndicatorRoot, {\n        isAxis: false,\n        date: date,\n        // key doesn't matter. will only ever be one\n        key: i\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n          style: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          }\n        }, innerContent);\n      });\n    });\n  };\n\n  TimeCol.prototype.computeSegHStyle = function (segHCoords) {\n    var _a = this.context,\n        isRtl = _a.isRtl,\n        options = _a.options;\n    var shouldOverlap = options.slotEventOverlap;\n    var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n\n    var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n\n    var left; // amount of space from left edge, a fraction of the total width\n\n    var right; // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n    }\n\n    if (isRtl) {\n      left = 1 - farCoord;\n      right = nearCoord;\n    } else {\n      left = nearCoord;\n      right = 1 - farCoord;\n    }\n\n    var props = {\n      zIndex: segHCoords.stackDepth + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return props;\n  };\n\n  return TimeCol;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction renderPlainFgSegs(sortedFgSegs, _a) {\n  var todayRange = _a.todayRange,\n      nowDate = _a.nowDate,\n      eventSelection = _a.eventSelection,\n      eventDrag = _a.eventDrag,\n      eventResize = _a.eventResize;\n  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, sortedFgSegs.map(function (seg) {\n    var instanceId = seg.eventRange.instance.instanceId;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getSegMeta)(seg, todayRange, nowDate))));\n  }));\n}\n\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\n\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(function (segEntry) {\n    return allSegs[segEntry.index];\n  });\n}\n\nvar TimeColsContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeColsContent, _super);\n\n  function TimeColsContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByCol);\n    _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByCol);\n    _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByCol);\n    _this.splitNowIndicatorSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByCol);\n    _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitSegsByCol);\n    _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitInteractionByCol);\n    _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(splitInteractionByCol);\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.RefMap();\n    return _this;\n  }\n\n  TimeColsContent.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n\n    var colCnt = props.cells.length;\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"table\", {\n      role: \"presentation\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tbody\", {\n      role: \"presentation\"\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", {\n      role: \"row\"\n    }, props.axis && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"td\", {\n      \"aria-hidden\": true,\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowIndicatorRoot, {\n      isAxis: true,\n      date: props.nowDate\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n        style: {\n          top: nowIndicatorTop\n        }\n      }, innerContent);\n    })))), props.cells.map(function (cell, i) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeCol, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        fgEventSegs: fgEventSegsByRow[i],\n        bgEventSegs: bgEventSegsByRow[i],\n        businessHourSegs: businessHourSegsByRow[i],\n        nowIndicatorSegs: nowIndicatorSegsByRow[i],\n        dateSelectionSegs: dateSelectionSegsByRow[i],\n        eventDrag: eventDragByRow[i],\n        eventResize: eventResizeByRow[i],\n        slatCoords: props.slatCoords,\n        eventSelection: props.eventSelection,\n        forPrint: props.forPrint\n      });\n    })))));\n  };\n\n  TimeColsContent.prototype.componentDidMount = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.componentDidUpdate = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.updateCoords = function () {\n    var props = this.props;\n\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n      false));\n    }\n  };\n\n  return TimeColsContent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BaseComponent);\n\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nvar TimeCols = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TimeCols, _super);\n\n  function TimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processSlotOptions = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(processSlotOptions);\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleRootEl = function (el) {\n      if (el) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: el,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    _this.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this.props.onScrollTopRequest;\n      var slatCoords = _this.state.slatCoords;\n\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top_1 = slatCoords.computeTimeTop(request.time);\n          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n\n          if (top_1) {\n            top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n\n          onScrollTopRequest(top_1);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.handleColCoords = function (colCoords) {\n      _this.colCoords = colCoords;\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(slatCoords);\n      }\n    };\n\n    return _this;\n  }\n\n  TimeCols.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null\n      /* axis depends on the colgroup's shrinking */\n      ,\n      onCoords: this.handleSlatCoords\n    }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  };\n\n  TimeCols.prototype.componentDidMount = function () {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n\n  TimeCols.prototype.componentDidUpdate = function (prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n\n  TimeCols.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n  };\n\n  TimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var colCoords = this.colCoords;\n    var dateProfile = this.props.dateProfile;\n    var slatCoords = this.state.slatCoords;\n\n    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n        snapDuration = _b.snapDuration,\n        snapsPerSlot = _b.snapsPerSlot;\n\n    var colIndex = colCoords.leftToIndex(positionLeft);\n    var slatIndex = slatCoords.positions.topToIndex(positionTop);\n\n    if (colIndex != null && slatIndex != null) {\n      var cell = this.props.cells[colIndex];\n      var slatTop = slatCoords.positions.tops[slatIndex];\n      var slatHeight = slatCoords.positions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addDurations)(dateProfile.slotMinTime, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.multiplyDuration)(snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, snapDuration);\n      return {\n        dateProfile: dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        }, cell.extraDateSpan),\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return TimeCols;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.wholeDivideDurations)(slotDuration, snapDuration);\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1; // TODO: say warning?\n  }\n\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\n\nvar DayTimeColsSlicer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTimeColsSlicer, _super);\n\n  function DayTimeColsSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n\n    for (var col = 0; col < dayRanges.length; col += 1) {\n      var segRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRanges)(range, dayRanges[col]);\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTimeColsSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Slicer);\n\nvar DayTimeCols = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTimeCols, _super);\n\n  function DayTimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayRanges = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(buildDayRanges);\n    _this.slicer = new DayTimeColsSlicer();\n    _this.timeColsRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n\n  DayTimeCols.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateProfile = props.dateProfile,\n        dayTableModel = props.dayTableModel;\n    var isNowIndicator = context.options.nowIndicator;\n    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv); // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, function (nowDate, todayRange) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(TimeCols, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: _this.timeColsRef\n      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n        forPrint: props.forPrint,\n        axis: props.axis,\n        dateProfile: dateProfile,\n        slatMetas: props.slatMetas,\n        slotDuration: props.slotDuration,\n        cells: dayTableModel.cells[0],\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        expandRows: props.expandRows,\n        nowDate: nowDate,\n        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n        todayRange: todayRange,\n        onScrollTopRequest: props.onScrollTopRequest,\n        onSlatCoords: props.onSlatCoords\n      }));\n    });\n  };\n\n  return DayTimeCols;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DateComponent);\n\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n\n  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n\n  return ranges;\n} // potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n\n\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n\n  while ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(slatTime) < (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.asRoughMs)(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.wholeDivideDurations)(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.formatIsoTimeString)(date),\n      isLabeled: isLabeled\n    });\n    slatTime = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addDurations)(slatTime, slotDuration);\n    slatIterator = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.addDurations)(slatIterator, slotDuration);\n  }\n\n  return metas;\n} // Computes an automatic value for slotLabelInterval\n\n\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.wholeDivideDurations)(labelInterval, slotDuration);\n\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n\n  return slotDuration; // fall back\n}\n\nvar DayTimeColsView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTimeColsView, _super);\n\n  function DayTimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildTimeColsModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(buildTimeColsModel);\n    _this.buildSlatMetas = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.memoize)(buildSlatMetas);\n    return _this;\n  }\n\n  DayTimeColsView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dateProfile = props.dateProfile;\n    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    var splitProps = this.allDaySplitter.splitProps(props);\n    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    var dayMinWidth = options.dayMinWidth;\n    var hasAttachedAxis = !dayMinWidth;\n    var hasDetachedAxis = dayMinWidth;\n    var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n\n    var allDayContent = options.allDaySlot !== false && function (contentArg) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__.DayTable, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, splitProps.allDay, {\n        dateProfile: dateProfile,\n        dayTableModel: dayTableModel,\n        nextDayThreshold: options.nextDayThreshold,\n        tableMinWidth: contentArg.tableMinWidth,\n        colGroupNode: contentArg.tableColGroupNode,\n        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n        showWeekNumbers: false,\n        expandRows: false,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      }, _this.getAllDayMaxEventProps()));\n    };\n\n    var timeGridContent = function timeGridContent(contentArg) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayTimeCols, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, splitProps.timed, {\n        dayTableModel: dayTableModel,\n        dateProfile: dateProfile,\n        axis: hasAttachedAxis,\n        slotDuration: options.slotDuration,\n        slatMetas: slatMetas,\n        forPrint: props.forPrint,\n        tableColGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        onSlatCoords: _this.handleSlatCoords,\n        expandRows: contentArg.expandRows,\n        onScrollTopRequest: _this.handleScrollTopRequest\n      }));\n    };\n\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  };\n\n  return DayTimeColsView;\n}(TimeColsView);\n\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.DayTableModel(daySeries, false);\n}\n\nvar OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n\nvar _c2;\n\n$RefreshReg$(_c2, \"TimeColsAxisCell\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBLElBQUl5RCxjQUFjLEdBQWtCLFVBQVVDLE1BQVYsRUFBa0I7QUFDbERKLEVBQUFBLGdEQUFTLENBQUNHLGNBQUQsRUFBaUJDLE1BQWpCLENBQVQ7O0FBQ0EsV0FBU0QsY0FBVCxHQUEwQjtBQUN0QixXQUFPQyxNQUFNLEtBQUssSUFBWCxJQUFtQkEsTUFBTSxDQUFDQyxLQUFQLENBQWEsSUFBYixFQUFtQkMsU0FBbkIsQ0FBbkIsSUFBb0QsSUFBM0Q7QUFDSDs7QUFDREgsRUFBQUEsY0FBYyxDQUFDSSxTQUFmLENBQXlCQyxVQUF6QixHQUFzQyxZQUFZO0FBQzlDLFdBQU87QUFDSEMsTUFBQUEsTUFBTSxFQUFFLEVBREw7QUFFSEMsTUFBQUEsS0FBSyxFQUFFO0FBRkosS0FBUDtBQUlILEdBTEQ7O0FBTUFQLEVBQUFBLGNBQWMsQ0FBQ0ksU0FBZixDQUF5Qkksa0JBQXpCLEdBQThDLFVBQVVDLFFBQVYsRUFBb0I7QUFDOUQsUUFBSUEsUUFBUSxDQUFDSCxNQUFiLEVBQXFCO0FBQ2pCLGFBQU8sQ0FBQyxRQUFELENBQVA7QUFDSDs7QUFDRCxXQUFPLENBQUMsT0FBRCxDQUFQO0FBQ0gsR0FMRDs7QUFNQU4sRUFBQUEsY0FBYyxDQUFDSSxTQUFmLENBQXlCTSxrQkFBekIsR0FBOEMsVUFBVUMsUUFBVixFQUFvQjtBQUM5RCxRQUFJLENBQUNBLFFBQVEsQ0FBQ0wsTUFBZCxFQUFzQjtBQUNsQixhQUFPLENBQUMsT0FBRCxDQUFQO0FBQ0g7O0FBQ0QsUUFBSS9ELG9FQUFjLENBQUNvRSxRQUFELENBQWxCLEVBQThCO0FBQzFCLGFBQU8sQ0FBQyxPQUFELEVBQVUsUUFBVixDQUFQO0FBQ0g7O0FBQ0QsV0FBTyxDQUFDLFFBQUQsQ0FBUDtBQUNILEdB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QSxJQUFJLEVBQUUsVUFESTtBQUVWOEQsTUFBQUEsUUFBUSxFQUFFO0FBQUVrVixRQUFBQSxLQUFLLEVBQUU7QUFBVDtBQUZBO0FBWlg7QUFIYSxDQUFELENBQXZCO0FBc0JBLCtEQUFlVixJQUFmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvdGltZWdyaWQvbWFpbi5qcz83YjRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjEwLjFcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIxIEFkYW0gU2hhd1xuKi9cbmltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCB7IGhhc0JnUmVuZGVyaW5nLCBTcGxpdHRlciwgY3JlYXRlRm9ybWF0dGVyLCBjcmVhdGVFbGVtZW50LCBWaWV3Q29udGV4dFR5cGUsIFJlbmRlckhvb2ssIEJhc2VDb21wb25lbnQsIGNyZWF0ZVJlZiwgZGlmZkRheXMsIGJ1aWxkTmF2TGlua0F0dHJzLCBXZWVrTnVtYmVyUm9vdCwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdSb290LCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIE5vd1RpbWVyLCBOb3dJbmRpY2F0b3JSb290LCByZW5kZXJTY3JvbGxTaGltLCBEYXRlQ29tcG9uZW50LCByYW5nZUNvbnRhaW5zTWFya2VyLCBzdGFydE9mRGF5LCBhc1JvdWdoTXMsIGNyZWF0ZUR1cmF0aW9uLCBSZWZNYXAsIFBvc2l0aW9uQ2FjaGUsIE1vcmVMaW5rUm9vdCwgc2V0UmVmLCBTZWdIaWVyYXJjaHksIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcywgYnVpbGRFbnRyeUtleSwgYmluYXJ5U2VhcmNoLCBnZXRFbnRyeVNwYW5FbmQsIFN0YW5kYXJkRXZlbnQsIERheUNlbGxDb250ZW50LCBGcmFnbWVudCwgZ2V0U2VnTWV0YSwgbWVtb2l6ZSwgc29ydEV2ZW50U2VncywgRGF5Q2VsbFJvb3QsIGJ1aWxkSXNvU3RyaW5nLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBhZGREdXJhdGlvbnMsIG11bHRpcGx5RHVyYXRpb24sIHdob2xlRGl2aWRlRHVyYXRpb25zLCBpbnRlcnNlY3RSYW5nZXMsIFNsaWNlciwgZm9ybWF0SXNvVGltZVN0cmluZywgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nO1xuaW1wb3J0IHsgX19leHRlbmRzLCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IERheVRhYmxlIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9kYXlncmlkJztcblxudmFyIEFsbERheVNwbGl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGxEYXlTcGxpdHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbGxEYXlTcGxpdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBbGxEYXlTcGxpdHRlci5wcm90b3R5cGUuZ2V0S2V5SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbERheToge30sXG4gICAgICAgICAgICB0aW1lZDoge30sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBbGxEYXlTcGxpdHRlci5wcm90b3R5cGUuZ2V0S2V5c0ZvckRhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgfTtcbiAgICBBbGxEYXlTcGxpdHRlci5wcm90b3R5cGUuZ2V0S2V5c0ZvckV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XG4gICAgICAgIGlmICghZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNCZ1JlbmRlcmluZyhldmVudERlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJywgJ2FsbERheSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2FsbERheSddO1xuICAgIH07XG4gICAgcmV0dXJuIEFsbERheVNwbGl0dGVyO1xufShTcGxpdHRlcikpO1xuXG52YXIgREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxufSk7XG5mdW5jdGlvbiBUaW1lQ29sc0F4aXNDZWxsKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcbiAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwnLFxuICAgICAgICBwcm9wcy5pc0xhYmVsZWQgPyAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgIF07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFwcm9wcy5pc0xhYmVsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJkYXRhLXRpbWVcIjogcHJvcHMuaXNvVGltZVN0ciB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIHZpZXdBcGkgPSBjb250ZXh0LnZpZXdBcGk7XG4gICAgICAgIHZhciBsYWJlbEZvcm1hdCA9IC8vIFRPRE86IGZ1bGx5IHByZS1wYXJzZVxuICAgICAgICAgb3B0aW9ucy5zbG90TGFiZWxGb3JtYXQgPT0gbnVsbCA/IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCkgPyBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXRbMF0pIDpcbiAgICAgICAgICAgICAgICBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLnNsb3RMYWJlbENvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lckNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYWJlbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFiZWxXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvblwiLCByZWY6IGlubmVyRWxSZWYgfSwgaW5uZXJDb250ZW50KSkpKTsgfSkpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0O1xufVxuXG52YXIgVGltZUJvZHlBeGlzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQm9keUF4aXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUJvZHlBeGlzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRpbWVCb2R5QXhpcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zbGF0TWV0YXMubWFwKGZ1bmN0aW9uIChzbGF0TWV0YSkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIF9fYXNzaWduKHt9LCBzbGF0TWV0YSkpKSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVCb2R5QXhpcztcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xudmFyIEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUyA9IDU7XG52YXIgVGltZUNvbHNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQ29sc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIF90aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zY3JvbGxlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlckVsID0gX3RoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgX3RoaXMucmVuZGVySGVhZEF4aXMgPSBmdW5jdGlvbiAocm93S2V5LCBmcmFtZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKGZyYW1lSGVpZ2h0ID09PSB2b2lkIDApIHsgZnJhbWVIZWlnaHQgPSAnJzsgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBfdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgdmFyIGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9IChkYXlDbnQgPT09IDEpIC8vIG9ubHkgZG8gaW4gZGF5IHZpZXdzICh0byBhdm9pZCBkb2luZyBpbiB3ZWVrIHZpZXdzIHRoYXQgZG9udCBuZWVkIGl0KVxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnMoX3RoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyUm9vdCwgeyBkYXRlOiByYW5nZS5zdGFydCwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRoXCIsIHsgcmVmOiByb290RWxSZWYsIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyByZWY6IGlubmVyRWxSZWYsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgX3RoaXMucmVuZGVyVGFibGVSb3dBeGlzID0gZnVuY3Rpb24gKHJvd0hlaWdodCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHZpZXdBcGkgPSBfYS52aWV3QXBpO1xuICAgICAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJBbGxEYXlJbm5lciwgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHJlZjogcm9vdEVsUmVmLCBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluaycsXG4gICAgICAgICAgICAgICAgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnICsgKHJvd0hlaWdodCA9PSBudWxsID8gJyBmYy10aW1lZ3JpZC1heGlzLWZyYW1lLWxpcXVpZCcgOiAnJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNsYXRDb29yZHMgPSBmdW5jdGlvbiAoc2xhdENvb3Jkcykge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzbGF0Q29vcmRzOiBzbGF0Q29vcmRzIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIHJlbmRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBUaW1lQ29sc1ZpZXcucHJvdG90eXBlLnJlbmRlclNpbXBsZUxheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0ID0gX2EuY29udGV4dCwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcbiAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYywgZWxSZWY6IHRoaXMucm9vdEVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW3sgd2lkdGg6ICdzaHJpbmsnIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgVGltZUNvbHNWaWV3LnByb3RvdHlwZS5yZW5kZXJIU2Nyb2xsTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHNsYXRDb29yZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIF90aGlzLnJlbmRlckhlYWRBeGlzKCdkYXknLCBhcmcucm93U3luY0hlaWdodHNbMF0pKSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBmdW5jdGlvbiAoY29udGVudEFyZykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgX3RoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIGZ1bmN0aW9uIChub3dEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yUm9vdCwgeyBpc0F4aXM6IHRydWUsIGRhdGU6IG5vd0RhdGUgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdyddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7IHRvcDogbm93SW5kaWNhdG9yVG9wIH0gfSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKTsgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjLCBlbFJlZjogdGhpcy5yb290RWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXG4gICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIC8qIERpbWVuc2lvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUuZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMsIGRheU1heEV2ZW50cyA9IF9hLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzID0gX2EuZGF5TWF4RXZlbnRSb3dzO1xuICAgICAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkgeyAvLyBpcyBhdXRvP1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF5TWF4RXZlbnRzOiBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogZGF5TWF4RXZlbnRSb3dzIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHNWaWV3O1xufShEYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihob29rUHJvcHMpIHtcbiAgICByZXR1cm4gaG9va1Byb3BzLnRleHQ7XG59XG5cbnZhciBUaW1lQ29sc1NsYXRzQ29vcmRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzU2xhdHNDb29yZHMocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5zYWZlQ29tcHV0ZVRvcCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIGlmIChyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE9mRGF5RGF0ZSA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgICAgICAgICB2YXIgdGltZU1zID0gZGF0ZS52YWx1ZU9mKCkgLSBzdGFydE9mRGF5RGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAodGltZU1zID49IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSkgJiZcbiAgICAgICAgICAgICAgICB0aW1lTXMgPCBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVRpbWVUb3AoY3JlYXRlRHVyYXRpb24odGltZU1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXG4gICAgVGltZUNvbHNTbGF0c0Nvb3Jkcy5wcm90b3R5cGUuY29tcHV0ZURhdGVUb3AgPSBmdW5jdGlvbiAod2hlbiwgc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgaWYgKCFzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICAgICAgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHdoZW4udmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpKSk7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cbiAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxuICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxuICAgIFRpbWVDb2xzU2xhdHNDb29yZHMucHJvdG90eXBlLmNvbXB1dGVUaW1lVG9wID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBvc2l0aW9ucyA9IF9hLnBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgPSBfYS5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIGxlbiA9IHBvc2l0aW9ucy5lbHMubGVuZ3RoO1xuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcbiAgICAgICAgdmFyIHNsYXRDb3ZlcmFnZSA9IChkdXJhdGlvbi5taWxsaXNlY29uZHMgLSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpKSAvIGFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIHZhciBzbGF0SW5kZXg7XG4gICAgICAgIHZhciBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzQ29vcmRzO1xufSgpKTtcblxudmFyIFRpbWVDb2xzU2xhdHNCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQ29sc1NsYXRzQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzbGF0RWxSZWZzID0gcHJvcHMuc2xhdEVsUmVmcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCwgcHJvcHMuc2xhdE1ldGFzLm1hcChmdW5jdGlvbiAoc2xhdE1ldGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFuZScsXG4gICAgICAgICAgICAgICAgc2xhdE1ldGEuaXNMYWJlbGVkID8gJycgOiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSwgcmVmOiBzbGF0RWxSZWZzLmNyZWF0ZVJlZihzbGF0TWV0YS5rZXkpIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuYXhpcyAmJiAoY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBfX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLnNsb3RMYW5lQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBzbGF0TWV0YS5pc29UaW1lU3RyIH0sIGlubmVyQ29udGVudCkpOyB9KSkpO1xuICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzU2xhdHNCb2R5O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8qXG5mb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuKi9cbnZhciBUaW1lQ29sc1NsYXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQ29sc1NsYXRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzU2xhdHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc2xhdEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH07XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVDb2xzU2xhdHMucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RTbGF0RWxzKHRoaXMuc2xhdEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5zbGF0TWV0YXMpLCBmYWxzZSwgdHJ1ZSksIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsIGNvbnRleHQub3B0aW9ucy5zbG90RHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzU2xhdHM7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbGxlY3RTbGF0RWxzKGVsTWFwLCBzbGF0TWV0YXMpIHtcbiAgICByZXR1cm4gc2xhdE1ldGFzLm1hcChmdW5jdGlvbiAoc2xhdE1ldGEpIHsgcmV0dXJuIGVsTWFwW3NsYXRNZXRhLmtleV07IH0pO1xufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUNvbChzZWdzLCBjb2xDbnQpIHtcbiAgICB2YXIgc2Vnc0J5Q29sID0gW107XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgaWYgKHNlZ3MpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKHVpLCBjb2xDbnQpIHtcbiAgICB2YXIgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB1aS5zZWdzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5jb2xdLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxudmFyIFRpbWVDb2xNb3JlTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbE1vcmVMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xNb3JlTGluaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xNb3JlTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW9yZUxpbmtSb290LCB7IGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBhbGlnbm1lbnRFbFJlZjogdGhpcy5yb290RWxSZWYsIGRlZmF1bHRDb250ZW50OiByZW5kZXJNb3JlTGlua0lubmVyLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyk7IH0gfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBoYW5kbGVDbGljaywgdGl0bGUsIGlzRXhwYW5kZWQsIHBvcG92ZXJJZCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgcmVmOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYocm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgfSwgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkLW1vcmUtbGluayddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7IHRvcDogcHJvcHMudG9wLCBib3R0b206IHByb3BzLmJvdHRvbSB9LCBvbkNsaWNrOiBoYW5kbGVDbGljaywgdGl0bGU6IHRpdGxlLCBcImFyaWEtZXhwYW5kZWRcIjogaXNFeHBhbmRlZCwgXCJhcmlhLWNvbnRyb2xzXCI6IHBvcG92ZXJJZCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lciBmYy1zdGlja3lcIiB9LCBpbm5lckNvbnRlbnQpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sTW9yZUxpbms7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xufVxuXG4vLyBzZWdJbnB1dHMgYXNzdW1lZCBzb3J0ZWRcbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBzdHJpY3RPcmRlciwgbWF4U3RhY2tDbnQpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gbmV3IFNlZ0hpZXJhcmNoeSgpO1xuICAgIGlmIChzdHJpY3RPcmRlciAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIH1cbiAgICBpZiAobWF4U3RhY2tDbnQgIT0gbnVsbCkge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBtYXhTdGFja0NudDtcbiAgICB9XG4gICAgdmFyIGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIHZhciBoaWRkZW5Hcm91cHMgPSBncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgdmFyIHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgdmFyIHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzOiBzZWdSZWN0cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIHZhciBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgYnVpbGROb2RlID0gY2FjaGVhYmxlKGZ1bmN0aW9uIChsZXZlbCwgbGF0ZXJhbCkgeyByZXR1cm4gbGV2ZWwgKyAnOicgKyBsYXRlcmFsOyB9LCBmdW5jdGlvbiAobGV2ZWwsIGxhdGVyYWwpIHtcbiAgICAgICAgdmFyIHNpYmxpbmdSYW5nZSA9IGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgbGV2ZWwsIGxhdGVyYWwpO1xuICAgICAgICB2YXIgbmV4dExldmVsUmVzID0gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNCeUxldmVsW2xldmVsXVtsYXRlcmFsXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICB2YXIgbGV2ZWwgPSBzaWJsaW5nUmFuZ2UubGV2ZWwsIGxhdGVyYWxTdGFydCA9IHNpYmxpbmdSYW5nZS5sYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgPSBzaWJsaW5nUmFuZ2UubGF0ZXJhbEVuZDtcbiAgICB2YXIgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgdmFyIGxldmVsQ29vcmRzID0gaGllcmFyY2h5LmxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgc3ViamVjdEVudHJ5ID0gZW50cmllc0J5TGV2ZWxbc3ViamVjdExldmVsXVtzdWJqZWN0TGF0ZXJhbF07XG4gICAgdmFyIGFmdGVyU3ViamVjdCA9IGxldmVsQ29vcmRzW3N1YmplY3RMZXZlbF0gKyBzdWJqZWN0RW50cnkudGhpY2tuZXNzO1xuICAgIHZhciBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcbiAgICB2YXIgbGV2ZWwgPSBzdWJqZWN0TGV2ZWw7XG4gICAgLy8gc2tpcCBwYXN0IGxldmVscyB0aGF0IGFyZSB0b28gaGlnaCB1cFxuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2xldmVsXSA8IGFmdGVyU3ViamVjdDsgbGV2ZWwgKz0gMSlcbiAgICAgICAgOyAvLyBkbyBub3RoaW5nXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgIHZhciBlbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHNlYXJjaEluZGV4ID0gYmluYXJ5U2VhcmNoKGVudHJpZXMsIHN1YmplY3RFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpO1xuICAgICAgICB2YXIgbGF0ZXJhbFN0YXJ0ID0gc2VhcmNoSW5kZXhbMF0gKyBzZWFyY2hJbmRleFsxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgIHZhciBsYXRlcmFsRW5kID0gbGF0ZXJhbFN0YXJ0O1xuICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAoZW50cnkgPSBlbnRyaWVzW2xhdGVyYWxFbmRdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIHNlZyBsaXN0XG4gICAgICAgICAgICBlbnRyeS5zcGFuLnN0YXJ0IDwgc3ViamVjdEVudHJ5LnNwYW4uZW5kKSB7XG4gICAgICAgICAgICBsYXRlcmFsRW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhdGVyYWxTdGFydCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxldmVsOiBsZXZlbCwgbGF0ZXJhbFN0YXJ0OiBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQ6IGxhdGVyYWxFbmQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHN0cmV0Y2hXZWIodG9wTGV2ZWxOb2RlcywgdG90YWxUaGlja25lc3MpIHtcbiAgICB2YXIgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoZnVuY3Rpb24gKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpIHsgcmV0dXJuIGJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSB7XG4gICAgICAgIHZhciBuZXh0TGV2ZWxOb2RlcyA9IG5vZGUubmV4dExldmVsTm9kZXMsIHRoaWNrbmVzcyA9IG5vZGUudGhpY2tuZXNzO1xuICAgICAgICB2YXIgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgdmFyIHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICB2YXIgZW5kQ29vcmQ7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV4dExldmVsTm9kZXNfMSA9IG5leHRMZXZlbE5vZGVzOyBfaSA8IG5leHRMZXZlbE5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5leHRMZXZlbE5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdOyB9KTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIHZhciByZWN0cyA9IFtdO1xuICAgIHZhciBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgeyByZXR1cm4gYnVpbGRFbnRyeUtleShub2RlKTsgfSwgZnVuY3Rpb24gKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZDogbGV2ZWxDb29yZCxcbiAgICAgICAgICAgIHN0YWNrRGVwdGg6IHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xuICAgICAgICB2YXIgc3RhY2tGb3J3YXJkID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNfMVtfaV07XG4gICAgICAgICAgICBzdGFja0ZvcndhcmQgPSBNYXRoLm1heChwcm9jZXNzTm9kZShub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSwgc3RhY2tGb3J3YXJkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tGb3J3YXJkO1xuICAgIH1cbiAgICBwcm9jZXNzTm9kZXModG9wTGV2ZWxOb2RlcywgMCwgMCk7XG4gICAgcmV0dXJuIHJlY3RzOyAvLyBUT0RPOiBzb3J0IHJlY3RzIGJ5IGxldmVsQ29vcmQgdG8gYmUgY29uc2lzdGVudCB3aXRoIHRvUmVjdHM/XG59XG4vLyBUT0RPOiBtb3ZlIHRvIGdlbmVyYWwgdXRpbFxuZnVuY3Rpb24gY2FjaGVhYmxlKGtleUZ1bmMsIHdvcmtGdW5jKSB7XG4gICAgdmFyIGNhY2hlID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0ga2V5RnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcbiAgICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jLmFwcGx5KHZvaWQgMCwgYXJncykpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGNvbERhdGUsIHNsYXRDb29yZHMsIGV2ZW50TWluSGVpZ2h0KSB7XG4gICAgaWYgKHNsYXRDb29yZHMgPT09IHZvaWQgMCkgeyBzbGF0Q29vcmRzID0gbnVsbDsgfVxuICAgIGlmIChldmVudE1pbkhlaWdodCA9PT0gdm9pZCAwKSB7IGV2ZW50TWluSGVpZ2h0ID0gMDsgfVxuICAgIHZhciB2Y29vcmRzID0gW107XG4gICAgaWYgKHNsYXRDb29yZHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHZhciBzcGFuU3RhcnQgPSBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgY29sRGF0ZSk7XG4gICAgICAgICAgICB2YXIgc3BhbkVuZCA9IE1hdGgubWF4KHNwYW5TdGFydCArIChldmVudE1pbkhlaWdodCB8fCAwKSwgLy8gOihcbiAgICAgICAgICAgIHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZCwgY29sRGF0ZSkpO1xuICAgICAgICAgICAgdmNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5yb3VuZChzcGFuU3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZDogTWF0aC5yb3VuZChzcGFuRW5kKSwgLy9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Y29vcmRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCAvLyBtaWdodCBub3QgaGF2ZSBmb3IgZXZlcnkgc2VnXG5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKSB7XG4gICAgdmFyIHNlZ0lucHV0cyA9IFtdO1xuICAgIHZhciBkdW1iU2VncyA9IFtdOyAvLyBzZWdzIHdpdGhvdXQgY29vcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB2Y29vcmRzID0gc2VnVkNvb3Jkc1tpXTtcbiAgICAgICAgaWYgKHZjb29yZHMpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICAgICAgc3BhbjogdmNvb3JkcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVtYlNlZ3MucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2EgPSBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayksIHNlZ1JlY3RzID0gX2Euc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyA9IF9hLmhpZGRlbkdyb3VwcztcbiAgICB2YXIgc2VnUGxhY2VtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgc2VnUmVjdHNfMSA9IHNlZ1JlY3RzOyBfaSA8IHNlZ1JlY3RzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWdSZWN0ID0gc2VnUmVjdHNfMVtfaV07XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZ3Nbc2VnUmVjdC5pbmRleF0sXG4gICAgICAgICAgICByZWN0OiBzZWdSZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2IgPSAwLCBkdW1iU2Vnc18xID0gZHVtYlNlZ3M7IF9iIDwgZHVtYlNlZ3NfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgdmFyIGR1bWJTZWcgPSBkdW1iU2Vnc18xW19iXTtcbiAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHsgc2VnOiBkdW1iU2VnLCByZWN0OiBudWxsIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWdQbGFjZW1lbnRzOiBzZWdQbGFjZW1lbnRzLCBoaWRkZW5Hcm91cHM6IGhpZGRlbkdyb3VwcyB9O1xufVxuXG52YXIgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG1lcmlkaWVtOiBmYWxzZSxcbn0pO1xudmFyIFRpbWVDb2xFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtdGltZWdyaWQtZXZlbnQnLFxuICAgICAgICAgICAgJ2ZjLXYtZXZlbnQnLFxuICAgICAgICBdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5pc1Nob3J0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXRpbWVncmlkLWV2ZW50LXNob3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIF9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGRlZmF1bHRUaW1lRm9ybWF0OiBERUZBVUxUX1RJTUVfRk9STUFULCBleHRyYUNsYXNzTmFtZXM6IGNsYXNzTmFtZXMgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sRXZlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFRpbWVDb2xNaXNjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQ29sTWlzYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sTWlzYygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sTWlzYy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRlbnQsIHsgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGlubmVyQ29udGVudCAmJlxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtbWlzY1wiLCByZWY6IGlubmVyRWxSZWYgfSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sTWlzYztcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGltZUNvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc29ydEV2ZW50U2VncyA9IG1lbW9pemUoc29ydEV2ZW50U2Vncyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIGlzU2VsZWN0TWlycm9yID0gY29udGV4dC5vcHRpb25zLnNlbGVjdE1pcnJvcjtcbiAgICAgICAgdmFyIG1pcnJvclNlZ3MgPSAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MpIHx8XG4gICAgICAgICAgICAoaXNTZWxlY3RNaXJyb3IgJiYgcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MpIHx8XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgdmFyIGludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICB2YXIgc29ydGVkRmdTZWdzID0gdGhpcy5zb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb250ZXh0Lm9wdGlvbnMuZXZlbnRPcmRlcik7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsUm9vdCwgeyBlbFJlZjogcHJvcHMuZWxSZWYsIGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGRhdGFBdHRycykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBfX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCByb2xlOiBcImdyaWRjZWxsXCIsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1jb2wnXS5jb25jYXQoY2xhc3NOYW1lcywgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKS5qb2luKCcgJykgfSwgZGF0YUF0dHJzLCBwcm9wcy5leHRyYURhdGFBdHRycyksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtYmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCAnYmctZXZlbnQnKSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsICdoaWdobGlnaHQnKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgX3RoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIF90aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvcikpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgX3RoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xNaXNjLCB7IGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0pKSkpOyB9KSk7XG4gICAgfTtcbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHNvcnRlZEZnU2VncywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBvc2l0aW9uZWRGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlclBvc2l0aW9uZWRGZ1NlZ3MgPSBmdW5jdGlvbiAoc2VncywgLy8gaWYgbm90IG1pcnJvciwgbmVlZHMgdG8gYmUgc29ydGVkXG4gICAgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQub3B0aW9ucywgZXZlbnRNYXhTdGFjayA9IF9hLmV2ZW50TWF4U3RhY2ssIGV2ZW50U2hvcnRIZWlnaHQgPSBfYS5ldmVudFNob3J0SGVpZ2h0LCBldmVudE9yZGVyU3RyaWN0ID0gX2EuZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgPSBfYS5ldmVudE1pbkhlaWdodDtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgZGF0ZSA9IF9iLmRhdGUsIHNsYXRDb29yZHMgPSBfYi5zbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiA9IF9iLmV2ZW50U2VsZWN0aW9uLCB0b2RheVJhbmdlID0gX2IudG9kYXlSYW5nZSwgbm93RGF0ZSA9IF9iLm5vd0RhdGU7XG4gICAgICAgIHZhciBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIHZhciBzZWdWQ29vcmRzID0gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgZGF0ZSwgc2xhdENvb3JkcywgZXZlbnRNaW5IZWlnaHQpO1xuICAgICAgICB2YXIgX2MgPSBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spLCBzZWdQbGFjZW1lbnRzID0gX2Muc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzID0gX2MuaGlkZGVuR3JvdXBzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoZnVuY3Rpb24gKHNlZ1BsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdQbGFjZW1lbnQuc2VnLCByZWN0ID0gc2VnUGxhY2VtZW50LnJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgIHZhciBpc1Zpc2libGUgPSBpc01pcnJvciB8fCBCb29sZWFuKCFzZWdJc0ludmlzaWJsZVtpbnN0YW5jZUlkXSAmJiByZWN0KTtcbiAgICAgICAgICAgICAgICB2YXIgdlN0eWxlID0gY29tcHV0ZVNlZ1ZTdHlsZShyZWN0ICYmIHJlY3Quc3Bhbik7XG4gICAgICAgICAgICAgICAgdmFyIGhTdHlsZSA9ICghaXNNaXJyb3IgJiYgcmVjdCkgPyBfdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICAgICAgICAgIHZhciBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKHsgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyB9LCB2U3R5bGUpLCBoU3R5bGUpIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCBfX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGlzU2hvcnQ6IGlzU2hvcnQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVySGlkZGVuR3JvdXBzID0gZnVuY3Rpb24gKGhpZGRlbkdyb3Vwcywgc2Vncykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBleHRyYURhdGVTcGFuID0gX2EuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGUgPSBfYS5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSA9IF9hLnRvZGF5UmFuZ2UsIG5vd0RhdGUgPSBfYS5ub3dEYXRlLCBldmVudFNlbGVjdGlvbiA9IF9hLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcgPSBfYS5ldmVudERyYWcsIGV2ZW50UmVzaXplID0gX2EuZXZlbnRSZXNpemU7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcChmdW5jdGlvbiAoaGlkZGVuR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICB2YXIgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbE1vcmVMaW5rLCB7IGtleTogYnVpbGRJc29TdHJpbmcoY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckZpbGxTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKGZ1bmN0aW9uICh2Y29vcmRzLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGNvbXB1dGVTZWdWU3R5bGUodmNvb3JkcykgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSwgcHJvcHMubm93RGF0ZSkpKSA6XG4gICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoc2Vncykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzbGF0Q29vcmRzID0gX2Euc2xhdENvb3JkcywgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICAgIGlmICghc2xhdENvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3MubWFwKGZ1bmN0aW9uIChzZWcsIGkpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSwgXG4gICAgICAgICAgICAvLyBrZXkgZG9lc24ndCBtYXR0ZXIuIHdpbGwgb25seSBldmVyIGJlIG9uZVxuICAgICAgICAgICAga2V5OiBpIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZSddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7IHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpIH0gfSwgaW5uZXJDb250ZW50KSk7IH0pKTsgfSk7XG4gICAgfTtcbiAgICBUaW1lQ29sLnByb3RvdHlwZS5jb21wdXRlU2VnSFN0eWxlID0gZnVuY3Rpb24gKHNlZ0hDb29yZHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBpc1J0bCA9IF9hLmlzUnRsLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XG4gICAgICAgIHZhciBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIHZhciBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuICAgICAgICB2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICB2YXIgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxuICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XG4gICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXG4gICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCBfYSkge1xuICAgIHZhciB0b2RheVJhbmdlID0gX2EudG9kYXlSYW5nZSwgbm93RGF0ZSA9IF9hLm5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uID0gX2EuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZyA9IF9hLmV2ZW50RHJhZywgZXZlbnRSZXNpemUgPSBfYS5ldmVudFJlc2l6ZTtcbiAgICB2YXIgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzb3J0ZWRGZ1NlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGlzU2hvcnQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgfSkpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdWU3R5bGUoc2VnVkNvb3Jkcykge1xuICAgIGlmICghc2VnVkNvb3Jkcykge1xuICAgICAgICByZXR1cm4geyB0b3A6ICcnLCBib3R0b206ICcnIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogc2VnVkNvb3Jkcy5zdGFydCxcbiAgICAgICAgYm90dG9tOiAtc2VnVkNvb3Jkcy5lbmQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoc2VnRW50cmllcywgYWxsU2Vncykge1xuICAgIHJldHVybiBzZWdFbnRyaWVzLm1hcChmdW5jdGlvbiAoc2VnRW50cnkpIHsgcmV0dXJuIGFsbFNlZ3Nbc2VnRW50cnkuaW5kZXhdOyB9KTtcbn1cblxudmFyIFRpbWVDb2xzQ29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbHNDb250ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICBfdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5jZWxsRWxSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgIHZhciBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIHZhciBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XG4gICAgICAgIHZhciBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JSb290LCB7IGlzQXhpczogdHJ1ZSwgZGF0ZTogcHJvcHMubm93RGF0ZSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogX3RoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IGNlbGwuZXh0cmFIb29rUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpOyB9KSkpKSkpO1xuICAgIH07XG4gICAgVGltZUNvbHNDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xuICAgIH07XG4gICAgVGltZUNvbHNDb250ZW50LnByb3RvdHlwZS51cGRhdGVDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvbENvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgcHJvcHMub25Db2xDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdENlbGxFbHModGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLmNlbGxzKSwgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzQ29udGVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gZWxNYXBbY2VsbC5rZXldOyB9KTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgVGltZUNvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVDb2xzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gbWVtb2l6ZShwcm9jZXNzU2xvdE9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNsYXRDb29yZHM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IF90aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBvblNjcm9sbFRvcFJlcXVlc3QgPSBfdGhpcy5wcm9wcy5vblNjcm9sbFRvcFJlcXVlc3Q7XG4gICAgICAgICAgICB2YXIgc2xhdENvb3JkcyA9IF90aGlzLnN0YXRlLnNsYXRDb29yZHM7XG4gICAgICAgICAgICBpZiAob25TY3JvbGxUb3BSZXF1ZXN0ICYmIHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IHNsYXRDb29yZHMuY29tcHV0ZVRpbWVUb3AocmVxdWVzdC50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdG9wXzEgPSBNYXRoLmNlaWwodG9wXzEpOyAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcF8xICs9IDE7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsVG9wUmVxdWVzdCh0b3BfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDb2xDb29yZHMgPSBmdW5jdGlvbiAoY29sQ29vcmRzKSB7XG4gICAgICAgICAgICBfdGhpcy5jb2xDb29yZHMgPSBjb2xDb29yZHM7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNsYXRDb29yZHMgPSBmdW5jdGlvbiAoc2xhdENvb3Jkcykge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzbGF0Q29vcmRzOiBzbGF0Q29vcmRzIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uU2xhdENvb3Jkcykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uU2xhdENvb3JkcyhzbGF0Q29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29scy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYm9keVwiLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQ29udGVudCwgeyBjZWxsczogcHJvcHMuY2VsbHMsIGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCBub3dJbmRpY2F0b3JTZWdzOiBwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgc2xhdENvb3Jkczogc3RhdGUuc2xhdENvb3Jkcywgb25Db2xDb29yZHM6IHRoaXMuaGFuZGxlQ29sQ29vcmRzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci51cGRhdGUocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbENvb3JkcyA9IHRoaXMuY29sQ29vcmRzO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLnByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgc2xhdENvb3JkcyA9IHRoaXMuc3RhdGUuc2xhdENvb3JkcztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnModGhpcy5wcm9wcy5zbG90RHVyYXRpb24sIG9wdGlvbnMuc25hcER1cmF0aW9uKSwgc25hcER1cmF0aW9uID0gX2Iuc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3QgPSBfYi5zbmFwc1BlclNsb3Q7XG4gICAgICAgIHZhciBjb2xJbmRleCA9IGNvbENvb3Jkcy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xuICAgICAgICB2YXIgc2xhdEluZGV4ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNsYXRUb3AgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF07XG4gICAgICAgICAgICB2YXIgc2xhdEhlaWdodCA9IHNsYXRDb29yZHMucG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSAocG9zaXRpb25Ub3AgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgICAgIHZhciBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxuICAgICAgICAgICAgdmFyIHNuYXBJbmRleCA9IHNsYXRJbmRleCAqIHNuYXBzUGVyU2xvdCArIGxvY2FsU25hcEluZGV4O1xuICAgICAgICAgICAgdmFyIGRheURhdGUgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XS5kYXRlO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBhZGREdXJhdGlvbnMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIG11bHRpcGx5RHVyYXRpb24oc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbmFwRHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IF9fYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHM7XG59KERhdGVDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3B0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbk92ZXJyaWRlKSB7XG4gICAgdmFyIHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbk92ZXJyaWRlIHx8IHNsb3REdXJhdGlvbjtcbiAgICB2YXIgc25hcHNQZXJTbG90ID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb24pO1xuICAgIGlmIChzbmFwc1BlclNsb3QgPT09IG51bGwpIHtcbiAgICAgICAgc25hcER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgICAgICBzbmFwc1BlclNsb3QgPSAxO1xuICAgICAgICAvLyBUT0RPOiBzYXkgd2FybmluZz9cbiAgICB9XG4gICAgcmV0dXJuIHsgc25hcER1cmF0aW9uOiBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdDogc25hcHNQZXJTbG90IH07XG59XG5cbnZhciBEYXlUaW1lQ29sc1NsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5VGltZUNvbHNTbGljZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGltZUNvbHNTbGljZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRGF5VGltZUNvbHNTbGljZXIucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGRheVJhbmdlcykge1xuICAgICAgICB2YXIgc2VncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBkYXlSYW5nZXMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHNlZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbY29sXSk7XG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzU2xpY2VyO1xufShTbGljZXIpKTtcblxudmFyIERheVRpbWVDb2xzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlUaW1lQ29scywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUaW1lQ29scygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XG4gICAgICAgIF90aGlzLnNsaWNlciA9IG5ldyBEYXlUaW1lQ29sc1NsaWNlcigpO1xuICAgICAgICBfdGhpcy50aW1lQ29sc1JlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbCA9IHByb3BzLmRheVRhYmxlTW9kZWw7XG4gICAgICAgIHZhciBpc05vd0luZGljYXRvciA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3I7XG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IGlzTm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyB9LCBmdW5jdGlvbiAobm93RGF0ZSwgdG9kYXlSYW5nZSkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIF9fYXNzaWduKHsgcmVmOiBfdGhpcy50aW1lQ29sc1JlZiB9LCBfdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogaXNOb3dJbmRpY2F0b3IgJiYgX3RoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBvblNjcm9sbFRvcFJlcXVlc3Q6IHByb3BzLm9uU2Nyb2xsVG9wUmVxdWVzdCwgb25TbGF0Q29vcmRzOiBwcm9wcy5vblNsYXRDb29yZHMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzO1xufShEYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBidWlsZERheVJhbmdlcyhkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZSwgZGF0ZUVudikge1xuICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGRhdGUgPSBfYVtfaV07XG4gICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5cbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcbnZhciBTVE9DS19TVUJfRFVSQVRJT05TID0gW1xuICAgIHsgaG91cnM6IDEgfSxcbiAgICB7IG1pbnV0ZXM6IDMwIH0sXG4gICAgeyBtaW51dGVzOiAxNSB9LFxuICAgIHsgc2Vjb25kczogMzAgfSxcbiAgICB7IHNlY29uZHM6IDE1IH0sXG5dO1xuZnVuY3Rpb24gYnVpbGRTbGF0TWV0YXMoc2xvdE1pblRpbWUsIHNsb3RNYXhUaW1lLCBleHBsaWNpdExhYmVsSW50ZXJ2YWwsIHNsb3REdXJhdGlvbiwgZGF0ZUVudikge1xuICAgIHZhciBkYXlTdGFydCA9IG5ldyBEYXRlKDApO1xuICAgIHZhciBzbGF0VGltZSA9IHNsb3RNaW5UaW1lO1xuICAgIHZhciBzbGF0SXRlcmF0b3IgPSBjcmVhdGVEdXJhdGlvbigwKTtcbiAgICB2YXIgbGFiZWxJbnRlcnZhbCA9IGV4cGxpY2l0TGFiZWxJbnRlcnZhbCB8fCBjb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pO1xuICAgIHZhciBtZXRhcyA9IFtdO1xuICAgIHdoaWxlIChhc1JvdWdoTXMoc2xhdFRpbWUpIDwgYXNSb3VnaE1zKHNsb3RNYXhUaW1lKSkge1xuICAgICAgICB2YXIgZGF0ZSA9IGRhdGVFbnYuYWRkKGRheVN0YXJ0LCBzbGF0VGltZSk7XG4gICAgICAgIHZhciBpc0xhYmVsZWQgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhzbGF0SXRlcmF0b3IsIGxhYmVsSW50ZXJ2YWwpICE9PSBudWxsO1xuICAgICAgICBtZXRhcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgICB0aW1lOiBzbGF0VGltZSxcbiAgICAgICAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaXNvVGltZVN0cjogZm9ybWF0SXNvVGltZVN0cmluZyhkYXRlKSxcbiAgICAgICAgICAgIGlzTGFiZWxlZDogaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBhZGREdXJhdGlvbnMoc2xhdFRpbWUsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIHNsYXRJdGVyYXRvciA9IGFkZER1cmF0aW9ucyhzbGF0SXRlcmF0b3IsIHNsb3REdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBtZXRhcztcbn1cbi8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcbmZ1bmN0aW9uIGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsYWJlbEludGVydmFsO1xuICAgIHZhciBzbG90c1BlckxhYmVsO1xuICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuICAgIGZvciAoaSA9IFNUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMobGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgaWYgKHNsb3RzUGVyTGFiZWwgIT09IG51bGwgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90RHVyYXRpb247IC8vIGZhbGwgYmFja1xufVxuXG52YXIgRGF5VGltZUNvbHNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlUaW1lQ29sc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGltZUNvbHNWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGRUaW1lQ29sc01vZGVsID0gbWVtb2l6ZShidWlsZFRpbWVDb2xzTW9kZWwpO1xuICAgICAgICBfdGhpcy5idWlsZFNsYXRNZXRhcyA9IG1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBfYS5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICB2YXIgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgdmFyIGRheU1pbldpZHRoID0gb3B0aW9ucy5kYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXM6IHRydWUsIHJlbmRlckludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlckhlYWRBeGlzIDogbnVsbCB9KSk7XG4gICAgICAgIHZhciBhbGxEYXlDb250ZW50ID0gKG9wdGlvbnMuYWxsRGF5U2xvdCAhPT0gZmFsc2UpICYmIChmdW5jdGlvbiAoY29udGVudEFyZykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIF9fYXNzaWduKHt9LCBzcGxpdFByb3BzLmFsbERheSwgeyBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHJlbmRlclJvd0ludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyBfdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgOiBudWxsLCBzaG93V2Vla051bWJlcnM6IGZhbHNlLCBleHBhbmRSb3dzOiBmYWxzZSwgaGVhZGVyQWxpZ25FbFJlZjogX3RoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSwgX3RoaXMuZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcygpKSkpOyB9KTtcbiAgICAgICAgdmFyIHRpbWVHcmlkQ29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50QXJnKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgX19hc3NpZ24oe30sIHNwbGl0UHJvcHMudGltZWQsIHsgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBheGlzOiBoYXNBdHRhY2hlZEF4aXMsIHNsb3REdXJhdGlvbjogb3B0aW9ucy5zbG90RHVyYXRpb24sIHNsYXRNZXRhczogc2xhdE1ldGFzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIHRhYmxlQ29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBvblNsYXRDb29yZHM6IF90aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiBfdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7IH07XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUaW1lQ29sc1ZpZXc7XG59KFRpbWVDb2xzVmlldykpO1xuZnVuY3Rpb24gYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCBmYWxzZSk7XG59XG5cbnZhciBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYWxsRGF5U2xvdDogQm9vbGVhbixcbn07XG5cbnZhciBtYWluID0gY3JlYXRlUGx1Z2luKHtcbiAgICBpbml0aWFsVmlldzogJ3RpbWVHcmlkV2VlaycsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICB2aWV3czoge1xuICAgICAgICB0aW1lR3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUaW1lQ29sc1ZpZXcsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsbERheVNsb3Q6IHRydWUsXG4gICAgICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXG4gICAgICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlLCAvLyBhIGJhZCBuYW1lLiBjb25mdXNlZCB3aXRoIG92ZXJsYXAvY29uc3RyYWludCBzeXN0ZW1cbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYWluO1xuZXhwb3J0IHsgRGF5VGltZUNvbHMsIERheVRpbWVDb2xzU2xpY2VyLCBEYXlUaW1lQ29sc1ZpZXcsIFRpbWVDb2xzLCBUaW1lQ29sc1NsYXRzQ29vcmRzLCBUaW1lQ29sc1ZpZXcsIGJ1aWxkRGF5UmFuZ2VzLCBidWlsZFNsYXRNZXRhcywgYnVpbGRUaW1lQ29sc01vZGVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbImhhc0JnUmVuZGVyaW5nIiwiU3BsaXR0ZXIiLCJjcmVhdGVGb3JtYXR0ZXIiLCJjcmVhdGVFbGVtZW50IiwiVmlld0NvbnRleHRUeXBlIiwiUmVuZGVySG9vayIsIkJhc2VDb21wb25lbnQiLCJjcmVhdGVSZWYiLCJkaWZmRGF5cyIsImJ1aWxkTmF2TGlua0F0dHJzIiwiV2Vla051bWJlclJvb3QiLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsIlZpZXdSb290IiwiU2ltcGxlU2Nyb2xsR3JpZCIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsIk5vd1RpbWVyIiwiTm93SW5kaWNhdG9yUm9vdCIsInJlbmRlclNjcm9sbFNoaW0iLCJEYXRlQ29tcG9uZW50IiwicmFuZ2VDb250YWluc01hcmtlciIsInN0YXJ0T2ZEYXkiLCJhc1JvdWdoTXMiLCJjcmVhdGVEdXJhdGlvbiIsIlJlZk1hcCIsIlBvc2l0aW9uQ2FjaGUiLCJNb3JlTGlua1Jvb3QiLCJzZXRSZWYiLCJTZWdIaWVyYXJjaHkiLCJncm91cEludGVyc2VjdGluZ0VudHJpZXMiLCJidWlsZEVudHJ5S2V5IiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwiU3RhbmRhcmRFdmVudCIsIkRheUNlbGxDb250ZW50IiwiRnJhZ21lbnQiLCJnZXRTZWdNZXRhIiwibWVtb2l6ZSIsInNvcnRFdmVudFNlZ3MiLCJEYXlDZWxsUm9vdCIsImJ1aWxkSXNvU3RyaW5nIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJCZ0V2ZW50IiwicmVuZGVyRmlsbCIsImFkZER1cmF0aW9ucyIsIm11bHRpcGx5RHVyYXRpb24iLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsImludGVyc2VjdFJhbmdlcyIsIlNsaWNlciIsImZvcm1hdElzb1RpbWVTdHJpbmciLCJEYXlIZWFkZXIiLCJEYXlTZXJpZXNNb2RlbCIsIkRheVRhYmxlTW9kZWwiLCJjcmVhdGVQbHVnaW4iLCJfX2V4dGVuZHMiLCJfX2Fzc2lnbiIsIkRheVRhYmxlIiwiQWxsRGF5U3BsaXR0ZXIiLCJfc3VwZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInByb3RvdHlwZSIsImdldEtleUluZm8iLCJhbGxEYXkiLCJ0aW1lZCIsImdldEtleXNGb3JEYXRlU3BhbiIsImRhdGVTcGFuIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwiZXZlbnREZWYiLCJERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJUaW1lQ29sc0F4aXNDZWxsIiwicHJvcHMiLCJjbGFzc05hbWVzIiwiaXNMYWJlbGVkIiwiQ29uc3VtZXIiLCJjb250ZXh0IiwiY2xhc3NOYW1lIiwiam9pbiIsImlzb1RpbWVTdHIiLCJkYXRlRW52Iiwib3B0aW9ucyIsInZpZXdBcGkiLCJsYWJlbEZvcm1hdCIsInNsb3RMYWJlbEZvcm1hdCIsIkFycmF5IiwiaXNBcnJheSIsImhvb2tQcm9wcyIsImxldmVsIiwidGltZSIsImRhdGUiLCJ0b0RhdGUiLCJ2aWV3IiwidGV4dCIsImZvcm1hdCIsInNsb3RMYWJlbENsYXNzTmFtZXMiLCJjb250ZW50Iiwic2xvdExhYmVsQ29udGVudCIsImRlZmF1bHRDb250ZW50IiwicmVuZGVySW5uZXJDb250ZW50IiwiZGlkTW91bnQiLCJzbG90TGFiZWxEaWRNb3VudCIsIndpbGxVbm1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJyb290RWxSZWYiLCJjdXN0b21DbGFzc05hbWVzIiwiaW5uZXJFbFJlZiIsImlubmVyQ29udGVudCIsInJlZiIsImNvbmNhdCIsIlRpbWVCb2R5QXhpcyIsInJlbmRlciIsInNsYXRNZXRhcyIsIm1hcCIsInNsYXRNZXRhIiwia2V5IiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJ3ZWVrIiwiQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTIiwiVGltZUNvbHNWaWV3IiwiX3RoaXMiLCJhbGxEYXlTcGxpdHRlciIsImhlYWRlckVsUmVmIiwic2Nyb2xsZXJFbFJlZiIsInN0YXRlIiwic2xhdENvb3JkcyIsImhhbmRsZVNjcm9sbFRvcFJlcXVlc3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxlckVsIiwiY3VycmVudCIsInJlbmRlckhlYWRBeGlzIiwicm93S2V5IiwiZnJhbWVIZWlnaHQiLCJkYXRlUHJvZmlsZSIsInJhbmdlIiwicmVuZGVyUmFuZ2UiLCJkYXlDbnQiLCJzdGFydCIsImVuZCIsIm5hdkxpbmtBdHRycyIsIndlZWtOdW1iZXJzIiwiZGVmYXVsdEZvcm1hdCIsInN0eWxlIiwiaGVpZ2h0IiwicmVuZGVyVGFibGVSb3dBeGlzIiwicm93SGVpZ2h0IiwiX2EiLCJhbGxEYXlUZXh0IiwiYWxsRGF5Q2xhc3NOYW1lcyIsImFsbERheUNvbnRlbnQiLCJyZW5kZXJBbGxEYXlJbm5lciIsImFsbERheURpZE1vdW50IiwiYWxsRGF5V2lsbFVubW91bnQiLCJoYW5kbGVTbGF0Q29vcmRzIiwic2V0U3RhdGUiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwidGltZUNvbnRlbnQiLCJzZWN0aW9ucyIsInN0aWNreUhlYWRlckRhdGVzIiwicHVzaCIsInR5cGUiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJvdXRlckNvbnRlbnQiLCJyb2xlIiwidGhlbWUiLCJnZXRDbGFzcyIsImxpcXVpZCIsImV4cGFuZFJvd3MiLCJCb29sZWFuIiwidmlld1NwZWMiLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb2xzIiwid2lkdGgiLCJyZW5kZXJIU2Nyb2xsTGF5b3V0IiwiY29sQ250IiwiZGF5TWluV2lkdGgiLCJTY3JvbGxHcmlkIiwicGx1Z2luSG9va3MiLCJzY3JvbGxHcmlkSW1wbCIsIkVycm9yIiwic3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwic3luY1Jvd0hlaWdodHMiLCJjaHVua3MiLCJhcmciLCJyb3dTeW5jSGVpZ2h0cyIsImNvbnRlbnRBcmciLCJjb2xTcGFuIiwiaXNOb3dJbmRpY2F0b3IiLCJub3dJbmRpY2F0b3IiLCJjbGllbnRIZWlnaHQiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsInVuaXQiLCJub3dEYXRlIiwibm93SW5kaWNhdG9yVG9wIiwic2FmZUNvbXB1dGVUb3AiLCJpc0F4aXMiLCJ0b3AiLCJjb2xHcm91cHMiLCJzcGFuIiwibWluV2lkdGgiLCJnZXRBbGxEYXlNYXhFdmVudFByb3BzIiwiZGF5TWF4RXZlbnRzIiwiZGF5TWF4RXZlbnRSb3dzIiwidW5kZWZpbmVkIiwiVGltZUNvbHNTbGF0c0Nvb3JkcyIsInBvc2l0aW9ucyIsInNsb3REdXJhdGlvbiIsImN1cnJlbnRSYW5nZSIsInN0YXJ0T2ZEYXlEYXRlIiwidGltZU1zIiwidmFsdWVPZiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJjb21wdXRlVGltZVRvcCIsImNvbXB1dGVEYXRlVG9wIiwid2hlbiIsImR1cmF0aW9uIiwibGVuIiwiZWxzIiwibGVuZ3RoIiwic2xhdENvdmVyYWdlIiwibWlsbGlzZWNvbmRzIiwic2xhdEluZGV4Iiwic2xhdFJlbWFpbmRlciIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmbG9vciIsInRvcHMiLCJnZXRIZWlnaHQiLCJUaW1lQ29sc1NsYXRzQm9keSIsInNsYXRFbFJlZnMiLCJpIiwiYXhpcyIsInNsb3RMYW5lQ2xhc3NOYW1lcyIsInNsb3RMYW5lQ29udGVudCIsInNsb3RMYW5lRGlkTW91bnQiLCJzbG90TGFuZVdpbGxVbm1vdW50IiwiVGltZUNvbHNTbGF0cyIsInRhYmxlTWluV2lkdGgiLCJjbGllbnRXaWR0aCIsIm1pbkhlaWdodCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlU2l6aW5nIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJvbkNvb3JkcyIsInJvb3RFbCIsIm9mZnNldEhlaWdodCIsImNvbGxlY3RTbGF0RWxzIiwiY3VycmVudE1hcCIsImVsTWFwIiwic3BsaXRTZWdzQnlDb2wiLCJzZWdzIiwic2Vnc0J5Q29sIiwiY29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Q29sIiwidWkiLCJieVJvdyIsImFmZmVjdGVkSW5zdGFuY2VzIiwiaXNFdmVudCIsIl9pIiwic2VnIiwiVGltZUNvbE1vcmVMaW5rIiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxsU2VncyIsImFsaWdubWVudEVsUmVmIiwicmVuZGVyTW9yZUxpbmtJbm5lciIsImV4dHJhRGF0ZVNwYW4iLCJ0b2RheVJhbmdlIiwicG9wb3ZlckNvbnRlbnQiLCJyZW5kZXJQbGFpbkZnU2VncyIsImhhbmRsZUNsaWNrIiwidGl0bGUiLCJpc0V4cGFuZGVkIiwicG9wb3ZlcklkIiwiZWwiLCJib3R0b20iLCJvbkNsaWNrIiwic2hvcnRUZXh0IiwiYnVpbGRQb3NpdGlvbmluZyIsInNlZ0lucHV0cyIsInN0cmljdE9yZGVyIiwibWF4U3RhY2tDbnQiLCJoaWVyYXJjaHkiLCJoaWRkZW5FbnRyaWVzIiwiYWRkU2VncyIsImhpZGRlbkdyb3VwcyIsIndlYiIsImJ1aWxkV2ViIiwic3RyZXRjaFdlYiIsInNlZ1JlY3RzIiwid2ViVG9SZWN0cyIsImVudHJpZXNCeUxldmVsIiwiYnVpbGROb2RlIiwiY2FjaGVhYmxlIiwibGF0ZXJhbCIsInNpYmxpbmdSYW5nZSIsImZpbmROZXh0TGV2ZWxTZWdzIiwibmV4dExldmVsUmVzIiwiYnVpbGROb2RlcyIsImVudHJ5IiwibmV4dExldmVsTm9kZXMiLCJ0aGlja25lc3MiLCJsYXRlcmFsU3RhcnQiLCJsYXRlcmFsRW5kIiwicGFpcnMiLCJzb3J0IiwiY21wRGVzY1ByZXNzdXJlcyIsImV4dHJhY3ROb2RlIiwiYSIsImIiLCJzdWJqZWN0TGV2ZWwiLCJzdWJqZWN0TGF0ZXJhbCIsImxldmVsQ29vcmRzIiwic3ViamVjdEVudHJ5IiwiYWZ0ZXJTdWJqZWN0IiwibGV2ZWxDbnQiLCJlbnRyaWVzIiwic2VhcmNoSW5kZXgiLCJ0b3BMZXZlbE5vZGVzIiwidG90YWxUaGlja25lc3MiLCJzdHJldGNoTm9kZSIsIm5vZGUiLCJzdGFydENvb3JkIiwicHJldlRoaWNrbmVzcyIsImFsbFRoaWNrbmVzcyIsInRoaWNrbmVzc0ZyYWN0aW9uIiwiZW5kQ29vcmQiLCJuZXdDaGlsZHJlbiIsIm5leHRMZXZlbE5vZGVzXzEiLCJjaGlsZE5vZGUiLCJyZXMiLCJuZXdUaGlja25lc3MiLCJyZWN0cyIsInByb2Nlc3NOb2RlIiwibGV2ZWxDb29yZCIsInN0YWNrRGVwdGgiLCJyZWN0Iiwic3RhY2tGb3J3YXJkIiwicHJvY2Vzc05vZGVzIiwibm9kZXMiLCJub2Rlc18xIiwia2V5RnVuYyIsIndvcmtGdW5jIiwiY2FjaGUiLCJhcmdzIiwiY29tcHV0ZVNlZ1ZDb29yZHMiLCJjb2xEYXRlIiwiZXZlbnRNaW5IZWlnaHQiLCJ2Y29vcmRzIiwic3BhblN0YXJ0Iiwic3BhbkVuZCIsInJvdW5kIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50cyIsInNlZ1ZDb29yZHMiLCJldmVudE9yZGVyU3RyaWN0IiwiZXZlbnRNYXhTdGFjayIsImR1bWJTZWdzIiwiaW5kZXgiLCJzZWdQbGFjZW1lbnRzIiwic2VnUmVjdHNfMSIsInNlZ1JlY3QiLCJfYiIsImR1bWJTZWdzXzEiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCIsIlRpbWVDb2xFdmVudCIsImlzU2hvcnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsImV4dHJhQ2xhc3NOYW1lcyIsIlRpbWVDb2xNaXNjIiwiZXh0cmFIb29rUHJvcHMiLCJUaW1lQ29sIiwiaXNTZWxlY3RNaXJyb3IiLCJzZWxlY3RNaXJyb3IiLCJtaXJyb3JTZWdzIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemUiLCJkYXRlU2VsZWN0aW9uU2VncyIsImludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMiLCJzb3J0ZWRGZ1NlZ3MiLCJmZ0V2ZW50U2VncyIsImV2ZW50T3JkZXIiLCJkYXRhQXR0cnMiLCJleHRyYURhdGFBdHRycyIsInJlbmRlckZpbGxTZWdzIiwiYnVzaW5lc3NIb3VyU2VncyIsImJnRXZlbnRTZWdzIiwicmVuZGVyRmdTZWdzIiwicmVuZGVyTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yU2VncyIsInNlZ0lzSW52aXNpYmxlIiwiaXNEcmFnZ2luZyIsImlzUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJyZW5kZXJQb3NpdGlvbmVkRmdTZWdzIiwiZXZlbnRTaG9ydEhlaWdodCIsImV2ZW50U2VsZWN0aW9uIiwiaXNNaXJyb3IiLCJfYyIsInJlbmRlckhpZGRlbkdyb3VwcyIsInNlZ1BsYWNlbWVudCIsImluc3RhbmNlSWQiLCJldmVudFJhbmdlIiwiaW5zdGFuY2UiLCJpc1Zpc2libGUiLCJ2U3R5bGUiLCJjb21wdXRlU2VnVlN0eWxlIiwiaFN0eWxlIiwiY29tcHV0ZVNlZ0hTdHlsZSIsImxlZnQiLCJyaWdodCIsImlzSW5zZXQiLCJ2aXNpYmlsaXR5IiwiaXNTZWxlY3RlZCIsImhpZGRlbkdyb3VwIiwicG9zaXRpb25Dc3MiLCJjb21waWxlU2Vnc0Zyb21FbnRyaWVzIiwiZmlsbFR5cGUiLCJjaGlsZHJlbiIsInNlZ0hDb29yZHMiLCJpc1J0bCIsInNob3VsZE92ZXJsYXAiLCJzbG90RXZlbnRPdmVybGFwIiwibmVhckNvb3JkIiwiZmFyQ29vcmQiLCJ6SW5kZXgiLCJoaWRkZW5JbnN0YW5jZXMiLCJzZWdFbnRyaWVzIiwic2VnRW50cnkiLCJUaW1lQ29sc0NvbnRlbnQiLCJzcGxpdEZnRXZlbnRTZWdzIiwic3BsaXRCZ0V2ZW50U2VncyIsInNwbGl0QnVzaW5lc3NIb3VyU2VncyIsInNwbGl0Tm93SW5kaWNhdG9yU2VncyIsInNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MiLCJzcGxpdEV2ZW50RHJhZyIsInNwbGl0RXZlbnRSZXNpemUiLCJjZWxsRWxSZWZzIiwiY2VsbHMiLCJmZ0V2ZW50U2Vnc0J5Um93IiwiYmdFdmVudFNlZ3NCeVJvdyIsImJ1c2luZXNzSG91clNlZ3NCeVJvdyIsIm5vd0luZGljYXRvclNlZ3NCeVJvdyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJldmVudERyYWdCeVJvdyIsImV2ZW50UmVzaXplQnlSb3ciLCJjZWxsIiwidXBkYXRlQ29vcmRzIiwib25Db2xDb29yZHMiLCJjb2xsZWN0Q2VsbEVscyIsIlRpbWVDb2xzIiwicHJvY2Vzc1Nsb3RPcHRpb25zIiwiaGFuZGxlUm9vdEVsIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiaGFuZGxlU2Nyb2xsUmVxdWVzdCIsInJlcXVlc3QiLCJvblNjcm9sbFRvcFJlcXVlc3QiLCJ0b3BfMSIsImNlaWwiLCJoYW5kbGVDb2xDb29yZHMiLCJjb2xDb29yZHMiLCJvblNsYXRDb29yZHMiLCJzY3JvbGxSZXNwb25kZXIiLCJjcmVhdGVTY3JvbGxSZXNwb25kZXIiLCJwcmV2UHJvcHMiLCJ1cGRhdGUiLCJkZXRhY2giLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwic25hcER1cmF0aW9uIiwic25hcHNQZXJTbG90IiwiY29sSW5kZXgiLCJsZWZ0VG9JbmRleCIsInRvcFRvSW5kZXgiLCJzbGF0VG9wIiwic2xhdEhlaWdodCIsInBhcnRpYWwiLCJsb2NhbFNuYXBJbmRleCIsInNuYXBJbmRleCIsImRheURhdGUiLCJhZGQiLCJkYXlFbCIsImxlZnRzIiwicmlnaHRzIiwibGF5ZXIiLCJzbmFwRHVyYXRpb25PdmVycmlkZSIsIkRheVRpbWVDb2xzU2xpY2VyIiwic2xpY2VSYW5nZSIsImRheVJhbmdlcyIsInNlZ1JhbmdlIiwiaXNTdGFydCIsImlzRW5kIiwiRGF5VGltZUNvbHMiLCJidWlsZERheVJhbmdlcyIsInNsaWNlciIsInRpbWVDb2xzUmVmIiwiZGF5VGFibGVNb2RlbCIsInNsaWNlUHJvcHMiLCJzbGljZU5vd0RhdGUiLCJyYW5nZXMiLCJoZWFkZXJEYXRlcyIsIlNUT0NLX1NVQl9EVVJBVElPTlMiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwiYnVpbGRTbGF0TWV0YXMiLCJleHBsaWNpdExhYmVsSW50ZXJ2YWwiLCJkYXlTdGFydCIsIkRhdGUiLCJzbGF0VGltZSIsInNsYXRJdGVyYXRvciIsImxhYmVsSW50ZXJ2YWwiLCJjb21wdXRlTGFiZWxJbnRlcnZhbCIsIm1ldGFzIiwidG9JU09TdHJpbmciLCJzbG90c1BlckxhYmVsIiwiRGF5VGltZUNvbHNWaWV3IiwiYnVpbGRUaW1lQ29sc01vZGVsIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJzcGxpdFByb3BzIiwic2xvdExhYmVsSW50ZXJ2YWwiLCJoYXNBdHRhY2hlZEF4aXMiLCJoYXNEZXRhY2hlZEF4aXMiLCJoZWFkZXJDb250ZW50IiwiZGF5SGVhZGVycyIsImRhdGVzIiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJyZW5kZXJJbnRybyIsImFsbERheVNsb3QiLCJuZXh0RGF5VGhyZXNob2xkIiwiY29sR3JvdXBOb2RlIiwicmVuZGVyUm93SW50cm8iLCJzaG93V2Vla051bWJlcnMiLCJoZWFkZXJBbGlnbkVsUmVmIiwidGltZUdyaWRDb250ZW50IiwiZGF5U2VyaWVzIiwiT1BUSU9OX1JFRklORVJTIiwibWFpbiIsImluaXRpYWxWaWV3Iiwib3B0aW9uUmVmaW5lcnMiLCJ2aWV3cyIsInRpbWVHcmlkIiwiY29tcG9uZW50IiwidXNlc01pbk1heFRpbWUiLCJ0aW1lR3JpZERheSIsImRheXMiLCJ0aW1lR3JpZFdlZWsiLCJ3ZWVrcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/timegrid/main.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Fiijimayuusuke%2FdevPortfolio%2Ffullcallendar-test%2Fpages%2Findex.tsx!":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Fiijimayuusuke%2FdevPortfolio%2Ffullcallendar-test%2Fpages%2Findex.tsx! ***!
  \**********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkYmYWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmlpamltYXl1dXN1a2UlMkZkZXZQb3J0Zm9saW8lMkZmdWxsY2FsbGVuZGFyLXRlc3QlMkZwYWdlcyUyRmluZGV4LnRzeCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0Q0FBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2NhZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Fiijimayuusuke%2FdevPortfolio%2Ffullcallendar-test%2Fpages%2Findex.tsx!\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": function() { return /* binding */ __extends; },\n/* harmony export */   \"__assign\": function() { return /* binding */ __assign; },\n/* harmony export */   \"__rest\": function() { return /* binding */ __rest; },\n/* harmony export */   \"__decorate\": function() { return /* binding */ __decorate; },\n/* harmony export */   \"__param\": function() { return /* binding */ __param; },\n/* harmony export */   \"__metadata\": function() { return /* binding */ __metadata; },\n/* harmony export */   \"__awaiter\": function() { return /* binding */ __awaiter; },\n/* harmony export */   \"__generator\": function() { return /* binding */ __generator; },\n/* harmony export */   \"__createBinding\": function() { return /* binding */ __createBinding; },\n/* harmony export */   \"__exportStar\": function() { return /* binding */ __exportStar; },\n/* harmony export */   \"__values\": function() { return /* binding */ __values; },\n/* harmony export */   \"__read\": function() { return /* binding */ __read; },\n/* harmony export */   \"__spread\": function() { return /* binding */ __spread; },\n/* harmony export */   \"__spreadArrays\": function() { return /* binding */ __spreadArrays; },\n/* harmony export */   \"__spreadArray\": function() { return /* binding */ __spreadArray; },\n/* harmony export */   \"__await\": function() { return /* binding */ __await; },\n/* harmony export */   \"__asyncGenerator\": function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   \"__asyncDelegator\": function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   \"__asyncValues\": function() { return /* binding */ __asyncValues; },\n/* harmony export */   \"__makeTemplateObject\": function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   \"__importStar\": function() { return /* binding */ __importStar; },\n/* harmony export */   \"__importDefault\": function() { return /* binding */ __importDefault; },\n/* harmony export */   \"__classPrivateFieldGet\": function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   \"__classPrivateFieldSet\": function() { return /* binding */ __classPrivateFieldSet; }\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QztBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/YTY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=%2FUsers%2Fiijimayuusuke%2FdevPortfolio%2Ffullcallendar-test%2Fpages%2Findex.tsx!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);