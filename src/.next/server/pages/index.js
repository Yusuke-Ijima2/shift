"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/react */ \"./node_modules/@fullcalendar/react/dist/main.cjs.js\");\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/timegrid */ \"./node_modules/@fullcalendar/timegrid/main.cjs.js\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/interaction */ \"@fullcalendar/interaction\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);\nvar _jsxFileName = \"/usr/src/app/pages/index.tsx\";\n\n\n\n\n\n\nconst Home = () => {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)((_fullcalendar_react__WEBPACK_IMPORTED_MODULE_0___default()), {\n    plugins: [(_fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_2___default()), _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_1__[\"default\"]],\n    initialView: \"timeGridWeek\",\n    nowIndicator: true,\n    editable: true,\n    initialEvents: [{\n      title: 'nice event',\n      start: new Date()\n    }]\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 8,\n    columnNumber: 5\n  }, undefined);\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Home);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsTUFBTUksSUFBSSxHQUFHLE1BQU07QUFDakIsc0JBQ0UsOERBQUMsNERBQUQ7QUFDQSxXQUFPLEVBQUUsQ0FBQ0Ysa0VBQUQsRUFBb0JELDhEQUFwQixDQURUO0FBRUEsZUFBVyxFQUFDLGNBRlo7QUFHQSxnQkFBWSxFQUFFLElBSGQ7QUFJQSxZQUFRLEVBQUUsSUFKVjtBQUtBLGlCQUFhLEVBQUUsQ0FDYjtBQUFFSSxNQUFBQSxLQUFLLEVBQUUsWUFBVDtBQUF1QkMsTUFBQUEsS0FBSyxFQUFFLElBQUlDLElBQUo7QUFBOUIsS0FEYTtBQUxmO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFERjtBQVdELENBWkQ7O0FBY0EsaUVBQWVILElBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdWxsY2FsbGVuZGFyLXRlc3QvLi9wYWdlcy9pbmRleC50c3g/MDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRnVsbENhbGVuZGFyIGZyb20gJ0BmdWxsY2FsZW5kYXIvcmVhY3QnXG5pbXBvcnQgdGltZUdyaWRQbHVnaW4gZnJvbSAnQGZ1bGxjYWxlbmRhci90aW1lZ3JpZCdcbmltcG9ydCBpbnRlcmFjdGlvblBsdWdpbiBmcm9tICdAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgSG9tZSA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8RnVsbENhbGVuZGFyXG4gICAgcGx1Z2lucz17W2ludGVyYWN0aW9uUGx1Z2luLCB0aW1lR3JpZFBsdWdpbl19XG4gICAgaW5pdGlhbFZpZXc9J3RpbWVHcmlkV2VlaydcbiAgICBub3dJbmRpY2F0b3I9e3RydWV9XG4gICAgZWRpdGFibGU9e3RydWV9XG4gICAgaW5pdGlhbEV2ZW50cz17W1xuICAgICAgeyB0aXRsZTogJ25pY2UgZXZlbnQnLCBzdGFydDogbmV3IERhdGUoKSB9XG4gICAgXX1cbiAgLz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBIb21lOyJdLCJuYW1lcyI6WyJGdWxsQ2FsZW5kYXIiLCJ0aW1lR3JpZFBsdWdpbiIsImludGVyYWN0aW9uUGx1Z2luIiwiUmVhY3QiLCJIb21lIiwidGl0bGUiLCJzdGFydCIsIkRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.tsx\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n;\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\nvar vdom_cjs = __webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/common/vdom.cjs.js\"); // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar EventSourceApi = function () {\n  function EventSourceApi(context, internalEventSource) {\n    this.context = context;\n    this.internalEventSource = internalEventSource;\n  }\n\n  EventSourceApi.prototype.remove = function () {\n    this.context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: this.internalEventSource.sourceId\n    });\n  };\n\n  EventSourceApi.prototype.refetch = function () {\n    this.context.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      sourceIds: [this.internalEventSource.sourceId],\n      isRefetch: true\n    });\n  };\n\n  Object.defineProperty(EventSourceApi.prototype, \"id\", {\n    get: function () {\n      return this.internalEventSource.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"url\", {\n    get: function () {\n      return this.internalEventSource.meta.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"format\", {\n    get: function () {\n      return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return EventSourceApi;\n}();\n\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n} // Querying\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction elementClosest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector); // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  }\n\n  if (!document.documentElement.contains(el)) {\n    return null;\n  }\n\n  do {\n    if (elementMatches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n}\n\nfunction elementMatches(el, selector) {\n  var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n  return method.call(el, selector);\n} // accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\n\n\nfunction findElements(container, selector) {\n  var containers = container instanceof HTMLElement ? [container] : container;\n  var allMatches = [];\n\n  for (var i = 0; i < containers.length; i += 1) {\n    var matches = containers[i].querySelectorAll(selector);\n\n    for (var j = 0; j < matches.length; j += 1) {\n      allMatches.push(matches[j]);\n    }\n  }\n\n  return allMatches;\n} // accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\n\n\nfunction findDirectChildren(parent, selector) {\n  var parents = parent instanceof HTMLElement ? [parent] : parent;\n  var allMatches = [];\n\n  for (var i = 0; i < parents.length; i += 1) {\n    var childNodes = parents[i].children; // only ever elements\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      var childNode = childNodes[j];\n\n      if (!selector || elementMatches(childNode, selector)) {\n        allMatches.push(childNode);\n      }\n    }\n  }\n\n  return allMatches;\n} // Style\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n\nfunction applyStyle(el, props) {\n  for (var propName in props) {\n    applyStyleProp(el, propName, props[propName]);\n  }\n}\n\nfunction applyStyleProp(el, name, val) {\n  if (val == null) {\n    el.style[name] = '';\n  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n    el.style[name] = val + \"px\";\n  } else {\n    el.style[name] = val;\n  }\n} // Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\n\n\nfunction getEventTargetViaRoot(ev) {\n  var _a, _b;\n\n  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n} // Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction getElRoot(el) {\n  return el.getRootNode ? el.getRootNode() : document;\n} // Unique ID for DOM attribute\n\n\nvar guid$1 = 0;\n\nfunction getUniqueDomId() {\n  guid$1 += 1;\n  return 'fc-dom-' + guid$1;\n} // Stops a mouse/touch event from doing it's native browser action\n\n\nfunction preventDefault(ev) {\n  ev.preventDefault();\n} // Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildDelegationHandler(selector, handler) {\n  return function (ev) {\n    var matchedChild = elementClosest(ev.target, selector);\n\n    if (matchedChild) {\n      handler.call(matchedChild, ev, matchedChild);\n    }\n  };\n}\n\nfunction listenBySelector(container, eventType, selector, handler) {\n  var attachedHandler = buildDelegationHandler(selector, handler);\n  container.addEventListener(eventType, attachedHandler);\n  return function () {\n    container.removeEventListener(eventType, attachedHandler);\n  };\n}\n\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n  var currentMatchedChild;\n  return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {\n    if (matchedChild !== currentMatchedChild) {\n      currentMatchedChild = matchedChild;\n      onMouseEnter(mouseOverEv, matchedChild);\n\n      var realOnMouseLeave_1 = function (mouseLeaveEv) {\n        currentMatchedChild = null;\n        onMouseLeave(mouseLeaveEv, matchedChild);\n        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n      }; // listen to the next mouseleave, and then unattach\n\n\n      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n    }\n  });\n} // Animation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes\n\nfunction whenTransitionDone(el, callback) {\n  var realCallback = function (ev) {\n    callback(ev);\n    transitionEventNames.forEach(function (eventName) {\n      el.removeEventListener(eventName, realCallback);\n    });\n  };\n\n  transitionEventNames.forEach(function (eventName) {\n    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n  });\n} // ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction createAriaClickAttrs(handler) {\n  return tslib.__assign({\n    onClick: handler\n  }, createAriaKeyboardAttrs(handler));\n}\n\nfunction createAriaKeyboardAttrs(handler) {\n  return {\n    tabIndex: 0,\n    onKeyDown: function (ev) {\n      if (ev.key === 'Enter' || ev.key === ' ') {\n        handler(ev);\n        ev.preventDefault(); // if space, don't scroll down page\n      }\n    }\n  };\n}\n\nvar guidNumber = 0;\n\nfunction guid() {\n  guidNumber += 1;\n  return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\n\n\nfunction disableCursor() {\n  document.body.classList.add('fc-not-allowed');\n} // Returns the mouse cursor to its original look\n\n\nfunction enableCursor() {\n  document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventSelection(el) {\n  el.classList.add('fc-unselectable');\n  el.addEventListener('selectstart', preventDefault);\n}\n\nfunction allowSelection(el) {\n  el.classList.remove('fc-unselectable');\n  el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventContextMenu(el) {\n  el.addEventListener('contextmenu', preventDefault);\n}\n\nfunction allowContextMenu(el) {\n  el.removeEventListener('contextmenu', preventDefault);\n}\n\nfunction parseFieldSpecs(input) {\n  var specs = [];\n  var tokens = [];\n  var i;\n  var token;\n\n  if (typeof input === 'string') {\n    tokens = input.split(/\\s*,\\s*/);\n  } else if (typeof input === 'function') {\n    tokens = [input];\n  } else if (Array.isArray(input)) {\n    tokens = input;\n  }\n\n  for (i = 0; i < tokens.length; i += 1) {\n    token = tokens[i];\n\n    if (typeof token === 'string') {\n      specs.push(token.charAt(0) === '-' ? {\n        field: token.substring(1),\n        order: -1\n      } : {\n        field: token,\n        order: 1\n      });\n    } else if (typeof token === 'function') {\n      specs.push({\n        func: token\n      });\n    }\n  }\n\n  return specs;\n}\n\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n  var i;\n  var cmp;\n\n  for (i = 0; i < fieldSpecs.length; i += 1) {\n    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n\n    if (cmp) {\n      return cmp;\n    }\n  }\n\n  return 0;\n}\n\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n  if (fieldSpec.func) {\n    return fieldSpec.func(obj0, obj1);\n  }\n\n  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\n\nfunction flexibleCompare(a, b) {\n  if (!a && !b) {\n    return 0;\n  }\n\n  if (b == null) {\n    return -1;\n  }\n\n  if (a == null) {\n    return 1;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return String(a).localeCompare(String(b));\n  }\n\n  return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction padStart(val, len) {\n  var s = String(val);\n  return '000'.substr(0, len - s.length) + s;\n}\n\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n  if (typeof formatter === 'function') {\n    return formatter.apply(void 0, args);\n  }\n\n  if (typeof formatter === 'string') {\n    // non-blank string\n    return args.reduce(function (str, arg, index) {\n      return str.replace('$' + index, arg || '');\n    }, formatter);\n  }\n\n  return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isInt(n) {\n  return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction computeSmallestCellWidth(cellEl) {\n  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n\n  if (!allWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n  }\n\n  if (!contentWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-cushion className');\n  }\n\n  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n  contentWidthEl.getBoundingClientRect().width;\n}\n\nvar DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding\n\nfunction addWeeks(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n * 7;\n  return arrayToUtcDate(a);\n}\n\nfunction addDays(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n;\n  return arrayToUtcDate(a);\n}\n\nfunction addMs(m, n) {\n  var a = dateToUtcArray(m);\n  a[6] += n;\n  return arrayToUtcDate(a);\n} // Diffing (all return floats)\n// TODO: why not use ranges?\n\n\nfunction diffWeeks(m0, m1) {\n  return diffDays(m0, m1) / 7;\n}\n\nfunction diffDays(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\n\nfunction diffHours(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\n\nfunction diffMinutes(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\n\nfunction diffSeconds(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / 1000;\n}\n\nfunction diffDayAndTime(m0, m1) {\n  var m0day = startOfDay(m0);\n  var m1day = startOfDay(m1);\n  return {\n    years: 0,\n    months: 0,\n    days: Math.round(diffDays(m0day, m1day)),\n    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n  };\n} // Diffing Whole Units\n\n\nfunction diffWholeWeeks(m0, m1) {\n  var d = diffWholeDays(m0, m1);\n\n  if (d !== null && d % 7 === 0) {\n    return d / 7;\n  }\n\n  return null;\n}\n\nfunction diffWholeDays(m0, m1) {\n  if (timeAsMs(m0) === timeAsMs(m1)) {\n    return Math.round(diffDays(m0, m1));\n  }\n\n  return null;\n} // Start-Of\n\n\nfunction startOfDay(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);\n}\n\nfunction startOfHour(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);\n}\n\nfunction startOfMinute(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);\n}\n\nfunction startOfSecond(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);\n} // Week Computation\n\n\nfunction weekOfYear(marker, dow, doy) {\n  var y = marker.getUTCFullYear();\n  var w = weekOfGivenYear(marker, y, dow, doy);\n\n  if (w < 1) {\n    return weekOfGivenYear(marker, y - 1, dow, doy);\n  }\n\n  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n\n  if (nextW >= 1) {\n    return Math.min(w, nextW);\n  }\n\n  return w;\n}\n\nfunction weekOfGivenYear(marker, year, dow, doy) {\n  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n  var dayStart = startOfDay(marker);\n  var days = Math.round(diffDays(firstWeekStart, dayStart));\n  return Math.floor(days / 7) + 1; // zero-indexed\n} // start-of-first-week - start-of-year\n\n\nfunction firstWeekOffset(year, dow, doy) {\n  // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd\n\n  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n  return -fwdlw + fwd - 1;\n} // Array Conversion\n\n\nfunction dateToLocalArray(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n}\n\nfunction arrayToLocalDate(a) {\n  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n  a[3] || 0, a[4] || 0, a[5] || 0);\n}\n\nfunction dateToUtcArray(date) {\n  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];\n}\n\nfunction arrayToUtcDate(a) {\n  // according to web standards (and Safari), a month index is required.\n  // massage if only given a year.\n  if (a.length === 1) {\n    a = a.concat([0]);\n  }\n\n  return new Date(Date.UTC.apply(Date, a));\n} // Other Utils\n\n\nfunction isValidDate(m) {\n  return !isNaN(m.valueOf());\n}\n\nfunction timeAsMs(m) {\n  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n  return {\n    instanceId: guid(),\n    defId: defId,\n    range: range,\n    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n\nfunction mergeProps(propObjs, complexPropsMap) {\n  var dest = {};\n\n  if (complexPropsMap) {\n    for (var name_1 in complexPropsMap) {\n      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n      for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n        var val = propObjs[i][name_1];\n\n        if (typeof val === 'object' && val) {\n          // non-null object\n          complexObjs.unshift(val);\n        } else if (val !== undefined) {\n          dest[name_1] = val; // if there were no objects, this value will be used\n\n          break;\n        }\n      } // if the trailing values were objects, use the merged value\n\n\n      if (complexObjs.length) {\n        dest[name_1] = mergeProps(complexObjs);\n      }\n    }\n  } // copy values into the destination, going from last to first\n\n\n  for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n    var props = propObjs[i];\n\n    for (var name_2 in props) {\n      if (!(name_2 in dest)) {\n        // if already assigned by previous props or complex props, don't reassign\n        dest[name_2] = props[name_2];\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction filterHash(hash, func) {\n  var filtered = {};\n\n  for (var key in hash) {\n    if (func(hash[key], key)) {\n      filtered[key] = hash[key];\n    }\n  }\n\n  return filtered;\n}\n\nfunction mapHash(hash, func) {\n  var newHash = {};\n\n  for (var key in hash) {\n    newHash[key] = func(hash[key], key);\n  }\n\n  return newHash;\n}\n\nfunction arrayToHash(a) {\n  var hash = {};\n\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var item = a_1[_i];\n    hash[item] = true;\n  }\n\n  return hash;\n}\n\nfunction buildHashFromArray(a, func) {\n  var hash = {};\n\n  for (var i = 0; i < a.length; i += 1) {\n    var tuple = func(a[i], i);\n    hash[tuple[0]] = tuple[1];\n  }\n\n  return hash;\n}\n\nfunction hashValuesToArray(obj) {\n  var a = [];\n\n  for (var key in obj) {\n    a.push(obj[key]);\n  }\n\n  return a;\n}\n\nfunction isPropsEqual(obj0, obj1) {\n  if (obj0 === obj1) {\n    return true;\n  }\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        return false;\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getUnequalProps(obj0, obj1) {\n  var keys = [];\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        keys.push(key);\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        keys.push(key);\n      }\n    }\n  }\n\n  return keys;\n}\n\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n  if (equalityFuncs === void 0) {\n    equalityFuncs = {};\n  }\n\n  if (oldProps === newProps) {\n    return true;\n  }\n\n  for (var key in newProps) {\n    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {\n      return false;\n    }\n  } // check for props that were omitted in the new\n\n\n  for (var key in oldProps) {\n    if (!(key in newProps)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\n\n\nfunction isObjValsEqual(val0, val1, comparator) {\n  if (val0 === val1 || comparator === true) {\n    return true;\n  }\n\n  if (comparator) {\n    return comparator(val0, val1);\n  }\n\n  return false;\n}\n\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n  if (startIndex === void 0) {\n    startIndex = 0;\n  }\n\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var res = [];\n\n  if (endIndex == null) {\n    endIndex = Object.keys(hash).length;\n  }\n\n  for (var i = startIndex; i < endIndex; i += step) {\n    var val = hash[i];\n\n    if (val !== undefined) {\n      // will disregard undefined for sparse arrays\n      res.push(val);\n    }\n  }\n\n  return res;\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n  for (var i = 0; i < recurringTypes.length; i += 1) {\n    var parsed = recurringTypes[i].parse(refined, dateEnv);\n\n    if (parsed) {\n      var allDay = refined.allDay;\n\n      if (allDay == null) {\n        allDay = defaultAllDay;\n\n        if (allDay == null) {\n          allDay = parsed.allDayGuess;\n\n          if (allDay == null) {\n            allDay = false;\n          }\n        }\n      }\n\n      return {\n        allDay: allDay,\n        duration: parsed.duration,\n        typeData: parsed.typeData,\n        typeId: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction expandRecurring(eventStore, framingRange, context) {\n  var dateEnv = context.dateEnv,\n      pluginHooks = context.pluginHooks,\n      options = context.options;\n  var defs = eventStore.defs,\n      instances = eventStore.instances; // remove existing recurring instances\n  // TODO: bad. always expand events as a second step\n\n  instances = filterHash(instances, function (instance) {\n    return !defs[instance.defId].recurringDef;\n  });\n\n  for (var defId in defs) {\n    var def = defs[defId];\n\n    if (def.recurringDef) {\n      var duration = def.recurringDef.duration;\n\n      if (!duration) {\n        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n      }\n\n      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n\n      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n        var start = starts_1[_i];\n        var instance = createEventInstance(defId, {\n          start: start,\n          end: dateEnv.add(start, duration)\n        });\n        instances[instance.instanceId] = instance;\n      }\n    }\n  }\n\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n/*\nEvent MUST have a recurringDef\n*/\n\n\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n  var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n  var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n    start: dateEnv.subtract(framingRange.start, duration),\n    end: framingRange.end\n  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n\n  if (eventDef.allDay) {\n    markers = markers.map(startOfDay);\n  }\n\n  return markers;\n}\n\nvar INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/; // Parsing and Creation\n\nfunction createDuration(input, unit) {\n  var _a;\n\n  if (typeof input === 'string') {\n    return parseString(input);\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseObject(input);\n  }\n\n  if (typeof input === 'number') {\n    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n  }\n\n  return null;\n}\n\nfunction parseString(s) {\n  var m = PARSE_RE.exec(s);\n\n  if (m) {\n    var sign = m[1] ? -1 : 1;\n    return {\n      years: 0,\n      months: 0,\n      days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0) // ms\n      )\n    };\n  }\n\n  return null;\n}\n\nfunction parseObject(obj) {\n  var duration = {\n    years: obj.years || obj.year || 0,\n    months: obj.months || obj.month || 0,\n    days: obj.days || obj.day || 0,\n    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n    (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n\n  };\n  var weeks = obj.weeks || obj.week;\n\n  if (weeks) {\n    duration.days += weeks * 7;\n    duration.specifiedWeeks = true;\n  }\n\n  return duration;\n} // Equality\n\n\nfunction durationsEqual(d0, d1) {\n  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\n\nfunction asCleanDays(dur) {\n  if (!dur.years && !dur.months && !dur.milliseconds) {\n    return dur.days;\n  }\n\n  return 0;\n} // Simple Math\n\n\nfunction addDurations(d0, d1) {\n  return {\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    days: d0.days + d1.days,\n    milliseconds: d0.milliseconds + d1.milliseconds\n  };\n}\n\nfunction subtractDurations(d1, d0) {\n  return {\n    years: d1.years - d0.years,\n    months: d1.months - d0.months,\n    days: d1.days - d0.days,\n    milliseconds: d1.milliseconds - d0.milliseconds\n  };\n}\n\nfunction multiplyDuration(d, n) {\n  return {\n    years: d.years * n,\n    months: d.months * n,\n    days: d.days * n,\n    milliseconds: d.milliseconds * n\n  };\n} // Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\n\n\nfunction asRoughYears(dur) {\n  return asRoughDays(dur) / 365;\n}\n\nfunction asRoughMonths(dur) {\n  return asRoughDays(dur) / 30;\n}\n\nfunction asRoughDays(dur) {\n  return asRoughMs(dur) / 864e5;\n}\n\nfunction asRoughMinutes(dur) {\n  return asRoughMs(dur) / (1000 * 60);\n}\n\nfunction asRoughSeconds(dur) {\n  return asRoughMs(dur) / 1000;\n}\n\nfunction asRoughMs(dur) {\n  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n} // Advanced Math\n\n\nfunction wholeDivideDurations(numerator, denominator) {\n  var res = null;\n\n  for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {\n    var unit = INTERNAL_UNITS[i];\n\n    if (denominator[unit]) {\n      var localRes = numerator[unit] / denominator[unit];\n\n      if (!isInt(localRes) || res !== null && res !== localRes) {\n        return null;\n      }\n\n      res = localRes;\n    } else if (numerator[unit]) {\n      // needs to divide by something but can't!\n      return null;\n    }\n  }\n\n  return res;\n}\n\nfunction greatestDurationDenominator(dur) {\n  var ms = dur.milliseconds;\n\n  if (ms) {\n    if (ms % 1000 !== 0) {\n      return {\n        unit: 'millisecond',\n        value: ms\n      };\n    }\n\n    if (ms % (1000 * 60) !== 0) {\n      return {\n        unit: 'second',\n        value: ms / 1000\n      };\n    }\n\n    if (ms % (1000 * 60 * 60) !== 0) {\n      return {\n        unit: 'minute',\n        value: ms / (1000 * 60)\n      };\n    }\n\n    if (ms) {\n      return {\n        unit: 'hour',\n        value: ms / (1000 * 60 * 60)\n      };\n    }\n  }\n\n  if (dur.days) {\n    if (dur.specifiedWeeks && dur.days % 7 === 0) {\n      return {\n        unit: 'week',\n        value: dur.days / 7\n      };\n    }\n\n    return {\n      unit: 'day',\n      value: dur.days\n    };\n  }\n\n  if (dur.months) {\n    return {\n      unit: 'month',\n      value: dur.months\n    };\n  }\n\n  if (dur.years) {\n    return {\n      unit: 'year',\n      value: dur.years\n    };\n  }\n\n  return {\n    unit: 'millisecond',\n    value: 0\n  };\n} // timeZoneOffset is in minutes\n\n\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n  if (stripZeroTime === void 0) {\n    stripZeroTime = false;\n  }\n\n  var s = marker.toISOString();\n  s = s.replace('.000', '');\n\n  if (stripZeroTime) {\n    s = s.replace('T00:00:00Z', '');\n  }\n\n  if (s.length > 10) {\n    // time part wasn't stripped, can add timezone info\n    if (timeZoneOffset == null) {\n      s = s.replace('Z', '');\n    } else if (timeZoneOffset !== 0) {\n      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n    } // otherwise, its UTC-0 and we want to keep the Z\n\n  }\n\n  return s;\n} // formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\n\n\nfunction formatDayString(marker) {\n  return marker.toISOString().replace(/T.*$/, '');\n} // TODO: use Date::toISOString and use everything after the T?\n\n\nfunction formatIsoTimeString(marker) {\n  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n}\n\nfunction formatTimeZoneOffset(minutes, doIso) {\n  if (doIso === void 0) {\n    doIso = false;\n  }\n\n  var sign = minutes < 0 ? '-' : '+';\n  var abs = Math.abs(minutes);\n  var hours = Math.floor(abs / 60);\n  var mins = Math.round(abs % 60);\n\n  if (doIso) {\n    return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n  }\n\n  return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : '');\n} // TODO: new util arrayify?\n\n\nfunction removeExact(array, exactVal) {\n  var removeCnt = 0;\n  var i = 0;\n\n  while (i < array.length) {\n    if (array[i] === exactVal) {\n      array.splice(i, 1);\n      removeCnt += 1;\n    } else {\n      i += 1;\n    }\n  }\n\n  return removeCnt;\n}\n\nfunction isArraysEqual(a0, a1, equalityFunc) {\n  if (a0 === a1) {\n    return true;\n  }\n\n  var len = a0.length;\n  var i;\n\n  if (len !== a1.length) {\n    // not array? or not same length?\n    return false;\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n  var currentArgs;\n  var currentRes;\n  return function () {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (!currentArgs) {\n      currentRes = workerFunc.apply(this, newArgs);\n    } else if (!isArraysEqual(currentArgs, newArgs)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.apply(this, newArgs);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArgs = newArgs;\n    return currentRes;\n  };\n}\n\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArg;\n  var currentRes;\n  return function (newArg) {\n    if (!currentArg) {\n      currentRes = workerFunc.call(_this, newArg);\n    } else if (!isPropsEqual(currentArg, newArg)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.call(_this, newArg);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArg = newArg;\n    return currentRes;\n  };\n}\n\nfunction memoizeArraylike( // used at all?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgSets = [];\n  var currentResults = [];\n  return function (newArgSets) {\n    var currentLen = currentArgSets.length;\n    var newLen = newArgSets.length;\n    var i = 0;\n\n    for (; i < currentLen; i += 1) {\n      if (!newArgSets[i]) {\n        // one of the old sets no longer exists\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n\n        var res = workerFunc.apply(_this, newArgSets[i]);\n\n        if (!resEquality || !resEquality(res, currentResults[i])) {\n          currentResults[i] = res;\n        }\n      }\n    }\n\n    for (; i < newLen; i += 1) {\n      currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n    }\n\n    currentArgSets = newArgSets;\n    currentResults.splice(newLen); // remove excess\n\n    return currentResults;\n  };\n}\n\nfunction memoizeHashlike( // used?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgHash = {};\n  var currentResHash = {};\n  return function (newArgHash) {\n    var newResHash = {};\n\n    for (var key in newArgHash) {\n      if (!currentResHash[key]) {\n        newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n        if (teardownFunc) {\n          teardownFunc(currentResHash[key]);\n        }\n\n        var res = workerFunc.apply(_this, newArgHash[key]);\n        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n      } else {\n        newResHash[key] = currentResHash[key];\n      }\n    }\n\n    currentArgHash = newArgHash;\n    currentResHash = newResHash;\n    return newResHash;\n  };\n}\n\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n  week: 3,\n  separator: 0,\n  omitZeroMinute: 0,\n  meridiem: 0,\n  omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n  timeZoneName: 7,\n  era: 6,\n  year: 5,\n  month: 4,\n  day: 2,\n  weekday: 2,\n  hour: 1,\n  minute: 1,\n  second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n\nvar COMMA_RE = /,/g; // we need re for globalness\n\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\n\nvar UTC_RE = /UTC|GMT/;\n\nvar NativeFormatter = function () {\n  function NativeFormatter(formatSettings) {\n    var standardDateProps = {};\n    var extendedSettings = {};\n    var severity = 0;\n\n    for (var name_1 in formatSettings) {\n      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n        extendedSettings[name_1] = formatSettings[name_1];\n        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n      } else {\n        standardDateProps[name_1] = formatSettings[name_1];\n\n        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n          // TODO: what about hour12? no severity\n          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n        }\n      }\n    }\n\n    this.standardDateProps = standardDateProps;\n    this.extendedSettings = extendedSettings;\n    this.severity = severity;\n    this.buildFormattingFunc = memoize(buildFormattingFunc);\n  }\n\n  NativeFormatter.prototype.format = function (date, context) {\n    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n  };\n\n  NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    var _a = this,\n        standardDateProps = _a.standardDateProps,\n        extendedSettings = _a.extendedSettings;\n\n    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n\n    if (!diffSeverity) {\n      return this.format(start, context);\n    }\n\n    var biggestUnitForPartial = diffSeverity;\n\n    if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n    }\n\n    var full0 = this.format(start, context);\n    var full1 = this.format(end, context);\n\n    if (full0 === full1) {\n      return full0;\n    }\n\n    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n    var partial0 = partialFormattingFunc(start);\n    var partial1 = partialFormattingFunc(end);\n    var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n    var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n\n    if (insertion) {\n      return insertion.before + partial0 + separator + partial1 + insertion.after;\n    }\n\n    return full0 + separator + full1;\n  };\n\n  NativeFormatter.prototype.getLargestUnit = function () {\n    switch (this.severity) {\n      case 7:\n      case 6:\n      case 5:\n        return 'year';\n\n      case 4:\n        return 'month';\n\n      case 3:\n        return 'week';\n\n      case 2:\n        return 'day';\n\n      default:\n        return 'time';\n      // really?\n    }\n  };\n\n  return NativeFormatter;\n}();\n\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n  var standardDatePropCnt = Object.keys(standardDateProps).length;\n\n  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n    return function (date) {\n      return formatTimeZoneOffset(date.timeZoneOffset);\n    };\n  }\n\n  if (standardDatePropCnt === 0 && extendedSettings.week) {\n    return function (date) {\n      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n    };\n  }\n\n  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\n\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n  standardDateProps = tslib.__assign({}, standardDateProps); // copy\n\n  extendedSettings = tslib.__assign({}, extendedSettings); // copy\n\n  sanitizeSettings(standardDateProps, extendedSettings);\n  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n\n  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n  var zeroFormat; // needed?\n\n  if (extendedSettings.omitZeroMinute) {\n    var zeroProps = tslib.__assign({}, standardDateProps);\n\n    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n\n    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n  }\n\n  return function (date) {\n    var marker = date.marker;\n    var format;\n\n    if (zeroFormat && !marker.getUTCMinutes()) {\n      format = zeroFormat;\n    } else {\n      format = normalFormat;\n    }\n\n    var s = format.format(marker);\n    return postProcess(s, date, standardDateProps, extendedSettings, context);\n  };\n}\n\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n  // deal with a browser inconsistency where formatting the timezone\n  // requires that the hour/minute be present.\n  if (standardDateProps.timeZoneName) {\n    if (!standardDateProps.hour) {\n      standardDateProps.hour = '2-digit';\n    }\n\n    if (!standardDateProps.minute) {\n      standardDateProps.minute = '2-digit';\n    }\n  } // only support short timezone names\n\n\n  if (standardDateProps.timeZoneName === 'long') {\n    standardDateProps.timeZoneName = 'short';\n  } // if requesting to display seconds, MUST display minutes\n\n\n  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n    delete extendedSettings.omitZeroMinute;\n  }\n}\n\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n\n  if (standardDateProps.timeZoneName === 'short') {\n    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does \"GMT\"\n    formatTimeZoneOffset(date.timeZoneOffset));\n  }\n\n  if (extendedSettings.omitCommas) {\n    s = s.replace(COMMA_RE, '').trim();\n  }\n\n  if (extendedSettings.omitZeroMinute) {\n    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n  } // ^ do anything that might create adjacent spaces before this point,\n  // because MERIDIEM_RE likes to eat up loading spaces\n\n\n  if (extendedSettings.meridiem === false) {\n    s = s.replace(MERIDIEM_RE, '').trim();\n  } else if (extendedSettings.meridiem === 'narrow') {\n    // a/p\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase();\n    });\n  } else if (extendedSettings.meridiem === 'short') {\n    // am/pm\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase() + \"m\";\n    });\n  } else if (extendedSettings.meridiem === 'lowercase') {\n    // other meridiem transformers already converted to lowercase\n    s = s.replace(MERIDIEM_RE, function (m0) {\n      return m0.toLocaleLowerCase();\n    });\n  }\n\n  s = s.replace(MULTI_SPACE_RE, ' ');\n  s = s.trim();\n  return s;\n}\n\nfunction injectTzoStr(s, tzoStr) {\n  var replaced = false;\n  s = s.replace(UTC_RE, function () {\n    replaced = true;\n    return tzoStr;\n  }); // IE11 doesn't include UTC/GMT in the original string, so append to end\n\n  if (!replaced) {\n    s += \" \" + tzoStr;\n  }\n\n  return s;\n}\n\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n  var parts = [];\n\n  if (display === 'long') {\n    parts.push(weekTextLong);\n  } else if (display === 'short' || display === 'narrow') {\n    parts.push(weekText);\n  }\n\n  if (display === 'long' || display === 'short') {\n    parts.push(' ');\n  }\n\n  parts.push(locale.simpleNumberFormat.format(num));\n\n  if (locale.options.direction === 'rtl') {\n    // TODO: use control characters instead?\n    parts.reverse();\n  }\n\n  return parts.join('');\n} // Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\n\n\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n    return 5;\n  }\n\n  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n    return 4;\n  }\n\n  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n    return 2;\n  }\n\n  if (timeAsMs(d0) !== timeAsMs(d1)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction computePartialFormattingOptions(options, biggestUnit) {\n  var partialOptions = {};\n\n  for (var name_2 in options) {\n    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n      partialOptions[name_2] = options[name_2];\n    }\n  }\n\n  return partialOptions;\n}\n\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n  var i0 = 0;\n\n  while (i0 < full0.length) {\n    var found0 = full0.indexOf(partial0, i0);\n\n    if (found0 === -1) {\n      break;\n    }\n\n    var before0 = full0.substr(0, found0);\n    i0 = found0 + partial0.length;\n    var after0 = full0.substr(i0);\n    var i1 = 0;\n\n    while (i1 < full1.length) {\n      var found1 = full1.indexOf(partial1, i1);\n\n      if (found1 === -1) {\n        break;\n      }\n\n      var before1 = full1.substr(0, found1);\n      i1 = found1 + partial1.length;\n      var after1 = full1.substr(i1);\n\n      if (before0 === before1 && after0 === after1) {\n        return {\n          before: before0,\n          after: after0\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n  var a = calendarSystem.markerToArray(dateInfo.marker);\n  return {\n    marker: dateInfo.marker,\n    timeZoneOffset: dateInfo.timeZoneOffset,\n    array: a,\n    year: a[0],\n    month: a[1],\n    day: a[2],\n    hour: a[3],\n    minute: a[4],\n    second: a[5],\n    millisecond: a[6]\n  };\n}\n\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n  var startInfo = expandZonedMarker(start, context.calendarSystem);\n  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n  return {\n    date: startInfo,\n    start: startInfo,\n    end: endInfo,\n    timeZone: context.timeZone,\n    localeCodes: context.locale.codes,\n    defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n  };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\n\n\nvar CmdFormatter = function () {\n  function CmdFormatter(cmdStr) {\n    this.cmdStr = cmdStr;\n  }\n\n  CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return CmdFormatter;\n}();\n\nvar FuncFormatter = function () {\n  function FuncFormatter(func) {\n    this.func = func;\n  }\n\n  FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return FuncFormatter;\n}();\n\nfunction createFormatter(input) {\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return new NativeFormatter(input);\n  }\n\n  if (typeof input === 'string') {\n    return new CmdFormatter(input);\n  }\n\n  if (typeof input === 'function') {\n    return new FuncFormatter(input);\n  }\n\n  return null;\n} // base options\n// ------------\n\n\nvar BASE_OPTION_REFINERS = {\n  navLinkDayClick: identity,\n  navLinkWeekClick: identity,\n  duration: createDuration,\n  bootstrapFontAwesome: identity,\n  buttonIcons: identity,\n  customButtons: identity,\n  defaultAllDayEventDuration: createDuration,\n  defaultTimedEventDuration: createDuration,\n  nextDayThreshold: createDuration,\n  scrollTime: createDuration,\n  scrollTimeReset: Boolean,\n  slotMinTime: createDuration,\n  slotMaxTime: createDuration,\n  dayPopoverFormat: createFormatter,\n  slotDuration: createDuration,\n  snapDuration: createDuration,\n  headerToolbar: identity,\n  footerToolbar: identity,\n  defaultRangeSeparator: String,\n  titleRangeSeparator: String,\n  forceEventDuration: Boolean,\n  dayHeaders: Boolean,\n  dayHeaderFormat: createFormatter,\n  dayHeaderClassNames: identity,\n  dayHeaderContent: identity,\n  dayHeaderDidMount: identity,\n  dayHeaderWillUnmount: identity,\n  dayCellClassNames: identity,\n  dayCellContent: identity,\n  dayCellDidMount: identity,\n  dayCellWillUnmount: identity,\n  initialView: String,\n  aspectRatio: Number,\n  weekends: Boolean,\n  weekNumberCalculation: identity,\n  weekNumbers: Boolean,\n  weekNumberClassNames: identity,\n  weekNumberContent: identity,\n  weekNumberDidMount: identity,\n  weekNumberWillUnmount: identity,\n  editable: Boolean,\n  viewClassNames: identity,\n  viewDidMount: identity,\n  viewWillUnmount: identity,\n  nowIndicator: Boolean,\n  nowIndicatorClassNames: identity,\n  nowIndicatorContent: identity,\n  nowIndicatorDidMount: identity,\n  nowIndicatorWillUnmount: identity,\n  showNonCurrentDates: Boolean,\n  lazyFetching: Boolean,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String,\n  timeZone: String,\n  locales: identity,\n  locale: identity,\n  themeSystem: String,\n  dragRevertDuration: Number,\n  dragScroll: Boolean,\n  allDayMaintainDuration: Boolean,\n  unselectAuto: Boolean,\n  dropAccept: identity,\n  eventOrder: parseFieldSpecs,\n  eventOrderStrict: Boolean,\n  handleWindowResize: Boolean,\n  windowResizeDelay: Number,\n  longPressDelay: Number,\n  eventDragMinDistance: Number,\n  expandRows: Boolean,\n  height: identity,\n  contentHeight: identity,\n  direction: String,\n  weekNumberFormat: createFormatter,\n  eventResizableFromStart: Boolean,\n  displayEventTime: Boolean,\n  displayEventEnd: Boolean,\n  weekText: String,\n  weekTextLong: String,\n  progressiveEventRendering: Boolean,\n  businessHours: identity,\n  initialDate: identity,\n  now: identity,\n  eventDataTransform: identity,\n  stickyHeaderDates: identity,\n  stickyFooterScrollbar: identity,\n  viewHeight: identity,\n  defaultAllDay: Boolean,\n  eventSourceFailure: identity,\n  eventSourceSuccess: identity,\n  eventDisplay: String,\n  eventStartEditable: Boolean,\n  eventDurationEditable: Boolean,\n  eventOverlap: identity,\n  eventConstraint: identity,\n  eventAllow: identity,\n  eventBackgroundColor: String,\n  eventBorderColor: String,\n  eventTextColor: String,\n  eventColor: String,\n  eventClassNames: identity,\n  eventContent: identity,\n  eventDidMount: identity,\n  eventWillUnmount: identity,\n  selectConstraint: identity,\n  selectOverlap: identity,\n  selectAllow: identity,\n  droppable: Boolean,\n  unselectCancel: String,\n  slotLabelFormat: identity,\n  slotLaneClassNames: identity,\n  slotLaneContent: identity,\n  slotLaneDidMount: identity,\n  slotLaneWillUnmount: identity,\n  slotLabelClassNames: identity,\n  slotLabelContent: identity,\n  slotLabelDidMount: identity,\n  slotLabelWillUnmount: identity,\n  dayMaxEvents: identity,\n  dayMaxEventRows: identity,\n  dayMinWidth: Number,\n  slotLabelInterval: createDuration,\n  allDayText: String,\n  allDayClassNames: identity,\n  allDayContent: identity,\n  allDayDidMount: identity,\n  allDayWillUnmount: identity,\n  slotMinWidth: Number,\n  navLinks: Boolean,\n  eventTimeFormat: createFormatter,\n  rerenderDelay: Number,\n  moreLinkText: identity,\n  moreLinkHint: identity,\n  selectMinDistance: Number,\n  selectable: Boolean,\n  selectLongPressDelay: Number,\n  eventLongPressDelay: Number,\n  selectMirror: Boolean,\n  eventMaxStack: Number,\n  eventMinHeight: Number,\n  eventMinWidth: Number,\n  eventShortHeight: Number,\n  slotEventOverlap: Boolean,\n  plugins: identity,\n  firstDay: Number,\n  dayCount: Number,\n  dateAlignment: String,\n  dateIncrement: createDuration,\n  hiddenDays: identity,\n  monthMode: Boolean,\n  fixedWeekCount: Boolean,\n  validRange: identity,\n  visibleRange: identity,\n  titleFormat: identity,\n  eventInteractive: Boolean,\n  // only used by list-view, but languages define the value, so we need it in base options\n  noEventsText: String,\n  viewHint: identity,\n  navLinkHint: identity,\n  closeHint: String,\n  timeHint: String,\n  eventHint: String,\n  moreLinkClick: identity,\n  moreLinkClassNames: identity,\n  moreLinkContent: identity,\n  moreLinkDidMount: identity,\n  moreLinkWillUnmount: identity\n}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\n\nvar BASE_OPTION_DEFAULTS = {\n  eventDisplay: 'auto',\n  defaultRangeSeparator: ' - ',\n  titleRangeSeparator: ' \\u2013 ',\n  defaultTimedEventDuration: '01:00:00',\n  defaultAllDayEventDuration: {\n    day: 1\n  },\n  forceEventDuration: false,\n  nextDayThreshold: '00:00:00',\n  dayHeaders: true,\n  initialView: '',\n  aspectRatio: 1.35,\n  headerToolbar: {\n    start: 'title',\n    center: '',\n    end: 'today prev,next'\n  },\n  weekends: true,\n  weekNumbers: false,\n  weekNumberCalculation: 'local',\n  editable: false,\n  nowIndicator: false,\n  scrollTime: '06:00:00',\n  scrollTimeReset: true,\n  slotMinTime: '00:00:00',\n  slotMaxTime: '24:00:00',\n  showNonCurrentDates: true,\n  lazyFetching: true,\n  startParam: 'start',\n  endParam: 'end',\n  timeZoneParam: 'timeZone',\n  timeZone: 'local',\n  locales: [],\n  locale: '',\n  themeSystem: 'standard',\n  dragRevertDuration: 500,\n  dragScroll: true,\n  allDayMaintainDuration: false,\n  unselectAuto: true,\n  dropAccept: '*',\n  eventOrder: 'start,-duration,allDay,title',\n  dayPopoverFormat: {\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric'\n  },\n  handleWindowResize: true,\n  windowResizeDelay: 100,\n  longPressDelay: 1000,\n  eventDragMinDistance: 5,\n  expandRows: false,\n  navLinks: false,\n  selectable: false,\n  eventMinHeight: 15,\n  eventMinWidth: 30,\n  eventShortHeight: 30\n}; // calendar listeners\n// ------------------\n\nvar CALENDAR_LISTENER_REFINERS = {\n  datesSet: identity,\n  eventsSet: identity,\n  eventAdd: identity,\n  eventChange: identity,\n  eventRemove: identity,\n  windowResize: identity,\n  eventClick: identity,\n  eventMouseEnter: identity,\n  eventMouseLeave: identity,\n  select: identity,\n  unselect: identity,\n  loading: identity,\n  // internal\n  _unmount: identity,\n  _beforeprint: identity,\n  _afterprint: identity,\n  _noEventDrop: identity,\n  _noEventResize: identity,\n  _resize: identity,\n  _scrollRequest: identity\n}; // calendar-specific options\n// -------------------------\n\nvar CALENDAR_OPTION_REFINERS = {\n  buttonText: identity,\n  buttonHints: identity,\n  views: identity,\n  plugins: identity,\n  initialEvents: identity,\n  events: identity,\n  eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n  headerToolbar: isBoolComplexEqual,\n  footerToolbar: isBoolComplexEqual,\n  buttonText: isBoolComplexEqual,\n  buttonHints: isBoolComplexEqual,\n  buttonIcons: isBoolComplexEqual\n};\n\nfunction isBoolComplexEqual(a, b) {\n  if (typeof a === 'object' && typeof b === 'object' && a && b) {\n    // both non-null objects\n    return isPropsEqual(a, b);\n  }\n\n  return a === b;\n} // view-specific options\n// ---------------------\n\n\nvar VIEW_OPTION_REFINERS = {\n  type: String,\n  component: identity,\n  buttonText: String,\n  buttonTextKey: String,\n  dateProfileGeneratorClass: identity,\n  usesMinMaxTime: Boolean,\n  classNames: identity,\n  content: identity,\n  didMount: identity,\n  willUnmount: identity\n}; // util funcs\n// ----------------------------------------------------------------------------------------------------\n\nfunction mergeRawOptions(optionSets) {\n  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\n\nfunction refineProps(input, refiners) {\n  var refined = {};\n  var extra = {};\n\n  for (var propName in refiners) {\n    if (propName in input) {\n      refined[propName] = refiners[propName](input[propName]);\n    }\n  }\n\n  for (var propName in input) {\n    if (!(propName in refiners)) {\n      extra[propName] = input[propName];\n    }\n  }\n\n  return {\n    refined: refined,\n    extra: extra\n  };\n}\n\nfunction identity(raw) {\n  return raw;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n  var eventStore = createEmptyEventStore();\n  var eventRefiners = buildEventRefiners(context);\n\n  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n    var rawEvent = rawEvents_1[_i];\n    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n\n    if (tuple) {\n      eventTupleToStore(tuple, eventStore);\n    }\n  }\n\n  return eventStore;\n}\n\nfunction eventTupleToStore(tuple, eventStore) {\n  if (eventStore === void 0) {\n    eventStore = createEmptyEventStore();\n  }\n\n  eventStore.defs[tuple.def.defId] = tuple.def;\n\n  if (tuple.instance) {\n    eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n  }\n\n  return eventStore;\n} // retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\n\n\nfunction getRelevantEvents(eventStore, instanceId) {\n  var instance = eventStore.instances[instanceId];\n\n  if (instance) {\n    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group\n\n    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n      return isEventDefsGrouped(def_1, lookDef);\n    }); // add the original\n    // TODO: wish we could use eventTupleToStore or something like it\n\n    newStore.defs[def_1.defId] = def_1;\n    newStore.instances[instance.instanceId] = instance;\n    return newStore;\n  }\n\n  return createEmptyEventStore();\n}\n\nfunction isEventDefsGrouped(def0, def1) {\n  return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\n\nfunction createEmptyEventStore() {\n  return {\n    defs: {},\n    instances: {}\n  };\n}\n\nfunction mergeEventStores(store0, store1) {\n  return {\n    defs: tslib.__assign(tslib.__assign({}, store0.defs), store1.defs),\n    instances: tslib.__assign(tslib.__assign({}, store0.instances), store1.instances)\n  };\n}\n\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n  var defs = filterHash(eventStore.defs, filterFunc);\n  var instances = filterHash(eventStore.instances, function (instance) {\n    return defs[instance.defId] // still exists?\n    ;\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeSubEventStore(master, sub) {\n  var defs = master.defs,\n      instances = master.instances;\n  var filteredDefs = {};\n  var filteredInstances = {};\n\n  for (var defId in defs) {\n    if (!sub.defs[defId]) {\n      // not explicitly excluded\n      filteredDefs[defId] = defs[defId];\n    }\n  }\n\n  for (var instanceId in instances) {\n    if (!sub.instances[instanceId] && // not explicitly excluded\n    filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n    ) {\n      filteredInstances[instanceId] = instances[instanceId];\n    }\n  }\n\n  return {\n    defs: filteredDefs,\n    instances: filteredInstances\n  };\n}\n\nfunction normalizeConstraint(input, context) {\n  if (Array.isArray(input)) {\n    return parseEvents(input, null, context, true); // allowOpenRange=true\n  }\n\n  if (typeof input === 'object' && input) {\n    // non-null object\n    return parseEvents([input], null, context, true); // allowOpenRange=true\n  }\n\n  if (input != null) {\n    return String(input);\n  }\n\n  return null;\n}\n\nfunction parseClassNames(raw) {\n  if (Array.isArray(raw)) {\n    return raw;\n  }\n\n  if (typeof raw === 'string') {\n    return raw.split(/\\s+/);\n  }\n\n  return [];\n} // TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n\n\nvar EVENT_UI_REFINERS = {\n  display: String,\n  editable: Boolean,\n  startEditable: Boolean,\n  durationEditable: Boolean,\n  constraint: identity,\n  overlap: identity,\n  allow: identity,\n  className: parseClassNames,\n  classNames: parseClassNames,\n  color: String,\n  backgroundColor: String,\n  borderColor: String,\n  textColor: String\n};\nvar EMPTY_EVENT_UI = {\n  display: null,\n  startEditable: null,\n  durationEditable: null,\n  constraints: [],\n  overlap: null,\n  allows: [],\n  backgroundColor: '',\n  borderColor: '',\n  textColor: '',\n  classNames: []\n};\n\nfunction createEventUi(refined, context) {\n  var constraint = normalizeConstraint(refined.constraint, context);\n  return {\n    display: refined.display || null,\n    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n    constraints: constraint != null ? [constraint] : [],\n    overlap: refined.overlap != null ? refined.overlap : null,\n    allows: refined.allow != null ? [refined.allow] : [],\n    backgroundColor: refined.backgroundColor || refined.color || '',\n    borderColor: refined.borderColor || refined.color || '',\n    textColor: refined.textColor || '',\n    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural\n\n  };\n} // TODO: prevent against problems with <2 args!\n\n\nfunction combineEventUis(uis) {\n  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\n\nfunction combineTwoEventUis(item0, item1) {\n  return {\n    display: item1.display != null ? item1.display : item0.display,\n    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n    constraints: item0.constraints.concat(item1.constraints),\n    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n    allows: item0.allows.concat(item1.allows),\n    backgroundColor: item1.backgroundColor || item0.backgroundColor,\n    borderColor: item1.borderColor || item0.borderColor,\n    textColor: item1.textColor || item0.textColor,\n    classNames: item0.classNames.concat(item1.classNames)\n  };\n}\n\nvar EVENT_NON_DATE_REFINERS = {\n  id: String,\n  groupId: String,\n  title: String,\n  url: String,\n  interactive: Boolean\n};\nvar EVENT_DATE_REFINERS = {\n  start: identity,\n  end: identity,\n  date: identity,\n  allDay: Boolean\n};\n\nvar EVENT_REFINERS = tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n  extendedProps: identity\n});\n\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  var _a = refineEventDef(raw, context, refiners),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n\n  if (recurringRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n    def.recurringDef = {\n      typeId: recurringRes.typeId,\n      typeData: recurringRes.typeData,\n      duration: recurringRes.duration\n    };\n    return {\n      def: def,\n      instance: null\n    };\n  }\n\n  var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n\n  if (singleRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n    var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n    return {\n      def: def,\n      instance: instance\n    };\n  }\n\n  return null;\n}\n\nfunction refineEventDef(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  return refineProps(raw, refiners);\n}\n\nfunction buildEventRefiners(context) {\n  return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\n\n\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n  var def = {\n    title: refined.title || '',\n    groupId: refined.groupId || '',\n    publicId: refined.id || '',\n    url: refined.url || '',\n    recurringDef: null,\n    defId: guid(),\n    sourceId: sourceId,\n    allDay: allDay,\n    hasEnd: hasEnd,\n    interactive: refined.interactive,\n    ui: createEventUi(refined, context),\n    extendedProps: tslib.__assign(tslib.__assign({}, refined.extendedProps || {}), extra)\n  };\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n    var memberAdder = _a[_i];\n\n    tslib.__assign(def, memberAdder(refined));\n  } // help out EventApi from having user modify props\n\n\n  Object.freeze(def.ui.classNames);\n  Object.freeze(def.extendedProps);\n  return def;\n}\n\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n  var allDay = refined.allDay;\n  var startMeta;\n  var startMarker = null;\n  var hasEnd = false;\n  var endMeta;\n  var endMarker = null;\n  var startInput = refined.start != null ? refined.start : refined.date;\n  startMeta = context.dateEnv.createMarkerMeta(startInput);\n\n  if (startMeta) {\n    startMarker = startMeta.marker;\n  } else if (!allowOpenRange) {\n    return null;\n  }\n\n  if (refined.end != null) {\n    endMeta = context.dateEnv.createMarkerMeta(refined.end);\n  }\n\n  if (allDay == null) {\n    if (defaultAllDay != null) {\n      allDay = defaultAllDay;\n    } else {\n      // fall back to the date props LAST\n      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n    }\n  }\n\n  if (allDay && startMarker) {\n    startMarker = startOfDay(startMarker);\n  }\n\n  if (endMeta) {\n    endMarker = endMeta.marker;\n\n    if (allDay) {\n      endMarker = startOfDay(endMarker);\n    }\n\n    if (startMarker && endMarker <= startMarker) {\n      endMarker = null;\n    }\n  }\n\n  if (endMarker) {\n    hasEnd = true;\n  } else if (!allowOpenRange) {\n    hasEnd = context.options.forceEventDuration || false;\n    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n  }\n\n  return {\n    allDay: allDay,\n    hasEnd: hasEnd,\n    range: {\n      start: startMarker,\n      end: endMarker\n    },\n    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n    forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n  };\n}\n\nfunction computeIsDefaultAllDay(eventSource, context) {\n  var res = null;\n\n  if (eventSource) {\n    res = eventSource.defaultAllDay;\n  }\n\n  if (res == null) {\n    res = context.options.defaultAllDay;\n  }\n\n  return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\n\n\nfunction computeAlignedDayRange(timedRange) {\n  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n  var start = startOfDay(timedRange.start);\n  var end = addDays(start, dayCnt);\n  return {\n    start: start,\n    end: end\n  };\n} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\n\n\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n  if (nextDayThreshold === void 0) {\n    nextDayThreshold = createDuration(0);\n  }\n\n  var startDay = null;\n  var endDay = null;\n\n  if (timedRange.end) {\n    endDay = startOfDay(timedRange.end);\n    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n    // If the end time is actually inclusively part of the next day and is equal to or\n    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n      endDay = addDays(endDay, 1);\n    }\n  }\n\n  if (timedRange.start) {\n    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n\n    if (endDay && endDay <= startDay) {\n      endDay = addDays(startDay, 1);\n    }\n  }\n\n  return {\n    start: startDay,\n    end: endDay\n  };\n} // spans from one day into another?\n\n\nfunction isMultiDayRange(range) {\n  var visibleRange = computeVisibleDayRange(range);\n  return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\n\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n  if (largeUnit === 'year') {\n    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n  }\n\n  if (largeUnit === 'month') {\n    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n  }\n\n  return diffDayAndTime(date0, date1); // returns a duration\n}\n\nfunction parseRange(input, dateEnv) {\n  var start = null;\n  var end = null;\n\n  if (input.start) {\n    start = dateEnv.createMarker(input.start);\n  }\n\n  if (input.end) {\n    end = dateEnv.createMarker(input.end);\n  }\n\n  if (!start && !end) {\n    return null;\n  }\n\n  if (start && end && end < start) {\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n} // SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\n\n\nfunction invertRanges(ranges, constraintRange) {\n  var invertedRanges = [];\n  var start = constraintRange.start; // the end of the previous range. the start of the new range\n\n  var i;\n  var dateRange; // ranges need to be in order. required for our date-walking algorithm\n\n  ranges.sort(compareRanges);\n\n  for (i = 0; i < ranges.length; i += 1) {\n    dateRange = ranges[i]; // add the span of time before the event (if there is any)\n\n    if (dateRange.start > start) {\n      // compare millisecond time (skip any ambig logic)\n      invertedRanges.push({\n        start: start,\n        end: dateRange.start\n      });\n    }\n\n    if (dateRange.end > start) {\n      start = dateRange.end;\n    }\n  } // add the span of time after the last event (if there is any)\n\n\n  if (start < constraintRange.end) {\n    // compare millisecond time (skip any ambig logic)\n    invertedRanges.push({\n      start: start,\n      end: constraintRange.end\n    });\n  }\n\n  return invertedRanges;\n}\n\nfunction compareRanges(range0, range1) {\n  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\n\nfunction intersectRanges(range0, range1) {\n  var start = range0.start,\n      end = range0.end;\n  var newRange = null;\n\n  if (range1.start !== null) {\n    if (start === null) {\n      start = range1.start;\n    } else {\n      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n    }\n  }\n\n  if (range1.end != null) {\n    if (end === null) {\n      end = range1.end;\n    } else {\n      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n    }\n  }\n\n  if (start === null || end === null || start < end) {\n    newRange = {\n      start: start,\n      end: end\n    };\n  }\n\n  return newRange;\n}\n\nfunction rangesEqual(range0, range1) {\n  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\n\nfunction rangesIntersect(range0, range1) {\n  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\n\nfunction rangeContainsRange(outerRange, innerRange) {\n  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\n\nfunction rangeContainsMarker(range, date) {\n  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n} // If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n\n\nfunction constrainMarkerToRange(date, range) {\n  if (range.start != null && date < range.start) {\n    return range.start;\n  }\n\n  if (range.end != null && date >= range.end) {\n    return new Date(range.end.valueOf() - 1);\n  }\n\n  return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\n\n\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n  var inverseBgByGroupId = {};\n  var inverseBgByDefId = {};\n  var defByGroupId = {};\n  var bgRanges = [];\n  var fgRanges = [];\n  var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    var ui = eventUis[def.defId];\n\n    if (ui.display === 'inverse-background') {\n      if (def.groupId) {\n        inverseBgByGroupId[def.groupId] = [];\n\n        if (!defByGroupId[def.groupId]) {\n          defByGroupId[def.groupId] = def;\n        }\n      } else {\n        inverseBgByDefId[defId] = [];\n      }\n    }\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = eventStore.defs[instance.defId];\n    var ui = eventUis[def.defId];\n    var origRange = instance.range;\n    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n    var slicedRange = intersectRanges(normalRange, framingRange);\n\n    if (slicedRange) {\n      if (ui.display === 'inverse-background') {\n        if (def.groupId) {\n          inverseBgByGroupId[def.groupId].push(slicedRange);\n        } else {\n          inverseBgByDefId[instance.defId].push(slicedRange);\n        }\n      } else if (ui.display !== 'none') {\n        (ui.display === 'background' ? bgRanges : fgRanges).push({\n          def: def,\n          ui: ui,\n          instance: instance,\n          range: slicedRange,\n          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n        });\n      }\n    }\n  }\n\n  for (var groupId in inverseBgByGroupId) {\n    // BY GROUP\n    var ranges = inverseBgByGroupId[groupId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n      var invertedRange = invertedRanges_1[_i];\n      var def = defByGroupId[groupId];\n      var ui = eventUis[def.defId];\n      bgRanges.push({\n        def: def,\n        ui: ui,\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  for (var defId in inverseBgByDefId) {\n    var ranges = inverseBgByDefId[defId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n      var invertedRange = invertedRanges_2[_a];\n      bgRanges.push({\n        def: eventStore.defs[defId],\n        ui: eventUis[defId],\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  return {\n    bg: bgRanges,\n    fg: fgRanges\n  };\n}\n\nfunction hasBgRendering(def) {\n  return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\n\nfunction setElSeg(el, seg) {\n  el.fcSeg = seg;\n}\n\nfunction getElSeg(el) {\n  return el.fcSeg || el.parentNode.fcSeg || // for the harness\n  null;\n} // event ui computation\n\n\nfunction compileEventUis(eventDefs, eventUiBases) {\n  return mapHash(eventDefs, function (eventDef) {\n    return compileEventUi(eventDef, eventUiBases);\n  });\n}\n\nfunction compileEventUi(eventDef, eventUiBases) {\n  var uis = [];\n\n  if (eventUiBases['']) {\n    uis.push(eventUiBases['']);\n  }\n\n  if (eventUiBases[eventDef.defId]) {\n    uis.push(eventUiBases[eventDef.defId]);\n  }\n\n  uis.push(eventDef.ui);\n  return combineEventUis(uis);\n}\n\nfunction sortEventSegs(segs, eventOrderSpecs) {\n  var objs = segs.map(buildSegCompareObj);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n} // returns a object with all primitive props that can be compared\n\n\nfunction buildSegCompareObj(seg) {\n  var eventRange = seg.eventRange;\n  var eventDef = eventRange.def;\n  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n\n  var end = range.end ? range.end.valueOf() : 0; // \"\n\n  return tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef.extendedProps), eventDef), {\n    id: eventDef.publicId,\n    start: start,\n    end: end,\n    duration: end - start,\n    allDay: Number(eventDef.allDay),\n    _seg: seg\n  });\n}\n\nfunction computeSegDraggable(seg, context) {\n  var pluginHooks = context.pluginHooks;\n  var transformers = pluginHooks.isDraggableTransformers;\n  var _a = seg.eventRange,\n      def = _a.def,\n      ui = _a.ui;\n  var val = ui.startEditable;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    val = transformer(val, def, ui, context);\n  }\n\n  return val;\n}\n\nfunction computeSegStartResizable(seg, context) {\n  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\n\nfunction computeSegEndResizable(seg, context) {\n  return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\n\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var displayEventTime = options.displayEventTime,\n      displayEventEnd = options.displayEventEnd;\n  var eventDef = seg.eventRange.def;\n  var eventInstance = seg.eventRange.instance;\n\n  if (displayEventTime == null) {\n    displayEventTime = defaultDisplayEventTime !== false;\n  }\n\n  if (displayEventEnd == null) {\n    displayEventEnd = defaultDisplayEventEnd !== false;\n  }\n\n  var wholeEventStart = eventInstance.range.start;\n  var wholeEventEnd = eventInstance.range.end;\n  var segStart = startOverride || seg.start || seg.eventRange.range.start;\n  var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n  var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n  var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n\n  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n    segStart = isStartDay ? wholeEventStart : segStart;\n    segEnd = isEndDay ? wholeEventEnd : segEnd;\n\n    if (displayEventEnd && eventDef.hasEnd) {\n      return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(segStart, timeFormat, {\n      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same\n\n    });\n  }\n\n  return '';\n}\n\nfunction getSegMeta(seg, todayRange, nowDate) {\n  var segRange = seg.eventRange.range;\n  return {\n    isPast: segRange.end < (nowDate || todayRange.start),\n    isFuture: segRange.start >= (nowDate || todayRange.end),\n    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n  };\n}\n\nfunction getEventClassNames(props) {\n  var classNames = ['fc-event'];\n\n  if (props.isMirror) {\n    classNames.push('fc-event-mirror');\n  }\n\n  if (props.isDraggable) {\n    classNames.push('fc-event-draggable');\n  }\n\n  if (props.isStartResizable || props.isEndResizable) {\n    classNames.push('fc-event-resizable');\n  }\n\n  if (props.isDragging) {\n    classNames.push('fc-event-dragging');\n  }\n\n  if (props.isResizing) {\n    classNames.push('fc-event-resizing');\n  }\n\n  if (props.isSelected) {\n    classNames.push('fc-event-selected');\n  }\n\n  if (props.isStart) {\n    classNames.push('fc-event-start');\n  }\n\n  if (props.isEnd) {\n    classNames.push('fc-event-end');\n  }\n\n  if (props.isPast) {\n    classNames.push('fc-event-past');\n  }\n\n  if (props.isToday) {\n    classNames.push('fc-event-today');\n  }\n\n  if (props.isFuture) {\n    classNames.push('fc-event-future');\n  }\n\n  return classNames;\n}\n\nfunction buildEventRangeKey(eventRange) {\n  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution\n}\n\nfunction getSegAnchorAttrs(seg, context) {\n  var _a = seg.eventRange,\n      def = _a.def,\n      instance = _a.instance;\n  var url = def.url;\n\n  if (url) {\n    return {\n      href: url\n    };\n  }\n\n  var emitter = context.emitter,\n      options = context.options;\n  var eventInteractive = options.eventInteractive;\n\n  if (eventInteractive == null) {\n    eventInteractive = def.interactive;\n\n    if (eventInteractive == null) {\n      eventInteractive = Boolean(emitter.hasHandlers('eventClick'));\n    }\n  } // mock what happens in EventClicking\n\n\n  if (eventInteractive) {\n    // only attach keyboard-related handlers because click handler is already done in EventClicking\n    return createAriaKeyboardAttrs(function (ev) {\n      emitter.trigger('eventClick', {\n        el: ev.target,\n        event: new EventApi(context, def, instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    });\n  }\n\n  return {};\n}\n\nvar STANDARD_PROPS = {\n  start: identity,\n  end: identity,\n  allDay: Boolean\n};\n\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n  var span = parseOpenDateSpan(raw, dateEnv);\n  var range = span.range;\n\n  if (!range.start) {\n    return null;\n  }\n\n  if (!range.end) {\n    if (defaultDuration == null) {\n      return null;\n    }\n\n    range.end = dateEnv.add(range.start, defaultDuration);\n  }\n\n  return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\n\n\nfunction parseOpenDateSpan(raw, dateEnv) {\n  var _a = refineProps(raw, STANDARD_PROPS),\n      standardProps = _a.refined,\n      extra = _a.extra;\n\n  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n  var allDay = standardProps.allDay;\n\n  if (allDay == null) {\n    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n  }\n\n  return tslib.__assign({\n    range: {\n      start: startMeta ? startMeta.marker : null,\n      end: endMeta ? endMeta.marker : null\n    },\n    allDay: allDay\n  }, extra);\n}\n\nfunction isDateSpansEqual(span0, span1) {\n  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n} // the NON-DATE-RELATED props\n\n\nfunction isSpanPropsEqual(span0, span1) {\n  for (var propName in span1) {\n    if (propName !== 'range' && propName !== 'allDay') {\n      if (span0[propName] !== span1[propName]) {\n        return false;\n      }\n    }\n  } // are there any props that span0 has that span1 DOESN'T have?\n  // both have range/allDay, so no need to special-case.\n\n\n  for (var propName in span0) {\n    if (!(propName in span1)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction buildDateSpanApi(span, dateEnv) {\n  return tslib.__assign(tslib.__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n    allDay: span.allDay\n  });\n}\n\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n  return tslib.__assign(tslib.__assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n    timeZone: dateEnv.timeZone\n  });\n}\n\nfunction buildRangeApi(range, dateEnv, omitTime) {\n  return {\n    start: dateEnv.toDate(range.start),\n    end: dateEnv.toDate(range.end),\n    startStr: dateEnv.formatIso(range.start, {\n      omitTime: omitTime\n    }),\n    endStr: dateEnv.formatIso(range.end, {\n      omitTime: omitTime\n    })\n  };\n}\n\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n  var res = refineEventDef({\n    editable: false\n  }, context);\n  var def = parseEventDef(res.refined, res.extra, '', // sourceId\n  dateSpan.allDay, true, // hasEnd\n  context);\n  return {\n    def: def,\n    ui: compileEventUi(def, eventUiBases),\n    instance: createEventInstance(def.defId, dateSpan.range),\n    range: dateSpan.range,\n    isStart: true,\n    isEnd: true\n  };\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n  context.emitter.trigger('select', tslib.__assign(tslib.__assign({}, buildDateSpanApiWithContext(selection, context)), {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  }));\n}\n\nfunction triggerDateUnselect(pev, context) {\n  context.emitter.trigger('unselect', {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  });\n}\n\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    tslib.__assign(props, transform(dateSpan, context));\n  }\n\n  tslib.__assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n\n  return props;\n} // Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\n\n\nfunction getDefaultEventEnd(allDay, marker, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var end = marker;\n\n  if (allDay) {\n    end = startOfDay(end);\n    end = dateEnv.add(end, options.defaultAllDayEventDuration);\n  } else {\n    end = dateEnv.add(end, options.defaultTimedEventDuration);\n  }\n\n  return end;\n} // applies the mutation to ALL defs/instances within the event store\n\n\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n  var dest = createEmptyEventStore();\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = dest.defs[instance.defId]; // important to grab the newly modified def\n\n    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n  }\n\n  return dest;\n}\n\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.\n  // if duration will change, there's no way the default duration will persist,\n  // and thus, we need to mark the event as having a real end\n\n  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n    standardProps.hasEnd = true; // TODO: is this mutation okay?\n  }\n\n  var copy = tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef), standardProps), {\n    ui: tslib.__assign(tslib.__assign({}, eventDef.ui), standardProps.ui)\n  });\n\n  if (mutation.extendedProps) {\n    copy.extendedProps = tslib.__assign(tslib.__assign({}, copy.extendedProps), mutation.extendedProps);\n  }\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n    var applier = _a[_i];\n    applier(copy, mutation, context);\n  }\n\n  if (!copy.hasEnd && context.options.forceEventDuration) {\n    copy.hasEnd = true;\n  }\n\n  return copy;\n}\n\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n  var dateEnv = context.dateEnv;\n  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n\n  var copy = tslib.__assign({}, eventInstance);\n\n  if (forceAllDay) {\n    copy.range = computeAlignedDayRange(copy.range);\n  }\n\n  if (mutation.datesDelta && eventConfig.startEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.datesDelta),\n      end: dateEnv.add(copy.range.end, mutation.datesDelta)\n    };\n  }\n\n  if (mutation.startDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.startDelta),\n      end: copy.range.end\n    };\n  }\n\n  if (mutation.endDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: copy.range.start,\n      end: dateEnv.add(copy.range.end, mutation.endDelta)\n    };\n  }\n\n  if (clearEnd) {\n    copy.range = {\n      start: copy.range.start,\n      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n    };\n  } // in case event was all-day but the supplied deltas were not\n  // better util for this?\n\n\n  if (eventDef.allDay) {\n    copy.range = {\n      start: startOfDay(copy.range.start),\n      end: startOfDay(copy.range.end)\n    };\n  } // handle invalid durations\n\n\n  if (copy.range.end < copy.range.start) {\n    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n  }\n\n  return copy;\n} // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar ViewApi = function () {\n  function ViewApi(type, getCurrentData, dateEnv) {\n    this.type = type;\n    this.getCurrentData = getCurrentData;\n    this.dateEnv = dateEnv;\n  }\n\n  Object.defineProperty(ViewApi.prototype, \"calendar\", {\n    get: function () {\n      return this.getCurrentData().calendarApi;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"title\", {\n    get: function () {\n      return this.getCurrentData().viewTitle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n    get: function () {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ViewApi.prototype.getOption = function (name) {\n    return this.getCurrentData().options[name]; // are the view-specific options\n  };\n\n  return ViewApi;\n}();\n\nvar EVENT_SOURCE_REFINERS = {\n  id: String,\n  defaultAllDay: Boolean,\n  url: String,\n  format: String,\n  events: identity,\n  eventDataTransform: identity,\n  // for any network-related sources\n  success: identity,\n  failure: identity\n};\n\nfunction parseEventSource(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventSourceRefiners(context);\n  }\n\n  var rawObj;\n\n  if (typeof raw === 'string') {\n    rawObj = {\n      url: raw\n    };\n  } else if (typeof raw === 'function' || Array.isArray(raw)) {\n    rawObj = {\n      events: raw\n    };\n  } else if (typeof raw === 'object' && raw) {\n    // not null\n    rawObj = raw;\n  }\n\n  if (rawObj) {\n    var _a = refineProps(rawObj, refiners),\n        refined = _a.refined,\n        extra = _a.extra;\n\n    var metaRes = buildEventSourceMeta(refined, context);\n\n    if (metaRes) {\n      return {\n        _raw: raw,\n        isFetching: false,\n        latestFetchId: '',\n        fetchRange: null,\n        defaultAllDay: refined.defaultAllDay,\n        eventDataTransform: refined.eventDataTransform,\n        success: refined.success,\n        failure: refined.failure,\n        publicId: refined.id || '',\n        sourceId: guid(),\n        sourceDefId: metaRes.sourceDefId,\n        meta: metaRes.meta,\n        ui: createEventUi(refined, context),\n        extendedProps: extra\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction buildEventSourceRefiners(context) {\n  return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\n\nfunction buildEventSourceMeta(raw, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n\n  for (var i = defs.length - 1; i >= 0; i -= 1) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(raw);\n\n    if (meta) {\n      return {\n        sourceDefId: i,\n        meta: meta\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n  switch (action.type) {\n    case 'CHANGE_DATE':\n      return action.dateMarker;\n\n    default:\n      return currentDate;\n  }\n}\n\nfunction getInitialDate(options, dateEnv) {\n  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date\n\n  if (initialDateInput != null) {\n    return dateEnv.createMarker(initialDateInput);\n  }\n\n  return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\n\nfunction getNow(nowInput, dateEnv) {\n  if (typeof nowInput === 'function') {\n    nowInput = nowInput();\n  }\n\n  if (nowInput == null) {\n    return dateEnv.createNowMarker();\n  }\n\n  return dateEnv.createMarker(nowInput);\n}\n\nvar CalendarApi = function () {\n  function CalendarApi() {}\n\n  CalendarApi.prototype.getCurrentData = function () {\n    return this.currentDataManager.getCurrentData();\n  };\n\n  CalendarApi.prototype.dispatch = function (action) {\n    return this.currentDataManager.dispatch(action);\n  };\n\n  Object.defineProperty(CalendarApi.prototype, \"view\", {\n    get: function () {\n      return this.getCurrentData().viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  CalendarApi.prototype.batchRendering = function (callback) {\n    callback();\n  };\n\n  CalendarApi.prototype.updateSize = function () {\n    this.trigger('_resize', true);\n  }; // Options\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.setOption = function (name, val) {\n    this.dispatch({\n      type: 'SET_OPTION',\n      optionName: name,\n      rawOptionValue: val\n    });\n  };\n\n  CalendarApi.prototype.getOption = function (name) {\n    return this.currentDataManager.currentCalendarOptionsInput[name];\n  };\n\n  CalendarApi.prototype.getAvailableLocaleCodes = function () {\n    return Object.keys(this.getCurrentData().availableRawLocales);\n  }; // Trigger\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.on = function (handlerName, handler) {\n    var currentDataManager = this.currentDataManager;\n\n    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n      currentDataManager.emitter.on(handlerName, handler);\n    } else {\n      console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n    }\n  };\n\n  CalendarApi.prototype.off = function (handlerName, handler) {\n    this.currentDataManager.emitter.off(handlerName, handler);\n  }; // not meant for public use\n\n\n  CalendarApi.prototype.trigger = function (handlerName) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.currentDataManager.emitter).trigger.apply(_a, tslib.__spreadArray([handlerName], args));\n  }; // View\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n    var _this = this;\n\n    this.batchRendering(function () {\n      _this.unselect();\n\n      if (dateOrRange) {\n        if (dateOrRange.start && dateOrRange.end) {\n          // a range\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType\n          });\n\n          _this.dispatch({\n            type: 'SET_OPTION',\n            optionName: 'visibleRange',\n            rawOptionValue: dateOrRange\n          });\n        } else {\n          var dateEnv = _this.getCurrentData().dateEnv;\n\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType,\n            dateMarker: dateEnv.createMarker(dateOrRange)\n          });\n        }\n      } else {\n        _this.dispatch({\n          type: 'CHANGE_VIEW_TYPE',\n          viewType: viewType\n        });\n      }\n    });\n  }; // Forces navigation to a view for the given date.\n  // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n  // needs to change\n\n\n  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n    var state = this.getCurrentData();\n    var spec;\n    viewType = viewType || 'day'; // day is default zoom\n\n    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n    this.unselect();\n\n    if (spec) {\n      this.dispatch({\n        type: 'CHANGE_VIEW_TYPE',\n        viewType: spec.type,\n        dateMarker: dateMarker\n      });\n    } else {\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: dateMarker\n      });\n    }\n  }; // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n  // Preference is given to views that have corresponding buttons.\n\n\n  CalendarApi.prototype.getUnitViewSpec = function (unit) {\n    var _a = this.getCurrentData(),\n        viewSpecs = _a.viewSpecs,\n        toolbarConfig = _a.toolbarConfig;\n\n    var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n    var i;\n    var spec;\n\n    for (var viewType in viewSpecs) {\n      viewTypes.push(viewType);\n    }\n\n    for (i = 0; i < viewTypes.length; i += 1) {\n      spec = viewSpecs[viewTypes[i]];\n\n      if (spec) {\n        if (spec.singleUnit === unit) {\n          return spec;\n        }\n      }\n    }\n\n    return null;\n  }; // Current Date\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.prev = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'PREV'\n    });\n  };\n\n  CalendarApi.prototype.next = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'NEXT'\n    });\n  };\n\n  CalendarApi.prototype.prevYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n    });\n  };\n\n  CalendarApi.prototype.nextYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n    });\n  };\n\n  CalendarApi.prototype.today = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n    });\n  };\n\n  CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.createMarker(zonedDateInput)\n    });\n  };\n\n  CalendarApi.prototype.incrementDate = function (deltaInput) {\n    var state = this.getCurrentData();\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // else, warn about invalid input?\n      this.unselect();\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: state.dateEnv.add(state.currentDate, delta)\n      });\n    }\n  }; // for external API\n\n\n  CalendarApi.prototype.getDate = function () {\n    var state = this.getCurrentData();\n    return state.dateEnv.toDate(state.currentDate);\n  }; // Date Formatting Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.formatDate = function (d, formatter) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n  }; // `settings` is for formatter AND isEndExclusive\n\n\n  CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n  };\n\n  CalendarApi.prototype.formatIso = function (d, omitTime) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatIso(dateEnv.createMarker(d), {\n      omitTime: omitTime\n    });\n  }; // Date Selection / Event Selection / DayClick\n  // -----------------------------------------------------------------------------------------------------------------\n  // this public method receives start/end dates in any format, with any timezone\n  // NOTE: args were changed from v3\n\n\n  CalendarApi.prototype.select = function (dateOrObj, endDate) {\n    var selectionInput;\n\n    if (endDate == null) {\n      if (dateOrObj.start != null) {\n        selectionInput = dateOrObj;\n      } else {\n        selectionInput = {\n          start: dateOrObj,\n          end: null\n        };\n      }\n    } else {\n      selectionInput = {\n        start: dateOrObj,\n        end: endDate\n      };\n    }\n\n    var state = this.getCurrentData();\n    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n      days: 1\n    }));\n\n    if (selection) {\n      // throw parse error otherwise?\n      this.dispatch({\n        type: 'SELECT_DATES',\n        selection: selection\n      });\n      triggerDateSelect(selection, null, state);\n    }\n  }; // public method\n\n\n  CalendarApi.prototype.unselect = function (pev) {\n    var state = this.getCurrentData();\n\n    if (state.dateSelection) {\n      this.dispatch({\n        type: 'UNSELECT_DATES'\n      });\n      triggerDateUnselect(pev, state);\n    }\n  }; // Public Events API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n    if (eventInput instanceof EventApi) {\n      var def = eventInput._def;\n      var instance = eventInput._instance;\n      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot\n\n      if (!currentData.eventStore.defs[def.defId]) {\n        this.dispatch({\n          type: 'ADD_EVENTS',\n          eventStore: eventTupleToStore({\n            def: def,\n            instance: instance\n          }) // TODO: better util for two args?\n\n        });\n        this.triggerEventAdd(eventInput);\n      }\n\n      return eventInput;\n    }\n\n    var state = this.getCurrentData();\n    var eventSource;\n\n    if (sourceInput instanceof EventSourceApi) {\n      eventSource = sourceInput.internalEventSource;\n    } else if (typeof sourceInput === 'boolean') {\n      if (sourceInput) {\n        // true. part of the first event source\n        eventSource = hashValuesToArray(state.eventSources)[0];\n      }\n    } else if (sourceInput != null) {\n      // an ID. accepts a number too\n      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n\n      if (!sourceApi) {\n        console.warn(\"Could not find an event source with ID \\\"\" + sourceInput + \"\\\"\"); // TODO: test\n\n        return null;\n      }\n\n      eventSource = sourceApi.internalEventSource;\n    }\n\n    var tuple = parseEvent(eventInput, eventSource, state, false);\n\n    if (tuple) {\n      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n      this.dispatch({\n        type: 'ADD_EVENTS',\n        eventStore: eventTupleToStore(tuple)\n      });\n      this.triggerEventAdd(newEventApi);\n      return newEventApi;\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n    var _this = this;\n\n    var emitter = this.getCurrentData().emitter;\n    emitter.trigger('eventAdd', {\n      event: eventApi,\n      relatedEvents: [],\n      revert: function () {\n        _this.dispatch({\n          type: 'REMOVE_EVENTS',\n          eventStore: eventApiToStore(eventApi)\n        });\n      }\n    });\n  }; // TODO: optimize\n\n\n  CalendarApi.prototype.getEventById = function (id) {\n    var state = this.getCurrentData();\n    var _a = state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    id = String(id);\n\n    for (var defId in defs) {\n      var def = defs[defId];\n\n      if (def.publicId === id) {\n        if (def.recurringDef) {\n          return new EventApi(state, def, null);\n        }\n\n        for (var instanceId in instances) {\n          var instance = instances[instanceId];\n\n          if (instance.defId === def.defId) {\n            return new EventApi(state, def, instance);\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.getEvents = function () {\n    var currentData = this.getCurrentData();\n    return buildEventApis(currentData.eventStore, currentData);\n  };\n\n  CalendarApi.prototype.removeAllEvents = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENTS'\n    });\n  }; // Public Event Sources API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.getEventSources = function () {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    var sourceApis = [];\n\n    for (var internalId in sourceHash) {\n      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n    }\n\n    return sourceApis;\n  };\n\n  CalendarApi.prototype.getEventSourceById = function (id) {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    id = String(id);\n\n    for (var sourceId in sourceHash) {\n      if (sourceHash[sourceId].publicId === id) {\n        return new EventSourceApi(state, sourceHash[sourceId]);\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.addEventSource = function (sourceInput) {\n    var state = this.getCurrentData();\n\n    if (sourceInput instanceof EventSourceApi) {\n      // not already present? don't want to add an old snapshot\n      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n        this.dispatch({\n          type: 'ADD_EVENT_SOURCES',\n          sources: [sourceInput.internalEventSource]\n        });\n      }\n\n      return sourceInput;\n    }\n\n    var eventSource = parseEventSource(sourceInput, state);\n\n    if (eventSource) {\n      // TODO: error otherwise?\n      this.dispatch({\n        type: 'ADD_EVENT_SOURCES',\n        sources: [eventSource]\n      });\n      return new EventSourceApi(state, eventSource);\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.removeAllEventSources = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENT_SOURCES'\n    });\n  };\n\n  CalendarApi.prototype.refetchEvents = function () {\n    this.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      isRefetch: true\n    });\n  }; // Scroll\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.scrollToTime = function (timeInput) {\n    var time = createDuration(timeInput);\n\n    if (time) {\n      this.trigger('_scrollRequest', {\n        time: time\n      });\n    }\n  };\n\n  return CalendarApi;\n}();\n\nvar EventApi = function () {\n  // instance will be null if expressing a recurring event that has no current instances,\n  // OR if trying to validate an incoming external event that has no dates assigned\n  function EventApi(context, def, instance) {\n    this._context = context;\n    this._def = def;\n    this._instance = instance || null;\n  }\n  /*\n  TODO: make event struct more responsible for this\n  */\n\n\n  EventApi.prototype.setProp = function (name, val) {\n    var _a, _b;\n\n    if (name in EVENT_DATE_REFINERS) {\n      console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?\n    } else if (name === 'id') {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: {\n          publicId: val\n        } // hardcoded internal name\n\n      });\n    } else if (name in EVENT_NON_DATE_REFINERS) {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: (_a = {}, _a[name] = val, _a)\n      });\n    } else if (name in EVENT_UI_REFINERS) {\n      var ui = EVENT_UI_REFINERS[name](val);\n\n      if (name === 'color') {\n        ui = {\n          backgroundColor: val,\n          borderColor: val\n        };\n      } else if (name === 'editable') {\n        ui = {\n          startEditable: val,\n          durationEditable: val\n        };\n      } else {\n        ui = (_b = {}, _b[name] = val, _b);\n      }\n\n      this.mutate({\n        standardProps: {\n          ui: ui\n        }\n      });\n    } else {\n      console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n    }\n  };\n\n  EventApi.prototype.setExtendedProp = function (name, val) {\n    var _a;\n\n    this.mutate({\n      extendedProps: (_a = {}, _a[name] = val, _a)\n    });\n  };\n\n  EventApi.prototype.setStart = function (startInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var start = dateEnv.createMarker(startInput);\n\n    if (start && this._instance) {\n      // TODO: warning if parsed bad\n      var instanceRange = this._instance.range;\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n\n      if (options.maintainDuration) {\n        this.mutate({\n          datesDelta: startDelta\n        });\n      } else {\n        this.mutate({\n          startDelta: startDelta\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setEnd = function (endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var end;\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        return; // TODO: warning if parsed bad\n      }\n    }\n\n    if (this._instance) {\n      if (end) {\n        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n        this.mutate({\n          endDelta: endDelta\n        });\n      } else {\n        this.mutate({\n          standardProps: {\n            hasEnd: false\n          }\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setDates = function (startInput, endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var standardProps = {\n      allDay: options.allDay\n    };\n    var start = dateEnv.createMarker(startInput);\n    var end;\n\n    if (!start) {\n      return; // TODO: warning if parsed bad\n    }\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        // TODO: warning if parsed bad\n        return;\n      }\n    }\n\n    if (this._instance) {\n      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,\n      // compute diff off of the all-day values the way event-mutation does.\n\n      if (options.allDay === true) {\n        instanceRange = computeAlignedDayRange(instanceRange);\n      }\n\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n\n      if (end) {\n        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n\n        if (durationsEqual(startDelta, endDelta)) {\n          this.mutate({\n            datesDelta: startDelta,\n            standardProps: standardProps\n          });\n        } else {\n          this.mutate({\n            startDelta: startDelta,\n            endDelta: endDelta,\n            standardProps: standardProps\n          });\n        }\n      } else {\n        // means \"clear the end\"\n        standardProps.hasEnd = false;\n        this.mutate({\n          datesDelta: startDelta,\n          standardProps: standardProps\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.moveStart = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        startDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveEnd = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        endDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveDates = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        datesDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.setAllDay = function (allDay, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var standardProps = {\n      allDay: allDay\n    };\n    var maintainDuration = options.maintainDuration;\n\n    if (maintainDuration == null) {\n      maintainDuration = this._context.options.allDayMaintainDuration;\n    }\n\n    if (this._def.allDay !== allDay) {\n      standardProps.hasEnd = maintainDuration;\n    }\n\n    this.mutate({\n      standardProps: standardProps\n    });\n  };\n\n  EventApi.prototype.formatRange = function (formatInput) {\n    var dateEnv = this._context.dateEnv;\n    var instance = this._instance;\n    var formatter = createFormatter(formatInput);\n\n    if (this._def.hasEnd) {\n      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n        forcedStartTzo: instance.forcedStartTzo,\n        forcedEndTzo: instance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(instance.range.start, formatter, {\n      forcedTzo: instance.forcedStartTzo\n    });\n  };\n\n  EventApi.prototype.mutate = function (mutation) {\n    var instance = this._instance;\n\n    if (instance) {\n      var def = this._def;\n      var context_1 = this._context;\n      var eventStore_1 = context_1.getCurrentData().eventStore;\n      var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n      var eventConfigBase = {\n        '': {\n          display: '',\n          startEditable: true,\n          durationEditable: true,\n          constraints: [],\n          overlap: null,\n          allows: [],\n          backgroundColor: '',\n          borderColor: '',\n          textColor: '',\n          classNames: []\n        }\n      };\n      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n      var oldEvent = new EventApi(context_1, def, instance); // snapshot\n\n      this._def = relevantEvents.defs[def.defId];\n      this._instance = relevantEvents.instances[instance.instanceId];\n      context_1.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: relevantEvents\n      });\n      context_1.emitter.trigger('eventChange', {\n        oldEvent: oldEvent,\n        event: this,\n        relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n        revert: function () {\n          context_1.dispatch({\n            type: 'RESET_EVENTS',\n            eventStore: eventStore_1\n          });\n        }\n      });\n    }\n  };\n\n  EventApi.prototype.remove = function () {\n    var context = this._context;\n    var asStore = eventApiToStore(this);\n    context.dispatch({\n      type: 'REMOVE_EVENTS',\n      eventStore: asStore\n    });\n    context.emitter.trigger('eventRemove', {\n      event: this,\n      relatedEvents: [],\n      revert: function () {\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: asStore\n        });\n      }\n    });\n  };\n\n  Object.defineProperty(EventApi.prototype, \"source\", {\n    get: function () {\n      var sourceId = this._def.sourceId;\n\n      if (sourceId) {\n        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"start\", {\n    get: function () {\n      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"end\", {\n    get: function () {\n      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startStr\", {\n    get: function () {\n      var instance = this._instance;\n\n      if (instance) {\n        return this._context.dateEnv.formatIso(instance.range.start, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedStartTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"endStr\", {\n    get: function () {\n      var instance = this._instance;\n\n      if (instance && this._def.hasEnd) {\n        return this._context.dateEnv.formatIso(instance.range.end, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedEndTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"id\", {\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get: function () {\n      return this._def.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"groupId\", {\n    get: function () {\n      return this._def.groupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allDay\", {\n    get: function () {\n      return this._def.allDay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"title\", {\n    get: function () {\n      return this._def.title;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"url\", {\n    get: function () {\n      return this._def.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"display\", {\n    get: function () {\n      return this._def.ui.display || 'auto';\n    } // bad. just normalize the type earlier\n    ,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startEditable\", {\n    get: function () {\n      return this._def.ui.startEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n    get: function () {\n      return this._def.ui.durationEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"constraint\", {\n    get: function () {\n      return this._def.ui.constraints[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"overlap\", {\n    get: function () {\n      return this._def.ui.overlap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allow\", {\n    get: function () {\n      return this._def.ui.allows[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n    get: function () {\n      return this._def.ui.backgroundColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"borderColor\", {\n    get: function () {\n      return this._def.ui.borderColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"textColor\", {\n    get: function () {\n      return this._def.ui.textColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"classNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function () {\n      return this._def.ui.classNames;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n    get: function () {\n      return this._def.extendedProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EventApi.prototype.toPlainObject = function (settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var def = this._def;\n    var ui = def.ui;\n\n    var _a = this,\n        startStr = _a.startStr,\n        endStr = _a.endStr;\n\n    var res = {};\n\n    if (def.title) {\n      res.title = def.title;\n    }\n\n    if (startStr) {\n      res.start = startStr;\n    }\n\n    if (endStr) {\n      res.end = endStr;\n    }\n\n    if (def.publicId) {\n      res.id = def.publicId;\n    }\n\n    if (def.groupId) {\n      res.groupId = def.groupId;\n    }\n\n    if (def.url) {\n      res.url = def.url;\n    }\n\n    if (ui.display && ui.display !== 'auto') {\n      res.display = ui.display;\n    } // TODO: what about recurring-event properties???\n    // TODO: include startEditable/durationEditable/constraint/overlap/allow\n\n\n    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n      res.color = ui.backgroundColor;\n    } else {\n      if (ui.backgroundColor) {\n        res.backgroundColor = ui.backgroundColor;\n      }\n\n      if (ui.borderColor) {\n        res.borderColor = ui.borderColor;\n      }\n    }\n\n    if (ui.textColor) {\n      res.textColor = ui.textColor;\n    }\n\n    if (ui.classNames.length) {\n      res.classNames = ui.classNames;\n    }\n\n    if (Object.keys(def.extendedProps).length) {\n      if (settings.collapseExtendedProps) {\n        tslib.__assign(res, def.extendedProps);\n      } else {\n        res.extendedProps = def.extendedProps;\n      }\n    }\n\n    return res;\n  };\n\n  EventApi.prototype.toJSON = function () {\n    return this.toPlainObject();\n  };\n\n  return EventApi;\n}();\n\nfunction eventApiToStore(eventApi) {\n  var _a, _b;\n\n  var def = eventApi._def;\n  var instance = eventApi._instance;\n  return {\n    defs: (_a = {}, _a[def.defId] = def, _a),\n    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n  };\n}\n\nfunction buildEventApis(eventStore, context, excludeInstance) {\n  var defs = eventStore.defs,\n      instances = eventStore.instances;\n  var eventApis = [];\n  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n\n  for (var id in instances) {\n    var instance = instances[id];\n    var def = defs[instance.defId];\n\n    if (instance.instanceId !== excludeInstanceId) {\n      eventApis.push(new EventApi(context, def, instance));\n    }\n  }\n\n  return eventApis;\n}\n\nvar calendarSystemClassMap = {};\n\nfunction registerCalendarSystem(name, theClass) {\n  calendarSystemClassMap[name] = theClass;\n}\n\nfunction createCalendarSystem(name) {\n  return new calendarSystemClassMap[name]();\n}\n\nvar GregorianCalendarSystem = function () {\n  function GregorianCalendarSystem() {}\n\n  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n    return d.getUTCFullYear();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n    return d.getUTCMonth();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n    return d.getUTCDate();\n  };\n\n  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n    return arrayToUtcDate(arr);\n  };\n\n  GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n    return dateToUtcArray(marker);\n  };\n\n  return GregorianCalendarSystem;\n}();\n\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n\nfunction parse(str) {\n  var m = ISO_RE.exec(str);\n\n  if (m) {\n    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n\n    if (isValidDate(marker)) {\n      var timeZoneOffset = null;\n\n      if (m[13]) {\n        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n      }\n\n      return {\n        marker: marker,\n        isTimeUnspecified: !m[6],\n        timeZoneOffset: timeZoneOffset\n      };\n    }\n  }\n\n  return null;\n}\n\nvar DateEnv = function () {\n  function DateEnv(settings) {\n    var timeZone = this.timeZone = settings.timeZone;\n    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n\n    if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n    }\n\n    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n    this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n    this.locale = settings.locale;\n    this.weekDow = settings.locale.week.dow;\n    this.weekDoy = settings.locale.week.doy;\n\n    if (settings.weekNumberCalculation === 'ISO') {\n      this.weekDow = 1;\n      this.weekDoy = 4;\n    }\n\n    if (typeof settings.firstDay === 'number') {\n      this.weekDow = settings.firstDay;\n    }\n\n    if (typeof settings.weekNumberCalculation === 'function') {\n      this.weekNumberFunc = settings.weekNumberCalculation;\n    }\n\n    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n    this.cmdFormatter = settings.cmdFormatter;\n    this.defaultSeparator = settings.defaultSeparator;\n  } // Creating / Parsing\n\n\n  DateEnv.prototype.createMarker = function (input) {\n    var meta = this.createMarkerMeta(input);\n\n    if (meta === null) {\n      return null;\n    }\n\n    return meta.marker;\n  };\n\n  DateEnv.prototype.createNowMarker = function () {\n    if (this.canComputeOffset) {\n      return this.timestampToMarker(new Date().valueOf());\n    } // if we can't compute the current date val for a timezone,\n    // better to give the current local date vals than UTC\n\n\n    return arrayToUtcDate(dateToLocalArray(new Date()));\n  };\n\n  DateEnv.prototype.createMarkerMeta = function (input) {\n    if (typeof input === 'string') {\n      return this.parse(input);\n    }\n\n    var marker = null;\n\n    if (typeof input === 'number') {\n      marker = this.timestampToMarker(input);\n    } else if (input instanceof Date) {\n      input = input.valueOf();\n\n      if (!isNaN(input)) {\n        marker = this.timestampToMarker(input);\n      }\n    } else if (Array.isArray(input)) {\n      marker = arrayToUtcDate(input);\n    }\n\n    if (marker === null || !isValidDate(marker)) {\n      return null;\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: false,\n      forcedTzo: null\n    };\n  };\n\n  DateEnv.prototype.parse = function (s) {\n    var parts = parse(s);\n\n    if (parts === null) {\n      return null;\n    }\n\n    var marker = parts.marker;\n    var forcedTzo = null;\n\n    if (parts.timeZoneOffset !== null) {\n      if (this.canComputeOffset) {\n        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n      } else {\n        forcedTzo = parts.timeZoneOffset;\n      }\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: parts.isTimeUnspecified,\n      forcedTzo: forcedTzo\n    };\n  }; // Accessors\n\n\n  DateEnv.prototype.getYear = function (marker) {\n    return this.calendarSystem.getMarkerYear(marker);\n  };\n\n  DateEnv.prototype.getMonth = function (marker) {\n    return this.calendarSystem.getMarkerMonth(marker);\n  }; // Adding / Subtracting\n\n\n  DateEnv.prototype.add = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += dur.years;\n    a[1] += dur.months;\n    a[2] += dur.days;\n    a[6] += dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.subtract = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] -= dur.years;\n    a[1] -= dur.months;\n    a[2] -= dur.days;\n    a[6] -= dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addYears = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addMonths = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[1] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  }; // Diffing Whole Units\n\n\n  DateEnv.prototype.diffWholeYears = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n    }\n\n    return null;\n  }; // Range / Duration\n\n\n  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n    var n = this.diffWholeYears(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'year',\n        value: n\n      };\n    }\n\n    n = this.diffWholeMonths(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'month',\n        value: n\n      };\n    }\n\n    n = diffWholeWeeks(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'week',\n        value: n\n      };\n    }\n\n    n = diffWholeDays(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'day',\n        value: n\n      };\n    }\n\n    n = diffHours(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'hour',\n        value: n\n      };\n    }\n\n    n = diffMinutes(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'minute',\n        value: n\n      };\n    }\n\n    n = diffSeconds(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'second',\n        value: n\n      };\n    }\n\n    return {\n      unit: 'millisecond',\n      value: m1.valueOf() - m0.valueOf()\n    };\n  };\n\n  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n    // TODO: can use greatestWholeUnit\n    var diff;\n\n    if (d.years) {\n      diff = this.diffWholeYears(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughYears(d);\n      }\n    }\n\n    if (d.months) {\n      diff = this.diffWholeMonths(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughMonths(d);\n      }\n    }\n\n    if (d.days) {\n      diff = diffWholeDays(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughDays(d);\n      }\n    }\n\n    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n  }; // Start-Of\n  // these DON'T return zoned-dates. only UTC start-of dates\n\n\n  DateEnv.prototype.startOf = function (m, unit) {\n    if (unit === 'year') {\n      return this.startOfYear(m);\n    }\n\n    if (unit === 'month') {\n      return this.startOfMonth(m);\n    }\n\n    if (unit === 'week') {\n      return this.startOfWeek(m);\n    }\n\n    if (unit === 'day') {\n      return startOfDay(m);\n    }\n\n    if (unit === 'hour') {\n      return startOfHour(m);\n    }\n\n    if (unit === 'minute') {\n      return startOfMinute(m);\n    }\n\n    if (unit === 'second') {\n      return startOfSecond(m);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.startOfYear = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);\n  };\n\n  DateEnv.prototype.startOfMonth = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);\n  };\n\n  DateEnv.prototype.startOfWeek = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);\n  }; // Week Number\n\n\n  DateEnv.prototype.computeWeekNumber = function (marker) {\n    if (this.weekNumberFunc) {\n      return this.weekNumberFunc(this.toDate(marker));\n    }\n\n    return weekOfYear(marker, this.weekDow, this.weekDoy);\n  }; // TODO: choke on timeZoneName: long\n\n\n  DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    return formatter.format({\n      marker: marker,\n      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n    }, this);\n  };\n\n  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    if (dateOptions.isEndExclusive) {\n      end = addMs(end, -1);\n    }\n\n    return formatter.formatRange({\n      marker: start,\n      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n    }, {\n      marker: end,\n      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n    }, this, dateOptions.defaultSeparator);\n  };\n  /*\n  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n  might as well use buildIsoString or some other util directly\n  */\n\n\n  DateEnv.prototype.formatIso = function (marker, extraOptions) {\n    if (extraOptions === void 0) {\n      extraOptions = {};\n    }\n\n    var timeZoneOffset = null;\n\n    if (!extraOptions.omitTimeZoneOffset) {\n      if (extraOptions.forcedTzo != null) {\n        timeZoneOffset = extraOptions.forcedTzo;\n      } else {\n        timeZoneOffset = this.offsetForMarker(marker);\n      }\n    }\n\n    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n  }; // TimeZone\n\n\n  DateEnv.prototype.timestampToMarker = function (ms) {\n    if (this.timeZone === 'local') {\n      return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n    }\n\n    if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n      return new Date(ms);\n    }\n\n    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n  };\n\n  DateEnv.prototype.offsetForMarker = function (m) {\n    if (this.timeZone === 'local') {\n      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n    }\n\n    if (this.timeZone === 'UTC') {\n      return 0;\n    }\n\n    if (this.namedTimeZoneImpl) {\n      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n    }\n\n    return null;\n  }; // Conversion\n\n\n  DateEnv.prototype.toDate = function (m, forcedTzo) {\n    if (this.timeZone === 'local') {\n      return arrayToLocalDate(dateToUtcArray(m));\n    }\n\n    if (this.timeZone === 'UTC') {\n      return new Date(m.valueOf()); // make sure it's a copy\n    }\n\n    if (!this.namedTimeZoneImpl) {\n      return new Date(m.valueOf() - (forcedTzo || 0));\n    }\n\n    return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n  };\n\n  return DateEnv;\n}();\n\nvar globalLocales = [];\nvar MINIMAL_RAW_EN_LOCALE = {\n  code: 'en',\n  week: {\n    dow: 0,\n    doy: 4 // 4 days need to be within the year to be considered the first week\n\n  },\n  direction: 'ltr',\n  buttonText: {\n    prev: 'prev',\n    next: 'next',\n    prevYear: 'prev year',\n    nextYear: 'next year',\n    year: 'year',\n    today: 'today',\n    month: 'month',\n    week: 'week',\n    day: 'day',\n    list: 'list'\n  },\n  weekText: 'W',\n  weekTextLong: 'Week',\n  closeHint: 'Close',\n  timeHint: 'Time',\n  eventHint: 'Event',\n  allDayText: 'all-day',\n  moreLinkText: 'more',\n  noEventsText: 'No events to display'\n};\n\nvar RAW_EN_LOCALE = tslib.__assign(tslib.__assign({}, MINIMAL_RAW_EN_LOCALE), {\n  // Includes things we don't want other locales to inherit,\n  // things that derive from other translatable strings.\n  buttonHints: {\n    prev: 'Previous $0',\n    next: 'Next $0',\n    today: function (buttonText, unit) {\n      return unit === 'day' ? 'Today' : \"This \" + buttonText;\n    }\n  },\n  viewHint: '$0 view',\n  navLinkHint: 'Go to $0',\n  moreLinkHint: function (eventCnt) {\n    return \"Show \" + eventCnt + \" more event\" + (eventCnt === 1 ? '' : 's');\n  }\n});\n\nfunction organizeRawLocales(explicitRawLocales) {\n  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n  var allRawLocales = globalLocales.concat(explicitRawLocales);\n  var rawLocaleMap = {\n    en: RAW_EN_LOCALE\n  };\n\n  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n    var rawLocale = allRawLocales_1[_i];\n    rawLocaleMap[rawLocale.code] = rawLocale;\n  }\n\n  return {\n    map: rawLocaleMap,\n    defaultCode: defaultCode\n  };\n}\n\nfunction buildLocale(inputSingular, available) {\n  if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n  }\n\n  return queryLocale(inputSingular, available);\n}\n\nfunction queryLocale(codeArg, available) {\n  var codes = [].concat(codeArg || []); // will convert to array\n\n  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n  return parseLocale(codeArg, codes, raw);\n}\n\nfunction queryRawLocale(codes, available) {\n  for (var i = 0; i < codes.length; i += 1) {\n    var parts = codes[i].toLocaleLowerCase().split('-');\n\n    for (var j = parts.length; j > 0; j -= 1) {\n      var simpleId = parts.slice(0, j).join('-');\n\n      if (available[simpleId]) {\n        return available[simpleId];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseLocale(codeArg, codes, raw) {\n  var merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);\n  delete merged.code; // don't want this part of the options\n\n  var week = merged.week;\n  delete merged.week;\n  return {\n    codeArg: codeArg,\n    codes: codes,\n    week: week,\n    simpleNumberFormat: new Intl.NumberFormat(codeArg),\n    options: merged\n  };\n}\n\nfunction formatDate(dateInput, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dateEnv = buildDateEnv$1(options);\n  var formatter = createFormatter(options);\n  var dateMeta = dateEnv.createMarkerMeta(dateInput);\n\n  if (!dateMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.format(dateMeta.marker, formatter, {\n    forcedTzo: dateMeta.forcedTzo\n  });\n}\n\nfunction formatRange(startInput, endInput, options) {\n  var dateEnv = buildDateEnv$1(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n\n  var formatter = createFormatter(options);\n  var startMeta = dateEnv.createMarkerMeta(startInput);\n  var endMeta = dateEnv.createMarkerMeta(endInput);\n\n  if (!startMeta || !endMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n    forcedStartTzo: startMeta.forcedTzo,\n    forcedEndTzo: endMeta.forcedTzo,\n    isEndExclusive: options.isEndExclusive,\n    defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n  });\n} // TODO: more DRY and optimized\n\n\nfunction buildDateEnv$1(settings) {\n  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n\n  return new DateEnv(tslib.__assign(tslib.__assign({\n    timeZone: BASE_OPTION_DEFAULTS.timeZone,\n    calendarSystem: 'gregory'\n  }, settings), {\n    locale: locale\n  }));\n}\n\nvar DEF_DEFAULTS = {\n  startTime: '09:00',\n  endTime: '17:00',\n  daysOfWeek: [1, 2, 3, 4, 5],\n  display: 'inverse-background',\n  classNames: 'fc-non-business',\n  groupId: '_businessHours' // so multiple defs get grouped\n\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\n\nfunction parseBusinessHours(input, context) {\n  return parseEvents(refineInputs(input), null, context);\n}\n\nfunction refineInputs(input) {\n  var rawDefs;\n\n  if (input === true) {\n    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n  } else if (Array.isArray(input)) {\n    // if specifying an array, every sub-definition NEEDS a day-of-week\n    rawDefs = input.filter(function (rawDef) {\n      return rawDef.daysOfWeek;\n    });\n  } else if (typeof input === 'object' && input) {\n    // non-null object\n    rawDefs = [input];\n  } else {\n    // is probably false\n    rawDefs = [];\n  }\n\n  rawDefs = rawDefs.map(function (rawDef) {\n    return tslib.__assign(tslib.__assign({}, DEF_DEFAULTS), rawDef);\n  });\n  return rawDefs;\n}\n\nfunction pointInsideRect(point, rect) {\n  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n\nfunction intersectRects(rect1, rect2) {\n  var res = {\n    left: Math.max(rect1.left, rect2.left),\n    right: Math.min(rect1.right, rect2.right),\n    top: Math.max(rect1.top, rect2.top),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n\n  if (res.left < res.right && res.top < res.bottom) {\n    return res;\n  }\n\n  return false;\n}\n\nfunction translateRect(rect, deltaX, deltaY) {\n  return {\n    left: rect.left + deltaX,\n    right: rect.right + deltaX,\n    top: rect.top + deltaY,\n    bottom: rect.bottom + deltaY\n  };\n} // Returns a new point that will have been moved to reside within the given rectangle\n\n\nfunction constrainPoint(point, rect) {\n  return {\n    left: Math.min(Math.max(point.left, rect.left), rect.right),\n    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n  };\n} // Returns a point that is the center of the given rectangle\n\n\nfunction getRectCenter(rect) {\n  return {\n    left: (rect.left + rect.right) / 2,\n    top: (rect.top + rect.bottom) / 2\n  };\n} // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\nfunction diffPoints(point1, point2) {\n  return {\n    left: point1.left - point2.left,\n    top: point1.top - point2.top\n  };\n}\n\nvar canVGrowWithinCell;\n\nfunction getCanVGrowWithinCell() {\n  if (canVGrowWithinCell == null) {\n    canVGrowWithinCell = computeCanVGrowWithinCell();\n  }\n\n  return canVGrowWithinCell;\n}\n\nfunction computeCanVGrowWithinCell() {\n  // for SSR, because this function is call immediately at top-level\n  // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.left = '0px';\n  el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n  el.querySelector('table').style.height = '100px';\n  el.querySelector('div').style.height = '100%';\n  document.body.appendChild(el);\n  var div = el.querySelector('div');\n  var possible = div.offsetHeight > 0;\n  document.body.removeChild(el);\n  return possible;\n}\n\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n\nvar Splitter = function () {\n  function Splitter() {\n    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n    this.splitDateSelection = memoize(this._splitDateSpan);\n    this.splitEventStore = memoize(this._splitEventStore);\n    this.splitIndividualUi = memoize(this._splitIndividualUi);\n    this.splitEventDrag = memoize(this._splitInteraction);\n    this.splitEventResize = memoize(this._splitInteraction);\n    this.eventUiBuilders = {}; // TODO: typescript protection\n  }\n\n  Splitter.prototype.splitProps = function (props) {\n    var _this = this;\n\n    var keyInfos = this.getKeyInfo(props);\n    var defKeys = this.getKeysForEventDefs(props.eventStore);\n    var dateSelections = this.splitDateSelection(props.dateSelection);\n    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n\n    var eventStores = this.splitEventStore(props.eventStore, defKeys);\n    var eventDrags = this.splitEventDrag(props.eventDrag);\n    var eventResizes = this.splitEventResize(props.eventResize);\n    var splitProps = {};\n    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n    });\n\n    for (var key in keyInfos) {\n      var keyInfo = keyInfos[key];\n      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n      var buildEventUi = this.eventUiBuilders[key];\n      splitProps[key] = {\n        businessHours: keyInfo.businessHours || props.businessHours,\n        dateSelection: dateSelections[key] || null,\n        eventStore: eventStore,\n        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n        eventDrag: eventDrags[key] || null,\n        eventResize: eventResizes[key] || null\n      };\n    }\n\n    return splitProps;\n  };\n\n  Splitter.prototype._splitDateSpan = function (dateSpan) {\n    var dateSpans = {};\n\n    if (dateSpan) {\n      var keys = this.getKeysForDateSpan(dateSpan);\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        dateSpans[key] = dateSpan;\n      }\n    }\n\n    return dateSpans;\n  };\n\n  Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n    var _this = this;\n\n    return mapHash(eventStore.defs, function (eventDef) {\n      return _this.getKeysForEventDef(eventDef);\n    });\n  };\n\n  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n    var defs = eventStore.defs,\n        instances = eventStore.instances;\n    var splitStores = {};\n\n    for (var defId in defs) {\n      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!splitStores[key]) {\n          splitStores[key] = createEmptyEventStore();\n        }\n\n        splitStores[key].defs[defId] = defs[defId];\n      }\n    }\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n\n      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n        var key = _c[_b];\n\n        if (splitStores[key]) {\n          // must have already been created\n          splitStores[key].instances[instanceId] = instance;\n        }\n      }\n    }\n\n    return splitStores;\n  };\n\n  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n    var splitHashes = {};\n\n    for (var defId in eventUiBases) {\n      if (defId) {\n        // not the '' key\n        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n          var key = _a[_i];\n\n          if (!splitHashes[key]) {\n            splitHashes[key] = {};\n          }\n\n          splitHashes[key][defId] = eventUiBases[defId];\n        }\n      }\n    }\n\n    return splitHashes;\n  };\n\n  Splitter.prototype._splitInteraction = function (interaction) {\n    var splitStates = {};\n\n    if (interaction) {\n      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents)); // can't rely on defKeys because event data is mutated\n\n\n      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n\n      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n\n      var populate = function (key) {\n        if (!splitStates[key]) {\n          splitStates[key] = {\n            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n            isEvent: interaction.isEvent\n          };\n        }\n      };\n\n      for (var key in affectedStores_1) {\n        populate(key);\n      }\n\n      for (var key in mutatedStores_1) {\n        populate(key);\n      }\n    }\n\n    return splitStates;\n  };\n\n  return Splitter;\n}();\n\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n  var baseParts = [];\n\n  if (allUi) {\n    baseParts.push(allUi);\n  }\n\n  if (eventUiForKey) {\n    baseParts.push(eventUiForKey);\n  }\n\n  var stuff = {\n    '': combineEventUis(baseParts)\n  };\n\n  if (individualUi) {\n    tslib.__assign(stuff, individualUi);\n  }\n\n  return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n  return {\n    dow: date.getUTCDay(),\n    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n  };\n}\n\nfunction getDayClassNames(meta, theme) {\n  var classNames = ['fc-day', \"fc-day-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-day-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-day-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-day-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-day-future');\n    }\n\n    if (meta.isOther) {\n      classNames.push('fc-day-other');\n    }\n  }\n\n  return classNames;\n}\n\nfunction getSlotClassNames(meta, theme) {\n  var classNames = ['fc-slot', \"fc-slot-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-slot-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-slot-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-slot-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-slot-future');\n    }\n  }\n\n  return classNames;\n}\n\nvar DAY_FORMAT = createFormatter({\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric'\n});\nvar WEEK_FORMAT = createFormatter({\n  week: 'long'\n});\n\nfunction buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {\n  if (viewType === void 0) {\n    viewType = 'day';\n  }\n\n  if (isTabbable === void 0) {\n    isTabbable = true;\n  }\n\n  var dateEnv = context.dateEnv,\n      options = context.options,\n      calendarApi = context.calendarApi;\n  var dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);\n\n  if (options.navLinks) {\n    var zonedDate = dateEnv.toDate(dateMarker);\n\n    var handleInteraction = function (ev) {\n      var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n\n      if (typeof customAction === 'function') {\n        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n      } else {\n        if (typeof customAction === 'string') {\n          viewType = customAction;\n        }\n\n        calendarApi.zoomTo(dateMarker, viewType);\n      }\n    };\n\n    return tslib.__assign({\n      title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr),\n      'data-navlink': ''\n    }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n      onClick: handleInteraction\n    });\n  }\n\n  return {\n    'aria-label': dateStr\n  };\n}\n\nvar _isRtlScrollbarOnLeft = null;\n\nfunction getIsRtlScrollbarOnLeft() {\n  if (_isRtlScrollbarOnLeft === null) {\n    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n  }\n\n  return _isRtlScrollbarOnLeft;\n}\n\nfunction computeIsRtlScrollbarOnLeft() {\n  var outerEl = document.createElement('div');\n  applyStyle(outerEl, {\n    position: 'absolute',\n    top: -1000,\n    left: 0,\n    border: 0,\n    padding: 0,\n    overflow: 'scroll',\n    direction: 'rtl'\n  });\n  outerEl.innerHTML = '<div></div>';\n  document.body.appendChild(outerEl);\n  var innerEl = outerEl.firstChild;\n  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n  removeElement(outerEl);\n  return res;\n}\n\nvar _scrollbarWidths;\n\nfunction getScrollbarWidths() {\n  if (!_scrollbarWidths) {\n    _scrollbarWidths = computeScrollbarWidths();\n  }\n\n  return _scrollbarWidths;\n}\n\nfunction computeScrollbarWidths() {\n  var el = document.createElement('div');\n  el.style.overflow = 'scroll';\n  el.style.position = 'absolute';\n  el.style.top = '-9999px';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  var res = computeScrollbarWidthsForEl(el);\n  document.body.removeChild(el);\n  return res;\n} // WARNING: will include border\n\n\nfunction computeScrollbarWidthsForEl(el) {\n  return {\n    x: el.offsetHeight - el.clientHeight,\n    y: el.offsetWidth - el.clientWidth\n  };\n}\n\nfunction computeEdges(el, getPadding) {\n  if (getPadding === void 0) {\n    getPadding = false;\n  }\n\n  var computedStyle = window.getComputedStyle(el);\n  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n\n  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n  var res = {\n    borderLeft: borderLeft,\n    borderRight: borderRight,\n    borderTop: borderTop,\n    borderBottom: borderBottom,\n    scrollbarBottom: scrollbarBottom,\n    scrollbarLeft: 0,\n    scrollbarRight: 0\n  };\n\n  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n    // is the scrollbar on the left side?\n    res.scrollbarLeft = scrollbarLeftRight;\n  } else {\n    res.scrollbarRight = scrollbarLeftRight;\n  }\n\n  if (getPadding) {\n    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n  }\n\n  return res;\n}\n\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n  if (goWithinPadding === void 0) {\n    goWithinPadding = false;\n  }\n\n  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n  var edges = computeEdges(el, goWithinPadding);\n  var res = {\n    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n    right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n    top: outerRect.top + edges.borderTop,\n    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n  };\n\n  if (goWithinPadding) {\n    res.left += edges.paddingLeft;\n    res.right -= edges.paddingRight;\n    res.top += edges.paddingTop;\n    res.bottom -= edges.paddingBottom;\n  }\n\n  return res;\n}\n\nfunction computeRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    right: rect.right + window.pageXOffset,\n    bottom: rect.bottom + window.pageYOffset\n  };\n}\n\nfunction computeClippedClientRect(el) {\n  var clippingParents = getClippingParents(el);\n  var rect = el.getBoundingClientRect();\n\n  for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {\n    var clippingParent = clippingParents_1[_i];\n    var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n\n    if (intersection) {\n      rect = intersection;\n    } else {\n      return null;\n    }\n  }\n\n  return rect;\n}\n\nfunction computeHeightAndMargins(el) {\n  return el.getBoundingClientRect().height + computeVMargins(el);\n}\n\nfunction computeVMargins(el) {\n  var computed = window.getComputedStyle(el);\n  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n} // does not return window\n\n\nfunction getClippingParents(el) {\n  var parents = [];\n\n  while (el instanceof HTMLElement) {\n    // will stop when gets to document or null\n    var computedStyle = window.getComputedStyle(el);\n\n    if (computedStyle.position === 'fixed') {\n      break;\n    }\n\n    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n      parents.push(el);\n    }\n\n    el = el.parentNode;\n  }\n\n  return parents;\n} // given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\n\n\nfunction unpromisify(func, success, failure) {\n  // guard against success/failure callbacks being called more than once\n  // and guard against a promise AND callback being used together.\n  var isResolved = false;\n\n  var wrappedSuccess = function () {\n    if (!isResolved) {\n      isResolved = true;\n      success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n    }\n  };\n\n  var wrappedFailure = function () {\n    if (!isResolved) {\n      isResolved = true;\n\n      if (failure) {\n        failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n      }\n    }\n  };\n\n  var res = func(wrappedSuccess, wrappedFailure);\n\n  if (res && typeof res.then === 'function') {\n    res.then(wrappedSuccess, wrappedFailure);\n  }\n}\n\nvar Emitter = function () {\n  function Emitter() {\n    this.handlers = {};\n    this.thisContext = null;\n  }\n\n  Emitter.prototype.setThisContext = function (thisContext) {\n    this.thisContext = thisContext;\n  };\n\n  Emitter.prototype.setOptions = function (options) {\n    this.options = options;\n  };\n\n  Emitter.prototype.on = function (type, handler) {\n    addToHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.off = function (type, handler) {\n    removeFromHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var attachedHandlers = this.handlers[type] || [];\n    var optionHandler = this.options && this.options[type];\n    var handlers = [].concat(optionHandler || [], attachedHandlers);\n\n    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n      var handler = handlers_1[_a];\n      handler.apply(this.thisContext, args);\n    }\n  };\n\n  Emitter.prototype.hasHandlers = function (type) {\n    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n  };\n\n  return Emitter;\n}();\n\nfunction addToHash(hash, type, handler) {\n  (hash[type] || (hash[type] = [])).push(handler);\n}\n\nfunction removeFromHash(hash, type, handler) {\n  if (handler) {\n    if (hash[type]) {\n      hash[type] = hash[type].filter(function (func) {\n        return func !== handler;\n      });\n    }\n  } else {\n    delete hash[type]; // remove all handler funcs for this type\n  }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\n\n\nvar PositionCache = function () {\n  function PositionCache(originEl, els, isHorizontal, isVertical) {\n    this.els = els;\n    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n\n    if (isHorizontal) {\n      this.buildElHorizontals(originClientRect.left);\n    }\n\n    if (isVertical) {\n      this.buildElVerticals(originClientRect.top);\n    }\n  } // Populates the left/right internal coordinate arrays\n\n\n  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n    var lefts = [];\n    var rights = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      lefts.push(rect.left - originClientLeft);\n      rights.push(rect.right - originClientLeft);\n    }\n\n    this.lefts = lefts;\n    this.rights = rights;\n  }; // Populates the top/bottom internal coordinate arrays\n\n\n  PositionCache.prototype.buildElVerticals = function (originClientTop) {\n    var tops = [];\n    var bottoms = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      tops.push(rect.top - originClientTop);\n      bottoms.push(rect.bottom - originClientTop);\n    }\n\n    this.tops = tops;\n    this.bottoms = bottoms;\n  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.leftToIndex = function (leftPosition) {\n    var _a = this,\n        lefts = _a.lefts,\n        rights = _a.rights;\n\n    var len = lefts.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.topToIndex = function (topPosition) {\n    var _a = this,\n        tops = _a.tops,\n        bottoms = _a.bottoms;\n\n    var len = tops.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Gets the width of the element at the given index\n\n\n  PositionCache.prototype.getWidth = function (leftIndex) {\n    return this.rights[leftIndex] - this.lefts[leftIndex];\n  }; // Gets the height of the element at the given index\n\n\n  PositionCache.prototype.getHeight = function (topIndex) {\n    return this.bottoms[topIndex] - this.tops[topIndex];\n  };\n\n  return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */\n\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\n\n\nvar ScrollController = function () {\n  function ScrollController() {}\n\n  ScrollController.prototype.getMaxScrollTop = function () {\n    return this.getScrollHeight() - this.getClientHeight();\n  };\n\n  ScrollController.prototype.getMaxScrollLeft = function () {\n    return this.getScrollWidth() - this.getClientWidth();\n  };\n\n  ScrollController.prototype.canScrollVertically = function () {\n    return this.getMaxScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollHorizontally = function () {\n    return this.getMaxScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollUp = function () {\n    return this.getScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollDown = function () {\n    return this.getScrollTop() < this.getMaxScrollTop();\n  };\n\n  ScrollController.prototype.canScrollLeft = function () {\n    return this.getScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollRight = function () {\n    return this.getScrollLeft() < this.getMaxScrollLeft();\n  };\n\n  return ScrollController;\n}();\n\nvar ElementScrollController = function (_super) {\n  tslib.__extends(ElementScrollController, _super);\n\n  function ElementScrollController(el) {\n    var _this = _super.call(this) || this;\n\n    _this.el = el;\n    return _this;\n  }\n\n  ElementScrollController.prototype.getScrollTop = function () {\n    return this.el.scrollTop;\n  };\n\n  ElementScrollController.prototype.getScrollLeft = function () {\n    return this.el.scrollLeft;\n  };\n\n  ElementScrollController.prototype.setScrollTop = function (top) {\n    this.el.scrollTop = top;\n  };\n\n  ElementScrollController.prototype.setScrollLeft = function (left) {\n    this.el.scrollLeft = left;\n  };\n\n  ElementScrollController.prototype.getScrollWidth = function () {\n    return this.el.scrollWidth;\n  };\n\n  ElementScrollController.prototype.getScrollHeight = function () {\n    return this.el.scrollHeight;\n  };\n\n  ElementScrollController.prototype.getClientHeight = function () {\n    return this.el.clientHeight;\n  };\n\n  ElementScrollController.prototype.getClientWidth = function () {\n    return this.el.clientWidth;\n  };\n\n  return ElementScrollController;\n}(ScrollController);\n\nvar WindowScrollController = function (_super) {\n  tslib.__extends(WindowScrollController, _super);\n\n  function WindowScrollController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WindowScrollController.prototype.getScrollTop = function () {\n    return window.pageYOffset;\n  };\n\n  WindowScrollController.prototype.getScrollLeft = function () {\n    return window.pageXOffset;\n  };\n\n  WindowScrollController.prototype.setScrollTop = function (n) {\n    window.scroll(window.pageXOffset, n);\n  };\n\n  WindowScrollController.prototype.setScrollLeft = function (n) {\n    window.scroll(n, window.pageYOffset);\n  };\n\n  WindowScrollController.prototype.getScrollWidth = function () {\n    return document.documentElement.scrollWidth;\n  };\n\n  WindowScrollController.prototype.getScrollHeight = function () {\n    return document.documentElement.scrollHeight;\n  };\n\n  WindowScrollController.prototype.getClientHeight = function () {\n    return document.documentElement.clientHeight;\n  };\n\n  WindowScrollController.prototype.getClientWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  return WindowScrollController;\n}(ScrollController);\n\nvar Theme = function () {\n  function Theme(calendarOptions) {\n    if (this.iconOverrideOption) {\n      this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n    }\n  }\n\n  Theme.prototype.setIconOverride = function (iconOverrideHash) {\n    var iconClassesCopy;\n    var buttonName;\n\n    if (typeof iconOverrideHash === 'object' && iconOverrideHash) {\n      // non-null object\n      iconClassesCopy = tslib.__assign({}, this.iconClasses);\n\n      for (buttonName in iconOverrideHash) {\n        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n      }\n\n      this.iconClasses = iconClassesCopy;\n    } else if (iconOverrideHash === false) {\n      this.iconClasses = {};\n    }\n  };\n\n  Theme.prototype.applyIconOverridePrefix = function (className) {\n    var prefix = this.iconOverridePrefix;\n\n    if (prefix && className.indexOf(prefix) !== 0) {\n      // if not already present\n      className = prefix + className;\n    }\n\n    return className;\n  };\n\n  Theme.prototype.getClass = function (key) {\n    return this.classes[key] || '';\n  };\n\n  Theme.prototype.getIconClass = function (buttonName, isRtl) {\n    var className;\n\n    if (isRtl && this.rtlIconClasses) {\n      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n    } else {\n      className = this.iconClasses[buttonName];\n    }\n\n    if (className) {\n      return this.baseIconClass + \" \" + className;\n    }\n\n    return '';\n  };\n\n  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n    var className;\n\n    if (this.iconOverrideCustomButtonOption) {\n      className = customButtonProps[this.iconOverrideCustomButtonOption];\n\n      if (className) {\n        return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n      }\n    }\n\n    return '';\n  };\n\n  return Theme;\n}();\n\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\nvar ScrollResponder = function () {\n  function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n    var _this = this;\n\n    this.execFunc = execFunc;\n    this.emitter = emitter;\n    this.scrollTime = scrollTime;\n    this.scrollTimeReset = scrollTimeReset;\n\n    this.handleScrollRequest = function (request) {\n      _this.queuedRequest = tslib.__assign({}, _this.queuedRequest || {}, request);\n\n      _this.drain();\n    };\n\n    emitter.on('_scrollRequest', this.handleScrollRequest);\n    this.fireInitialScroll();\n  }\n\n  ScrollResponder.prototype.detach = function () {\n    this.emitter.off('_scrollRequest', this.handleScrollRequest);\n  };\n\n  ScrollResponder.prototype.update = function (isDatesNew) {\n    if (isDatesNew && this.scrollTimeReset) {\n      this.fireInitialScroll(); // will drain\n    } else {\n      this.drain();\n    }\n  };\n\n  ScrollResponder.prototype.fireInitialScroll = function () {\n    this.handleScrollRequest({\n      time: this.scrollTime\n    });\n  };\n\n  ScrollResponder.prototype.drain = function () {\n    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n      this.queuedRequest = null;\n    }\n  };\n\n  return ScrollResponder;\n}();\n\nvar ViewContextType = vdom_cjs.createContext({}); // for Components\n\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n  return {\n    dateEnv: dateEnv,\n    options: viewOptions,\n    pluginHooks: pluginHooks,\n    emitter: emitter,\n    dispatch: dispatch,\n    getCurrentData: getCurrentData,\n    calendarApi: calendarApi,\n    viewSpec: viewSpec,\n    viewApi: viewApi,\n    dateProfileGenerator: dateProfileGenerator,\n    theme: theme,\n    isRtl: viewOptions.direction === 'rtl',\n    addResizeHandler: function (handler) {\n      emitter.on('_resize', handler);\n    },\n    removeResizeHandler: function (handler) {\n      emitter.off('_resize', handler);\n    },\n    createScrollResponder: function (execFunc) {\n      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n    },\n    registerInteractiveComponent: registerInteractiveComponent,\n    unregisterInteractiveComponent: unregisterInteractiveComponent\n  };\n}\n/* eslint max-classes-per-file: off */\n\n\nvar PureComponent = function (_super) {\n  tslib.__extends(PureComponent, _super);\n\n  function PureComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    if (this.debug) {\n      // eslint-disable-next-line no-console\n      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n    }\n\n    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n  };\n\n  PureComponent.addPropsEquality = addPropsEquality;\n  PureComponent.addStateEquality = addStateEquality;\n  PureComponent.contextType = ViewContextType;\n  return PureComponent;\n}(vdom_cjs.Component);\n\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\n\nvar BaseComponent = function (_super) {\n  tslib.__extends(BaseComponent, _super);\n\n  function BaseComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BaseComponent.contextType = ViewContextType;\n  return BaseComponent;\n}(PureComponent);\n\nfunction addPropsEquality(propEquality) {\n  var hash = Object.create(this.prototype.propEquality);\n\n  tslib.__assign(hash, propEquality);\n\n  this.prototype.propEquality = hash;\n}\n\nfunction addStateEquality(stateEquality) {\n  var hash = Object.create(this.prototype.stateEquality);\n\n  tslib.__assign(hash, stateEquality);\n\n  this.prototype.stateEquality = hash;\n} // use other one\n\n\nfunction setRef(ref, current) {\n  if (typeof ref === 'function') {\n    ref(current);\n  } else if (ref) {\n    // see https://github.com/facebook/react/issues/13029\n    ref.current = current;\n  }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\n\n\nvar DateComponent = function (_super) {\n  tslib.__extends(DateComponent, _super);\n\n  function DateComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.uid = guid();\n    return _this;\n  } // Hit System\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.prepareHits = function () {};\n\n  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    return null; // this should be abstract\n  }; // Pointer Interaction Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isValidSegDownEl = function (el) {\n    return !this.props.eventDrag && // HACK\n    !this.props.eventResize && // HACK\n    !elementClosest(el, '.fc-event-mirror');\n  };\n\n  DateComponent.prototype.isValidDateDownEl = function (el) {\n    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n    !elementClosest(el, '.fc-popover'); // hack\n  };\n\n  return DateComponent;\n}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things\n\n\nfunction createPlugin(input) {\n  return {\n    id: guid(),\n    deps: input.deps || [],\n    reducers: input.reducers || [],\n    isLoadingFuncs: input.isLoadingFuncs || [],\n    contextInit: [].concat(input.contextInit || []),\n    eventRefiners: input.eventRefiners || {},\n    eventDefMemberAdders: input.eventDefMemberAdders || [],\n    eventSourceRefiners: input.eventSourceRefiners || {},\n    isDraggableTransformers: input.isDraggableTransformers || [],\n    eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n    eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n    dateSelectionTransformers: input.dateSelectionTransformers || [],\n    datePointTransforms: input.datePointTransforms || [],\n    dateSpanTransforms: input.dateSpanTransforms || [],\n    views: input.views || {},\n    viewPropsTransformers: input.viewPropsTransformers || [],\n    isPropsValid: input.isPropsValid || null,\n    externalDefTransforms: input.externalDefTransforms || [],\n    viewContainerAppends: input.viewContainerAppends || [],\n    eventDropTransformers: input.eventDropTransformers || [],\n    componentInteractions: input.componentInteractions || [],\n    calendarInteractions: input.calendarInteractions || [],\n    themeClasses: input.themeClasses || {},\n    eventSourceDefs: input.eventSourceDefs || [],\n    cmdFormatter: input.cmdFormatter,\n    recurringTypes: input.recurringTypes || [],\n    namedTimeZonedImpl: input.namedTimeZonedImpl,\n    initialView: input.initialView || '',\n    elementDraggingImpl: input.elementDraggingImpl,\n    optionChangeHandlers: input.optionChangeHandlers || {},\n    scrollGridImpl: input.scrollGridImpl || null,\n    contentTypeHandlers: input.contentTypeHandlers || {},\n    listenerRefiners: input.listenerRefiners || {},\n    optionRefiners: input.optionRefiners || {},\n    propSetHandlers: input.propSetHandlers || {}\n  };\n}\n\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n  var isAdded = {};\n  var hooks = {\n    reducers: [],\n    isLoadingFuncs: [],\n    contextInit: [],\n    eventRefiners: {},\n    eventDefMemberAdders: [],\n    eventSourceRefiners: {},\n    isDraggableTransformers: [],\n    eventDragMutationMassagers: [],\n    eventDefMutationAppliers: [],\n    dateSelectionTransformers: [],\n    datePointTransforms: [],\n    dateSpanTransforms: [],\n    views: {},\n    viewPropsTransformers: [],\n    isPropsValid: null,\n    externalDefTransforms: [],\n    viewContainerAppends: [],\n    eventDropTransformers: [],\n    componentInteractions: [],\n    calendarInteractions: [],\n    themeClasses: {},\n    eventSourceDefs: [],\n    cmdFormatter: null,\n    recurringTypes: [],\n    namedTimeZonedImpl: null,\n    initialView: '',\n    elementDraggingImpl: null,\n    optionChangeHandlers: {},\n    scrollGridImpl: null,\n    contentTypeHandlers: {},\n    listenerRefiners: {},\n    optionRefiners: {},\n    propSetHandlers: {}\n  };\n\n  function addDefs(defs) {\n    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n      var def = defs_1[_i];\n\n      if (!isAdded[def.id]) {\n        isAdded[def.id] = true;\n        addDefs(def.deps);\n        hooks = combineHooks(hooks, def);\n      }\n    }\n  }\n\n  if (pluginDefs) {\n    addDefs(pluginDefs);\n  }\n\n  addDefs(globalDefs);\n  return hooks;\n}\n\nfunction buildBuildPluginHooks() {\n  var currentOverrideDefs = [];\n  var currentGlobalDefs = [];\n  var currentHooks;\n  return function (overrideDefs, globalDefs) {\n    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n      currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n    }\n\n    currentOverrideDefs = overrideDefs;\n    currentGlobalDefs = globalDefs;\n    return currentHooks;\n  };\n}\n\nfunction combineHooks(hooks0, hooks1) {\n  return {\n    reducers: hooks0.reducers.concat(hooks1.reducers),\n    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n    contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n    eventRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n    eventSourceRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n    views: tslib.__assign(tslib.__assign({}, hooks0.views), hooks1.views),\n    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n    themeClasses: tslib.__assign(tslib.__assign({}, hooks0.themeClasses), hooks1.themeClasses),\n    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n    initialView: hooks0.initialView || hooks1.initialView,\n    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n    optionChangeHandlers: tslib.__assign(tslib.__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n    contentTypeHandlers: tslib.__assign(tslib.__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n    listenerRefiners: tslib.__assign(tslib.__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n    optionRefiners: tslib.__assign(tslib.__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n    propSetHandlers: tslib.__assign(tslib.__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n  };\n}\n\nvar StandardTheme = function (_super) {\n  tslib.__extends(StandardTheme, _super);\n\n  function StandardTheme() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StandardTheme;\n}(Theme);\n\nStandardTheme.prototype.classes = {\n  root: 'fc-theme-standard',\n  tableCellShaded: 'fc-cell-shaded',\n  buttonGroup: 'fc-button-group',\n  button: 'fc-button fc-button-primary',\n  buttonActive: 'fc-button-active'\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n  close: 'fc-icon-x',\n  prev: 'fc-icon-chevron-left',\n  next: 'fc-icon-chevron-right',\n  prevYear: 'fc-icon-chevrons-left',\n  nextYear: 'fc-icon-chevrons-right'\n};\nStandardTheme.prototype.rtlIconClasses = {\n  prev: 'fc-icon-chevron-right',\n  next: 'fc-icon-chevron-left',\n  prevYear: 'fc-icon-chevrons-right',\n  nextYear: 'fc-icon-chevrons-left'\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n  var hash = {};\n  var viewType;\n\n  for (viewType in defaultConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  for (viewType in overrideConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  return hash;\n}\n\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  if (hash[viewType]) {\n    return hash[viewType];\n  }\n\n  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n\n  if (viewDef) {\n    hash[viewType] = viewDef;\n  }\n\n  return viewDef;\n}\n\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  var defaultConfig = defaultConfigs[viewType];\n  var overrideConfig = overrideConfigs[viewType];\n\n  var queryProp = function (name) {\n    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n  };\n\n  var theComponent = queryProp('component');\n  var superType = queryProp('superType');\n  var superDef = null;\n\n  if (superType) {\n    if (superType === viewType) {\n      throw new Error('Can\\'t have a custom view type that references itself');\n    }\n\n    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  if (!theComponent && superDef) {\n    theComponent = superDef.component;\n  }\n\n  if (!theComponent) {\n    return null; // don't throw a warning, might be settings for a single-unit view\n  }\n\n  return {\n    type: viewType,\n    component: theComponent,\n    defaults: tslib.__assign(tslib.__assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n    overrides: tslib.__assign(tslib.__assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n  };\n}\n/* eslint max-classes-per-file: off */\n// NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n\n\nvar RenderHook = function (_super) {\n  tslib.__extends(RenderHook, _super);\n\n  function RenderHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = vdom_cjs.createRef();\n\n    _this.handleRootEl = function (el) {\n      setRef(_this.rootElRef, el);\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    };\n\n    return _this;\n  }\n\n  RenderHook.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var hookProps = props.hookProps;\n    return vdom_cjs.createElement(MountHook, {\n      hookProps: hookProps,\n      didMount: props.didMount,\n      willUnmount: props.willUnmount,\n      elRef: this.handleRootEl\n    }, function (rootElRef) {\n      return vdom_cjs.createElement(ContentHook, {\n        hookProps: hookProps,\n        content: props.content,\n        defaultContent: props.defaultContent,\n        backupElRef: _this.rootElRef\n      }, function (innerElRef, innerContent) {\n        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n      });\n    });\n  };\n\n  return RenderHook;\n}(BaseComponent); // TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\n\n\nvar CustomContentRenderContext = vdom_cjs.createContext(0);\n\nfunction ContentHook(props) {\n  return vdom_cjs.createElement(CustomContentRenderContext.Consumer, null, function (renderId) {\n    return vdom_cjs.createElement(ContentHookInner, tslib.__assign({\n      renderId: renderId\n    }, props));\n  });\n}\n\nvar ContentHookInner = function (_super) {\n  tslib.__extends(ContentHookInner, _super);\n\n  function ContentHookInner() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.innerElRef = vdom_cjs.createRef();\n    return _this;\n  }\n\n  ContentHookInner.prototype.render = function () {\n    return this.props.children(this.innerElRef, this.renderInnerContent());\n  };\n\n  ContentHookInner.prototype.componentDidMount = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentDidUpdate = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentWillUnmount = function () {\n    if (this.customContentInfo && this.customContentInfo.destroy) {\n      this.customContentInfo.destroy();\n    }\n  };\n\n  ContentHookInner.prototype.renderInnerContent = function () {\n    var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n\n    var innerContent = this.getInnerContent();\n    var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)\n\n    if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n      // clearing old value\n      if (customContentInfo) {\n        if (customContentInfo.destroy) {\n          customContentInfo.destroy();\n        }\n\n        customContentInfo = this.customContentInfo = null;\n      } // assigning new value\n\n\n      if (meta.contentKey) {\n        customContentInfo = this.customContentInfo = tslib.__assign({\n          contentKey: meta.contentKey,\n          contentVal: innerContent[meta.contentKey]\n        }, meta.buildLifecycleFuncs());\n      } // updating\n\n    } else if (customContentInfo) {\n      customContentInfo.contentVal = innerContent[meta.contentKey];\n    }\n\n    return customContentInfo ? [] // signal that something was specified\n    : innerContent; // assume a [p]react vdom node. use it\n  };\n\n  ContentHookInner.prototype.getInnerContent = function () {\n    var props = this.props;\n    var innerContent = normalizeContent(props.content, props.hookProps);\n\n    if (innerContent === undefined) {\n      // use the default\n      innerContent = normalizeContent(props.defaultContent, props.hookProps);\n    }\n\n    return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n  };\n\n  ContentHookInner.prototype.getContentMeta = function (innerContent) {\n    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n    var contentKey = '';\n    var buildLifecycleFuncs = null;\n\n    if (innerContent) {\n      // allowed to be null, for convenience to caller\n      for (var searchKey in contentTypeHandlers) {\n        if (innerContent[searchKey] !== undefined) {\n          contentKey = searchKey;\n          buildLifecycleFuncs = contentTypeHandlers[searchKey];\n          break;\n        }\n      }\n    }\n\n    return {\n      contentKey: contentKey,\n      buildLifecycleFuncs: buildLifecycleFuncs\n    };\n  };\n\n  ContentHookInner.prototype.updateCustomContent = function () {\n    if (this.customContentInfo) {\n      // for non-[p]react\n      this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n      this.customContentInfo.contentVal);\n    }\n  };\n\n  return ContentHookInner;\n}(BaseComponent);\n\nvar MountHook = function (_super) {\n  tslib.__extends(MountHook, _super);\n\n  function MountHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, rootEl);\n      }\n    };\n\n    return _this;\n  }\n\n  MountHook.prototype.render = function () {\n    return this.props.children(this.handleRootEl);\n  };\n\n  MountHook.prototype.componentDidMount = function () {\n    var callback = this.props.didMount;\n\n    if (callback) {\n      callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  MountHook.prototype.componentWillUnmount = function () {\n    var callback = this.props.willUnmount;\n\n    if (callback) {\n      callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  return MountHook;\n}(BaseComponent);\n\nfunction buildClassNameNormalizer() {\n  var currentGenerator;\n  var currentHookProps;\n  var currentClassNames = [];\n  return function (generator, hookProps) {\n    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n      currentGenerator = generator;\n      currentHookProps = hookProps;\n      currentClassNames = normalizeClassNames(generator, hookProps);\n    }\n\n    return currentClassNames;\n  };\n}\n\nfunction normalizeClassNames(classNames, hookProps) {\n  if (typeof classNames === 'function') {\n    classNames = classNames(hookProps);\n  }\n\n  return parseClassNames(classNames);\n}\n\nfunction normalizeContent(input, hookProps) {\n  if (typeof input === 'function') {\n    return input(hookProps, vdom_cjs.createElement); // give the function the vdom-creation func\n  }\n\n  return input;\n}\n\nvar ViewRoot = function (_super) {\n  tslib.__extends(ViewRoot, _super);\n\n  function ViewRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  ViewRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = {\n      view: context.viewApi\n    };\n    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n    return vdom_cjs.createElement(MountHook, {\n      hookProps: hookProps,\n      didMount: options.viewDidMount,\n      willUnmount: options.viewWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames));\n    });\n  };\n\n  return ViewRoot;\n}(BaseComponent);\n\nfunction parseViewConfigs(inputs) {\n  return mapHash(inputs, parseViewConfig);\n}\n\nfunction parseViewConfig(input) {\n  var rawOptions = typeof input === 'function' ? {\n    component: input\n  } : input;\n  var component = rawOptions.component;\n\n  if (rawOptions.content) {\n    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?\n  }\n\n  return {\n    superType: rawOptions.type,\n    component: component,\n    rawOptions: rawOptions\n  };\n}\n\nfunction createViewHookComponent(options) {\n  return function (viewProps) {\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function (context) {\n      return vdom_cjs.createElement(ViewRoot, {\n        viewSpec: context.viewSpec\n      }, function (viewElRef, viewClassNames) {\n        var hookProps = tslib.__assign(tslib.__assign({}, viewProps), {\n          nextDayThreshold: context.options.nextDayThreshold\n        });\n\n        return vdom_cjs.createElement(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.classNames,\n          content: options.content,\n          didMount: options.didMount,\n          willUnmount: options.willUnmount,\n          elRef: viewElRef\n        }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n          return vdom_cjs.createElement(\"div\", {\n            className: viewClassNames.concat(customClassNames).join(' '),\n            ref: rootElRef\n          }, innerContent);\n        });\n      });\n    });\n  };\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var defaultConfigs = parseViewConfigs(defaultInputs);\n  var overrideConfigs = parseViewConfigs(optionOverrides.views);\n  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n  return mapHash(viewDefs, function (viewDef) {\n    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n  });\n}\n\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n  var duration = null;\n  var durationUnit = '';\n  var singleUnit = '';\n  var singleUnitOverrides = {};\n\n  if (durationInput) {\n    duration = createDurationCached(durationInput);\n\n    if (duration) {\n      // valid?\n      var denom = greatestDurationDenominator(duration);\n      durationUnit = denom.unit;\n\n      if (denom.value === 1) {\n        singleUnit = durationUnit;\n        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n      }\n    }\n  }\n\n  var queryButtonText = function (optionsSubset) {\n    var buttonTextMap = optionsSubset.buttonText || {};\n    var buttonTextKey = viewDef.defaults.buttonTextKey;\n\n    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n      return buttonTextMap[buttonTextKey];\n    }\n\n    if (buttonTextMap[viewDef.type] != null) {\n      return buttonTextMap[viewDef.type];\n    }\n\n    if (buttonTextMap[singleUnit] != null) {\n      return buttonTextMap[singleUnit];\n    }\n\n    return null;\n  };\n\n  var queryButtonTitle = function (optionsSubset) {\n    var buttonHints = optionsSubset.buttonHints || {};\n    var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n\n    if (buttonKey != null && buttonHints[buttonKey] != null) {\n      return buttonHints[buttonKey];\n    }\n\n    if (buttonHints[viewDef.type] != null) {\n      return buttonHints[viewDef.type];\n    }\n\n    if (buttonHints[singleUnit] != null) {\n      return buttonHints[singleUnit];\n    }\n\n    return null;\n  };\n\n  return {\n    type: viewDef.type,\n    component: viewDef.component,\n    duration: duration,\n    durationUnit: durationUnit,\n    singleUnit: singleUnit,\n    optionDefaults: viewDef.defaults,\n    optionOverrides: tslib.__assign(tslib.__assign({}, singleUnitOverrides), viewDef.overrides),\n    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n    viewDef.overrides.buttonText,\n    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n    // not DRY\n    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS) // will eventually fall back to buttonText\n\n  };\n} // hack to get memoization working\n\n\nvar durationInputMap = {};\n\nfunction createDurationCached(durationInput) {\n  var json = JSON.stringify(durationInput);\n  var res = durationInputMap[json];\n\n  if (res === undefined) {\n    res = createDuration(durationInput);\n    durationInputMap[json] = res;\n  }\n\n  return res;\n}\n\nvar DateProfileGenerator = function () {\n  function DateProfileGenerator(props) {\n    this.props = props;\n    this.nowDate = getNow(props.nowInput, props.dateEnv);\n    this.initHiddenDays();\n  }\n  /* Date Range Computation\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n\n\n  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(prevDate, -1, forceToValid);\n  }; // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n\n\n  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(nextDate, 1, forceToValid);\n  }; // Builds a structure holding dates/ranges for rendering around the given date.\n  // Optional direction param indicates whether the date is being incremented/decremented\n  // from its previous value. decremented = -1, incremented = 1 (default).\n\n\n  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n    if (forceToValid === void 0) {\n      forceToValid = true;\n    }\n\n    var props = this.props;\n    var validRange;\n    var currentInfo;\n    var isRangeAllDay;\n    var renderRange;\n    var activeRange;\n    var isValid;\n    validRange = this.buildValidRange();\n    validRange = this.trimHiddenDays(validRange);\n\n    if (forceToValid) {\n      currentDate = constrainMarkerToRange(currentDate, validRange);\n    }\n\n    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n    renderRange = this.trimHiddenDays(renderRange);\n    activeRange = renderRange;\n\n    if (!props.showNonCurrentDates) {\n      activeRange = intersectRanges(activeRange, currentInfo.range);\n    }\n\n    activeRange = this.adjustActiveRange(activeRange);\n    activeRange = intersectRanges(activeRange, validRange); // might return null\n    // it's invalid if the originally requested date is not contained,\n    // or if the range is completely outside of the valid range.\n\n    isValid = rangesIntersect(currentInfo.range, validRange);\n    return {\n      // constraint for where prev/next operations can go and where events can be dragged/resized to.\n      // an object with optional start and end properties.\n      validRange: validRange,\n      // range the view is formally responsible for.\n      // for example, a month view might have 1st-31st, excluding padded dates\n      currentRange: currentInfo.range,\n      // name of largest unit being displayed, like \"month\" or \"week\"\n      currentRangeUnit: currentInfo.unit,\n      isRangeAllDay: isRangeAllDay,\n      // dates that display events and accept drag-n-drop\n      // will be `null` if no dates accept events\n      activeRange: activeRange,\n      // date range with a rendered skeleton\n      // includes not-active days that need some sort of DOM\n      renderRange: renderRange,\n      // Duration object that denotes the first visible time of any given day\n      slotMinTime: props.slotMinTime,\n      // Duration object that denotes the exclusive visible end time of any given day\n      slotMaxTime: props.slotMaxTime,\n      isValid: isValid,\n      // how far the current date will move for a prev/next operation\n      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^\n\n    };\n  }; // Builds an object with optional start/end properties.\n  // Indicates the minimum/maximum dates to display.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildValidRange = function () {\n    var input = this.props.validRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n    return this.refineRange(simpleInput) || {\n      start: null,\n      end: null\n    }; // completely open-ended\n  }; // Builds a structure with info about the \"current\" range, the range that is\n  // highlighted as being the current month for example.\n  // See build() for a description of `direction`.\n  // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n\n\n  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n    var props = this.props;\n    var duration = null;\n    var unit = null;\n    var range = null;\n    var dayCount;\n\n    if (props.duration) {\n      duration = props.duration;\n      unit = props.durationUnit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    } else if (dayCount = this.props.dayCount) {\n      unit = 'day';\n      range = this.buildRangeFromDayCount(date, direction, dayCount);\n    } else if (range = this.buildCustomVisibleRange(date)) {\n      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n    } else {\n      duration = this.getFallbackDuration();\n      unit = greatestDurationDenominator(duration).unit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    }\n\n    return {\n      duration: duration,\n      unit: unit,\n      range: range\n    };\n  };\n\n  DateProfileGenerator.prototype.getFallbackDuration = function () {\n    return createDuration({\n      day: 1\n    });\n  }; // Returns a new activeRange to have time values (un-ambiguate)\n  // slotMinTime or slotMaxTime causes the range to expand.\n\n\n  DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        usesMinMaxTime = _a.usesMinMaxTime,\n        slotMinTime = _a.slotMinTime,\n        slotMaxTime = _a.slotMaxTime;\n    var start = range.start,\n        end = range.end;\n\n    if (usesMinMaxTime) {\n      // expand active range if slotMinTime is negative (why not when positive?)\n      if (asRoughDays(slotMinTime) < 0) {\n        start = startOfDay(start); // necessary?\n\n        start = dateEnv.add(start, slotMinTime);\n      } // expand active range if slotMaxTime is beyond one day (why not when negative?)\n\n\n      if (asRoughDays(slotMaxTime) > 1) {\n        end = startOfDay(end); // necessary?\n\n        end = addDays(end, -1);\n        end = dateEnv.add(end, slotMaxTime);\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds the \"current\" range when it is specified as an explicit duration.\n  // `unit` is the already-computed greatestDurationDenominator unit of duration.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var start;\n    var end;\n    var res; // compute what the alignment should be\n\n    if (!dateAlignment) {\n      var dateIncrement = this.props.dateIncrement;\n\n      if (dateIncrement) {\n        // use the smaller of the two units\n        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n          dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n        } else {\n          dateAlignment = unit;\n        }\n      } else {\n        dateAlignment = unit;\n      }\n    } // if the view displays a single day or smaller\n\n\n    if (asRoughDays(duration) <= 1) {\n      if (this.isHiddenDay(start)) {\n        start = this.skipHiddenDays(start, direction);\n        start = startOfDay(start);\n      }\n    }\n\n    function computeRes() {\n      start = dateEnv.startOf(date, dateAlignment);\n      end = dateEnv.add(start, duration);\n      res = {\n        start: start,\n        end: end\n      };\n    }\n\n    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days\n\n    if (!this.trimHiddenDays(res)) {\n      date = this.skipHiddenDays(date, direction);\n      computeRes();\n    }\n\n    return res;\n  }; // Builds the \"current\" range when a dayCount is specified.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var runningCount = 0;\n    var start = date;\n    var end;\n\n    if (dateAlignment) {\n      start = dateEnv.startOf(start, dateAlignment);\n    }\n\n    start = startOfDay(start);\n    start = this.skipHiddenDays(start, direction);\n    end = start;\n\n    do {\n      end = addDays(end, 1);\n\n      if (!this.isHiddenDay(end)) {\n        runningCount += 1;\n      }\n    } while (runningCount < dayCount);\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds a normalized range object for the \"visible\" range,\n  // which is a way to define the currentRange and activeRange at the same time.\n\n\n  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n    var props = this.props;\n    var input = props.visibleRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n    var range = this.refineRange(simpleInput);\n\n    if (range && (range.start == null || range.end == null)) {\n      return null;\n    }\n\n    return range;\n  }; // Computes the range that will represent the element/cells for *rendering*,\n  // but which may have voided days/times.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    return currentRange;\n  }; // Compute the duration value that should be added/substracted to the current date\n  // when a prev/next operation happens.\n\n\n  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n    var dateIncrement = this.props.dateIncrement;\n    var customAlignment;\n\n    if (dateIncrement) {\n      return dateIncrement;\n    }\n\n    if (customAlignment = this.props.dateAlignment) {\n      return createDuration(1, customAlignment);\n    }\n\n    if (fallback) {\n      return fallback;\n    }\n\n    return createDuration({\n      days: 1\n    });\n  };\n\n  DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n    if (rangeInput) {\n      var range = parseRange(rangeInput, this.props.dateEnv);\n\n      if (range) {\n        range = computeVisibleDayRange(range);\n      }\n\n      return range;\n    }\n\n    return null;\n  };\n  /* Hidden Days\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Initializes internal variables related to calculating hidden days-of-week\n\n\n  DateProfileGenerator.prototype.initHiddenDays = function () {\n    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n\n    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n    var dayCnt = 0;\n    var i;\n\n    if (this.props.weekends === false) {\n      hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n    }\n\n    for (i = 0; i < 7; i += 1) {\n      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n        dayCnt += 1;\n      }\n    }\n\n    if (!dayCnt) {\n      throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n    }\n\n    this.isHiddenDayHash = isHiddenDayHash;\n  }; // Remove days from the beginning and end of the range that are computed as hidden.\n  // If the whole range is trimmed off, returns null\n\n\n  DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n    var start = range.start,\n        end = range.end;\n\n    if (start) {\n      start = this.skipHiddenDays(start);\n    }\n\n    if (end) {\n      end = this.skipHiddenDays(end, -1, true);\n    }\n\n    if (start == null || end == null || start < end) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    return null;\n  }; // Is the current day hidden?\n  // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n\n\n  DateProfileGenerator.prototype.isHiddenDay = function (day) {\n    if (day instanceof Date) {\n      day = day.getUTCDay();\n    }\n\n    return this.isHiddenDayHash[day];\n  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.\n  // DOES NOT CONSIDER validRange!\n  // If the initial value of `date` is not a hidden day, don't do anything.\n  // Pass `isExclusive` as `true` if you are dealing with an end date.\n  // `inc` defaults to `1` (increment one day forward each time)\n\n\n  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n    if (inc === void 0) {\n      inc = 1;\n    }\n\n    if (isExclusive === void 0) {\n      isExclusive = false;\n    }\n\n    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n      date = addDays(date, inc);\n    }\n\n    return date;\n  };\n\n  return DateProfileGenerator;\n}();\n\nfunction reduceViewType(viewType, action) {\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      viewType = action.viewType;\n  }\n\n  return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'SET_OPTION':\n      return tslib.__assign(tslib.__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n\n    default:\n      return dynamicOptionOverrides;\n  }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n  var dp;\n\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return dateProfileGenerator.build(action.dateMarker || currentDate);\n\n    case 'CHANGE_DATE':\n      return dateProfileGenerator.build(action.dateMarker);\n\n    case 'PREV':\n      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n\n    case 'NEXT':\n      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n  }\n\n  return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null;\n  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\n\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  switch (action.type) {\n    case 'ADD_EVENT_SOURCES':\n      // already parsed\n      return addSources(eventSources, action.sources, activeRange, context);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return removeSource(eventSources, action.sourceId);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return fetchDirtySources(eventSources, activeRange, context);\n      }\n\n      return eventSources;\n\n    case 'FETCH_EVENT_SOURCES':\n      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n\n    case 'RECEIVE_EVENTS':\n    case 'RECEIVE_EVENT_ERROR':\n      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return {};\n\n    default:\n      return eventSources;\n  }\n}\n\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\n\nfunction computeEventSourcesLoading(eventSources) {\n  for (var sourceId in eventSources) {\n    if (eventSources[sourceId].isFetching) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n  var hash = {};\n\n  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n    var source = sources_1[_i];\n    hash[source.sourceId] = source;\n  }\n\n  if (fetchRange) {\n    hash = fetchDirtySources(hash, fetchRange, context);\n  }\n\n  return tslib.__assign(tslib.__assign({}, eventSourceHash), hash);\n}\n\nfunction removeSource(eventSourceHash, sourceId) {\n  return filterHash(eventSourceHash, function (eventSource) {\n    return eventSource.sourceId !== sourceId;\n  });\n}\n\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n    return isSourceDirty(eventSource, fetchRange, context);\n  }), fetchRange, false, context);\n}\n\nfunction isSourceDirty(eventSource, fetchRange, context) {\n  if (!doesSourceNeedRange(eventSource, context)) {\n    return !eventSource.latestFetchId;\n  }\n\n  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\n\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n  var nextSources = {};\n\n  for (var sourceId in prevSources) {\n    var source = prevSources[sourceId];\n\n    if (sourceIdHash[sourceId]) {\n      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n    } else {\n      nextSources[sourceId] = source;\n    }\n  }\n\n  return nextSources;\n}\n\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n  var options = context.options,\n      calendarApi = context.calendarApi;\n  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n  var fetchId = guid();\n  sourceDef.fetch({\n    eventSource: eventSource,\n    range: fetchRange,\n    isRefetch: isRefetch,\n    context: context\n  }, function (res) {\n    var rawEvents = res.rawEvents;\n\n    if (options.eventSourceSuccess) {\n      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    if (eventSource.success) {\n      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENTS',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawEvents: rawEvents\n    });\n  }, function (error) {\n    console.warn(error.message, error);\n\n    if (options.eventSourceFailure) {\n      options.eventSourceFailure.call(calendarApi, error);\n    }\n\n    if (eventSource.failure) {\n      eventSource.failure(error);\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENT_ERROR',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return tslib.__assign(tslib.__assign({}, eventSource), {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n  var _a;\n\n  var eventSource = sourceHash[sourceId];\n\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId) {\n    return tslib.__assign(tslib.__assign({}, sourceHash), (_a = {}, _a[sourceId] = tslib.__assign(tslib.__assign({}, eventSource), {\n      isFetching: false,\n      fetchRange: fetchRange\n    }), _a));\n  }\n\n  return sourceHash;\n}\n\nfunction excludeStaticSources(eventSources, context) {\n  return filterHash(eventSources, function (eventSource) {\n    return doesSourceNeedRange(eventSource, context);\n  });\n}\n\nfunction parseInitialSources(rawOptions, context) {\n  var refiners = buildEventSourceRefiners(context);\n  var rawSources = [].concat(rawOptions.eventSources || []);\n  var sources = []; // parsed\n\n  if (rawOptions.initialEvents) {\n    rawSources.unshift(rawOptions.initialEvents);\n  }\n\n  if (rawOptions.events) {\n    rawSources.unshift(rawOptions.events);\n  }\n\n  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n    var rawSource = rawSources_1[_i];\n    var source = parseEventSource(rawSource, context, refiners);\n\n    if (source) {\n      sources.push(source);\n    }\n  }\n\n  return sources;\n}\n\nfunction doesSourceNeedRange(eventSource, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n  return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n  switch (action.type) {\n    case 'RECEIVE_EVENTS':\n      // raw\n      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n\n    case 'ADD_EVENTS':\n      // already parsed, but not expanded\n      return addEvent(eventStore, action.eventStore, // new ones\n      dateProfile ? dateProfile.activeRange : null, context);\n\n    case 'RESET_EVENTS':\n      return action.eventStore;\n\n    case 'MERGE_EVENTS':\n      // already parsed and expanded\n      return mergeEventStores(eventStore, action.eventStore);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return expandRecurring(eventStore, dateProfile.activeRange, context);\n      }\n\n      return eventStore;\n\n    case 'REMOVE_EVENTS':\n      return excludeSubEventStore(eventStore, action.eventStore);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return excludeEventsBySourceId(eventStore, action.sourceId);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return filterEventStoreDefs(eventStore, function (eventDef) {\n        return !eventDef.sourceId // only keep events with no source id\n        ;\n      });\n\n    case 'REMOVE_ALL_EVENTS':\n      return createEmptyEventStore();\n\n    default:\n      return eventStore;\n  }\n}\n\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n  ) {\n    var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n\n    if (fetchRange) {\n      subset = expandRecurring(subset, fetchRange, context);\n    }\n\n    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n  }\n\n  return eventStore;\n}\n\nfunction transformRawEvents(rawEvents, eventSource, context) {\n  var calEachTransform = context.options.eventDataTransform;\n  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n\n  if (sourceEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n  }\n\n  if (calEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n  }\n\n  return rawEvents;\n}\n\nfunction transformEachRawEvent(rawEvents, func) {\n  var refinedEvents;\n\n  if (!func) {\n    refinedEvents = rawEvents;\n  } else {\n    refinedEvents = [];\n\n    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n      var rawEvent = rawEvents_1[_i];\n      var refinedEvent = func(rawEvent);\n\n      if (refinedEvent) {\n        refinedEvents.push(refinedEvent);\n      } else if (refinedEvent == null) {\n        refinedEvents.push(rawEvent);\n      } // if a different falsy value, do nothing\n\n    }\n  }\n\n  return refinedEvents;\n}\n\nfunction addEvent(eventStore, subset, expandRange, context) {\n  if (expandRange) {\n    subset = expandRecurring(subset, expandRange, context);\n  }\n\n  return mergeEventStores(eventStore, subset);\n}\n\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n  var defs = eventStore.defs;\n  var instances = mapHash(eventStore.instances, function (instance) {\n    var def = defs[instance.defId];\n\n    if (def.allDay || def.recurringDef) {\n      return instance; // isn't dependent on timezone\n    }\n\n    return tslib.__assign(tslib.__assign({}, instance), {\n      range: {\n        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n      },\n      forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n      forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n    });\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n  return filterEventStoreDefs(eventStore, function (eventDef) {\n    return eventDef.sourceId !== sourceId;\n  });\n} // QUESTION: why not just return instances? do a general object-property-exclusion util\n\n\nfunction excludeInstances(eventStore, removals) {\n  return {\n    defs: eventStore.defs,\n    instances: filterHash(eventStore.instances, function (instance) {\n      return !removals[instance.instanceId];\n    })\n  };\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n  switch (action.type) {\n    case 'UNSELECT_DATES':\n      return null;\n\n    case 'SELECT_DATES':\n      return action.selection;\n\n    default:\n      return currentSelection;\n  }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n  switch (action.type) {\n    case 'UNSELECT_EVENT':\n      return '';\n\n    case 'SELECT_EVENT':\n      return action.eventInstanceId;\n\n    default:\n      return currentInstanceId;\n  }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n  var newDrag;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_DRAG':\n      return null;\n\n    case 'SET_EVENT_DRAG':\n      newDrag = action.state;\n      return {\n        affectedEvents: newDrag.affectedEvents,\n        mutatedEvents: newDrag.mutatedEvents,\n        isEvent: newDrag.isEvent\n      };\n\n    default:\n      return currentDrag;\n  }\n}\n\nfunction reduceEventResize(currentResize, action) {\n  var newResize;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_RESIZE':\n      return null;\n\n    case 'SET_EVENT_RESIZE':\n      newResize = action.state;\n      return {\n        affectedEvents: newResize.affectedEvents,\n        mutatedEvents: newResize.mutatedEvents,\n        isEvent: newResize.isEvent\n      };\n\n    default:\n      return currentResize;\n  }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n  var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n  return {\n    header: header,\n    footer: footer\n  };\n}\n\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var sectionWidgets = {};\n  var viewsWithButtons = [];\n  var hasTitle = false;\n\n  for (var sectionName in sectionStrHash) {\n    var sectionStr = sectionStrHash[sectionName];\n    var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n    sectionWidgets[sectionName] = sectionRes.widgets;\n    viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);\n    hasTitle = hasTitle || sectionRes.hasTitle;\n  }\n\n  return {\n    sectionWidgets: sectionWidgets,\n    viewsWithButtons: viewsWithButtons,\n    hasTitle: hasTitle\n  };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\n\n\nfunction parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined\ncalendarOptionOverrides, // overrides only!, unrefined :(\ntheme, viewSpecs, calendarApi) {\n  var isRtl = calendarOptions.direction === 'rtl';\n  var calendarCustomButtons = calendarOptions.customButtons || {};\n  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n  var calendarButtonText = calendarOptions.buttonText || {};\n  var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n  var calendarButtonHints = calendarOptions.buttonHints || {};\n  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n  var viewsWithButtons = [];\n  var hasTitle = false;\n  var widgets = sectionSubstrs.map(function (buttonGroupStr) {\n    return buttonGroupStr.split(',').map(function (buttonName) {\n      if (buttonName === 'title') {\n        hasTitle = true;\n        return {\n          buttonName: buttonName\n        };\n      }\n\n      var customButtonProps;\n      var viewSpec;\n      var buttonClick;\n      var buttonIcon; // only one of these will be set\n\n      var buttonText; // \"\n\n      var buttonHint; // ^ for the title=\"\" attribute, for accessibility\n\n      if (customButtonProps = calendarCustomButtons[buttonName]) {\n        buttonClick = function (ev) {\n          if (customButtonProps.click) {\n            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n          }\n        };\n\n        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n        buttonHint = customButtonProps.hint || customButtonProps.text;\n      } else if (viewSpec = viewSpecs[buttonName]) {\n        viewsWithButtons.push(buttonName);\n\n        buttonClick = function () {\n          calendarApi.changeView(buttonName);\n        };\n\n        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n        var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n        buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName\n        textFallback);\n      } else if (calendarApi[buttonName]) {\n        // a calendarApi method\n        buttonClick = function () {\n          calendarApi[buttonName]();\n        };\n\n        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n\n        if (buttonName === 'prevYear' || buttonName === 'nextYear') {\n          var prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';\n          buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [calendarButtonText.year || 'year', 'year'], calendarButtonText[buttonName]);\n        } else {\n          buttonHint = function (navUnit) {\n            return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [calendarButtonText[navUnit] || navUnit, navUnit], calendarButtonText[buttonName]);\n          };\n        }\n      }\n\n      return {\n        buttonName: buttonName,\n        buttonClick: buttonClick,\n        buttonIcon: buttonIcon,\n        buttonText: buttonText,\n        buttonHint: buttonHint\n      };\n    });\n  });\n  return {\n    widgets: widgets,\n    viewsWithButtons: viewsWithButtons,\n    hasTitle: hasTitle\n  };\n}\n\nvar eventSourceDef$2 = {\n  ignoreRange: true,\n  parseMeta: function (refined) {\n    if (Array.isArray(refined.events)) {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function (arg, success) {\n    success({\n      rawEvents: arg.eventSource.meta\n    });\n  }\n};\nvar arrayEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$2]\n});\nvar eventSourceDef$1 = {\n  parseMeta: function (refined) {\n    if (typeof refined.events === 'function') {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function (arg, success, failure) {\n    var dateEnv = arg.context.dateEnv;\n    var func = arg.eventSource.meta;\n    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n      success({\n        rawEvents: rawEvents\n      }); // needs an object response\n    }, failure);\n  }\n};\nvar funcEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$1]\n});\n\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n  method = method.toUpperCase();\n  var body = null;\n\n  if (method === 'GET') {\n    url = injectQueryStringParams(url, params);\n  } else {\n    body = encodeParams(params);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (method !== 'GET') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 400) {\n      var parsed = false;\n      var res = void 0;\n\n      try {\n        res = JSON.parse(xhr.responseText);\n        parsed = true;\n      } catch (err) {// will handle parsed=false\n      }\n\n      if (parsed) {\n        successCallback(res, xhr);\n      } else {\n        failureCallback('Failure parsing JSON', xhr);\n      }\n    } else {\n      failureCallback('Request failed', xhr);\n    }\n  };\n\n  xhr.onerror = function () {\n    failureCallback('Request failed', xhr);\n  };\n\n  xhr.send(body);\n}\n\nfunction injectQueryStringParams(url, params) {\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);\n}\n\nfunction encodeParams(params) {\n  var parts = [];\n\n  for (var key in params) {\n    parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n\n  return parts.join('&');\n}\n\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n  method: String,\n  extraParams: identity,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String\n};\nvar eventSourceDef = {\n  parseMeta: function (refined) {\n    if (refined.url && (refined.format === 'json' || !refined.format)) {\n      return {\n        url: refined.url,\n        format: 'json',\n        method: (refined.method || 'GET').toUpperCase(),\n        extraParams: refined.extraParams,\n        startParam: refined.startParam,\n        endParam: refined.endParam,\n        timeZoneParam: refined.timeZoneParam\n      };\n    }\n\n    return null;\n  },\n  fetch: function (arg, success, failure) {\n    var meta = arg.eventSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.context);\n    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n      success({\n        rawEvents: rawEvents,\n        xhr: xhr\n      });\n    }, function (errorMessage, xhr) {\n      failure({\n        message: errorMessage,\n        xhr: xhr\n      });\n    });\n  }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n  eventSourceDefs: [eventSourceDef]\n});\n\nfunction buildRequestParams(meta, range, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n  startParam = meta.startParam;\n\n  if (startParam == null) {\n    startParam = options.startParam;\n  }\n\n  endParam = meta.endParam;\n\n  if (endParam == null) {\n    endParam = options.endParam;\n  }\n\n  timeZoneParam = meta.timeZoneParam;\n\n  if (timeZoneParam == null) {\n    timeZoneParam = options.timeZoneParam;\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  tslib.__assign(params, customRequestParams);\n\n  params[startParam] = dateEnv.formatIso(range.start);\n  params[endParam] = dateEnv.formatIso(range.end);\n\n  if (dateEnv.timeZone !== 'local') {\n    params[timeZoneParam] = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nvar SIMPLE_RECURRING_REFINERS = {\n  daysOfWeek: identity,\n  startTime: createDuration,\n  endTime: createDuration,\n  duration: createDuration,\n  startRecur: identity,\n  endRecur: identity\n};\nvar recurring = {\n  parse: function (refined, dateEnv) {\n    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n      var recurringData = {\n        daysOfWeek: refined.daysOfWeek || null,\n        startTime: refined.startTime || null,\n        endTime: refined.endTime || null,\n        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n      };\n      var duration = void 0;\n\n      if (refined.duration) {\n        duration = refined.duration;\n      }\n\n      if (!duration && refined.startTime && refined.endTime) {\n        duration = subtractDurations(refined.endTime, refined.startTime);\n      }\n\n      return {\n        allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n        duration: duration,\n        typeData: recurringData // doesn't need endTime anymore but oh well\n\n      };\n    }\n\n    return null;\n  },\n  expand: function (typeData, framingRange, dateEnv) {\n    var clippedFramingRange = intersectRanges(framingRange, {\n      start: typeData.startRecur,\n      end: typeData.endRecur\n    });\n\n    if (clippedFramingRange) {\n      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n    }\n\n    return [];\n  }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n  recurringTypes: [recurring],\n  eventRefiners: SIMPLE_RECURRING_REFINERS\n});\n\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n  var dayMarker = startOfDay(framingRange.start);\n  var endMarker = framingRange.end;\n  var instanceStarts = [];\n\n  while (dayMarker < endMarker) {\n    var instanceStart // if everyday, or this particular day-of-week\n    = void 0; // if everyday, or this particular day-of-week\n\n    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n      if (startTime) {\n        instanceStart = dateEnv.add(dayMarker, startTime);\n      } else {\n        instanceStart = dayMarker;\n      }\n\n      instanceStarts.push(instanceStart);\n    }\n\n    dayMarker = addDays(dayMarker, 1);\n  }\n\n  return instanceStarts;\n}\n\nvar changeHandlerPlugin = createPlugin({\n  optionChangeHandlers: {\n    events: function (events, context) {\n      handleEventSources([events], context);\n    },\n    eventSources: handleEventSources\n  }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\n\nfunction handleEventSources(inputs, context) {\n  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n  var newInputs = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputFound = false;\n\n    for (var i = 0; i < unfoundSources.length; i += 1) {\n      if (unfoundSources[i]._raw === input) {\n        unfoundSources.splice(i, 1); // delete\n\n        inputFound = true;\n        break;\n      }\n    }\n\n    if (!inputFound) {\n      newInputs.push(input);\n    }\n  }\n\n  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n    var unfoundSource = unfoundSources_1[_a];\n    context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: unfoundSource.sourceId\n    });\n  }\n\n  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n    var newInput = newInputs_1[_b];\n    context.calendarApi.addEventSource(newInput);\n  }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n  context.emitter.trigger('datesSet', tslib.__assign(tslib.__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n    view: context.viewApi\n  }));\n}\n\nfunction handleEventStore(eventStore, context) {\n  var emitter = context.emitter;\n\n  if (emitter.hasHandlers('eventsSet')) {\n    emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n  }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\n\n\nvar globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({\n  isLoadingFuncs: [function (state) {\n    return computeEventSourcesLoading(state.eventSources);\n  }],\n  contentTypeHandlers: {\n    html: buildHtmlRenderer,\n    domNodes: buildDomNodeRenderer\n  },\n  propSetHandlers: {\n    dateProfile: handleDateProfile,\n    eventStore: handleEventStore\n  }\n})];\n\nfunction buildHtmlRenderer() {\n  var currentEl = null;\n  var currentHtml = '';\n\n  function render(el, html) {\n    if (el !== currentEl || html !== currentHtml) {\n      el.innerHTML = html;\n    }\n\n    currentEl = el;\n    currentHtml = html;\n  }\n\n  function destroy() {\n    currentEl.innerHTML = '';\n    currentEl = null;\n    currentHtml = '';\n  }\n\n  return {\n    render: render,\n    destroy: destroy\n  };\n}\n\nfunction buildDomNodeRenderer() {\n  var currentEl = null;\n  var currentDomNodes = [];\n\n  function render(el, domNodes) {\n    var newDomNodes = Array.prototype.slice.call(domNodes);\n\n    if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {\n      // append first, remove second (for scroll resetting)\n      for (var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++) {\n        var newNode = newDomNodes_1[_i];\n        el.appendChild(newNode);\n      }\n\n      destroy();\n    }\n\n    currentEl = el;\n    currentDomNodes = newDomNodes;\n  }\n\n  function destroy() {\n    currentDomNodes.forEach(removeElement);\n    currentDomNodes = [];\n    currentEl = null;\n  }\n\n  return {\n    render: render,\n    destroy: destroy\n  };\n}\n\nvar DelayedRunner = function () {\n  function DelayedRunner(drainedOption) {\n    this.drainedOption = drainedOption;\n    this.isRunning = false;\n    this.isDirty = false;\n    this.pauseDepths = {};\n    this.timeoutId = 0;\n  }\n\n  DelayedRunner.prototype.request = function (delay) {\n    this.isDirty = true;\n\n    if (!this.isPaused()) {\n      this.clearTimeout();\n\n      if (delay == null) {\n        this.tryDrain();\n      } else {\n        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce\n        this.tryDrain.bind(this), delay);\n      }\n    }\n  };\n\n  DelayedRunner.prototype.pause = function (scope) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n    this.clearTimeout();\n  };\n\n  DelayedRunner.prototype.resume = function (scope, force) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n\n    if (scope in pauseDepths) {\n      if (force) {\n        delete pauseDepths[scope];\n      } else {\n        pauseDepths[scope] -= 1;\n        var depth = pauseDepths[scope];\n\n        if (depth <= 0) {\n          delete pauseDepths[scope];\n        }\n      }\n\n      this.tryDrain();\n    }\n  };\n\n  DelayedRunner.prototype.isPaused = function () {\n    return Object.keys(this.pauseDepths).length;\n  };\n\n  DelayedRunner.prototype.tryDrain = function () {\n    if (!this.isRunning && !this.isPaused()) {\n      this.isRunning = true;\n\n      while (this.isDirty) {\n        this.isDirty = false;\n        this.drained(); // might set isDirty to true again\n      }\n\n      this.isRunning = false;\n    }\n  };\n\n  DelayedRunner.prototype.clear = function () {\n    this.clearTimeout();\n    this.isDirty = false;\n    this.pauseDepths = {};\n  };\n\n  DelayedRunner.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = 0;\n    }\n  };\n\n  DelayedRunner.prototype.drained = function () {\n    if (this.drainedOption) {\n      this.drainedOption();\n    }\n  };\n\n  return DelayedRunner;\n}();\n\nvar TaskRunner = function () {\n  function TaskRunner(runTaskOption, drainedOption) {\n    this.runTaskOption = runTaskOption;\n    this.drainedOption = drainedOption;\n    this.queue = [];\n    this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n  }\n\n  TaskRunner.prototype.request = function (task, delay) {\n    this.queue.push(task);\n    this.delayedRunner.request(delay);\n  };\n\n  TaskRunner.prototype.pause = function (scope) {\n    this.delayedRunner.pause(scope);\n  };\n\n  TaskRunner.prototype.resume = function (scope, force) {\n    this.delayedRunner.resume(scope, force);\n  };\n\n  TaskRunner.prototype.drain = function () {\n    var queue = this.queue;\n\n    while (queue.length) {\n      var completedTasks = [];\n      var task = void 0;\n\n      while (task = queue.shift()) {\n        this.runTask(task);\n        completedTasks.push(task);\n      }\n\n      this.drained(completedTasks);\n    } // keep going, in case new tasks were added in the drained handler\n\n  };\n\n  TaskRunner.prototype.runTask = function (task) {\n    if (this.runTaskOption) {\n      this.runTaskOption(task);\n    }\n  };\n\n  TaskRunner.prototype.drained = function (completedTasks) {\n    if (this.drainedOption) {\n      this.drainedOption(completedTasks);\n    }\n  };\n\n  return TaskRunner;\n}(); // Computes what the title at the top of the calendarApi should be for this view\n\n\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n\n  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n    range = dateProfile.currentRange;\n  } else {\n    // for day units or smaller, use the actual day range\n    range = dateProfile.activeRange;\n  }\n\n  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n    isEndExclusive: dateProfile.isRangeAllDay,\n    defaultSeparator: viewOptions.titleRangeSeparator\n  });\n} // Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\n\nfunction buildTitleFormat(dateProfile) {\n  var currentRangeUnit = dateProfile.currentRangeUnit;\n\n  if (currentRangeUnit === 'year') {\n    return {\n      year: 'numeric'\n    };\n  }\n\n  if (currentRangeUnit === 'month') {\n    return {\n      year: 'numeric',\n      month: 'long'\n    }; // like \"September 2014\"\n  }\n\n  var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n\n  if (days !== null && days > 1) {\n    // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n    return {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    };\n  } // one day. longer, like \"September 9 2014\"\n\n\n  return {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  };\n} // in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\n\n\nvar CalendarDataManager = function () {\n  function CalendarDataManager(props) {\n    var _this = this;\n\n    this.computeOptionsData = memoize(this._computeOptionsData);\n    this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n    this.organizeRawLocales = memoize(organizeRawLocales);\n    this.buildLocale = memoize(buildLocale);\n    this.buildPluginHooks = buildBuildPluginHooks();\n    this.buildDateEnv = memoize(buildDateEnv);\n    this.buildTheme = memoize(buildTheme);\n    this.parseToolbars = memoize(parseToolbars);\n    this.buildViewSpecs = memoize(buildViewSpecs);\n    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n    this.buildViewApi = memoize(buildViewApi);\n    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n    this.buildEventUiBases = memoize(buildEventUiBases);\n    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n    this.buildTitle = memoize(buildTitle);\n    this.emitter = new Emitter();\n    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n    this.currentCalendarOptionsInput = {};\n    this.currentCalendarOptionsRefined = {};\n    this.currentViewOptionsInput = {};\n    this.currentViewOptionsRefined = {};\n    this.currentCalendarOptionsRefiners = {};\n\n    this.getCurrentData = function () {\n      return _this.data;\n    };\n\n    this.dispatch = function (action) {\n      _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n\n    };\n\n    this.props = props;\n    this.actionRunner.pause();\n    var dynamicOptionOverrides = {};\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    this.emitter.setThisContext(props.calendarApi);\n    this.emitter.setOptions(currentViewData.options);\n    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n\n    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }; // needs to be after setThisContext\n\n    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback(calendarContext);\n    } // NOT DRY\n\n\n    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n    var initialState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      eventSources: eventSources,\n      eventUiBases: {},\n      eventStore: createEmptyEventStore(),\n      renderableEventStore: createEmptyEventStore(),\n      dateSelection: null,\n      eventSelection: '',\n      eventDrag: null,\n      eventResize: null,\n      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n    };\n\n    var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), initialState);\n\n    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n      var reducer = _c[_b];\n\n      tslib.__assign(initialState, reducer(null, null, contextAndState));\n    }\n\n    if (computeIsLoading(initialState, calendarContext)) {\n      this.emitter.trigger('loading', true); // NOT DRY\n    }\n\n    this.state = initialState;\n    this.updateData();\n    this.actionRunner.resume();\n  }\n\n  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n    var props = this.props;\n    props.optionOverrides = append ? tslib.__assign(tslib.__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;\n    this.actionRunner.request({\n      type: 'NOTHING'\n    });\n  };\n\n  CalendarDataManager.prototype._handleAction = function (action) {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        emitter = _a.emitter;\n\n    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = reduceViewType(state.currentViewType, action);\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    emitter.setThisContext(props.calendarApi);\n    emitter.setOptions(currentViewData.options);\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: emitter,\n      getCurrentData: this.getCurrentData\n    };\n    var currentDate = state.currentDate,\n        dateProfile = state.dateProfile;\n\n    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n      // hack\n      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n    }\n\n    currentDate = reduceCurrentDate(currentDate, action);\n    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n\n    if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n    action.type === 'NEXT' || // \"\n    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n    var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n\n    var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state\n    eventStore;\n\n    var _b = this.buildViewUiProps(calendarContext),\n        eventUiSingleBase = _b.eventUiSingleBase,\n        selectionConfig = _b.selectionConfig; // will memoize obj\n\n\n    var eventUiBySource = this.buildEventUiBySource(eventSources);\n    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n    var newState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      eventSources: eventSources,\n      eventStore: eventStore,\n      renderableEventStore: renderableEventStore,\n      selectionConfig: selectionConfig,\n      eventUiBases: eventUiBases,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      dateSelection: reduceDateSelection(state.dateSelection, action),\n      eventSelection: reduceSelectedEvent(state.eventSelection, action),\n      eventDrag: reduceEventDrag(state.eventDrag, action),\n      eventResize: reduceEventResize(state.eventResize, action)\n    };\n\n    var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), newState);\n\n    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n      var reducer = _c[_i];\n\n      tslib.__assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n\n    }\n\n    var wasLoading = computeIsLoading(state, calendarContext);\n    var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system\n\n    if (!wasLoading && isLoading) {\n      emitter.trigger('loading', true);\n    } else if (wasLoading && !isLoading) {\n      emitter.trigger('loading', false);\n    }\n\n    this.state = newState;\n\n    if (props.onAction) {\n      props.onAction(action);\n    }\n  };\n\n  CalendarDataManager.prototype.updateData = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var oldData = this.data;\n    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n\n    var data = this.data = tslib.__assign(tslib.__assign(tslib.__assign({\n      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }, optionsData), currentViewData), state);\n\n    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n    var oldCalendarOptions = oldData && oldData.calendarOptions;\n    var newCalendarOptions = optionsData.calendarOptions;\n\n    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n        // hack\n        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n      }\n\n      for (var optionName in changeHandlers) {\n        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n          changeHandlers[optionName](newCalendarOptions[optionName], data);\n        }\n      }\n    }\n\n    if (props.onData) {\n      props.onData(data);\n    }\n  };\n\n  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n    // TODO: blacklist options that are handled by optionChangeHandlers\n    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        pluginHooks = _a.pluginHooks,\n        localeDefaults = _a.localeDefaults,\n        availableLocaleData = _a.availableLocaleData,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    var theme = this.buildTheme(refinedOptions, pluginHooks);\n    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n    return {\n      calendarOptions: refinedOptions,\n      pluginHooks: pluginHooks,\n      dateEnv: dateEnv,\n      viewSpecs: viewSpecs,\n      theme: theme,\n      toolbarConfig: toolbarConfig,\n      localeDefaults: localeDefaults,\n      availableRawLocales: availableLocaleData.map\n    };\n  }; // always called from behind a memoizer\n\n\n  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),\n        locales = _a.locales,\n        locale = _a.locale;\n\n    var availableLocaleData = this.organizeRawLocales(locales);\n    var availableRawLocales = availableLocaleData.map;\n    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n\n    var refiners = this.currentCalendarOptionsRefiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var extra = {};\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);\n    var refined = {};\n    var currentRaw = this.currentCalendarOptionsInput;\n    var currentRefined = this.currentCalendarOptionsRefined;\n    var anyChanges = false;\n\n    for (var optionName in raw) {\n      if (optionName !== 'plugins') {\n        // because plugins is special-cased\n        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n          refined[optionName] = currentRefined[optionName];\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n          anyChanges = true;\n        } else {\n          extra[optionName] = currentRaw[optionName];\n        }\n      }\n    }\n\n    if (anyChanges) {\n      this.currentCalendarOptionsInput = raw;\n      this.currentCalendarOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentCalendarOptionsInput,\n      refinedOptions: this.currentCalendarOptionsRefined,\n      pluginHooks: pluginHooks,\n      availableLocaleData: availableLocaleData,\n      localeDefaults: localeDefaults,\n      extra: extra\n    };\n  };\n\n  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n    var viewSpec = optionsData.viewSpecs[viewType];\n\n    if (!viewSpec) {\n      throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n    }\n\n    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateProfileGenerator = this.buildDateProfileGenerator({\n      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n      duration: viewSpec.duration,\n      durationUnit: viewSpec.durationUnit,\n      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n      dateEnv: optionsData.dateEnv,\n      calendarApi: this.props.calendarApi,\n      slotMinTime: refinedOptions.slotMinTime,\n      slotMaxTime: refinedOptions.slotMaxTime,\n      showNonCurrentDates: refinedOptions.showNonCurrentDates,\n      dayCount: refinedOptions.dayCount,\n      dateAlignment: refinedOptions.dateAlignment,\n      dateIncrement: refinedOptions.dateIncrement,\n      hiddenDays: refinedOptions.hiddenDays,\n      weekends: refinedOptions.weekends,\n      nowInput: refinedOptions.now,\n      validRangeInput: refinedOptions.validRange,\n      visibleRangeInput: refinedOptions.visibleRange,\n      monthMode: refinedOptions.monthMode,\n      fixedWeekCount: refinedOptions.fixedWeekCount\n    });\n    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n    return {\n      viewSpec: viewSpec,\n      options: refinedOptions,\n      dateProfileGenerator: dateProfileGenerator,\n      viewApi: viewApi\n    };\n  };\n\n  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);\n\n    var refiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var refined = {};\n    var currentRaw = this.currentViewOptionsInput;\n    var currentRefined = this.currentViewOptionsRefined;\n    var anyChanges = false;\n    var extra = {};\n\n    for (var optionName in raw) {\n      if (raw[optionName] === currentRaw[optionName]) {\n        refined[optionName] = currentRefined[optionName];\n      } else {\n        if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n          if (optionName in this.currentCalendarOptionsRefined) {\n            // might be an \"extra\" prop\n            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n          }\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n        } else {\n          extra[optionName] = raw[optionName];\n        }\n\n        anyChanges = true;\n      }\n    }\n\n    if (anyChanges) {\n      this.currentViewOptionsInput = raw;\n      this.currentViewOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentViewOptionsInput,\n      refinedOptions: this.currentViewOptionsRefined,\n      extra: extra\n    };\n  };\n\n  return CalendarDataManager;\n}();\n\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n  return new DateEnv({\n    calendarSystem: 'gregory',\n    timeZone: timeZone,\n    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n    locale: locale,\n    weekNumberCalculation: weekNumberCalculation,\n    firstDay: firstDay,\n    weekText: weekText,\n    cmdFormatter: pluginHooks.cmdFormatter,\n    defaultSeparator: defaultSeparator\n  });\n}\n\nfunction buildTheme(options, pluginHooks) {\n  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n  return new ThemeClass(options);\n}\n\nfunction buildDateProfileGenerator(props) {\n  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n  return new DateProfileGeneratorClass(props);\n}\n\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n  return new ViewApi(type, getCurrentData, dateEnv);\n}\n\nfunction buildEventUiBySource(eventSources) {\n  return mapHash(eventSources, function (eventSource) {\n    return eventSource.ui;\n  });\n}\n\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n  var eventUiBases = {\n    '': eventUiSingleBase\n  };\n\n  for (var defId in eventDefs) {\n    var def = eventDefs[defId];\n\n    if (def.sourceId && eventUiBySource[def.sourceId]) {\n      eventUiBases[defId] = eventUiBySource[def.sourceId];\n    }\n  }\n\n  return eventUiBases;\n}\n\nfunction buildViewUiProps(calendarContext) {\n  var options = calendarContext.options;\n  return {\n    eventUiSingleBase: createEventUi({\n      display: options.eventDisplay,\n      editable: options.editable,\n      startEditable: options.eventStartEditable,\n      durationEditable: options.eventDurationEditable,\n      constraint: options.eventConstraint,\n      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n      allow: options.eventAllow,\n      backgroundColor: options.eventBackgroundColor,\n      borderColor: options.eventBorderColor,\n      textColor: options.eventTextColor,\n      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this\n\n    }, calendarContext),\n    selectionConfig: createEventUi({\n      constraint: options.selectConstraint,\n      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n      allow: options.selectAllow\n    }, calendarContext)\n  };\n}\n\nfunction computeIsLoading(state, context) {\n  for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {\n    var isLoadingFunc = _a[_i];\n\n    if (isLoadingFunc(state)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction parseContextBusinessHours(calendarContext) {\n  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\n\nfunction warnUnknownOptions(options, viewName) {\n  for (var optionName in options) {\n    console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : ''));\n  }\n} // TODO: move this to react plugin?\n\n\nvar CalendarDataProvider = function (_super) {\n  tslib.__extends(CalendarDataProvider, _super);\n\n  function CalendarDataProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleData = function (data) {\n      if (!_this.dataManager) {\n        // still within initial run, before assignment in constructor\n        // eslint-disable-next-line react/no-direct-mutation-state\n        _this.state = data; // can't use setState yet\n      } else {\n        _this.setState(data);\n      }\n    };\n\n    _this.dataManager = new CalendarDataManager({\n      optionOverrides: props.optionOverrides,\n      calendarApi: props.calendarApi,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  CalendarDataProvider.prototype.render = function () {\n    return this.props.children(this.state);\n  };\n\n  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n    var newOptionOverrides = this.props.optionOverrides;\n\n    if (newOptionOverrides !== prevProps.optionOverrides) {\n      // prevent recursive handleData\n      this.dataManager.resetOptions(newOptionOverrides);\n    }\n  };\n\n  return CalendarDataProvider;\n}(vdom_cjs.Component); // HELPERS\n\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\n\n\nfunction sliceEvents(props, allDay) {\n  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nvar NamedTimeZoneImpl = function () {\n  function NamedTimeZoneImpl(timeZoneName) {\n    this.timeZoneName = timeZoneName;\n  }\n\n  return NamedTimeZoneImpl;\n}();\n\nvar SegHierarchy = function () {\n  function SegHierarchy() {\n    // settings\n    this.strictOrder = false;\n    this.allowReslicing = false;\n    this.maxCoord = -1; // -1 means no max\n\n    this.maxStackCnt = -1; // -1 means no max\n\n    this.levelCoords = []; // ordered\n\n    this.entriesByLevel = []; // parallel with levelCoords\n\n    this.stackCnts = {}; // TODO: use better technique!?\n  }\n\n  SegHierarchy.prototype.addSegs = function (inputs) {\n    var hiddenEntries = [];\n\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n      var input = inputs_1[_i];\n      this.insertEntry(input, hiddenEntries);\n    }\n\n    return hiddenEntries;\n  };\n\n  SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {\n    var insertion = this.findInsertion(entry);\n\n    if (this.isInsertionValid(insertion, entry)) {\n      this.insertEntryAt(entry, insertion);\n      return 1;\n    }\n\n    return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n  };\n\n  SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {\n    return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n  }; // returns number of new entries inserted\n\n\n  SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    if (this.allowReslicing && insertion.touchingEntry) {\n      return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {\n    var partCnt = 0;\n    var splitHiddenEntries = [];\n    var entrySpan = entry.span;\n    var barrierSpan = barrier.span;\n\n    if (entrySpan.start < barrierSpan.start) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: entrySpan.start,\n          end: barrierSpan.start\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (entrySpan.end > barrierSpan.end) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: barrierSpan.end,\n          end: entrySpan.end\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (partCnt) {\n      hiddenEntries.push.apply(hiddenEntries, tslib.__spreadArray([{\n        index: entry.index,\n        thickness: entry.thickness,\n        span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect\n\n      }], splitHiddenEntries));\n      return partCnt;\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    if (insertion.lateral === -1) {\n      // create a new level\n      insertAt(levelCoords, insertion.level, insertion.levelCoord);\n      insertAt(entriesByLevel, insertion.level, [entry]);\n    } else {\n      // insert into existing level\n      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n    }\n\n    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n  };\n\n  SegHierarchy.prototype.findInsertion = function (newEntry) {\n    var _a = this,\n        levelCoords = _a.levelCoords,\n        entriesByLevel = _a.entriesByLevel,\n        strictOrder = _a.strictOrder,\n        stackCnts = _a.stackCnts;\n\n    var levelCnt = levelCoords.length;\n    var candidateCoord = 0;\n    var touchingLevel = -1;\n    var touchingLateral = -1;\n    var touchingEntry = null;\n    var stackCnt = 0;\n\n    for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {\n      var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.\n      // if strictOrder, keep finding more lateral intersections.\n\n      if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n        break;\n      }\n\n      var trackingEntries = entriesByLevel[trackingLevel];\n      var trackingEntry = void 0;\n      var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n\n      var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n\n      while ( // loop through entries that horizontally intersect\n      (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n      trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n      ) {\n        var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?\n\n        if (trackingEntryBottom > candidateCoord) {\n          candidateCoord = trackingEntryBottom;\n          touchingEntry = trackingEntry;\n          touchingLevel = trackingLevel;\n          touchingLateral = lateralIndex;\n        } // butts up against top of candidate? (will happen if just intersected as well)\n\n\n        if (trackingEntryBottom === candidateCoord) {\n          // accumulate the highest possible stackCnt of the trackingEntries that butt up\n          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n        }\n\n        lateralIndex += 1;\n      }\n    } // the destination level will be after touchingEntry's level. find it\n\n\n    var destLevel = 0;\n\n    if (touchingEntry) {\n      destLevel = touchingLevel + 1;\n\n      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {\n        destLevel += 1;\n      }\n    } // if adding to an existing level, find where to insert\n\n\n    var destLateral = -1;\n\n    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n    }\n\n    return {\n      touchingLevel: touchingLevel,\n      touchingLateral: touchingLateral,\n      touchingEntry: touchingEntry,\n      stackCnt: stackCnt,\n      levelCoord: candidateCoord,\n      level: destLevel,\n      lateral: destLateral\n    };\n  }; // sorted by levelCoord (lowest to highest)\n\n\n  SegHierarchy.prototype.toRects = function () {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    var levelCnt = entriesByLevel.length;\n    var rects = [];\n\n    for (var level = 0; level < levelCnt; level += 1) {\n      var entries = entriesByLevel[level];\n      var levelCoord = levelCoords[level];\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n        rects.push(tslib.__assign(tslib.__assign({}, entry), {\n          levelCoord: levelCoord\n        }));\n      }\n    }\n\n    return rects;\n  };\n\n  return SegHierarchy;\n}();\n\nfunction getEntrySpanEnd(entry) {\n  return entry.span.end;\n}\n\nfunction buildEntryKey(entry) {\n  return entry.index + ':' + entry.span.start;\n} // returns groups with entries sorted by input order\n\n\nfunction groupIntersectingEntries(entries) {\n  var merges = [];\n\n  for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {\n    var entry = entries_2[_i];\n    var filteredMerges = [];\n    var hungryMerge = {\n      span: entry.span,\n      entries: [entry]\n    };\n\n    for (var _a = 0, merges_1 = merges; _a < merges_1.length; _a++) {\n      var merge = merges_1[_a];\n\n      if (intersectSpans(merge.span, hungryMerge.span)) {\n        hungryMerge = {\n          entries: merge.entries.concat(hungryMerge.entries),\n          span: joinSpans(merge.span, hungryMerge.span)\n        };\n      } else {\n        filteredMerges.push(merge);\n      }\n    }\n\n    filteredMerges.push(hungryMerge);\n    merges = filteredMerges;\n  }\n\n  return merges;\n}\n\nfunction joinSpans(span0, span1) {\n  return {\n    start: Math.min(span0.start, span1.start),\n    end: Math.max(span0.end, span1.end)\n  };\n}\n\nfunction intersectSpans(span0, span1) {\n  var start = Math.max(span0.start, span1.start);\n  var end = Math.min(span0.end, span1.end);\n\n  if (start < end) {\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  return null;\n} // general util\n// ---------------------------------------------------------------------------------------------------------------------\n\n\nfunction insertAt(arr, index, item) {\n  arr.splice(index, 0, item);\n}\n\nfunction binarySearch(a, searchVal, getItemVal) {\n  var startIndex = 0;\n  var endIndex = a.length; // exclusive\n\n  if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n    // no items OR before first item\n    return [0, 0];\n  }\n\n  if (searchVal > getItemVal(a[endIndex - 1])) {\n    // after last item\n    return [endIndex, 0];\n  }\n\n  while (startIndex < endIndex) {\n    var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n    var middleVal = getItemVal(a[middleIndex]);\n\n    if (searchVal < middleVal) {\n      endIndex = middleIndex;\n    } else if (searchVal > middleVal) {\n      startIndex = middleIndex + 1;\n    } else {\n      // equal!\n      return [middleIndex, 1];\n    }\n  }\n\n  return [startIndex, 0];\n}\n\nvar Interaction = function () {\n  function Interaction(settings) {\n    this.component = settings.component;\n    this.isHitComboAllowed = settings.isHitComboAllowed || null;\n  }\n\n  Interaction.prototype.destroy = function () {};\n\n  return Interaction;\n}();\n\nfunction parseInteractionSettings(component, input) {\n  return {\n    component: component,\n    el: input.el,\n    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n    isHitComboAllowed: input.isHitComboAllowed || null\n  };\n}\n\nfunction interactionSettingsToStore(settings) {\n  var _a;\n\n  return _a = {}, _a[settings.component.uid] = settings, _a;\n} // global state\n\n\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\n\nvar ElementDragging = function () {\n  function ElementDragging(el, selector) {\n    this.emitter = new Emitter();\n  }\n\n  ElementDragging.prototype.destroy = function () {};\n\n  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional\n  };\n\n  return ElementDragging;\n}(); // TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\n\n\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\n\nvar DRAG_META_REFINERS = {\n  startTime: createDuration,\n  duration: createDuration,\n  create: Boolean,\n  sourceId: String\n};\n\nfunction parseDragMeta(raw) {\n  var _a = refineProps(raw, DRAG_META_REFINERS),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  return {\n    startTime: refined.startTime || null,\n    duration: refined.duration || null,\n    create: refined.create != null ? refined.create : true,\n    sourceId: refined.sourceId,\n    leftoverProps: extra\n  };\n}\n\nvar ToolbarSection = function (_super) {\n  tslib.__extends(ToolbarSection, _super);\n\n  function ToolbarSection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarSection.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.widgetGroups.map(function (widgetGroup) {\n      return _this.renderWidgetGroup(widgetGroup);\n    });\n    return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['div', {\n      className: 'fc-toolbar-chunk'\n    }], children));\n  };\n\n  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n    var props = this.props;\n    var theme = this.context.theme;\n    var children = [];\n    var isOnlyButtons = true;\n\n    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n      var widget = widgetGroup_1[_i];\n      var buttonName = widget.buttonName,\n          buttonClick = widget.buttonClick,\n          buttonText = widget.buttonText,\n          buttonIcon = widget.buttonIcon,\n          buttonHint = widget.buttonHint;\n\n      if (buttonName === 'title') {\n        isOnlyButtons = false;\n        children.push(vdom_cjs.createElement(\"h2\", {\n          className: \"fc-toolbar-title\",\n          id: props.titleId\n        }, props.title));\n      } else {\n        var isPressed = buttonName === props.activeButton;\n        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n        var buttonClasses = [\"fc-\" + buttonName + \"-button\", theme.getClass('button')];\n\n        if (isPressed) {\n          buttonClasses.push(theme.getClass('buttonActive'));\n        }\n\n        children.push(vdom_cjs.createElement(\"button\", {\n          type: \"button\",\n          title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,\n          disabled: isDisabled,\n          \"aria-pressed\": isPressed,\n          className: buttonClasses.join(' '),\n          onClick: buttonClick\n        }, buttonText || (buttonIcon ? vdom_cjs.createElement(\"span\", {\n          className: buttonIcon\n        }) : '')));\n      }\n    }\n\n    if (children.length > 1) {\n      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n      return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['div', {\n        className: groupClassName\n      }], children));\n    }\n\n    return children[0];\n  };\n\n  return ToolbarSection;\n}(BaseComponent);\n\nvar Toolbar = function (_super) {\n  tslib.__extends(Toolbar, _super);\n\n  function Toolbar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Toolbar.prototype.render = function () {\n    var _a = this.props,\n        model = _a.model,\n        extraClassName = _a.extraClassName;\n    var forceLtr = false;\n    var startContent;\n    var endContent;\n    var sectionWidgets = model.sectionWidgets;\n    var centerContent = sectionWidgets.center;\n\n    if (sectionWidgets.left) {\n      forceLtr = true;\n      startContent = sectionWidgets.left;\n    } else {\n      startContent = sectionWidgets.start;\n    }\n\n    if (sectionWidgets.right) {\n      forceLtr = true;\n      endContent = sectionWidgets.right;\n    } else {\n      endContent = sectionWidgets.end;\n    }\n\n    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];\n    return vdom_cjs.createElement(\"div\", {\n      className: classNames.join(' ')\n    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n  };\n\n  Toolbar.prototype.renderSection = function (key, widgetGroups) {\n    var props = this.props;\n    return vdom_cjs.createElement(ToolbarSection, {\n      key: key,\n      widgetGroups: widgetGroups,\n      title: props.title,\n      navUnit: props.navUnit,\n      activeButton: props.activeButton,\n      isTodayEnabled: props.isTodayEnabled,\n      isPrevEnabled: props.isPrevEnabled,\n      isNextEnabled: props.isNextEnabled,\n      titleId: props.titleId\n    });\n  };\n\n  return Toolbar;\n}(BaseComponent); // TODO: do function component?\n\n\nvar ViewContainer = function (_super) {\n  tslib.__extends(ViewContainer, _super);\n\n  function ViewContainer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      availableWidth: null\n    };\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n\n      _this.updateAvailableWidth();\n    };\n\n    _this.handleResize = function () {\n      _this.updateAvailableWidth();\n    };\n\n    return _this;\n  }\n\n  ViewContainer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var aspectRatio = props.aspectRatio;\n    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n    : 'fc-view-harness-passive' // let the view do the height\n    ];\n    var height = '';\n    var paddingBottom = '';\n\n    if (aspectRatio) {\n      if (state.availableWidth !== null) {\n        height = state.availableWidth / aspectRatio;\n      } else {\n        // while waiting to know availableWidth, we can't set height to *zero*\n        // because will cause lots of unnecessary scrollbars within scrollgrid.\n        // BETTER: don't start rendering ANYTHING yet until we know container width\n        // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n        paddingBottom = 1 / aspectRatio * 100 + \"%\";\n      }\n    } else {\n      height = props.height || '';\n    }\n\n    return vdom_cjs.createElement(\"div\", {\n      \"aria-labelledby\": props.labeledById,\n      ref: this.handleEl,\n      className: classNames.join(' '),\n      style: {\n        height: height,\n        paddingBottom: paddingBottom\n      }\n    }, props.children);\n  };\n\n  ViewContainer.prototype.componentDidMount = function () {\n    this.context.addResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.updateAvailableWidth = function () {\n    if (this.el && // needed. but why?\n    this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n    ) {\n      this.setState({\n        availableWidth: this.el.offsetWidth\n      });\n    }\n  };\n\n  return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\n\n\nvar EventClicking = function (_super) {\n  tslib.__extends(EventClicking, _super);\n\n  function EventClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handleSegClick = function (ev, segEl) {\n      var component = _this.component;\n      var context = component.context;\n      var seg = getElSeg(segEl);\n\n      if (seg && // might be the <div> surrounding the more link\n      component.isValidSegDownEl(ev.target)) {\n        // our way to simulate a link click for elements that can't be <a> tags\n        // grab before trigger fired in case trigger trashes DOM thru rerendering\n        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n        context.emitter.trigger('eventClick', {\n          el: segEl,\n          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n\n        if (url && !ev.defaultPrevented) {\n          window.location.href = url;\n        }\n      }\n    };\n\n    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n    _this.handleSegClick);\n    return _this;\n  }\n\n  return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\n\n\nvar EventHovering = function (_super) {\n  tslib.__extends(EventHovering, _super);\n\n  function EventHovering(settings) {\n    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n\n\n    _this.handleEventElRemove = function (el) {\n      if (el === _this.currentSegEl) {\n        _this.handleSegLeave(null, _this.currentSegEl);\n      }\n    };\n\n    _this.handleSegEnter = function (ev, segEl) {\n      if (getElSeg(segEl)) {\n        // TODO: better way to make sure not hovering over more+ link or its wrapper\n        _this.currentSegEl = segEl;\n\n        _this.triggerEvent('eventMouseEnter', ev, segEl);\n      }\n    };\n\n    _this.handleSegLeave = function (ev, segEl) {\n      if (_this.currentSegEl) {\n        _this.currentSegEl = null;\n\n        _this.triggerEvent('eventMouseLeave', ev, segEl);\n      }\n    };\n\n    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n    _this.handleSegEnter, _this.handleSegLeave);\n    return _this;\n  }\n\n  EventHovering.prototype.destroy = function () {\n    this.removeHoverListeners();\n  };\n\n  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n    var component = this.component;\n    var context = component.context;\n    var seg = getElSeg(segEl);\n\n    if (!ev || component.isValidSegDownEl(ev.target)) {\n      context.emitter.trigger(publicEvName, {\n        el: segEl,\n        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    }\n  };\n\n  return EventHovering;\n}(Interaction);\n\nvar CalendarContent = function (_super) {\n  tslib.__extends(CalendarContent, _super);\n\n  function CalendarContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildViewContext = memoize(buildViewContext);\n    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n    _this.buildToolbarProps = memoize(buildToolbarProps);\n    _this.headerRef = vdom_cjs.createRef();\n    _this.footerRef = vdom_cjs.createRef();\n    _this.interactionsStore = {}; // eslint-disable-next-line\n\n    _this.state = {\n      viewLabelId: getUniqueDomId()\n    }; // Component Registration\n    // -----------------------------------------------------------------------------------------------------------------\n\n    _this.registerInteractiveComponent = function (component, settingsInput) {\n      var settings = parseInteractionSettings(component, settingsInput);\n      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];\n      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n      var interactions = interactionClasses.map(function (TheInteractionClass) {\n        return new TheInteractionClass(settings);\n      });\n      _this.interactionsStore[component.uid] = interactions;\n      interactionSettingsStore[component.uid] = settings;\n    };\n\n    _this.unregisterInteractiveComponent = function (component) {\n      for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.destroy();\n      }\n\n      delete _this.interactionsStore[component.uid];\n      delete interactionSettingsStore[component.uid];\n    }; // Resizing\n    // -----------------------------------------------------------------------------------------------------------------\n\n\n    _this.resizeRunner = new DelayedRunner(function () {\n      _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n\n\n      _this.props.emitter.trigger('windowResize', {\n        view: _this.props.viewApi\n      });\n    });\n\n    _this.handleWindowResize = function (ev) {\n      var options = _this.props.options;\n\n      if (options.handleWindowResize && ev.target === window // avoid jqui events\n      ) {\n        _this.resizeRunner.request(options.windowResizeDelay);\n      }\n    };\n\n    return _this;\n  }\n  /*\n  renders INSIDE of an outer div\n  */\n\n\n  CalendarContent.prototype.render = function () {\n    var props = this.props;\n    var toolbarConfig = props.toolbarConfig,\n        options = props.options;\n    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n    props.viewTitle);\n    var viewVGrow = false;\n    var viewHeight = '';\n    var viewAspectRatio;\n\n    if (props.isHeightAuto || props.forPrint) {\n      viewHeight = '';\n    } else if (options.height != null) {\n      viewVGrow = true;\n    } else if (options.contentHeight != null) {\n      viewHeight = options.contentHeight;\n    } else {\n      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n    }\n\n    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n    var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';\n    return vdom_cjs.createElement(ViewContextType.Provider, {\n      value: viewContext\n    }, toolbarConfig.header && vdom_cjs.createElement(Toolbar, tslib.__assign({\n      ref: this.headerRef,\n      extraClassName: \"fc-header-toolbar\",\n      model: toolbarConfig.header,\n      titleId: viewLabelId\n    }, toolbarProps)), vdom_cjs.createElement(ViewContainer, {\n      liquid: viewVGrow,\n      height: viewHeight,\n      aspectRatio: viewAspectRatio,\n      labeledById: viewLabelId\n    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && vdom_cjs.createElement(Toolbar, tslib.__assign({\n      ref: this.footerRef,\n      extraClassName: \"fc-footer-toolbar\",\n      model: toolbarConfig.footer,\n      titleId: \"\"\n    }, toolbarProps)));\n  };\n\n  CalendarContent.prototype.componentDidMount = function () {\n    var props = this.props;\n    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {\n      return new CalendarInteractionClass(props);\n    });\n    window.addEventListener('resize', this.handleWindowResize);\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      propSetHandlers[propName](props[propName], props);\n    }\n  };\n\n  CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n    var props = this.props;\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      if (props[propName] !== prevProps[propName]) {\n        propSetHandlers[propName](props[propName], props);\n      }\n    }\n  };\n\n  CalendarContent.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.resizeRunner.clear();\n\n    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n      var interaction = _a[_i];\n      interaction.destroy();\n    }\n\n    this.props.emitter.trigger('_unmount');\n  };\n\n  CalendarContent.prototype.buildAppendContent = function () {\n    var props = this.props;\n    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {\n      return buildAppendContent(props);\n    });\n    return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([vdom_cjs.Fragment, {}], children));\n  };\n\n  CalendarContent.prototype.renderView = function (props) {\n    var pluginHooks = props.pluginHooks;\n    var viewSpec = props.viewSpec;\n    var viewProps = {\n      dateProfile: props.dateProfile,\n      businessHours: props.businessHours,\n      eventStore: props.renderableEventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isHeightAuto: props.isHeightAuto,\n      forPrint: props.forPrint\n    };\n    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n      var transformer = transformers_1[_i];\n\n      tslib.__assign(viewProps, transformer.transform(viewProps, props));\n    }\n\n    var ViewComponent = viewSpec.component;\n    return vdom_cjs.createElement(ViewComponent, tslib.__assign({}, viewProps));\n  };\n\n  return CalendarContent;\n}(PureComponent);\n\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n\n  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n  return {\n    title: title,\n    activeButton: viewSpec.type,\n    navUnit: viewSpec.singleUnit,\n    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n    isPrevEnabled: prevInfo.isValid,\n    isNextEnabled: nextInfo.isValid\n  };\n} // Plugin\n// -----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildViewPropTransformers(theClasses) {\n  return theClasses.map(function (TheClass) {\n    return new TheClass();\n  });\n}\n\nvar CalendarRoot = function (_super) {\n  tslib.__extends(CalendarRoot, _super);\n\n  function CalendarRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      forPrint: false\n    };\n\n    _this.handleBeforePrint = function () {\n      _this.setState({\n        forPrint: true\n      });\n    };\n\n    _this.handleAfterPrint = function () {\n      _this.setState({\n        forPrint: false\n      });\n    };\n\n    return _this;\n  }\n\n  CalendarRoot.prototype.render = function () {\n    var props = this.props;\n    var options = props.options;\n    var forPrint = this.state.forPrint;\n    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n    var height = !isHeightAuto && options.height != null ? options.height : '';\n    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', \"fc-direction-\" + options.direction, props.theme.getClass('root')];\n\n    if (!getCanVGrowWithinCell()) {\n      classNames.push('fc-liquid-hack');\n    }\n\n    return props.children(classNames, height, isHeightAuto, forPrint);\n  };\n\n  CalendarRoot.prototype.componentDidMount = function () {\n    var emitter = this.props.emitter;\n    emitter.on('_beforeprint', this.handleBeforePrint);\n    emitter.on('_afterprint', this.handleAfterPrint);\n  };\n\n  CalendarRoot.prototype.componentWillUnmount = function () {\n    var emitter = this.props.emitter;\n    emitter.off('_beforeprint', this.handleBeforePrint);\n    emitter.off('_afterprint', this.handleAfterPrint);\n  };\n\n  return CalendarRoot;\n}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined\n\n\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n  // if more than one week row, or if there are a lot of columns with not much space,\n  // put just the day numbers will be in each cell\n  if (!datesRepDistinctDays || dayCnt > 10) {\n    return createFormatter({\n      weekday: 'short'\n    }); // \"Sat\"\n  }\n\n  if (dayCnt > 1) {\n    return createFormatter({\n      weekday: 'short',\n      month: 'numeric',\n      day: 'numeric',\n      omitCommas: true\n    }); // \"Sat 11/12\"\n  }\n\n  return createFormatter({\n    weekday: 'long'\n  }); // \"Saturday\"\n}\n\nvar CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n\nfunction renderInner$1(hookProps) {\n  return hookProps.text;\n}\n\nvar TableDateCell = function (_super) {\n  tslib.__extends(TableDateCell, _super);\n\n  function TableDateCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDateCell.prototype.render = function () {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        theme = _a.theme,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink\n\n    var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n\n    var hookProps = tslib.__assign(tslib.__assign(tslib.__assign({\n      date: dateEnv.toDate(date),\n      view: viewApi\n    }, props.extraHookProps), {\n      text: text\n    }), dayMeta);\n\n    return vdom_cjs.createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return vdom_cjs.createElement(\"th\", tslib.__assign({\n        ref: rootElRef,\n        role: \"columnheader\",\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, !dayMeta.isDisabled && vdom_cjs.createElement(\"a\", tslib.__assign({\n        ref: innerElRef,\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')\n      }, navLinkAttrs), innerContent)));\n    });\n  };\n\n  return TableDateCell;\n}(BaseComponent);\n\nvar WEEKDAY_FORMAT = createFormatter({\n  weekday: 'long'\n});\n\nvar TableDowCell = function (_super) {\n  tslib.__extends(TableDowCell, _super);\n\n  function TableDowCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDowCell.prototype.render = function () {\n    var props = this.props;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        viewApi = _a.viewApi,\n        options = _a.options;\n    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n\n    var dateMeta = {\n      dow: props.dow,\n      isDisabled: false,\n      isFuture: false,\n      isPast: false,\n      isToday: false,\n      isOther: false\n    };\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n    var text = dateEnv.format(date, props.dayHeaderFormat);\n\n    var hookProps = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({\n      // TODO: make this public?\n      date: date\n    }, dateMeta), {\n      view: viewApi\n    }), props.extraHookProps), {\n      text: text\n    });\n\n    return vdom_cjs.createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return vdom_cjs.createElement(\"th\", tslib.__assign({\n        ref: rootElRef,\n        role: \"columnheader\",\n        className: classNames.concat(customClassNames).join(' '),\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, vdom_cjs.createElement(\"a\", {\n        \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT),\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return TableDowCell;\n}(BaseComponent);\n\nvar NowTimer = function (_super) {\n  tslib.__extends(NowTimer, _super);\n\n  function NowTimer(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n    _this.initialNowQueriedMs = new Date().valueOf();\n    _this.state = _this.computeTiming().currentState;\n    return _this;\n  }\n\n  NowTimer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return props.children(state.nowDate, state.todayRange);\n  };\n\n  NowTimer.prototype.componentDidMount = function () {\n    this.setTimeout();\n  };\n\n  NowTimer.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.unit !== this.props.unit) {\n      this.clearTimeout();\n      this.setTimeout();\n    }\n  };\n\n  NowTimer.prototype.componentWillUnmount = function () {\n    this.clearTimeout();\n  };\n\n  NowTimer.prototype.computeTiming = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n    // ensure no longer than a day\n\n    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n    return {\n      currentState: {\n        nowDate: currentUnitStart,\n        todayRange: buildDayRange(currentUnitStart)\n      },\n      nextState: {\n        nowDate: nextUnitStart,\n        todayRange: buildDayRange(nextUnitStart)\n      },\n      waitMs: waitMs\n    };\n  };\n\n  NowTimer.prototype.setTimeout = function () {\n    var _this = this;\n\n    var _a = this.computeTiming(),\n        nextState = _a.nextState,\n        waitMs = _a.waitMs;\n\n    this.timeoutId = setTimeout(function () {\n      _this.setState(nextState, function () {\n        _this.setTimeout();\n      });\n    }, waitMs);\n  };\n\n  NowTimer.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  };\n\n  NowTimer.contextType = ViewContextType;\n  return NowTimer;\n}(vdom_cjs.Component);\n\nfunction buildDayRange(date) {\n  var start = startOfDay(date);\n  var end = addDays(start, 1);\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DayHeader = function (_super) {\n  tslib.__extends(DayHeader, _super);\n\n  function DayHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    return _this;\n  }\n\n  DayHeader.prototype.render = function () {\n    var context = this.context;\n    var _a = this.props,\n        dates = _a.dates,\n        dateProfile = _a.dateProfile,\n        datesRepDistinctDays = _a.datesRepDistinctDays,\n        renderIntro = _a.renderIntro;\n    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n    return vdom_cjs.createElement(NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return vdom_cjs.createElement(\"tr\", {\n        role: \"row\"\n      }, renderIntro && renderIntro('day'), dates.map(function (date) {\n        return datesRepDistinctDays ? vdom_cjs.createElement(TableDateCell, {\n          key: date.toISOString(),\n          date: date,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          colCnt: dates.length,\n          dayHeaderFormat: dayHeaderFormat\n        }) : vdom_cjs.createElement(TableDowCell, {\n          key: date.getUTCDay(),\n          dow: date.getUTCDay(),\n          dayHeaderFormat: dayHeaderFormat\n        });\n      }));\n    });\n  };\n\n  return DayHeader;\n}(BaseComponent);\n\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nvar DaySeriesModel = function () {\n  function DaySeriesModel(range, dateProfileGenerator) {\n    var date = range.start;\n    var end = range.end;\n    var indices = [];\n    var dates = [];\n    var dayIndex = -1;\n\n    while (date < end) {\n      // loop each day from start to end\n      if (dateProfileGenerator.isHiddenDay(date)) {\n        indices.push(dayIndex + 0.5); // mark that it's between indices\n      } else {\n        dayIndex += 1;\n        indices.push(dayIndex);\n        dates.push(date);\n      }\n\n      date = addDays(date, 1);\n    }\n\n    this.dates = dates;\n    this.indices = indices;\n    this.cnt = dates.length;\n  }\n\n  DaySeriesModel.prototype.sliceRange = function (range) {\n    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n\n    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n\n    var clippedFirstIndex = Math.max(0, firstIndex);\n    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices\n\n    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n\n    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n\n    if (clippedFirstIndex <= clippedLastIndex) {\n      return {\n        firstIndex: clippedFirstIndex,\n        lastIndex: clippedLastIndex,\n        isStart: firstIndex === clippedFirstIndex,\n        isEnd: lastIndex === clippedLastIndex\n      };\n    }\n\n    return null;\n  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n  // If before the first offset, returns a negative number.\n  // If after the last offset, returns an offset past the last cell offset.\n  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\n\n  DaySeriesModel.prototype.getDateDayIndex = function (date) {\n    var indices = this.indices;\n    var dayOffset = Math.floor(diffDays(this.dates[0], date));\n\n    if (dayOffset < 0) {\n      return indices[0] - 1;\n    }\n\n    if (dayOffset >= indices.length) {\n      return indices[indices.length - 1] + 1;\n    }\n\n    return indices[dayOffset];\n  };\n\n  return DaySeriesModel;\n}();\n\nvar DayTableModel = function () {\n  function DayTableModel(daySeries, breakOnWeeks) {\n    var dates = daySeries.dates;\n    var daysPerRow;\n    var firstDay;\n    var rowCnt;\n\n    if (breakOnWeeks) {\n      // count columns until the day-of-week repeats\n      firstDay = dates[0].getUTCDay();\n\n      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n        if (dates[daysPerRow].getUTCDay() === firstDay) {\n          break;\n        }\n      }\n\n      rowCnt = Math.ceil(dates.length / daysPerRow);\n    } else {\n      rowCnt = 1;\n      daysPerRow = dates.length;\n    }\n\n    this.rowCnt = rowCnt;\n    this.colCnt = daysPerRow;\n    this.daySeries = daySeries;\n    this.cells = this.buildCells();\n    this.headerDates = this.buildHeaderDates();\n  }\n\n  DayTableModel.prototype.buildCells = function () {\n    var rows = [];\n\n    for (var row = 0; row < this.rowCnt; row += 1) {\n      var cells = [];\n\n      for (var col = 0; col < this.colCnt; col += 1) {\n        cells.push(this.buildCell(row, col));\n      }\n\n      rows.push(cells);\n    }\n\n    return rows;\n  };\n\n  DayTableModel.prototype.buildCell = function (row, col) {\n    var date = this.daySeries.dates[row * this.colCnt + col];\n    return {\n      key: date.toISOString(),\n      date: date\n    };\n  };\n\n  DayTableModel.prototype.buildHeaderDates = function () {\n    var dates = [];\n\n    for (var col = 0; col < this.colCnt; col += 1) {\n      dates.push(this.cells[0][col].date);\n    }\n\n    return dates;\n  };\n\n  DayTableModel.prototype.sliceRange = function (range) {\n    var colCnt = this.colCnt;\n    var seriesSeg = this.daySeries.sliceRange(range);\n    var segs = [];\n\n    if (seriesSeg) {\n      var firstIndex = seriesSeg.firstIndex,\n          lastIndex = seriesSeg.lastIndex;\n      var index = firstIndex;\n\n      while (index <= lastIndex) {\n        var row = Math.floor(index / colCnt);\n        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n        segs.push({\n          row: row,\n          firstCol: index % colCnt,\n          lastCol: (nextIndex - 1) % colCnt,\n          isStart: seriesSeg.isStart && index === firstIndex,\n          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n        });\n        index = nextIndex;\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTableModel;\n}();\n\nvar Slicer = function () {\n  function Slicer() {\n    this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n    this.sliceDateSelection = memoize(this._sliceDateSpan);\n    this.sliceEventStore = memoize(this._sliceEventStore);\n    this.sliceEventDrag = memoize(this._sliceInteraction);\n    this.sliceEventResize = memoize(this._sliceInteraction);\n    this.forceDayIfListItem = false; // hack\n  }\n\n  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    var eventUiBases = props.eventUiBases;\n    var eventSegs = this.sliceEventStore.apply(this, tslib.__spreadArray([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n    return {\n      dateSelectionSegs: this.sliceDateSelection.apply(this, tslib.__spreadArray([props.dateSelection, eventUiBases, context], extraArgs)),\n      businessHourSegs: this.sliceBusinessHours.apply(this, tslib.__spreadArray([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n      fgEventSegs: eventSegs.fg,\n      bgEventSegs: eventSegs.bg,\n      eventDrag: this.sliceEventDrag.apply(this, tslib.__spreadArray([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventResize: this.sliceEventResize.apply(this, tslib.__spreadArray([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventSelection: props.eventSelection\n    }; // TODO: give interactionSegs?\n  };\n\n  Slicer.prototype.sliceNowDate = function ( // does not memoize\n  date, context) {\n    var extraArgs = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      extraArgs[_i - 2] = arguments[_i];\n    }\n\n    return this._sliceDateSpan.apply(this, tslib.__spreadArray([{\n      range: {\n        start: date,\n        end: addMs(date, 1)\n      },\n      allDay: false\n    }, {}, context], extraArgs));\n  };\n\n  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!businessHours) {\n      return [];\n    }\n\n    return this._sliceEventStore.apply(this, tslib.__spreadArray([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;\n  };\n\n  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (eventStore) {\n      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n      return {\n        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n      };\n    }\n\n    return {\n      bg: [],\n      fg: []\n    };\n  };\n\n  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!interaction) {\n      return null;\n    }\n\n    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n    return {\n      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n      affectedInstances: interaction.affectedEvents.instances,\n      isEvent: interaction.isEvent\n    };\n  };\n\n  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n    var extraArgs = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      extraArgs[_i - 3] = arguments[_i];\n    }\n\n    if (!dateSpan) {\n      return [];\n    }\n\n    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n    var segs = this.sliceRange.apply(this, tslib.__spreadArray([dateSpan.range], extraArgs));\n\n    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n      var seg = segs_1[_a];\n      seg.eventRange = eventRange;\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n\n    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n      dateRange = {\n        start: dateRange.start,\n        end: addDays(dateRange.start, 1)\n      };\n    }\n\n    var segs = this.sliceRange.apply(this, tslib.__spreadArray([dateRange], extraArgs));\n\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      seg.eventRange = eventRange;\n      seg.isStart = eventRange.isStart && seg.isStart;\n      seg.isEnd = eventRange.isEnd && seg.isEnd;\n    }\n\n    return segs;\n  };\n\n  return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\n\n\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n  var range = dateProfile.activeRange;\n\n  if (isComponentAllDay) {\n    return range;\n  }\n\n  return {\n    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day\n\n  };\n} // high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionValid(interaction, dateProfile, context) {\n  var instances = interaction.mutatedEvents.instances;\n\n  for (var instanceId in instances) {\n    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n      return false;\n    }\n  }\n\n  return isNewPropsValid({\n    eventDrag: interaction\n  }, context); // HACK: the eventDrag props is used for ALL interactions\n}\n\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n    return false;\n  }\n\n  return isNewPropsValid({\n    dateSelection: dateSelection\n  }, context);\n}\n\nfunction isNewPropsValid(newProps, context) {\n  var calendarState = context.getCurrentData();\n\n  var props = tslib.__assign({\n    businessHours: calendarState.businessHours,\n    dateSelection: '',\n    eventStore: calendarState.eventStore,\n    eventUiBases: calendarState.eventUiBases,\n    eventSelection: '',\n    eventDrag: null,\n    eventResize: null\n  }, newProps);\n\n  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\n\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n  if (dateSpanMeta === void 0) {\n    dateSpanMeta = {};\n  }\n\n  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  return true;\n} // Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var currentState = context.getCurrentData();\n  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n\n  var subjectEventStore = interaction.mutatedEvents;\n  var subjectDefs = subjectEventStore.defs;\n  var subjectInstances = subjectEventStore.instances;\n  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n    '': currentState.selectionConfig\n  });\n\n  if (filterConfig) {\n    subjectConfigs = mapHash(subjectConfigs, filterConfig);\n  } // exclude the subject events. TODO: exclude defs too?\n\n\n  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n  var otherDefs = otherEventStore.defs;\n  var otherInstances = otherEventStore.instances;\n  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n\n  for (var subjectInstanceId in subjectInstances) {\n    var subjectInstance = subjectInstances[subjectInstanceId];\n    var subjectRange = subjectInstance.range;\n    var subjectConfig = subjectConfigs[subjectInstance.defId];\n    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint\n\n    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n      return false;\n    } // overlap\n\n\n    var eventOverlap = context.options.eventOverlap;\n    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n\n    for (var otherInstanceId in otherInstances) {\n      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate\n\n      if (rangesIntersect(subjectRange, otherInstance.range)) {\n        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a \"real\" event\n\n        if (otherOverlap === false && interaction.isEvent) {\n          return false;\n        }\n\n        if (subjectConfig.overlap === false) {\n          return false;\n        }\n\n        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n        new EventApi(context, subjectDef, subjectInstance))) {\n          return false;\n        }\n      }\n    } // allow (a function)\n\n\n    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n\n    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n      var subjectAllow = _a[_i];\n\n      var subjectDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), {\n        range: subjectInstance.range,\n        allDay: subjectDef.allDay\n      });\n\n      var origDef = calendarEventStore.defs[subjectDef.defId];\n      var origInstance = calendarEventStore.instances[subjectInstanceId];\n      var eventApi = void 0;\n\n      if (origDef) {\n        // was previously in the calendar\n        eventApi = new EventApi(context, origDef, origInstance);\n      } else {\n        // was an external event\n        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n      }\n\n      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var relevantEventStore = state.eventStore;\n  var relevantDefs = relevantEventStore.defs;\n  var relevantInstances = relevantEventStore.instances;\n  var selection = state.dateSelection;\n  var selectionRange = selection.range;\n  var selectionConfig = context.getCurrentData().selectionConfig;\n\n  if (filterConfig) {\n    selectionConfig = filterConfig(selectionConfig);\n  } // constraint\n\n\n  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n    return false;\n  } // overlap\n\n\n  var selectOverlap = context.options.selectOverlap;\n  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n\n  for (var relevantInstanceId in relevantInstances) {\n    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate\n\n    if (rangesIntersect(selectionRange, relevantInstance.range)) {\n      if (selectionConfig.overlap === false) {\n        return false;\n      }\n\n      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n        return false;\n      }\n    }\n  } // allow (a function)\n\n\n  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n    var selectionAllow = _a[_i];\n\n    var fullDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), selection);\n\n    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n      return false;\n    }\n  }\n\n  return true;\n} // Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n    var constraint = constraints_1[_i];\n\n    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext) {\n  if (constraint === 'businessHours') {\n    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n  }\n\n  if (typeof constraint === 'string') {\n    // an group ID\n    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n      return eventDef.groupId === constraint;\n    }));\n  }\n\n  if (typeof constraint === 'object' && constraint) {\n    // non-null object\n    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n  }\n\n  return []; // if it's false\n} // TODO: move to event-store file?\n\n\nfunction eventStoreToRanges(eventStore) {\n  var instances = eventStore.instances;\n  var ranges = [];\n\n  for (var instanceId in instances) {\n    ranges.push(instances[instanceId].range);\n  }\n\n  return ranges;\n} // TODO: move to geom file?\n\n\nfunction anyRangesContainRange(outerRanges, innerRange) {\n  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n    var outerRange = outerRanges_1[_i];\n\n    if (rangeContainsRange(outerRange, innerRange)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n\nvar Scroller = function (_super) {\n  tslib.__extends(Scroller, _super);\n\n  function Scroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  Scroller.prototype.render = function () {\n    var props = this.props;\n    var liquid = props.liquid,\n        liquidIsAbsolute = props.liquidIsAbsolute;\n    var isAbsolute = liquid && liquidIsAbsolute;\n    var className = ['fc-scroller'];\n\n    if (liquid) {\n      if (liquidIsAbsolute) {\n        className.push('fc-scroller-liquid-absolute');\n      } else {\n        className.push('fc-scroller-liquid');\n      }\n    }\n\n    return vdom_cjs.createElement(\"div\", {\n      ref: this.handleEl,\n      className: className.join(' '),\n      style: {\n        overflowX: props.overflowX,\n        overflowY: props.overflowY,\n        left: isAbsolute && -(props.overcomeLeft || 0) || '',\n        right: isAbsolute && -(props.overcomeRight || 0) || '',\n        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n        maxHeight: props.maxHeight || ''\n      }\n    }, props.children);\n  };\n\n  Scroller.prototype.needsXScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return false;\n    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().width > realClientWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.needsYScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return false;\n    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().height > realClientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.getXScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return 0;\n    }\n\n    return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  Scroller.prototype.getYScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return 0;\n    }\n\n    return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\n\n\nvar RefMap = function () {\n  function RefMap(masterCallback) {\n    var _this = this;\n\n    this.masterCallback = masterCallback;\n    this.currentMap = {};\n    this.depths = {};\n    this.callbackMap = {};\n\n    this.handleValue = function (val, key) {\n      var _a = _this,\n          depths = _a.depths,\n          currentMap = _a.currentMap;\n      var removed = false;\n      var added = false;\n\n      if (val !== null) {\n        // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n        removed = key in currentMap;\n        currentMap[key] = val;\n        depths[key] = (depths[key] || 0) + 1;\n        added = true;\n      } else {\n        depths[key] -= 1;\n\n        if (!depths[key]) {\n          delete currentMap[key];\n          delete _this.callbackMap[key];\n          removed = true;\n        }\n      }\n\n      if (_this.masterCallback) {\n        if (removed) {\n          _this.masterCallback(null, String(key));\n        }\n\n        if (added) {\n          _this.masterCallback(val, String(key));\n        }\n      }\n    };\n  }\n\n  RefMap.prototype.createRef = function (key) {\n    var _this = this;\n\n    var refCallback = this.callbackMap[key];\n\n    if (!refCallback) {\n      refCallback = this.callbackMap[key] = function (val) {\n        _this.handleValue(val, String(key));\n      };\n    }\n\n    return refCallback;\n  }; // TODO: check callers that don't care about order. should use getAll instead\n  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n\n\n  RefMap.prototype.collect = function (startIndex, endIndex, step) {\n    return collectFromHash(this.currentMap, startIndex, endIndex, step);\n  };\n\n  RefMap.prototype.getAll = function () {\n    return hashValuesToArray(this.currentMap);\n  };\n\n  return RefMap;\n}();\n\nfunction computeShrinkWidth(chunkEls) {\n  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n  var largestWidth = 0;\n\n  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n    var shrinkCell = shrinkCells_1[_i];\n    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n  }\n\n  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\n\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\n\nfunction getAllowYScrolling(props, sectionConfig) {\n  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n} // TODO: ONLY use `arg`. force out internal function to use same API\n\n\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n  var expandRows = arg.expandRows;\n  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : vdom_cjs.createElement('table', {\n    role: 'presentation',\n    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),\n    style: {\n      minWidth: arg.tableMinWidth,\n      width: arg.clientWidth,\n      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height\n\n    }\n  }, arg.tableColGroupNode, vdom_cjs.createElement(isHeader ? 'thead' : 'tbody', {\n    role: 'presentation'\n  }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n  return content;\n}\n\nfunction isColPropsEqual(cols0, cols1) {\n  return isArraysEqual(cols0, cols1, isPropsEqual);\n}\n\nfunction renderMicroColGroup(cols, shrinkWidth) {\n  var colNodes = [];\n  /*\n  for ColProps with spans, it would have been great to make a single <col span=\"\">\n  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n  SOLUTION: making individual <col> elements makes Chrome behave.\n  */\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var colProps = cols_1[_i];\n    var span = colProps.span || 1;\n\n    for (var i = 0; i < span; i += 1) {\n      colNodes.push(vdom_cjs.createElement(\"col\", {\n        style: {\n          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n          minWidth: colProps.minWidth || ''\n        }\n      }));\n    }\n  }\n\n  return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['colgroup', {}], colNodes));\n}\n\nfunction sanitizeShrinkWidth(shrinkWidth) {\n  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n  4 accounts for 2 2-pixel borders. TODO: better solution? */\n  return shrinkWidth == null ? 4 : shrinkWidth;\n}\n\nfunction hasShrinkWidth(cols) {\n  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n    var col = cols_2[_i];\n\n    if (col.width === 'shrink') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScrollGridClassNames(liquid, context) {\n  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];\n\n  if (liquid) {\n    classNames.push('fc-scrollgrid-liquid');\n  }\n\n  return classNames;\n}\n\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n  var classNames = ['fc-scrollgrid-section', \"fc-scrollgrid-section-\" + sectionConfig.type, sectionConfig.className // used?\n  ];\n\n  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n    classNames.push('fc-scrollgrid-section-liquid');\n  }\n\n  if (sectionConfig.isSticky) {\n    classNames.push('fc-scrollgrid-section-sticky');\n  }\n\n  return classNames;\n}\n\nfunction renderScrollShim(arg) {\n  return vdom_cjs.createElement(\"div\", {\n    className: \"fc-scrollgrid-sticky-shim\",\n    style: {\n      width: arg.clientWidth,\n      minWidth: arg.tableMinWidth\n    }\n  });\n}\n\nfunction getStickyHeaderDates(options) {\n  var stickyHeaderDates = options.stickyHeaderDates;\n\n  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyHeaderDates;\n}\n\nfunction getStickyFooterScrollbar(options) {\n  var stickyFooterScrollbar = options.stickyFooterScrollbar;\n\n  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyFooterScrollbar;\n}\n\nvar SimpleScrollGrid = function (_super) {\n  tslib.__extends(SimpleScrollGrid, _super);\n\n  function SimpleScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processCols = memoize(function (a) {\n      return a;\n    }, isColPropsEqual); // so we get same `cols` props every time\n    // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.renderMicroColGroup = memoize(renderMicroColGroup);\n    _this.scrollerRefs = new RefMap();\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.state = {\n      shrinkWidth: null,\n      forceYScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {}\n    }; // TODO: can do a really simple print-view. dont need to join rows\n\n    _this.handleSizing = function () {\n      _this.setState(tslib.__assign({\n        shrinkWidth: _this.computeShrinkWidth()\n      }, _this.computeScrollerDims()));\n    };\n\n    return _this;\n  }\n\n  SimpleScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var sectionConfigs = props.sections || [];\n    var cols = this.processCols(props.cols);\n    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    if (props.collapsibleWidth) {\n      classNames.push('fc-scrollgrid-collapsible');\n    } // TODO: make DRY\n\n\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n      configI += 1;\n    } // firefox bug: when setting height on table and there is a thead or tfoot,\n    // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n    // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n    // if so, use a simpler dom structure, jam everything into a lone tbody.\n\n\n    var isBuggy = !getCanVGrowWithinCell();\n    var roleAttrs = {\n      role: 'rowgroup'\n    };\n    return vdom_cjs.createElement('table', {\n      role: 'grid',\n      className: classNames.join(' '),\n      style: {\n        height: props.height\n      }\n    }, Boolean(!isBuggy && headSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(['tfoot', roleAttrs], footSectionNodes)), isBuggy && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));\n  };\n\n  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode, isHeader) {\n    if ('outerContent' in sectionConfig) {\n      return vdom_cjs.createElement(vdom_cjs.Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return vdom_cjs.createElement(\"tr\", {\n      key: sectionConfig.key,\n      role: \"presentation\",\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n  };\n\n  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n    if ('outerContent' in chunkConfig) {\n      return chunkConfig.outerContent;\n    }\n\n    var props = this.props;\n    var _a = this.state,\n        forceYScrollbars = _a.forceYScrollbars,\n        scrollerClientWidths = _a.scrollerClientWidths,\n        scrollerClientHeights = _a.scrollerClientHeights;\n    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n\n    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?\n    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n\n    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n    var sectionKey = sectionConfig.key;\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: '',\n      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n      expandRows: sectionConfig.expandRows,\n      syncRowHeights: false,\n      rowSyncHeights: [],\n      reportRowHeightChange: function () {}\n    }, isHeader);\n    return vdom_cjs.createElement(isHeader ? 'th' : 'td', {\n      ref: chunkConfig.elRef,\n      role: 'presentation'\n    }, vdom_cjs.createElement(\"div\", {\n      className: \"fc-scroller-harness\" + (isLiquid ? ' fc-scroller-harness-liquid' : '')\n    }, vdom_cjs.createElement(Scroller, {\n      ref: this.scrollerRefs.createRef(sectionKey),\n      elRef: this.scrollerElRefs.createRef(sectionKey),\n      overflowY: overflowY,\n      overflowX: !props.liquid ? 'visible' : 'hidden'\n      /* natural height? */\n      ,\n      maxHeight: sectionConfig.maxHeight,\n      liquid: isLiquid,\n      liquidIsAbsolute // because its within a harness\n      : true\n    }, content)));\n  };\n\n  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var section = getSectionByKey(this.props.sections, key);\n\n    if (section) {\n      setRef(section.chunk.scrollerElRef, scrollerEl);\n    }\n  };\n\n  SimpleScrollGrid.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.componentDidUpdate = function () {\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing();\n  };\n\n  SimpleScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n  };\n\n  SimpleScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this,\n        scrollerRefs = _a.scrollerRefs,\n        scrollerElRefs = _a.scrollerElRefs;\n\n    var forceYScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionKey in scrollerRefs.currentMap) {\n      var scroller = scrollerRefs.currentMap[sectionKey];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {\n      var section = _b[_i];\n      var sectionKey = section.key;\n      var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n\n      if (scrollerEl) {\n        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n\n        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n        : 0));\n        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  return SimpleScrollGrid;\n}(BaseComponent);\n\nSimpleScrollGrid.addStateEquality({\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction getSectionByKey(sections, key) {\n  for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {\n    var section = sections_1[_i];\n\n    if (section.key === key) {\n      return section;\n    }\n  }\n\n  return null;\n}\n\nvar EventRoot = function (_super) {\n  tslib.__extends(EventRoot, _super);\n\n  function EventRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = vdom_cjs.createRef();\n    return _this;\n  }\n\n  EventRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var seg = props.seg;\n    var eventRange = seg.eventRange;\n    var ui = eventRange.ui;\n    var hookProps = {\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      view: context.viewApi,\n      timeText: props.timeText,\n      textColor: ui.textColor,\n      backgroundColor: ui.backgroundColor,\n      borderColor: ui.borderColor,\n      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n      isStart: Boolean(seg.isStart),\n      isEnd: Boolean(seg.isEnd),\n      isPast: Boolean(props.isPast),\n      isFuture: Boolean(props.isFuture),\n      isToday: Boolean(props.isToday),\n      isSelected: Boolean(props.isSelected),\n      isDragging: Boolean(props.isDragging),\n      isResizing: Boolean(props.isResizing)\n    };\n    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n    return vdom_cjs.createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.eventClassNames,\n      content: options.eventContent,\n      defaultContent: props.defaultContent,\n      didMount: options.eventDidMount,\n      willUnmount: options.eventWillUnmount,\n      elRef: this.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n    });\n  };\n\n  EventRoot.prototype.componentDidMount = function () {\n    setElSeg(this.elRef.current, this.props.seg);\n  };\n  /*\n  need to re-assign seg to the element if seg changes, even if the element is the same\n  */\n\n\n  EventRoot.prototype.componentDidUpdate = function (prevProps) {\n    var seg = this.props.seg;\n\n    if (seg !== prevProps.seg) {\n      setElSeg(this.elRef.current, seg);\n    }\n  };\n\n  return EventRoot;\n}(BaseComponent); // should not be a purecomponent\n\n\nvar StandardEvent = function (_super) {\n  tslib.__extends(StandardEvent, _super);\n\n  function StandardEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StandardEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n    return vdom_cjs.createElement(EventRoot, {\n      seg: seg,\n      timeText: timeText,\n      disableDragging: props.disableDragging,\n      disableResizing: props.disableResizing,\n      defaultContent: props.defaultContent || renderInnerContent$1,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return vdom_cjs.createElement(\"a\", tslib.__assign({\n        className: props.extraClassNames.concat(classNames).join(' '),\n        style: {\n          borderColor: hookProps.borderColor,\n          backgroundColor: hookProps.backgroundColor\n        },\n        ref: rootElRef\n      }, getSegAnchorAttrs(seg, context)), vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-main\",\n        ref: innerElRef,\n        style: {\n          color: hookProps.textColor\n        }\n      }, innerContent), hookProps.isStartResizable && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-start\"\n      }), hookProps.isEndResizable && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-end\"\n      }));\n    });\n  };\n\n  return StandardEvent;\n}(BaseComponent);\n\nfunction renderInnerContent$1(innerProps) {\n  return vdom_cjs.createElement(\"div\", {\n    className: \"fc-event-main-frame\"\n  }, innerProps.timeText && vdom_cjs.createElement(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), vdom_cjs.createElement(\"div\", {\n    className: \"fc-event-title-container\"\n  }, vdom_cjs.createElement(\"div\", {\n    className: \"fc-event-title fc-sticky\"\n  }, innerProps.event.title || vdom_cjs.createElement(vdom_cjs.Fragment, null, \"\\u00A0\"))));\n}\n\nvar NowIndicatorRoot = function (props) {\n  return vdom_cjs.createElement(ViewContextType.Consumer, null, function (context) {\n    var options = context.options;\n    var hookProps = {\n      isAxis: props.isAxis,\n      date: context.dateEnv.toDate(props.date),\n      view: context.viewApi\n    };\n    return vdom_cjs.createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.nowIndicatorClassNames,\n      content: options.nowIndicatorContent,\n      didMount: options.nowIndicatorDidMount,\n      willUnmount: options.nowIndicatorWillUnmount\n    }, props.children);\n  });\n};\n\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\n\nvar DayCellContent = function (_super) {\n  tslib.__extends(DayCellContent, _super);\n\n  function DayCellContent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayCellContent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = refineDayCellHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    return vdom_cjs.createElement(ContentHook, {\n      hookProps: hookProps,\n      content: options.dayCellContent,\n      defaultContent: props.defaultContent\n    }, props.children);\n  };\n\n  return DayCellContent;\n}(BaseComponent);\n\nfunction refineDayCellHookProps(raw) {\n  var date = raw.date,\n      dateEnv = raw.dateEnv;\n  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n  return tslib.__assign(tslib.__assign(tslib.__assign({\n    date: dateEnv.toDate(date),\n    view: raw.viewApi\n  }, dayMeta), {\n    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''\n  }), raw.extraProps);\n}\n\nvar DayCellRoot = function (_super) {\n  tslib.__extends(DayCellRoot, _super);\n\n  function DayCellRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  DayCellRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = this.refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n    : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n    var dataAttrs = hookProps.isDisabled ? {} : {\n      'data-date': formatDayString(props.date)\n    };\n    return vdom_cjs.createElement(MountHook, {\n      hookProps: hookProps,\n      didMount: options.dayCellDidMount,\n      willUnmount: options.dayCellWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n    });\n  };\n\n  return DayCellRoot;\n}(BaseComponent);\n\nfunction renderFill(fillType) {\n  return vdom_cjs.createElement(\"div\", {\n    className: \"fc-\" + fillType\n  });\n}\n\nvar BgEvent = function (props) {\n  return vdom_cjs.createElement(EventRoot, {\n    defaultContent: renderInnerContent,\n    seg: props.seg\n    /* uselesss i think */\n    ,\n    timeText: \"\",\n    disableDragging: true,\n    disableResizing: true,\n    isDragging: false,\n    isResizing: false,\n    isDateSelecting: false,\n    isSelected: false,\n    isPast: props.isPast,\n    isFuture: props.isFuture,\n    isToday: props.isToday\n  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n    return vdom_cjs.createElement(\"div\", {\n      ref: rootElRef,\n      className: ['fc-bg-event'].concat(classNames).join(' '),\n      style: {\n        backgroundColor: hookProps.backgroundColor\n      }\n    }, innerContent);\n  });\n};\n\nfunction renderInnerContent(props) {\n  var title = props.event.title;\n  return title && vdom_cjs.createElement(\"div\", {\n    className: \"fc-event-title\"\n  }, props.event.title);\n}\n\nvar WeekNumberRoot = function (props) {\n  return vdom_cjs.createElement(ViewContextType.Consumer, null, function (context) {\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var date = props.date;\n    var format = options.weekNumberFormat || props.defaultFormat;\n    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n\n    var text = dateEnv.format(date, format);\n    var hookProps = {\n      num: num,\n      text: text,\n      date: date\n    };\n    return vdom_cjs.createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.weekNumberClassNames,\n      content: options.weekNumberContent,\n      defaultContent: renderInner,\n      didMount: options.weekNumberDidMount,\n      willUnmount: options.weekNumberWillUnmount\n    }, props.children);\n  });\n};\n\nfunction renderInner(innerProps) {\n  return innerProps.text;\n}\n\nvar PADDING_FROM_VIEWPORT = 10;\n\nvar Popover = function (_super) {\n  tslib.__extends(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      titleId: getUniqueDomId()\n    };\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMouseDown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      var target = getEventTargetViaRoot(ev);\n\n      if (!_this.rootEl.contains(target)) {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleDocumentKeyDown = function (ev) {\n      if (ev.key === 'Escape') {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var _a = this.context,\n        theme = _a.theme,\n        options = _a.options;\n\n    var _b = this,\n        props = _b.props,\n        state = _b.state;\n\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return vdom_cjs.createPortal(vdom_cjs.createElement(\"div\", tslib.__assign({\n      id: props.id,\n      className: classNames.join(' '),\n      \"aria-labelledby\": state.titleId\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), vdom_cjs.createElement(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, vdom_cjs.createElement(\"span\", {\n      className: \"fc-popover-title\",\n      id: state.titleId\n    }, props.title), vdom_cjs.createElement(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      title: options.closeHint,\n      onClick: this.handleCloseClick\n    })), vdom_cjs.createElement(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children)), props.parentEl);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMouseDown);\n    document.addEventListener('keydown', this.handleDocumentKeyDown);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n    document.removeEventListener('keydown', this.handleDocumentKeyDown);\n  };\n\n  Popover.prototype.updateSize = function () {\n    var isRtl = this.context.isRtl;\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        alignGridTop = _a.alignGridTop;\n    var rootEl = this.rootEl;\n    var alignmentRect = computeClippedClientRect(alignmentEl);\n\n    if (alignmentRect) {\n      var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport\n\n      var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n      var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain\n\n      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n      var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n      applyStyle(rootEl, {\n        top: popoverTop - origin_1.top,\n        left: popoverLeft - origin_1.left\n      });\n    }\n  };\n\n  return Popover;\n}(BaseComponent);\n\nvar MorePopover = function (_super) {\n  tslib.__extends(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          useEventCenter: false\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var startDate = props.startDate,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile;\n    var title = dateEnv.format(startDate, options.dayPopoverFormat);\n    return vdom_cjs.createElement(DayCellRoot, {\n      date: startDate,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.handleRootEl\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return vdom_cjs.createElement(Popover, {\n        elRef: rootElRef,\n        id: props.id,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs\n        /* TODO: make these time-based when not whole-day? */\n        ,\n        parentEl: props.parentEl,\n        alignmentEl: props.alignmentEl,\n        alignGridTop: props.alignGridTop,\n        onClose: props.onClose\n      }, vdom_cjs.createElement(DayCellContent, {\n        date: startDate,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && vdom_cjs.createElement(\"div\", {\n          className: \"fc-more-popover-misc\",\n          ref: innerElRef\n        }, innerContent);\n      }), props.children);\n    });\n  };\n\n  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var _a = this,\n        rootEl = _a.rootEl,\n        props = _a.props;\n\n    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n      return {\n        dateProfile: props.dateProfile,\n        dateSpan: tslib.__assign({\n          allDay: true,\n          range: {\n            start: props.startDate,\n            end: props.endDate\n          }\n        }, props.extraDateSpan),\n        dayEl: rootEl,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1 // important when comparing with hits from other components\n\n      };\n    }\n\n    return null;\n  };\n\n  return MorePopover;\n}(DateComponent);\n\nvar MoreLinkRoot = function (_super) {\n  tslib.__extends(MoreLinkRoot, _super);\n\n  function MoreLinkRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.linkElRef = vdom_cjs.createRef();\n    _this.state = {\n      isPopoverOpen: false,\n      popoverId: getUniqueDomId()\n    };\n\n    _this.handleClick = function (ev) {\n      var _a = _this,\n          props = _a.props,\n          context = _a.context;\n      var moreLinkClick = context.options.moreLinkClick;\n      var date = computeRange(props).start;\n\n      function buildPublicSeg(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new EventApi(context, def, instance),\n          start: context.dateEnv.toDate(range.start),\n          end: context.dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof moreLinkClick === 'function') {\n        moreLinkClick = moreLinkClick({\n          date: date,\n          allDay: Boolean(props.allDayDate),\n          allSegs: props.allSegs.map(buildPublicSeg),\n          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n      }\n\n      if (!moreLinkClick || moreLinkClick === 'popover') {\n        _this.setState({\n          isPopoverOpen: true\n        });\n      } else if (typeof moreLinkClick === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(date, moreLinkClick);\n      }\n    };\n\n    _this.handlePopoverClose = function () {\n      _this.setState({\n        isPopoverOpen: false\n      });\n    };\n\n    return _this;\n  }\n\n  MoreLinkRoot.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function (context) {\n      var viewApi = context.viewApi,\n          options = context.options,\n          calendarApi = context.calendarApi;\n      var moreLinkText = options.moreLinkText;\n      var moreCnt = props.moreCnt;\n      var range = computeRange(props);\n      var text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals\n      ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText;\n      var title = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);\n      var hookProps = {\n        num: moreCnt,\n        shortText: \"+\" + moreCnt,\n        text: text,\n        view: viewApi\n      };\n      return vdom_cjs.createElement(vdom_cjs.Fragment, null, Boolean(props.moreCnt) && vdom_cjs.createElement(RenderHook, {\n        elRef: _this.linkElRef,\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: props.defaultContent || renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : '');\n      }), state.isPopoverOpen && vdom_cjs.createElement(MorePopover, {\n        id: state.popoverId,\n        startDate: range.start,\n        endDate: range.end,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraDateSpan: props.extraDateSpan,\n        parentEl: _this.parentEl,\n        alignmentEl: props.alignmentElRef.current,\n        alignGridTop: props.alignGridTop,\n        onClose: _this.handlePopoverClose\n      }, props.popoverContent()));\n    });\n  };\n\n  MoreLinkRoot.prototype.componentDidMount = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.componentDidUpdate = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.updateParentEl = function () {\n    if (this.linkElRef.current) {\n      this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');\n    }\n  };\n\n  return MoreLinkRoot;\n}(BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nfunction computeRange(props) {\n  if (props.allDayDate) {\n    return {\n      start: props.allDayDate,\n      end: addDays(props.allDayDate, 1)\n    };\n  }\n\n  var hiddenSegs = props.hiddenSegs;\n  return {\n    start: computeEarliestSegStart(hiddenSegs),\n    end: computeLatestSegEnd(hiddenSegs)\n  };\n}\n\nfunction computeEarliestSegStart(segs) {\n  return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\n\nfunction pickEarliestStart(seg0, seg1) {\n  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\n\nfunction computeLatestSegEnd(segs) {\n  return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\n\nfunction pickLatestEnd(seg0, seg1) {\n  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n} // exports\n// --------------------------------------------------------------------------------------------------\n\n\nvar version = '5.10.1'; // important to type it, so .d.ts has generic string\n\nexports.BASE_OPTION_DEFAULTS = BASE_OPTION_DEFAULTS;\nexports.BASE_OPTION_REFINERS = BASE_OPTION_REFINERS;\nexports.BaseComponent = BaseComponent;\nexports.BgEvent = BgEvent;\nexports.CalendarApi = CalendarApi;\nexports.CalendarContent = CalendarContent;\nexports.CalendarDataManager = CalendarDataManager;\nexports.CalendarDataProvider = CalendarDataProvider;\nexports.CalendarRoot = CalendarRoot;\nexports.ContentHook = ContentHook;\nexports.CustomContentRenderContext = CustomContentRenderContext;\nexports.DateComponent = DateComponent;\nexports.DateEnv = DateEnv;\nexports.DateProfileGenerator = DateProfileGenerator;\nexports.DayCellContent = DayCellContent;\nexports.DayCellRoot = DayCellRoot;\nexports.DayHeader = DayHeader;\nexports.DaySeriesModel = DaySeriesModel;\nexports.DayTableModel = DayTableModel;\nexports.DelayedRunner = DelayedRunner;\nexports.ElementDragging = ElementDragging;\nexports.ElementScrollController = ElementScrollController;\nexports.Emitter = Emitter;\nexports.EventApi = EventApi;\nexports.EventRoot = EventRoot;\nexports.EventSourceApi = EventSourceApi;\nexports.Interaction = Interaction;\nexports.MoreLinkRoot = MoreLinkRoot;\nexports.MountHook = MountHook;\nexports.NamedTimeZoneImpl = NamedTimeZoneImpl;\nexports.NowIndicatorRoot = NowIndicatorRoot;\nexports.NowTimer = NowTimer;\nexports.PositionCache = PositionCache;\nexports.RefMap = RefMap;\nexports.RenderHook = RenderHook;\nexports.ScrollController = ScrollController;\nexports.ScrollResponder = ScrollResponder;\nexports.Scroller = Scroller;\nexports.SegHierarchy = SegHierarchy;\nexports.SimpleScrollGrid = SimpleScrollGrid;\nexports.Slicer = Slicer;\nexports.Splitter = Splitter;\nexports.StandardEvent = StandardEvent;\nexports.TableDateCell = TableDateCell;\nexports.TableDowCell = TableDowCell;\nexports.Theme = Theme;\nexports.ViewApi = ViewApi;\nexports.ViewContextType = ViewContextType;\nexports.ViewRoot = ViewRoot;\nexports.WeekNumberRoot = WeekNumberRoot;\nexports.WindowScrollController = WindowScrollController;\nexports.addDays = addDays;\nexports.addDurations = addDurations;\nexports.addMs = addMs;\nexports.addWeeks = addWeeks;\nexports.allowContextMenu = allowContextMenu;\nexports.allowSelection = allowSelection;\nexports.applyMutationToEventStore = applyMutationToEventStore;\nexports.applyStyle = applyStyle;\nexports.applyStyleProp = applyStyleProp;\nexports.asCleanDays = asCleanDays;\nexports.asRoughMinutes = asRoughMinutes;\nexports.asRoughMs = asRoughMs;\nexports.asRoughSeconds = asRoughSeconds;\nexports.binarySearch = binarySearch;\nexports.buildClassNameNormalizer = buildClassNameNormalizer;\nexports.buildEntryKey = buildEntryKey;\nexports.buildEventApis = buildEventApis;\nexports.buildEventRangeKey = buildEventRangeKey;\nexports.buildHashFromArray = buildHashFromArray;\nexports.buildIsoString = buildIsoString;\nexports.buildNavLinkAttrs = buildNavLinkAttrs;\nexports.buildSegCompareObj = buildSegCompareObj;\nexports.buildSegTimeText = buildSegTimeText;\nexports.collectFromHash = collectFromHash;\nexports.combineEventUis = combineEventUis;\nexports.compareByFieldSpec = compareByFieldSpec;\nexports.compareByFieldSpecs = compareByFieldSpecs;\nexports.compareNumbers = compareNumbers;\nexports.compareObjs = compareObjs;\nexports.computeEarliestSegStart = computeEarliestSegStart;\nexports.computeEdges = computeEdges;\nexports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;\nexports.computeHeightAndMargins = computeHeightAndMargins;\nexports.computeInnerRect = computeInnerRect;\nexports.computeRect = computeRect;\nexports.computeSegDraggable = computeSegDraggable;\nexports.computeSegEndResizable = computeSegEndResizable;\nexports.computeSegStartResizable = computeSegStartResizable;\nexports.computeShrinkWidth = computeShrinkWidth;\nexports.computeSmallestCellWidth = computeSmallestCellWidth;\nexports.computeVisibleDayRange = computeVisibleDayRange;\nexports.config = config;\nexports.constrainPoint = constrainPoint;\nexports.createAriaClickAttrs = createAriaClickAttrs;\nexports.createDuration = createDuration;\nexports.createEmptyEventStore = createEmptyEventStore;\nexports.createEventInstance = createEventInstance;\nexports.createEventUi = createEventUi;\nexports.createFormatter = createFormatter;\nexports.createPlugin = createPlugin;\nexports.diffDates = diffDates;\nexports.diffDayAndTime = diffDayAndTime;\nexports.diffDays = diffDays;\nexports.diffPoints = diffPoints;\nexports.diffWeeks = diffWeeks;\nexports.diffWholeDays = diffWholeDays;\nexports.diffWholeWeeks = diffWholeWeeks;\nexports.disableCursor = disableCursor;\nexports.elementClosest = elementClosest;\nexports.elementMatches = elementMatches;\nexports.enableCursor = enableCursor;\nexports.eventTupleToStore = eventTupleToStore;\nexports.filterEventStoreDefs = filterEventStoreDefs;\nexports.filterHash = filterHash;\nexports.findDirectChildren = findDirectChildren;\nexports.findElements = findElements;\nexports.flexibleCompare = flexibleCompare;\nexports.formatDate = formatDate;\nexports.formatDayString = formatDayString;\nexports.formatIsoTimeString = formatIsoTimeString;\nexports.formatRange = formatRange;\nexports.getAllowYScrolling = getAllowYScrolling;\nexports.getCanVGrowWithinCell = getCanVGrowWithinCell;\nexports.getClippingParents = getClippingParents;\nexports.getDateMeta = getDateMeta;\nexports.getDayClassNames = getDayClassNames;\nexports.getDefaultEventEnd = getDefaultEventEnd;\nexports.getElRoot = getElRoot;\nexports.getElSeg = getElSeg;\nexports.getEntrySpanEnd = getEntrySpanEnd;\nexports.getEventClassNames = getEventClassNames;\nexports.getEventTargetViaRoot = getEventTargetViaRoot;\nexports.getIsRtlScrollbarOnLeft = getIsRtlScrollbarOnLeft;\nexports.getRectCenter = getRectCenter;\nexports.getRelevantEvents = getRelevantEvents;\nexports.getScrollGridClassNames = getScrollGridClassNames;\nexports.getScrollbarWidths = getScrollbarWidths;\nexports.getSectionClassNames = getSectionClassNames;\nexports.getSectionHasLiquidHeight = getSectionHasLiquidHeight;\nexports.getSegAnchorAttrs = getSegAnchorAttrs;\nexports.getSegMeta = getSegMeta;\nexports.getSlotClassNames = getSlotClassNames;\nexports.getStickyFooterScrollbar = getStickyFooterScrollbar;\nexports.getStickyHeaderDates = getStickyHeaderDates;\nexports.getUnequalProps = getUnequalProps;\nexports.getUniqueDomId = getUniqueDomId;\nexports.globalLocales = globalLocales;\nexports.globalPlugins = globalPlugins;\nexports.greatestDurationDenominator = greatestDurationDenominator;\nexports.groupIntersectingEntries = groupIntersectingEntries;\nexports.guid = guid;\nexports.hasBgRendering = hasBgRendering;\nexports.hasShrinkWidth = hasShrinkWidth;\nexports.identity = identity;\nexports.interactionSettingsStore = interactionSettingsStore;\nexports.interactionSettingsToStore = interactionSettingsToStore;\nexports.intersectRanges = intersectRanges;\nexports.intersectRects = intersectRects;\nexports.intersectSpans = intersectSpans;\nexports.isArraysEqual = isArraysEqual;\nexports.isColPropsEqual = isColPropsEqual;\nexports.isDateSelectionValid = isDateSelectionValid;\nexports.isDateSpansEqual = isDateSpansEqual;\nexports.isInt = isInt;\nexports.isInteractionValid = isInteractionValid;\nexports.isMultiDayRange = isMultiDayRange;\nexports.isPropsEqual = isPropsEqual;\nexports.isPropsValid = isPropsValid;\nexports.isValidDate = isValidDate;\nexports.joinSpans = joinSpans;\nexports.listenBySelector = listenBySelector;\nexports.mapHash = mapHash;\nexports.memoize = memoize;\nexports.memoizeArraylike = memoizeArraylike;\nexports.memoizeHashlike = memoizeHashlike;\nexports.memoizeObjArg = memoizeObjArg;\nexports.mergeEventStores = mergeEventStores;\nexports.multiplyDuration = multiplyDuration;\nexports.padStart = padStart;\nexports.parseBusinessHours = parseBusinessHours;\nexports.parseClassNames = parseClassNames;\nexports.parseDragMeta = parseDragMeta;\nexports.parseEventDef = parseEventDef;\nexports.parseFieldSpecs = parseFieldSpecs;\nexports.parseMarker = parse;\nexports.pointInsideRect = pointInsideRect;\nexports.preventContextMenu = preventContextMenu;\nexports.preventDefault = preventDefault;\nexports.preventSelection = preventSelection;\nexports.rangeContainsMarker = rangeContainsMarker;\nexports.rangeContainsRange = rangeContainsRange;\nexports.rangesEqual = rangesEqual;\nexports.rangesIntersect = rangesIntersect;\nexports.refineEventDef = refineEventDef;\nexports.refineProps = refineProps;\nexports.removeElement = removeElement;\nexports.removeExact = removeExact;\nexports.renderChunkContent = renderChunkContent;\nexports.renderFill = renderFill;\nexports.renderMicroColGroup = renderMicroColGroup;\nexports.renderScrollShim = renderScrollShim;\nexports.requestJson = requestJson;\nexports.sanitizeShrinkWidth = sanitizeShrinkWidth;\nexports.setElSeg = setElSeg;\nexports.setRef = setRef;\nexports.sliceEventStore = sliceEventStore;\nexports.sliceEvents = sliceEvents;\nexports.sortEventSegs = sortEventSegs;\nexports.startOfDay = startOfDay;\nexports.translateRect = translateRect;\nexports.triggerDateSelect = triggerDateSelect;\nexports.unpromisify = unpromisify;\nexports.version = version;\nexports.whenTransitionDone = whenTransitionDone;\nexports.wholeDivideDurations = wholeDivideDurations;\nObject.keys(vdom_cjs).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return vdom_cjs[k];\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViQSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7QUFFQTs7QUFDQSxJQUFJQyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsb0JBQUQsQ0FBbkI7O0FBQ0EsSUFBSUMsUUFBUSxHQUFHRCxtQkFBTyxDQUFDLG9FQUF2QixDLENBRUE7QUFDQTs7O0FBQ0EsSUFBSUUsY0FBYyxHQUFrQixZQUFZO0FBQzVDLFdBQVNBLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDQyxtQkFBakMsRUFBc0Q7QUFDbEQsU0FBS0QsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkJBLG1CQUEzQjtBQUNIOztBQUNERixFQUFBQSxjQUFjLENBQUNHLFNBQWYsQ0FBeUJDLE1BQXpCLEdBQWtDLFlBQVk7QUFDMUMsU0FBS0gsT0FBTCxDQUFhSSxRQUFiLENBQXNCO0FBQ2xCQyxNQUFBQSxJQUFJLEVBQUUscUJBRFk7QUFFbEJDLE1BQUFBLFFBQVEsRUFBRSxLQUFLTCxtQkFBTCxDQUF5Qks7QUFGakIsS0FBdEI7QUFJSCxHQUxEOztBQU1BUCxFQUFBQSxjQUFjLENBQUNHLFNBQWYsQ0FBeUJLLE9BQXpCLEdBQW1DLFlBQVk7QUFDM0MsU0FBS1AsT0FBTCxDQUFhSSxRQUFiLENBQXNCO0FBQ2xCQyxNQUFBQSxJQUFJLEVBQUUscUJBRFk7QUFFbEJHLE1BQUFBLFNBQVMsRUFBRSxDQUFDLEtBQUtQLG1CQUFMLENBQXlCSyxRQUExQixDQUZPO0FBR2xCRyxNQUFBQSxTQUFTLEVBQUU7QUFITyxLQUF0QjtBQUtILEdBTkQ7O0FBT0FqQixFQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JNLGNBQWMsQ0FBQ0csU0FBckMsRUFBZ0QsSUFBaEQsRUFBc0Q7QUFDbERRLElBQUFBLEdBQUcsRUFB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LFFBQW5CO0FBQ0FqMEIsY0FBQSxHQUFpQnU0QyxNQUFqQjtBQUNBdjRDLHVCQUFBLEdBQTBCNnlCLGVBQTFCO0FBQ0E3eUIsbUJBQUEsR0FBc0JtekQsV0FBdEI7QUFDQW56RCxxQkFBQSxHQUF3QnUwQixhQUF4QjtBQUNBdjBCLGtCQUFBLEdBQXFCdUwsVUFBckI7QUFDQXZMLHFCQUFBLEdBQXdCb29DLGFBQXhCO0FBQ0Fwb0MseUJBQUEsR0FBNEJpNUIsaUJBQTVCO0FBQ0FqNUIsbUJBQUEsR0FBc0JteEMsV0FBdEI7QUFDQW54QyxlQUFBLEdBQWtCd3dFLE9BQWxCO0FBQ0F4d0UsMEJBQUEsR0FBNkI2RixrQkFBN0I7QUFDQTdGLDRCQUFBLEdBQStCaVcsb0JBQS9CO0FBQ0FuVyxNQUFNLENBQUM4USxJQUFQLENBQVl4USxRQUFaLEVBQXNCNEYsT0FBdEIsQ0FBOEIsVUFBVTBxRSxDQUFWLEVBQWE7QUFDdkMsTUFBSUEsQ0FBQyxLQUFLLFNBQU4sSUFBbUIsQ0FBQzF3RSxPQUFPLENBQUNtUCxjQUFSLENBQXVCdWhFLENBQXZCLENBQXhCLEVBQW1ENXdFLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0Iwd0UsQ0FBL0IsRUFBa0M7QUFDakZ4dkUsSUFBQUEsVUFBVSxFQUFFLElBRHFFO0FBRWpGRixJQUFBQSxHQUFHLEVBQUUsWUFBWTtBQUNiLGFBQU9aLFFBQVEsQ0FBQ3N3RSxDQUFELENBQWY7QUFDSDtBQUpnRixHQUFsQztBQU10RCxDQVBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVsbGNhbGxlbmRhci10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL21haW4uY2pzLmpzP2QwNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5GdWxsQ2FsZW5kYXIgdjUuMTAuMVxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuKGMpIDIwMjEgQWRhbSBTaGF3XG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG47XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIHZkb21fY2pzID0gcmVxdWlyZSgnLi92ZG9tLmNqcycpO1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIEV2ZW50U291cmNlQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlQXBpKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICB9XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxuICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRXZlbnRTb3VyY2VBcGk7XG59KCkpO1xuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxufVxuLy8gUXVlcnlpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgLy8gcmVhbGx5IGJhZCBmYWxsYmFjayBmb3IgSUVcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSk7XG4gICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG1ldGhvZCA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBtZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4vLyBUT0RPOiBhY2NlcHQgdGhlIGRvY3VtZW50XG5mdW5jdGlvbiBmaW5kRWxlbWVudHMoY29udGFpbmVyLCBzZWxlY3Rvcikge1xuICAgIHZhciBjb250YWluZXJzID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbY29udGFpbmVyXSA6IGNvbnRhaW5lcjtcbiAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRhaW5lcnNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKG1hdGNoZXNbal0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gb25seSBxdWVyaWVzIGRpcmVjdCBjaGlsZCBlbGVtZW50cyAvLyBUT0RPOiByZW5hbWUgdG8gZmluZERpcmVjdENoaWxkcmVuIVxuZnVuY3Rpb24gZmluZERpcmVjdENoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnQ7XG4gICAgdmFyIGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuOyAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsO1xuICAgIH1cbn1cbi8vIEV2ZW50IEhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpZiBpbnRlcmNlcHRpbmcgYnViYmxlZCBldmVudHMgYXQgdGhlIGRvY3VtZW50L3dpbmRvdy9ib2R5IGxldmVsLFxuLy8gYW5kIHdhbnQgdG8gc2VlIG9yaWdpbmF0aW5nIGVsZW1lbnQgKHRoZSAndGFyZ2V0JyksIHVzZSB0aGlzIHV0aWwgaW5zdGVhZFxuLy8gb2YgYGV2LnRhcmdldGAgYmVjYXVzZSBpdCBnb2VzIHdpdGhpbiB3ZWItY29tcG9uZW50IGJvdW5kYXJpZXMuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBldi5jb21wb3NlZFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGV2KVswXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXYudGFyZ2V0O1xufVxuLy8gU2hhZG93IERPTSBjb25zdWRlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0RWxSb290KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xufVxuLy8gVW5pcXVlIElEIGZvciBET00gYXR0cmlidXRlXG52YXIgZ3VpZCQxID0gMDtcbmZ1bmN0aW9uIGdldFVuaXF1ZURvbUlkKCkge1xuICAgIGd1aWQkMSArPSAxO1xuICAgIHJldHVybiAnZmMtZG9tLScgKyBndWlkJDE7XG59XG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xufVxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG1hdGNoZWRDaGlsZCA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgc2VsZWN0b3IpO1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHZhciBhdHRhY2hlZEhhbmRsZXIgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb250YWluZXIsIHNlbGVjdG9yLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSkge1xuICAgIHZhciBjdXJyZW50TWF0Y2hlZENoaWxkO1xuICAgIHJldHVybiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHNlbGVjdG9yLCBmdW5jdGlvbiAobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkICE9PSBjdXJyZW50TWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbWF0Y2hlZENoaWxkO1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgdmFyIHJlYWxPbk1vdXNlTGVhdmVfMSA9IGZ1bmN0aW9uIChtb3VzZUxlYXZlRXYpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxudmFyIGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy11bnNlbGVjdGFibGUnKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIHZhciBzcGVjcyA9IFtdO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIHZhciBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgYXJnLCBpbmRleCkgeyByZXR1cm4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKTsgfSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbi8qIE51bWJlciBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XG59XG4vKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcbiAgICB2YXIgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcbiAgICB2YXIgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcbiAgICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XG4gICAgfVxuICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXG4gICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xufVxuXG52YXIgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgdmFyIG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgdmFyIG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICB2YXIgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIHZhciB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgdmFyIG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgdmFyIGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIHZhciBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICB2YXIgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgdmFyIGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZDogZGVmSWQsXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICAgIH07XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XG4gICAgdmFyIGRlc3QgPSB7fTtcbiAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHByb3BPYmpzW2ldW25hbWVfMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVfMV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXzFdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAodmFyIGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lXzIgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV8yXSA9IHByb3BzW25hbWVfMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgdmFyIG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFfMVtfaV07XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGJ1aWxkSGFzaEZyb21BcnJheShhLCBmdW5jKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHR1cGxlID0gZnVuYyhhW2ldLCBpKTtcbiAgICAgICAgaGFzaFt0dXBsZVswXV0gPSB0dXBsZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGlmIChvYmowID09PSBvYmoxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzKSB7XG4gICAgaWYgKGVxdWFsaXR5RnVuY3MgPT09IHZvaWQgMCkgeyBlcXVhbGl0eUZ1bmNzID0ge307IH1cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yICh2YXIga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cbiAgICB2YXIgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICB2YXIgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXk7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3MsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZjsgfSk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBkZWYucmVjdXJyaW5nRGVmLmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdGFydHNfMSA9IHN0YXJ0czsgX2kgPCBzdGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICB2YXIgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIHZhciBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG52YXIgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xudmFyIFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoKF9hID0ge30sIF9hW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddID0gaW5wdXQsIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIHZhciBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgdmFyIHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICB2YXIgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXG5mdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lKSB7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cbiAgICB2YXIgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xuICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XG4vLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcbi8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXG5mdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XG59XG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvKSB7XG4gICAgaWYgKGRvSXNvID09PSB2b2lkIDApIHsgZG9Jc28gPSBmYWxzZTsgfVxuICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW5zLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiR01UXCIgKyBzaWduICsgaG91cnMgKyAobWlucyA/IFwiOlwiICsgcGFkU3RhcnQobWlucywgMikgOiAnJyk7XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGEwLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgY3VycmVudEFyZ3M7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBcmdzKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJncywgbmV3QXJncykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPYmpBcmcod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmc7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmcpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKF90aGlzLCBuZXdBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1Byb3BzRXF1YWwoY3VycmVudEFyZywgbmV3QXJnKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmNhbGwoX3RoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnU2V0cyA9IFtdO1xuICAgIHZhciBjdXJyZW50UmVzdWx0cyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnU2V0cykge1xuICAgICAgICB2YXIgY3VycmVudExlbiA9IGN1cnJlbnRBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdTZXRzW2ldLCBuZXdBcmdTZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2UoLy8gdXNlZD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIHZhciBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnSGFzaCkge1xuICAgICAgICB2YXIgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnSGFzaFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdIYXNoW2tleV0sIG5ld0FyZ0hhc2hba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzSGFzaFtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoO1xuICAgICAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2g7XG4gICAgICAgIHJldHVybiBuZXdSZXNIYXNoO1xuICAgIH07XG59XG5cbnZhciBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbnZhciBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyA9IHtcbiAgICB0aW1lWm9uZU5hbWU6IDcsXG4gICAgZXJhOiA2LFxuICAgIHllYXI6IDUsXG4gICAgbW9udGg6IDQsXG4gICAgZGF5OiAyLFxuICAgIHdlZWtkYXk6IDIsXG4gICAgaG91cjogMSxcbiAgICBtaW51dGU6IDEsXG4gICAgc2Vjb25kOiAxLFxufTtcbnZhciBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG52YXIgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG52YXIgTVVMVElfU1BBQ0VfUkUgPSAvXFxzKy9nO1xudmFyIExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG52YXIgVVRDX1JFID0gL1VUQ3xHTVQvO1xudmFyIE5hdGl2ZUZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXRpdmVGb3JtYXR0ZXIoZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHN0YW5kYXJkRGF0ZVByb3BzID0ge307XG4gICAgICAgIHZhciBleHRlbmRlZFNldHRpbmdzID0ge307XG4gICAgICAgIHZhciBzZXZlcml0eSA9IDA7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWVfMSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXzFdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXzFdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVfMV0sIHNldmVyaXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFuZGFyZERhdGVQcm9wcyA9IHN0YW5kYXJkRGF0ZVByb3BzO1xuICAgICAgICB0aGlzLmV4dGVuZGVkU2V0dGluZ3MgPSBleHRlbmRlZFNldHRpbmdzO1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyA9IG1lbW9pemUoYnVpbGRGb3JtYXR0aW5nRnVuYyk7XG4gICAgfVxuICAgIE5hdGl2ZUZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH07XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YW5kYXJkRGF0ZVByb3BzID0gX2Euc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgPSBfYS5leHRlbmRlZFNldHRpbmdzO1xuICAgICAgICB2YXIgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIHZhciBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgdmFyIHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIHZhciBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIHZhciBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICB2YXIgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH07XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5nZXRMYXJnZXN0VW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmF0aXZlRm9ybWF0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhbmRhcmREYXRlUHJvcENudCA9IE9iamVjdC5rZXlzKHN0YW5kYXJkRGF0ZVByb3BzKS5sZW5ndGg7XG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDEgJiYgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpKTsgfTtcbiAgICB9XG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BDbnQgPT09IDAgJiYgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGZvcm1hdFdlZWtOdW1iZXIoY29udGV4dC5jb21wdXRlV2Vla051bWJlcihkYXRlLm1hcmtlciksIGNvbnRleHQud2Vla1RleHQsIGNvbnRleHQud2Vla1RleHRMb25nLCBjb250ZXh0LmxvY2FsZSwgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrKSk7IH07XG4gICAgfVxuICAgIHJldHVybiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICBzdGFuZGFyZERhdGVQcm9wcyA9IHRzbGliLl9fYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcbiAgICBleHRlbmRlZFNldHRpbmdzID0gdHNsaWIuX19hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgdmFyIG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgdmFyIHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICB2YXIgemVyb1Byb3BzID0gdHNsaWIuX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICAgICAgZGVsZXRlIHplcm9Qcm9wcy5taW51dGU7IC8vIHNlY29uZHMgYW5kIG1zIHdlcmUgYWxyZWFkeSBjb25zaWRlcmVkIGluIHNhbml0aXplU2V0dGluZ3NcbiAgICAgICAgemVyb0Zvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCB6ZXJvUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IGRhdGUubWFya2VyO1xuICAgICAgICB2YXIgZm9ybWF0O1xuICAgICAgICBpZiAoemVyb0Zvcm1hdCAmJiAhbWFya2VyLmdldFVUQ01pbnV0ZXMoKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gemVyb0Zvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IG5vcm1hbEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGZvcm1hdC5mb3JtYXQobWFya2VyKTtcbiAgICAgICAgcmV0dXJuIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncykge1xuICAgIC8vIGRlYWwgd2l0aCBhIGJyb3dzZXIgaW5jb25zaXN0ZW5jeSB3aGVyZSBmb3JtYXR0aW5nIHRoZSB0aW1lem9uZVxuICAgIC8vIHJlcXVpcmVzIHRoYXQgdGhlIGhvdXIvbWludXRlIGJlIHByZXNlbnQuXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSkge1xuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLmhvdXIpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLmhvdXIgPSAnMi1kaWdpdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5taW51dGUpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmx5IHN1cHBvcnQgc2hvcnQgdGltZXpvbmUgbmFtZXNcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnbG9uZycpIHtcbiAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID0gJ3Nob3J0JztcbiAgICB9XG4gICAgLy8gaWYgcmVxdWVzdGluZyB0byBkaXNwbGF5IHNlY29uZHMsIE1VU1QgZGlzcGxheSBtaW51dGVzXG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUgJiYgKHN0YW5kYXJkRGF0ZVByb3BzLnNlY29uZCB8fCBzdGFuZGFyZERhdGVQcm9wcy5taWxsaXNlY29uZCkpIHtcbiAgICAgICAgZGVsZXRlIGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGU7XG4gICAgfVxufVxuZnVuY3Rpb24gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpIHtcbiAgICBzID0gcy5yZXBsYWNlKExUUl9SRSwgJycpOyAvLyByZW1vdmUgbGVmdC10by1yaWdodCBjb250cm9sIGNoYXJzLiBkbyBmaXJzdC4gZ29vZCBmb3Igb3RoZXIgcmVnZXhlc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcyA9IGluamVjdFR6b1N0cihzLCAoY29udGV4dC50aW1lWm9uZSA9PT0gJ1VUQycgfHwgZGF0ZS50aW1lWm9uZU9mZnNldCA9PSBudWxsKSA/XG4gICAgICAgICAgICAnVVRDJyA6IC8vIGltcG9ydGFudCB0byBub3JtYWxpemUgZm9yIElFLCB3aGljaCBkb2VzIFwiR01UXCJcbiAgICAgICAgICAgIGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdENvbW1hcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKENPTU1BX1JFLCAnJykudHJpbSgpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCc6MDAnLCAnJyk7IC8vIHplcm9Gb3JtYXQgZG9lc24ndCBhbHdheXMgYWNoaWV2ZSB0aGlzXG4gICAgfVxuICAgIC8vIF4gZG8gYW55dGhpbmcgdGhhdCBtaWdodCBjcmVhdGUgYWRqYWNlbnQgc3BhY2VzIGJlZm9yZSB0aGlzIHBvaW50LFxuICAgIC8vIGJlY2F1c2UgTUVSSURJRU1fUkUgbGlrZXMgdG8gZWF0IHVwIGxvYWRpbmcgc3BhY2VzXG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICduYXJyb3cnKSB7IC8vIGEvcFxuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTAsIG0xKSB7IHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ3Nob3J0JykgeyAvLyBhbS9wbVxuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTAsIG0xKSB7IHJldHVybiBtMS50b0xvY2FsZUxvd2VyQ2FzZSgpICsgXCJtXCI7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCkgeyByZXR1cm4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKTsgfSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIHZhciByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gXCIgXCIgKyB0em9TdHI7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcGFydHMucHVzaCgnICcpO1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xuICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cbiAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG4vLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXG4vLyAwID0gZXhhY3RseSB0aGUgc2FtZVxuLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4vLyBhbmQgYmlnZ2VyXG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcbiAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xuICAgIHZhciBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKG5hbWVfMiBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXzJdIDw9IGJpZ2dlc3RVbml0KSB7XG4gICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXzJdID0gb3B0aW9uc1tuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICB2YXIgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICB2YXIgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIHZhciBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICB2YXIgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICB2YXIgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICB2YXIgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIHZhciBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbnZhciBDbWRGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ21kRm9ybWF0dGVyKGNtZFN0cikge1xuICAgICAgICB0aGlzLmNtZFN0ciA9IGNtZFN0cjtcbiAgICB9XG4gICAgQ21kRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIENtZEZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBDbWRGb3JtYXR0ZXI7XG59KCkpO1xuXG52YXIgRnVuY0Zvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdW5jRm9ybWF0dGVyKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgRnVuY0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICBGdW5jRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmNGb3JtYXR0ZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgbmF2TGlua0RheUNsaWNrOiBpZGVudGl0eSxcbiAgICBuYXZMaW5rV2Vla0NsaWNrOiBpZGVudGl0eSxcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgYm9vdHN0cmFwRm9udEF3ZXNvbWU6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkljb25zOiBpZGVudGl0eSxcbiAgICBjdXN0b21CdXR0b25zOiBpZGVudGl0eSxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgbmV4dERheVRocmVzaG9sZDogY3JlYXRlRHVyYXRpb24sXG4gICAgc2Nyb2xsVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgc2Nyb2xsVGltZVJlc2V0OiBCb29sZWFuLFxuICAgIHNsb3RNaW5UaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbG90TWF4VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIHNsb3REdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc25hcER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBoZWFkZXJUb29sYmFyOiBpZGVudGl0eSxcbiAgICBmb290ZXJUb29sYmFyOiBpZGVudGl0eSxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBCb29sZWFuLFxuICAgIGRheUhlYWRlcnM6IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZGF5SGVhZGVyQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZGF5Q2VsbENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBpbml0aWFsVmlldzogU3RyaW5nLFxuICAgIGFzcGVjdFJhdGlvOiBOdW1iZXIsXG4gICAgd2Vla2VuZHM6IEJvb2xlYW4sXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICB2aWV3Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgdmlld0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICB2aWV3V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvcjogQm9vbGVhbixcbiAgICBub3dJbmRpY2F0b3JDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JDb250ZW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IEJvb2xlYW4sXG4gICAgbGF6eUZldGNoaW5nOiBCb29sZWFuLFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZTogU3RyaW5nLFxuICAgIGxvY2FsZXM6IGlkZW50aXR5LFxuICAgIGxvY2FsZTogaWRlbnRpdHksXG4gICAgdGhlbWVTeXN0ZW06IFN0cmluZyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IE51bWJlcixcbiAgICBkcmFnU2Nyb2xsOiBCb29sZWFuLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RBdXRvOiBCb29sZWFuLFxuICAgIGRyb3BBY2NlcHQ6IGlkZW50aXR5LFxuICAgIGV2ZW50T3JkZXI6IHBhcnNlRmllbGRTcGVjcyxcbiAgICBldmVudE9yZGVyU3RyaWN0OiBCb29sZWFuLFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogQm9vbGVhbixcbiAgICB3aW5kb3dSZXNpemVEZWxheTogTnVtYmVyLFxuICAgIGxvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IE51bWJlcixcbiAgICBleHBhbmRSb3dzOiBCb29sZWFuLFxuICAgIGhlaWdodDogaWRlbnRpdHksXG4gICAgY29udGVudEhlaWdodDogaWRlbnRpdHksXG4gICAgZGlyZWN0aW9uOiBTdHJpbmcsXG4gICAgd2Vla051bWJlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBCb29sZWFuLFxuICAgIGRpc3BsYXlFdmVudFRpbWU6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50RW5kOiBCb29sZWFuLFxuICAgIHdlZWtUZXh0OiBTdHJpbmcsXG4gICAgd2Vla1RleHRMb25nOiBTdHJpbmcsXG4gICAgcHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZzogQm9vbGVhbixcbiAgICBidXNpbmVzc0hvdXJzOiBpZGVudGl0eSxcbiAgICBpbml0aWFsRGF0ZTogaWRlbnRpdHksXG4gICAgbm93OiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIHN0aWNreUhlYWRlckRhdGVzOiBpZGVudGl0eSxcbiAgICBzdGlja3lGb290ZXJTY3JvbGxiYXI6IGlkZW50aXR5LFxuICAgIHZpZXdIZWlnaHQ6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgZXZlbnRTb3VyY2VGYWlsdXJlOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZVN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlzcGxheTogU3RyaW5nLFxuICAgIGV2ZW50U3RhcnRFZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudER1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZXZlbnRPdmVybGFwOiBpZGVudGl0eSxcbiAgICBldmVudENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWxsb3c6IGlkZW50aXR5LFxuICAgIGV2ZW50QmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRCb3JkZXJDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50VGV4dENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgZXZlbnRDb250ZW50OiBpZGVudGl0eSxcbiAgICBldmVudERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBldmVudFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RDb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RPdmVybGFwOiBpZGVudGl0eSxcbiAgICBzZWxlY3RBbGxvdzogaWRlbnRpdHksXG4gICAgZHJvcHBhYmxlOiBCb29sZWFuLFxuICAgIHVuc2VsZWN0Q2FuY2VsOiBTdHJpbmcsXG4gICAgc2xvdExhYmVsRm9ybWF0OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZUNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ29udGVudDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsQ29udGVudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbFdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlNYXhFdmVudHM6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50Um93czogaWRlbnRpdHksXG4gICAgZGF5TWluV2lkdGg6IE51bWJlcixcbiAgICBzbG90TGFiZWxJbnRlcnZhbDogY3JlYXRlRHVyYXRpb24sXG4gICAgYWxsRGF5VGV4dDogU3RyaW5nLFxuICAgIGFsbERheUNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGFsbERheUNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGFsbERheURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBhbGxEYXlXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2xvdE1pbldpZHRoOiBOdW1iZXIsXG4gICAgbmF2TGlua3M6IEJvb2xlYW4sXG4gICAgZXZlbnRUaW1lRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgcmVyZW5kZXJEZWxheTogTnVtYmVyLFxuICAgIG1vcmVMaW5rVGV4dDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBzZWxlY3RNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIHNlbGVjdGFibGU6IEJvb2xlYW4sXG4gICAgc2VsZWN0TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgc2VsZWN0TWlycm9yOiBCb29sZWFuLFxuICAgIGV2ZW50TWF4U3RhY2s6IE51bWJlcixcbiAgICBldmVudE1pbkhlaWdodDogTnVtYmVyLFxuICAgIGV2ZW50TWluV2lkdGg6IE51bWJlcixcbiAgICBldmVudFNob3J0SGVpZ2h0OiBOdW1iZXIsXG4gICAgc2xvdEV2ZW50T3ZlcmxhcDogQm9vbGVhbixcbiAgICBwbHVnaW5zOiBpZGVudGl0eSxcbiAgICBmaXJzdERheTogTnVtYmVyLFxuICAgIGRheUNvdW50OiBOdW1iZXIsXG4gICAgZGF0ZUFsaWdubWVudDogU3RyaW5nLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhpZGRlbkRheXM6IGlkZW50aXR5LFxuICAgIG1vbnRoTW9kZTogQm9vbGVhbixcbiAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcbiAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxuICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcbiAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxuICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcbiAgICB2aWV3SGludDogaWRlbnRpdHksXG4gICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIGNsb3NlSGludDogU3RyaW5nLFxuICAgIHRpbWVIaW50OiBTdHJpbmcsXG4gICAgZXZlbnRIaW50OiBTdHJpbmcsXG4gICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxufTtcbi8vIGRvIE5PVCBnaXZlIGEgdHlwZSBoZXJlLiBuZWVkIGB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNgIHRvIGdpdmUgcmVhbCByZXN1bHRzLlxuLy8gcmF3IHZhbHVlcy5cbnZhciBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG59O1xuLy8gY2FsZW5kYXIgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBidXR0b25UZXh0OiBpZGVudGl0eSxcbiAgICBidXR0b25IaW50czogaWRlbnRpdHksXG4gICAgdmlld3M6IGlkZW50aXR5LFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxFdmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRTb3VyY2VzOiBpZGVudGl0eSxcbn07XG52YXIgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMgPSB7XG4gICAgaGVhZGVyVG9vbGJhcjogaXNCb29sQ29tcGxleEVxdWFsLFxuICAgIGZvb3RlclRvb2xiYXI6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc0Jvb2xDb21wbGV4RXF1YWwsXG4gICAgYnV0dG9uSGludHM6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgICBidXR0b25JY29uczogaXNCb29sQ29tcGxleEVxdWFsLFxufTtcbmZ1bmN0aW9uIGlzQm9vbENvbXBsZXhFcXVhbChhLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiKSB7IC8vIGJvdGggbm9uLW51bGwgb2JqZWN0c1xuICAgICAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVklFV19PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNvbXBvbmVudDogaWRlbnRpdHksXG4gICAgYnV0dG9uVGV4dDogU3RyaW5nLFxuICAgIGJ1dHRvblRleHRLZXk6IFN0cmluZyxcbiAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSxcbiAgICB1c2VzTWluTWF4VGltZTogQm9vbGVhbixcbiAgICBjbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBjb250ZW50OiBpZGVudGl0eSxcbiAgICBkaWRNb3VudDogaWRlbnRpdHksXG4gICAgd2lsbFVubW91bnQ6IGlkZW50aXR5LFxufTtcbi8vIHV0aWwgZnVuY3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpO1xufVxuZnVuY3Rpb24gcmVmaW5lUHJvcHMoaW5wdXQsIHJlZmluZXJzKSB7XG4gICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiByZWZpbmVycykge1xuICAgICAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XG4gICAgICAgICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmaW5lZDogcmVmaW5lZCwgZXh0cmE6IGV4dHJhIH07XG59XG5mdW5jdGlvbiBpZGVudGl0eShyYXcpIHtcbiAgICByZXR1cm4gcmF3O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIHZhciBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgdmFyIGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50ID0gcmF3RXZlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMpO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKSB7XG4gICAgaWYgKGV2ZW50U3RvcmUgPT09IHZvaWQgMCkgeyBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IH1cbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWZfMSA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICB2YXIgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAobG9va0RlZikgeyByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZl8xLCBsb29rRGVmKTsgfSk7XG4gICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWZfMS5kZWZJZF0gPSBkZWZfMTtcbiAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xufVxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH07XG59XG5mdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxuICAgICAgICBpbnN0YW5jZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICB2YXIgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICB2YXIgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICk7IH0pO1xuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXIsIHN1Yikge1xuICAgIHZhciBkZWZzID0gbWFzdGVyLmRlZnMsIGluc3RhbmNlcyA9IG1hc3Rlci5pbnN0YW5jZXM7XG4gICAgdmFyIGZpbHRlcmVkRGVmcyA9IHt9O1xuICAgIHZhciBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xuICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0LCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhpbnB1dCwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhbaW5wdXRdLCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lcyhyYXcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmF3LnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcbi8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xuLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXG52YXIgRVZFTlRfVUlfUkVGSU5FUlMgPSB7XG4gICAgZGlzcGxheTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBjb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBvdmVybGFwOiBpZGVudGl0eSxcbiAgICBhbGxvdzogaWRlbnRpdHksXG4gICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICB0ZXh0Q29sb3I6IFN0cmluZyxcbn07XG52YXIgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIHZhciBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbnZhciBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuLFxufTtcbnZhciBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG52YXIgRVZFTlRfUkVGSU5FUlMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzKSB7XG4gICAgaWYgKHJlZmluZXJzID09PSB2b2lkIDApIHsgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7IH1cbiAgICB2YXIgX2EgPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgdmFyIGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dC5kYXRlRW52LCBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XG4gICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXG4gICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxuICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIHZhciBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpIHtcbiAgICBpZiAocmVmaW5lcnMgPT09IHZvaWQgMCkgeyByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KTsgfVxuICAgIHJldHVybiByZWZpbmVQcm9wcyhyYXcsIHJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzKTtcbn1cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZnVuY3Rpb24gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcbiAgICAgICAgZGVmSWQ6IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgaGFzRW5kOiBoYXNFbmQsXG4gICAgICAgIGludGVyYWN0aXZlOiByZWZpbmVkLmludGVyYWN0aXZlLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXJBZGRlciA9IF9hW19pXTtcbiAgICAgICAgdHNsaWIuX19hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50QXBpIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gICAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgdmFyIGFsbERheSA9IHJlZmluZWQuYWxsRGF5O1xuICAgIHZhciBzdGFydE1ldGE7XG4gICAgdmFyIHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICB2YXIgaGFzRW5kID0gZmFsc2U7XG4gICAgdmFyIGVuZE1ldGE7XG4gICAgdmFyIGVuZE1hcmtlciA9IG51bGw7XG4gICAgdmFyIHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlO1xuICAgIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE1ldGEubWFya2VyO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZWZpbmVkLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZCk7XG4gICAgfVxuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoZW5kTWV0YSkge1xuICAgICAgICBlbmRNYXJrZXIgPSBlbmRNZXRhLm1hcmtlcjtcbiAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gc3RhcnRPZkRheShlbmRNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE1hcmtlcikge1xuICAgICAgICBoYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgaGFzRW5kID0gY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgZW5kTWFya2VyID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICBoYXNFbmQ6IGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZSkge1xuICAgIHZhciBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMTtcbiAgICB2YXIgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgaWYgKG5leHREYXlUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBuZXh0RGF5VGhyZXNob2xkID0gY3JlYXRlRHVyYXRpb24oMCk7IH1cbiAgICB2YXIgc3RhcnREYXkgPSBudWxsO1xuICAgIHZhciBlbmREYXkgPSBudWxsO1xuICAgIGlmICh0aW1lZFJhbmdlLmVuZCkge1xuICAgICAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKTtcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZWRSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG59XG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMTtcbn1cbmZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGxhcmdlVW5pdCkge1xuICAgIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgdmFyIGludmVydGVkUmFuZ2VzID0gW107XG4gICAgdmFyIHN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0ZVJhbmdlO1xuICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0OiBzdGFydCwgZW5kOiBjb25zdHJhaW50UmFuZ2UuZW5kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXM7XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIHJhbmdlMC5zdGFydC52YWx1ZU9mKCkgLSByYW5nZTEuc3RhcnQudmFsdWVPZigpOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuZnVuY3Rpb24gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2UwLnN0YXJ0LCBlbmQgPSByYW5nZTAuZW5kO1xuICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XG4gICAgaWYgKHJhbmdlMS5zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UxLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShNYXRoLm1heChzdGFydC52YWx1ZU9mKCksIHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2UxLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlMS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShNYXRoLm1pbihlbmQudmFsdWVPZigpLCByYW5nZTEuZW5kLnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JhbmdlO1xufVxuZnVuY3Rpb24gcmFuZ2VzRXF1YWwocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuc3RhcnQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuc3RhcnQudmFsdWVPZigpKSAmJlxuICAgICAgICAocmFuZ2UwLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuZW5kLnZhbHVlT2YoKSkgPT09IChyYW5nZTEuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5lbmQudmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLmVuZCA9PT0gbnVsbCB8fCByYW5nZTEuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UwLmVuZCA+IHJhbmdlMS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlMC5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTEuZW5kID09PSBudWxsIHx8IHJhbmdlMC5zdGFydCA8IHJhbmdlMS5lbmQpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpIHtcbiAgICByZXR1cm4gKG91dGVyUmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSkgJiZcbiAgICAgICAgKG91dGVyUmFuZ2UuZW5kID09PSBudWxsIHx8IChpbm5lclJhbmdlLmVuZCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZCA8PSBvdXRlclJhbmdlLmVuZCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc01hcmtlcihyYW5nZSwgZGF0ZSkge1xuICAgIHJldHVybiAocmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlLmVuZCA9PT0gbnVsbCB8fCBkYXRlIDwgcmFuZ2UuZW5kKTtcbn1cbi8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cbi8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuZnVuY3Rpb24gY29uc3RyYWluTWFya2VyVG9SYW5nZShkYXRlLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsICYmIGRhdGUgPCByYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCAmJiBkYXRlID49IHJhbmdlLmVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocmFuZ2UuZW5kLnZhbHVlT2YoKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICB2YXIgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgdmFyIGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICB2YXIgZGVmQnlHcm91cElkID0ge307XG4gICAgdmFyIGJnUmFuZ2VzID0gW107XG4gICAgdmFyIGZnUmFuZ2VzID0gW107XG4gICAgdmFyIGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBpbnZlcnNlQmdCeUdyb3VwSWQpIHsgLy8gQlkgR1JPVVBcbiAgICAgICAgdmFyIHJhbmdlcyA9IGludmVyc2VCZ0J5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnZlcnRlZFJhbmdlc18xID0gaW52ZXJ0ZWRSYW5nZXM7IF9pIDwgaW52ZXJ0ZWRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgdmFyIHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBpbnZlcnRlZFJhbmdlc18yID0gaW52ZXJ0ZWRSYW5nZXM7IF9hIDwgaW52ZXJ0ZWRSYW5nZXNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMltfYV07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xufVxuZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xufVxuZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgIGVsLmZjU2VnID0gc2VnO1xufVxuZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICByZXR1cm4gZWwuZmNTZWcgfHxcbiAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICAgICAgbnVsbDtcbn1cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcyk7IH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xuICAgIHZhciB1aXMgPSBbXTtcbiAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XG4gICAgfVxuICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcbiAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xuICAgIHZhciBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcbiAgICBvYmpzLnNvcnQoZnVuY3Rpb24gKG9iajAsIG9iajEpIHsgcmV0dXJuIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKTsgfSk7XG4gICAgcmV0dXJuIG9ianMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLl9zZWc7IH0pO1xufVxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIHZhciBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIHZhciByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIHBsdWdpbkhvb2tzID0gY29udGV4dC5wbHVnaW5Ib29rcztcbiAgICB2YXIgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgdWkgPSBfYS51aTtcbiAgICB2YXIgdmFsID0gdWkuc3RhcnRFZGl0YWJsZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHRyYW5zZm9ybWVyc18xID0gdHJhbnNmb3JtZXJzOyBfaSA8IHRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcnNfMVtfaV07XG4gICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XG59XG5mdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcbnN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRpc3BsYXlFdmVudFRpbWUgPSBvcHRpb25zLmRpc3BsYXlFdmVudFRpbWUsIGRpc3BsYXlFdmVudEVuZCA9IG9wdGlvbnMuZGlzcGxheUV2ZW50RW5kO1xuICAgIHZhciBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICB2YXIgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIHZhciBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIHZhciBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICB2YXIgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICB2YXIgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgdmFyIHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPCAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBldmVudFJhbmdlLmRlZi5kZWZJZCArIFwiOlwiICsgZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpO1xuICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICB2YXIgdXJsID0gZGVmLnVybDtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlciwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZXZlbnRJbnRlcmFjdGl2ZSA9IG9wdGlvbnMuZXZlbnRJbnRlcmFjdGl2ZTtcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbnZhciBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIHZhciBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICB2YXIgcmFuZ2UgPSBzcGFuLnJhbmdlO1xuICAgIGlmICghcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xufVxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmZ1bmN0aW9uIHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudikge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpLCBzdGFuZGFyZFByb3BzID0gX2EucmVmaW5lZCwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICB2YXIgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGw7XG4gICAgdmFyIGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsO1xuICAgIHZhciBhbGxEYXkgPSBzdGFuZGFyZFByb3BzLmFsbERheTtcbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgYWxsRGF5ID0gKHN0YXJ0TWV0YSAmJiBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheTogYWxsRGF5IH0sIGV4dHJhKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNwYW5zRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHJhbmdlc0VxdWFsKHNwYW4wLnJhbmdlLCBzcGFuMS5yYW5nZSkgJiZcbiAgICAgICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICAgICAgaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpO1xufVxuLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbmZ1bmN0aW9uIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmFuZ2UnICYmIHByb3BOYW1lICE9PSAnYWxsRGF5Jykge1xuICAgICAgICAgICAgaWYgKHNwYW4wW3Byb3BOYW1lXSAhPT0gc3BhbjFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFyZSB0aGVyZSBhbnkgcHJvcHMgdGhhdCBzcGFuMCBoYXMgdGhhdCBzcGFuMSBET0VTTidUIGhhdmU/XG4gICAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjApIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWU6IG9taXRUaW1lIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dCk7XG4gICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYocmVzLnJlZmluZWQsIHJlcy5leHRyYSwgJycsIC8vIHNvdXJjZUlkXG4gICAgZGF0ZVNwYW4uYWxsRGF5LCB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignc2VsZWN0JywgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzZWxlY3Rpb24sIGNvbnRleHQpKSwgeyBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCd1bnNlbGVjdCcsIHtcbiAgICAgICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZGF0ZVNwYW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU3BhblRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIHRzbGliLl9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgdHNsaWIuX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVNwYW5BcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbi8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cbi8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5mdW5jdGlvbiBnZXREZWZhdWx0RXZlbnRFbmQoYWxsRGF5LCBtYXJrZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZW5kID0gbWFya2VyO1xuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpO1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgdmFyIGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXG4gICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICB9XG4gICAgdmFyIGNvcHkgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50RGVmLnVpKSwgc3RhbmRhcmRQcm9wcy51aSkgfSk7XG4gICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgY29weS5leHRlbmRlZFByb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBhcHBsaWVyID0gX2FbX2ldO1xuICAgICAgICBhcHBsaWVyKGNvcHksIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG4gICAgICAgIGNvcHkuaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG5ldmVudENvbmZpZywgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudjtcbiAgICB2YXIgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xuICAgIHZhciBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xuICAgIHZhciBjb3B5ID0gdHNsaWIuX19hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIG5vIHB1YmxpYyB0eXBlcyB5ZXQuIHdoZW4gdGhlcmUgYXJlLCBleHBvcnQgZnJvbTpcbi8vIGltcG9ydCB7fSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG52YXIgVmlld0FwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBnZXRDdXJyZW50RGF0YTtcbiAgICAgICAgdGhpcy5kYXRlRW52ID0gZGF0ZUVudjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImNhbGVuZGFyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVFbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImN1cnJlbnRTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiY3VycmVudEVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld0FwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5vcHRpb25zW25hbWVdOyAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdBcGk7XG59KCkpO1xuXG52YXIgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBmb3JtYXQ6IFN0cmluZyxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgLy8gZm9yIGFueSBuZXR3b3JrLXJlbGF0ZWQgc291cmNlc1xuICAgIHN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGZhaWx1cmU6IGlkZW50aXR5LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjb250ZXh0LCByZWZpbmVycykge1xuICAgIGlmIChyZWZpbmVycyA9PT0gdm9pZCAwKSB7IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpOyB9XG4gICAgdmFyIHJhd09iajtcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmF3T2JqID0geyB1cmw6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmIHJhdykgeyAvLyBub3QgbnVsbFxuICAgICAgICByYXdPYmogPSByYXc7XG4gICAgfVxuICAgIGlmIChyYXdPYmopIHtcbiAgICAgICAgdmFyIF9hID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB2YXIgbWV0YVJlcyA9IGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWV0YVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGF0ZXN0RmV0Y2hJZDogJycsXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxsRGF5OiByZWZpbmVkLmRlZmF1bHRBbGxEYXksXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiByZWZpbmVkLmV2ZW50RGF0YVRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZWZpbmVkLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVmaW5lZC5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBndWlkKCksXG4gICAgICAgICAgICAgICAgc291cmNlRGVmSWQ6IG1ldGFSZXMuc291cmNlRGVmSWQsXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YVJlcy5tZXRhLFxuICAgICAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IGV4dHJhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VSZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlTWV0YShyYXcsIGNvbnRleHQpIHtcbiAgICB2YXIgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIGZvciAodmFyIGkgPSBkZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7IC8vIGxhdGVyLWFkZGVkIHBsdWdpbnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICB2YXIgbWV0YSA9IGRlZi5wYXJzZU1ldGEocmF3KTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZURlZklkOiBpLCBtZXRhOiBtZXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zLCBkYXRlRW52KSB7XG4gICAgdmFyIGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlO1xuICAgIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuICAgIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG59XG5mdW5jdGlvbiBnZXROb3cobm93SW5wdXQsIGRhdGVFbnYpIHtcbiAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKTtcbiAgICB9XG4gICAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dCk7XG59XG5cbnZhciBDYWxlbmRhckFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxlbmRhckFwaSgpIHtcbiAgICB9XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FsZW5kYXJBcGkucHJvdG90eXBlLCBcInZpZXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9IC8vIGZvciBwdWJsaWMgQVBJXG4gICAgICAgICxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5iYXRjaFJlbmRlcmluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpO1xuICAgIH07XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRBdmFpbGFibGVMb2NhbGVDb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5hdmFpbGFibGVSYXdMb2NhbGVzKTtcbiAgICB9O1xuICAgIC8vIFRyaWdnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXI7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsaXN0ZW5lciBuYW1lICdcIiArIGhhbmRsZXJOYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlcikudHJpZ2dlci5hcHBseShfYSwgdHNsaWIuX19zcHJlYWRBcnJheShbaGFuZGxlck5hbWVdLCBhcmdzKSk7XG4gICAgfTtcbiAgICAvLyBWaWV3XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlLnN0YXJ0ICYmIGRhdGVPclJhbmdlLmVuZCkgeyAvLyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlOiB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6ICd2aXNpYmxlUmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IGRhdGVPclJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24gKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLCB2aWV3U3BlY3MgPSBfYS52aWV3U3BlY3MsIHRvb2xiYXJDb25maWcgPSBfYS50b29sYmFyQ29uZmlnO1xuICAgICAgICB2YXIgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgc3BlYztcbiAgICAgICAgZm9yICh2YXIgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIEN1cnJlbnQgRGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnTkVYVCcgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogZ2V0Tm93KHN0YXRlLmNhbGVuZGFyT3B0aW9ucy5ub3csIHN0YXRlLmRhdGVFbnYpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nb3RvRGF0ZSA9IGZ1bmN0aW9uICh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmb3IgZXh0ZXJuYWwgQVBJXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICB9O1xuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmZvcm1hdERhdGUgPSBmdW5jdGlvbiAoZCwgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xuICAgIH07XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChkMCwgZDEsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKGQsIG9taXRUaW1lKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZTogb21pdFRpbWUgfSk7XG4gICAgfTtcbiAgICAvLyBEYXRlIFNlbGVjdGlvbiAvIEV2ZW50IFNlbGVjdGlvbiAvIERheUNsaWNrXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gICAgLy8gTk9URTogYXJncyB3ZXJlIGNoYW5nZWQgZnJvbSB2M1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0ZU9yT2JqLCBlbmREYXRlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JbnB1dDtcbiAgICAgICAgaWYgKGVuZERhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRhdGVPck9iai5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihzZWxlY3Rpb25JbnB1dCwgc3RhdGUuZGF0ZUVudiwgY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyAvLyB0aHJvdyBwYXJzZSBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHB1YmxpYyBtZXRob2RcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHVibGljIEV2ZW50cyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50QXBpKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZXZlbnRJbnB1dC5fZGVmO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRJbnB1dC5faW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghY3VycmVudERhdGEuZXZlbnRTdG9yZS5kZWZzW2RlZi5kZWZJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfSksIC8vIFRPRE86IGJldHRlciB1dGlsIGZvciB0d28gYXJncz9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChldmVudElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudElucHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBoYXNoVmFsdWVzVG9BcnJheShzdGF0ZS5ldmVudFNvdXJjZXMpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZUlucHV0ICE9IG51bGwpIHsgLy8gYW4gSUQuIGFjY2VwdHMgYSBudW1iZXIgdG9vXG4gICAgICAgICAgICB2YXIgc291cmNlQXBpID0gdGhpcy5nZXRFdmVudFNvdXJjZUJ5SWQoc291cmNlSW5wdXQpOyAvLyBUT0RPOiB1c2UgYW4gaW50ZXJuYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghc291cmNlQXBpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXFxcIlwiICsgc291cmNlSW5wdXQgKyBcIlxcXCJcIik7IC8vIFRPRE86IHRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoc3RhdGUsIHR1cGxlLmRlZiwgdHVwbGUuZGVmLnJlY3VycmluZ0RlZiA/IG51bGwgOiB0dXBsZS5pbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChuZXdFdmVudEFwaSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRBcGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudHJpZ2dlckV2ZW50QWRkID0gZnVuY3Rpb24gKGV2ZW50QXBpKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRFdmVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgX2EgPSBzdGF0ZS5ldmVudFN0b3JlLCBkZWZzID0gX2EuZGVmcywgaW5zdGFuY2VzID0gX2EuaW5zdGFuY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGVmSWQgPT09IGRlZi5kZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRTJyB9KTtcbiAgICB9O1xuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgdmFyIHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgIGlkID0gU3RyaW5nKGlkKTtcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUhhc2hbc291cmNlSWRdLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlQXBpKSB7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghc3RhdGUuZXZlbnRTb3VyY2VzW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHNvdXJjZUlucHV0LCBzdGF0ZSk7XG4gICAgICAgIGlmIChldmVudFNvdXJjZSkgeyAvLyBUT0RPOiBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogW2V2ZW50U291cmNlXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLCBpc1JlZmV0Y2g6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvLyBTY3JvbGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zY3JvbGxUb1RpbWUgPSBmdW5jdGlvbiAodGltZUlucHV0KSB7XG4gICAgICAgIHZhciB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWU6IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckFwaTtcbn0oKSk7XG5cbnZhciBFdmVudEFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcbiAgICBmdW5jdGlvbiBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgLypcbiAgICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICAgKi9cbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0UHJvcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YXIgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpID0gKF9iID0ge30sIF9iW25hbWVdID0gdmFsLCBfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aTogdWkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHNldCBwcm9wICdcIiArIG5hbWUgKyBcIicuIFVzZSBzZXRFeHRlbmRlZFByb3AgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFeHRlbmRlZFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEVuZCA9IGZ1bmN0aW9uIChlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiB7IGhhc0VuZDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldERhdGVzID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSwgZW5kRGVsdGE6IGVuZERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBtZWFucyBcImNsZWFyIHRoZSBlbmRcIlxuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlRW5kID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZURhdGVzID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRBbGxEYXkgPSBmdW5jdGlvbiAoYWxsRGF5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IGFsbERheSB9O1xuICAgICAgICB2YXIgbWFpbnRhaW5EdXJhdGlvbiA9IG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgaWYgKG1haW50YWluRHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFpbnRhaW5EdXJhdGlvbiA9IHRoaXMuX2NvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gbWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5yYW5nZS5lbmQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmVfMSA9IGNvbnRleHRfMS5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmU7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlXzEsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0XzEpO1xuICAgICAgICAgICAgdmFyIG9sZEV2ZW50ID0gbmV3IEV2ZW50QXBpKGNvbnRleHRfMSwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBvbGRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgY29udGV4dF8xLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmVfMSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIHZhciBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpO1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdGhpcy5fZGVmLnNvdXJjZUlkO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydFN0clwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZW5kU3RyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYucHVibGljSWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImdyb3VwSWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxEYXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudGl0bGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZGlzcGxheVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmRpc3BsYXkgfHwgJ2F1dG8nOyB9IC8vIGJhZC4ganVzdCBub3JtYWxpemUgdGhlIHR5cGUgZWFybGllclxuICAgICAgICAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInN0YXJ0RWRpdGFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJkdXJhdGlvbkVkaXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcIm92ZXJsYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxvd1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImJvcmRlckNvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XG4gICAgICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImV4dGVuZGVkUHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICB2YXIgdWkgPSBkZWYudWk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXJ0U3RyID0gX2Euc3RhcnRTdHIsIGVuZFN0ciA9IF9hLmVuZFN0cjtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBpZiAoZGVmLnRpdGxlKSB7XG4gICAgICAgICAgICByZXMudGl0bGUgPSBkZWYudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0U3RyKSB7XG4gICAgICAgICAgICByZXMuc3RhcnQgPSBzdGFydFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kU3RyKSB7XG4gICAgICAgICAgICByZXMuZW5kID0gZW5kU3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucHVibGljSWQpIHtcbiAgICAgICAgICAgIHJlcy5pZCA9IGRlZi5wdWJsaWNJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgIHJlcy5ncm91cElkID0gZGVmLmdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51cmwpIHtcbiAgICAgICAgICAgIHJlcy51cmwgPSBkZWYudXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ICYmIHVpLmRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmVzLmRpc3BsYXkgPSB1aS5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgcmVjdXJyaW5nLWV2ZW50IHByb3BlcnRpZXM/Pz9cbiAgICAgICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUNvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgPT09IHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICByZXMuY29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodWkuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJhY2tncm91bmRDb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5ib3JkZXJDb2xvciA9IHVpLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aS50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIHJlcy50ZXh0Q29sb3IgPSB1aS50ZXh0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZi5leHRlbmRlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGxhaW5PYmplY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEFwaTtcbn0oKSk7XG5mdW5jdGlvbiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiAoX2EgPSB7fSwgX2FbZGVmLmRlZklkXSA9IGRlZiwgX2EpLFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICAgICAgICA/IChfYiA9IHt9LCBfYltpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlLCBfYikgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBldmVudEFwaXMgPSBbXTtcbiAgICB2YXIgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAodmFyIGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRBcGlzO1xufVxuXG52YXIgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbnZhciBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSgpIHtcbiAgICB9XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlclllYXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlck1vbnRoID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9O1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJEYXkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuYXJyYXlUb01hcmtlciA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUubWFya2VyVG9BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcik7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW07XG59KCkpO1xucmVnaXN0ZXJDYWxlbmRhclN5c3RlbSgnZ3JlZ29yeScsIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtKTtcblxudmFyIElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoXCIwLlwiICsgbVsxMl0pICogMTAwMCA6IDApKTtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IChtWzE1XSA9PT0gJy0nID8gLTEgOiAxKSAqIChOdW1iZXIobVsxNl0gfHwgMCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogdGltZVpvbmVPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgRGF0ZUVudiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlRW52KHNldHRpbmdzKSB7XG4gICAgICAgIHZhciB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgdmFyIGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVOb3dNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxuICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTWFya2VyTWV0YSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcGFyc2Uocyk7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtlciA9IHBhcnRzLm1hcmtlcjtcbiAgICAgICAgdmFyIGZvcmNlZFR6byA9IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIobWFya2VyLnZhbHVlT2YoKSAtIHBhcnRzLnRpbWVab25lT2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcmtlcjogbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6bzogZm9yY2VkVHpvIH07XG4gICAgfTtcbiAgICAvLyBBY2Nlc3NvcnNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRZZWFyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG1hcmtlcik7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRNb250aCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobWFya2VyKTtcbiAgICB9O1xuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdIC09IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gLT0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmFkZFllYXJzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRNb250aHMgPSBmdW5jdGlvbiAobWFya2VyLCBuKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVZZWFycyA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIGNhbGVuZGFyU3lzdGVtID0gdGhpcy5jYWxlbmRhclN5c3RlbTtcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVNb250aHMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIFJhbmdlIC8gRHVyYXRpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS5ncmVhdGVzdFdob2xlVW5pdCA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZkhvdXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNvdW50RHVyYXRpb25zQmV0d2VlbiA9IGZ1bmN0aW9uIChtMCwgbTEsIGQpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKGQueWVhcnMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLm1vbnRocykge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaE1vbnRocyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5kYXlzKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKTtcbiAgICB9O1xuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2YgPSBmdW5jdGlvbiAobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZZZWFyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuc3RhcnRPZk1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZXZWVrID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8vIFdlZWsgTnVtYmVyXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY29tcHV0ZVdlZWtOdW1iZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoe1xuICAgICAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgICB9LCB0aGlzLCBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXRJc28gPSBmdW5jdGlvbiAobWFya2VyLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICB9O1xuICAgIC8vIFRpbWVab25lXG4gICAgRGF0ZUVudi5wcm90b3R5cGUudGltZXN0YW1wVG9NYXJrZXIgPSBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5vZmZzZXRGb3JNYXJrZXIgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpOyAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIENvbnZlcnNpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS50b0RhdGUgPSBmdW5jdGlvbiAobSwgZm9yY2VkVHpvKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpOyAvLyBtYWtlIHN1cmUgaXQncyBhIGNvcHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUVudjtcbn0oKSk7XG5cbnZhciBnbG9iYWxMb2NhbGVzID0gW107XG5cbnZhciBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG52YXIgUkFXX0VOX0xPQ0FMRSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5OiBmdW5jdGlvbiAoYnV0dG9uVGV4dCwgdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICA/ICdUb2RheSdcbiAgICAgICAgICAgICAgICA6IFwiVGhpcyBcIiArIGJ1dHRvblRleHQ7XG4gICAgICAgIH0sXG4gICAgfSwgdmlld0hpbnQ6ICckMCB2aWV3JywgbmF2TGlua0hpbnQ6ICdHbyB0byAkMCcsIG1vcmVMaW5rSGludDogZnVuY3Rpb24gKGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBcIlNob3cgXCIgKyBldmVudENudCArIFwiIG1vcmUgZXZlbnRcIiArIChldmVudENudCA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9IH0pO1xuZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlcykge1xuICAgIHZhciBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nO1xuICAgIHZhciBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKTtcbiAgICB2YXIgcmF3TG9jYWxlTWFwID0ge1xuICAgICAgICBlbjogUkFXX0VOX0xPQ0FMRSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgYWxsUmF3TG9jYWxlc18xID0gYWxsUmF3TG9jYWxlczsgX2kgPCBhbGxSYXdMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdMb2NhbGUgPSBhbGxSYXdMb2NhbGVzXzFbX2ldO1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGU6IGRlZmF1bHRDb2RlLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XG59XG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnLCBhdmFpbGFibGUpIHtcbiAgICB2YXIgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgIHZhciByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFO1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgdmFyIHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpIHtcbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbTUlOSU1BTF9SQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgZGVsZXRlIG1lcmdlZC5jb2RlOyAvLyBkb24ndCB3YW50IHRoaXMgcGFydCBvZiB0aGUgb3B0aW9uc1xuICAgIHZhciB3ZWVrID0gbWVyZ2VkLndlZWs7XG4gICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVBcmc6IGNvZGVBcmcsXG4gICAgICAgIGNvZGVzOiBjb2RlcyxcbiAgICAgICAgd2Vlazogd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGRhdGVFbnYgPSBidWlsZERhdGVFbnYkMShvcHRpb25zKTtcbiAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIHZhciBkYXRlTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShkYXRlSW5wdXQpO1xuICAgIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkVHpvOiBkYXRlTWV0YS5mb3JjZWRUem8sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgdmFyIHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICB2YXIgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEoc2V0dGluZ3MpIHtcbiAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgdGltZVpvbmU6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLnRpbWVab25lLCBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknIH0sIHNldHRpbmdzKSwgeyBsb2NhbGU6IGxvY2FsZSB9KSk7XG59XG5cbnZhciBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgdmFyIHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChyYXdEZWYpIHsgcmV0dXJuIHJhd0RlZi5kYXlzT2ZXZWVrOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcChmdW5jdGlvbiAocmF3RGVmKSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpOyB9KTtcbiAgICByZXR1cm4gcmF3RGVmcztcbn1cblxuZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICB9O1xuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICAgIH07XG59XG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgICB9O1xufVxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgICB9O1xufVxuXG52YXIgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIHZhciBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxudmFyIEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IC8vIGZvciBwdXJlY29tcG9uZW50cy4gVE9ETzoga2VlcCBlbHNld2hlcmVcbnZhciBTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGxpdHRlcigpIHtcbiAgICAgICAgdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzID0gbWVtb2l6ZSh0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc3BsaXRFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zcGxpdEluZGl2aWR1YWxVaSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbmRpdmlkdWFsVWkpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSB7fTsgLy8gVE9ETzogdHlwZXNjcmlwdCBwcm90ZWN0aW9uXG4gICAgfVxuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5zcGxpdFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgIHZhciBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xuICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICB2YXIgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcbiAgICAgICAgdmFyIGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XG4gICAgICAgIHZhciBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICB2YXIgc3BsaXRQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIGZ1bmN0aW9uIChpbmZvLCBrZXkpIHsgcmV0dXJuIF90aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KTsgfSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgdmFyIGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgdmFyIGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdERhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgIHZhciBkYXRlU3BhbnMgPSB7fTtcbiAgICAgICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9nZXRLZXlzRm9yRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTdG9yZS5kZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIF90aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZik7IH0pO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZGVmS2V5cykge1xuICAgICAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcywgaW5zdGFuY2VzID0gZXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgICAgIHZhciBzcGxpdFN0b3JlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmRlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBkZWZLZXlzW2luc3RhbmNlLmRlZklkXTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdFN0b3Jlc1trZXldKSB7IC8vIG11c3QgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRTdG9yZXM7XG4gICAgfTtcbiAgICBTcGxpdHRlci5wcm90b3R5cGUuX3NwbGl0SW5kaXZpZHVhbFVpID0gZnVuY3Rpb24gKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICB2YXIgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRIYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV1bZGVmSWRdID0gZXZlbnRVaUJhc2VzW2RlZklkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0SGFzaGVzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIHZhciBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFN0b3Jlc18xID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLCB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSk7XG4gICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgIHZhciBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xuICAgICAgICAgICAgdmFyIG11dGF0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpO1xuICAgICAgICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdGF0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0YXRlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNfMVtrZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFmZmVjdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG11dGF0ZWRTdG9yZXNfMSkge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNwbGl0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgdmFyIGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICB2YXIgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgdHNsaWIuX19hc3NpZ24oc3R1ZmYsIGluZGl2aWR1YWxVaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHVmZjtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZGF0ZVByb2ZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksXG4gICAgICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNUb2RheTogQm9vbGVhbih0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcbiAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1kYXknLFxuICAgICAgICBcImZjLWRheS1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIFwiZmMtc2xvdC1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxudmFyIERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xudmFyIFdFRUtfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ2xvbmcnIH0pO1xuZnVuY3Rpb24gYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZU1hcmtlciwgdmlld1R5cGUsIGlzVGFiYmFibGUpIHtcbiAgICBpZiAodmlld1R5cGUgPT09IHZvaWQgMCkgeyB2aWV3VHlwZSA9ICdkYXknOyB9XG4gICAgaWYgKGlzVGFiYmFibGUgPT09IHZvaWQgMCkgeyBpc1RhYmJhYmxlID0gdHJ1ZTsgfVxuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgdmFyIGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICB2YXIgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIHZhciBoYW5kbGVJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IHZpZXdUeXBlID09PSAnZGF5JyA/IG9wdGlvbnMubmF2TGlua0RheUNsaWNrIDpcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gb3B0aW9ucy5uYXZMaW5rV2Vla0NsaWNrIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWN0aW9uLmNhbGwoY2FsZW5kYXJBcGksIGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLnpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHRpdGxlOiBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5uYXZMaW5rSGludCwgW2RhdGVTdHIsIHpvbmVkRGF0ZV0sIGRhdGVTdHIpLCAnZGF0YS1uYXZsaW5rJzogJycgfSwgKGlzVGFiYmFibGVcbiAgICAgICAgICAgID8gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlSW50ZXJhY3Rpb24pXG4gICAgICAgICAgICA6IHsgb25DbGljazogaGFuZGxlSW50ZXJhY3Rpb24gfSkpO1xuICAgIH1cbiAgICByZXR1cm4geyAnYXJpYS1sYWJlbCc6IGRhdGVTdHIgfTtcbn1cblxudmFyIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgIHZhciBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IC0xMDAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgICB9KTtcbiAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcbiAgICB2YXIgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICB2YXIgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIF9zY3JvbGxiYXJXaWR0aHM7XG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB2YXIgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gV0FSTklORzogd2lsbCBpbmNsdWRlIGJvcmRlclxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICB5OiBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbCwgZ2V0UGFkZGluZykge1xuICAgIGlmIChnZXRQYWRkaW5nID09PSB2b2lkIDApIHsgZ2V0UGFkZGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpOyAvLyBpbmNsdWRlcyBib3JkZXIhXG4gICAgdmFyIHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0O1xuICAgIHZhciBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJMZWZ0LFxuICAgICAgICBib3JkZXJSaWdodDogYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcDogYm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJCb3R0b206IGJvcmRlckJvdHRvbSxcbiAgICAgICAgc2Nyb2xsYmFyQm90dG9tOiBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZywgZG9Gcm9tV2luZG93Vmlld3BvcnQpIHtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nID09PSB2b2lkIDApIHsgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2U7IH1cbiAgICB2YXIgb3V0ZXJSZWN0ID0gZG9Gcm9tV2luZG93Vmlld3BvcnQgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNvbXB1dGVSZWN0KGVsKTtcbiAgICB2YXIgZWRnZXMgPSBjb21wdXRlRWRnZXMoZWwsIGdvV2l0aGluUGFkZGluZyk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbGVmdDogb3V0ZXJSZWN0LmxlZnQgKyBlZGdlcy5ib3JkZXJMZWZ0ICsgZWRnZXMuc2Nyb2xsYmFyTGVmdCxcbiAgICAgICAgcmlnaHQ6IG91dGVyUmVjdC5yaWdodCAtIGVkZ2VzLmJvcmRlclJpZ2h0IC0gZWRnZXMuc2Nyb2xsYmFyUmlnaHQsXG4gICAgICAgIHRvcDogb3V0ZXJSZWN0LnRvcCArIGVkZ2VzLmJvcmRlclRvcCxcbiAgICAgICAgYm90dG9tOiBvdXRlclJlY3QuYm90dG9tIC0gZWRnZXMuYm9yZGVyQm90dG9tIC0gZWRnZXMuc2Nyb2xsYmFyQm90dG9tLFxuICAgIH07XG4gICAgaWYgKGdvV2l0aGluUGFkZGluZykge1xuICAgICAgICByZXMubGVmdCArPSBlZGdlcy5wYWRkaW5nTGVmdDtcbiAgICAgICAgcmVzLnJpZ2h0IC09IGVkZ2VzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVzLnRvcCArPSBlZGdlcy5wYWRkaW5nVG9wO1xuICAgICAgICByZXMuYm90dG9tIC09IGVkZ2VzLnBhZGRpbmdCb3R0b207XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21wdXRlUmVjdChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGVsKSB7XG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCk7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNsaXBwaW5nUGFyZW50c18xID0gY2xpcHBpbmdQYXJlbnRzOyBfaSA8IGNsaXBwaW5nUGFyZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNfMVtfaV07XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGNvbXB1dGVWTWFyZ2lucyhlbCk7XG59XG5mdW5jdGlvbiBjb21wdXRlVk1hcmdpbnMoZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApICtcbiAgICAgICAgcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luQm90dG9tLCAxMCk7XG59XG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG4vLyBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXG4vLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbi8vIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxuLy8gaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICB9XG59XG5cbnZhciBFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldFRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKHRoaXNDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgRW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoZWRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV0gfHwgW107XG4gICAgICAgIHZhciBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2EgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19hXTtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMuaGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtaXR0ZXI7XG59KCkpO1xuZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcbiAgICAgICAgLnB1c2goaGFuZGxlcik7XG59XG5mdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcbiAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYyAhPT0gaGFuZGxlcjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxuICAgIH1cbn1cblxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xudmFyIFBvc2l0aW9uQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICAgIHZhciBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuYnVpbGRFbEhvcml6b250YWxzID0gZnVuY3Rpb24gKG9yaWdpbkNsaWVudExlZnQpIHtcbiAgICAgICAgdmFyIGxlZnRzID0gW107XG4gICAgICAgIHZhciByaWdodHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZWxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9O1xuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxWZXJ0aWNhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50VG9wKSB7XG4gICAgICAgIHZhciB0b3BzID0gW107XG4gICAgICAgIHZhciBib3R0b21zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmxlZnRUb0luZGV4ID0gZnVuY3Rpb24gKGxlZnRQb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBsZWZ0cyA9IF9hLmxlZnRzLCByaWdodHMgPSBfYS5yaWdodHM7XG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS50b3BUb0luZGV4ID0gZnVuY3Rpb24gKHRvcFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvcHMgPSBfYS50b3BzLCBib3R0b21zID0gX2EuYm90dG9tcztcbiAgICAgICAgdmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgIH07XG4gICAgcmV0dXJuIFBvc2l0aW9uQ2FjaGU7XG59KCkpO1xuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG52YXIgU2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKCk7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxIb3Jpem9udGFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxDb250cm9sbGVyO1xufSgpKTtcbnZhciBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFNjcm9sbENvbnRyb2xsZXI7XG59KFNjcm9sbENvbnRyb2xsZXIpKTtcbnZhciBXaW5kb3dTY3JvbGxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U2Nyb2xsQ29udHJvbGxlcjtcbn0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhlbWUoY2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIHZhciBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIHZhciBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSB0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5pY29uQ2xhc3Nlcyk7XG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGljb25PdmVycmlkZUhhc2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRJY29uQ2xhc3MgPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSwgaXNSdGwpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBUaGVtZTtcbn0oKSk7XG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xuXG52YXIgU2Nyb2xsUmVzcG9uZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gdHNsaWIuX19hc3NpZ24oe30sIF90aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgX3RoaXMuZHJhaW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW1pdHRlci5vbignX3Njcm9sbFJlcXVlc3QnLCB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7XG4gICAgfVxuICAgIFNjcm9sbFJlc3BvbmRlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS5maXJlSW5pdGlhbFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLmRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbFJlc3BvbmRlcjtcbn0oKSk7XG5cbnZhciBWaWV3Q29udGV4dFR5cGUgPSB2ZG9tX2Nqcy5jcmVhdGVDb250ZXh0KHt9KTsgLy8gZm9yIENvbXBvbmVudHNcbmZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQodmlld1NwZWMsIHZpZXdBcGksIHZpZXdPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgZGF0ZUVudiwgdGhlbWUsIHBsdWdpbkhvb2tzLCBkaXNwYXRjaCwgZ2V0Q3VycmVudERhdGEsIGVtaXR0ZXIsIGNhbGVuZGFyQXBpLCByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgcGx1Z2luSG9va3M6IHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICAgIGdldEN1cnJlbnREYXRhOiBnZXRDdXJyZW50RGF0YSxcbiAgICAgICAgY2FsZW5kYXJBcGk6IGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYzogdmlld1NwZWMsXG4gICAgICAgIHZpZXdBcGk6IHZpZXdBcGksXG4gICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBkYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcjogZnVuY3Rpb24gKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG52YXIgUHVyZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoUHVyZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGdldFVuZXF1YWxQcm9wcyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpLCBnZXRVbmVxdWFsUHJvcHMobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb21wYXJlT2Jqcyh0aGlzLnByb3BzLCBuZXh0UHJvcHMsIHRoaXMucHJvcEVxdWFsaXR5KSB8fFxuICAgICAgICAgICAgIWNvbXBhcmVPYmpzKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSwgdGhpcy5zdGF0ZUVxdWFsaXR5KTtcbiAgICB9O1xuICAgIFB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG4gICAgUHVyZUNvbXBvbmVudC5hZGRTdGF0ZUVxdWFsaXR5ID0gYWRkU3RhdGVFcXVhbGl0eTtcbiAgICBQdXJlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBQdXJlQ29tcG9uZW50O1xufSh2ZG9tX2Nqcy5Db21wb25lbnQpKTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xudmFyIEJhc2VDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEJhc2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBCYXNlQ29tcG9uZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBhZGRQcm9wc0VxdWFsaXR5KHByb3BFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5wcm9wRXF1YWxpdHkpO1xuICAgIHRzbGliLl9fYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaDtcbn1cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkoc3RhdGVFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5KTtcbiAgICB0c2xpYi5fX2Fzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG4vKlxuYW4gSU5URVJBQ1RBQkxFIGRhdGUgY29tcG9uZW50XG5cblBVUlBPU0VTOlxuLSBob29rIHVwIHRvIGZnLCBmaWxsLCBhbmQgbWlycm9yIHJlbmRlcmVyc1xuLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXG4qL1xudmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVpZCA9IGd1aWQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIHNob3VsZCBiZSBhYnN0cmFjdFxuICAgIH07XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNWYWxpZFNlZ0Rvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWREYXRlRG93bkVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDb21wb25lbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZWFzaWVyIHdheSB0byBhZGQgbmV3IGhvb2tzPyBuZWVkIHRvIHVwZGF0ZSBhIG1pbGxpb24gdGhpbmdzXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczogaW5wdXQuY29udGVudFR5cGVIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XG4gICAgdmFyIGlzQWRkZWQgPSB7fTtcbiAgICB2YXIgaG9va3MgPSB7XG4gICAgICAgIHJlZHVjZXJzOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10sXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3czoge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczoge30sXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZWZzXzEgPSBkZWZzOyBfaSA8IGRlZnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFpc0FkZGVkW2RlZi5pZF0pIHtcbiAgICAgICAgICAgICAgICBpc0FkZGVkW2RlZi5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIHZhciBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMpLCBob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyksXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSwgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAuY29udGVudFR5cGVIYW5kbGVycyksIGhvb2tzMS5jb250ZW50VHlwZUhhbmRsZXJzKSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxuICAgICAgICBvcHRpb25SZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25SZWZpbmVycyksIGhvb2tzMS5vcHRpb25SZWZpbmVycyksXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xufShUaGVtZSkpO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgdmFyIHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICB2YXIgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIHZhciBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgdmFyIHF1ZXJ5UHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTsgfTtcbiAgICB2YXIgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICB2YXIgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICB2YXIgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSkpLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgICAgIG92ZXJyaWRlczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG4vLyBOT1RFOiBpbiBKU1gsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB0aGlzIGNsYXNzIHdpdGggPEhvb2tQcm9wcz4gYXJnLiBvdGhlcndpc2UsIHdpbGwgZGVmYXVsdCB0byBhbnk/Pz9cbnZhciBSZW5kZXJIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhSZW5kZXJIb29rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlckhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSBwcm9wcy5ob29rUHJvcHM7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChNb3VudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGRpZE1vdW50OiBwcm9wcy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IHByb3BzLndpbGxVbm1vdW50LCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZikgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNvbnRlbnQ6IHByb3BzLmNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCwgYmFja3VwRWxSZWY6IF90aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lcywgaG9va1Byb3BzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KTsgfSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVySG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuLy8gVE9ETzogcmVuYW1lIHRvIGJlIGFib3V0IGZ1bmN0aW9uLCBub3QgZGVmYXVsdC4gdXNlIGluIGFib3ZlIHR5cGVcbi8vIGZvciBmb3JjaW5nIHJlcmVuZGVyIG9mIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlIENvbnRlbnRIb29rXG52YXIgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQgPSB2ZG9tX2Nqcy5jcmVhdGVDb250ZXh0KDApO1xuZnVuY3Rpb24gQ29udGVudEhvb2socHJvcHMpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChyZW5kZXJJZCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2tJbm5lciwgdHNsaWIuX19hc3NpZ24oeyByZW5kZXJJZDogcmVuZGVySWQgfSwgcHJvcHMpKSk7IH0pKTtcbn1cbnZhciBDb250ZW50SG9va0lubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDb250ZW50SG9va0lubmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRlbnRIb29rSW5uZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbm5lckVsUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmlubmVyRWxSZWYsIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCkpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ3VzdG9tQ29udGVudCgpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21Db250ZW50SW5mbyAmJiB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm87IC8vIG9ubHkgcG9wdWxhdGVkIGlmIHVzaW5nIG5vbi1bcF1yZWFjdCBub2RlKHMpXG4gICAgICAgIHZhciBpbm5lckNvbnRlbnQgPSB0aGlzLmdldElubmVyQ29udGVudCgpO1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuZ2V0Q29udGVudE1ldGEoaW5uZXJDb250ZW50KTtcbiAgICAgICAgLy8gaW5pdGlhbCBydW4sIG9yIGNvbnRlbnQtdHlwZSBjaGFuZ2luZz8gKGZyb20gdnVlIC0+IHJlYWN0IGZvciBleGFtcGxlKVxuICAgICAgICBpZiAoIWN1c3RvbUNvbnRlbnRJbmZvIHx8IGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRLZXkgIT09IG1ldGEuY29udGVudEtleSkge1xuICAgICAgICAgICAgLy8gY2xlYXJpbmcgb2xkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3NpZ25pbmcgbmV3IHZhbHVlXG4gICAgICAgICAgICBpZiAobWV0YS5jb250ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvID0gdHNsaWIuX19hc3NpZ24oeyBjb250ZW50S2V5OiBtZXRhLmNvbnRlbnRLZXksIGNvbnRlbnRWYWw6IGlubmVyQ29udGVudFttZXRhLmNvbnRlbnRLZXldIH0sIG1ldGEuYnVpbGRMaWZlY3ljbGVGdW5jcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0aW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRWYWwgPSBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VzdG9tQ29udGVudEluZm9cbiAgICAgICAgICAgID8gW10gLy8gc2lnbmFsIHRoYXQgc29tZXRoaW5nIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIDogaW5uZXJDb250ZW50OyAvLyBhc3N1bWUgYSBbcF1yZWFjdCB2ZG9tIG5vZGUuIHVzZSBpdFxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuZ2V0SW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5jb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50ID09PSB1bmRlZmluZWQpIHsgLy8gdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50KHByb3BzLmRlZmF1bHRDb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbm5lckNvbnRlbnQgPT0gbnVsbCA/IG51bGwgOiBpbm5lckNvbnRlbnQ7IC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgKGJldHRlciBmb3IgUmVhY3QpXG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5nZXRDb250ZW50TWV0YSA9IGZ1bmN0aW9uIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGFuZGxlcnMgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3MuY29udGVudFR5cGVIYW5kbGVycztcbiAgICAgICAgdmFyIGNvbnRlbnRLZXkgPSAnJztcbiAgICAgICAgdmFyIGJ1aWxkTGlmZWN5Y2xlRnVuY3MgPSBudWxsO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7IC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgZm9yIGNvbnZlbmllbmNlIHRvIGNhbGxlclxuICAgICAgICAgICAgZm9yICh2YXIgc2VhcmNoS2V5IGluIGNvbnRlbnRUeXBlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50W3NlYXJjaEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50S2V5ID0gc2VhcmNoS2V5O1xuICAgICAgICAgICAgICAgICAgICBidWlsZExpZmVjeWNsZUZ1bmNzID0gY29udGVudFR5cGVIYW5kbGVyc1tzZWFyY2hLZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29udGVudEtleTogY29udGVudEtleSwgYnVpbGRMaWZlY3ljbGVGdW5jczogYnVpbGRMaWZlY3ljbGVGdW5jcyB9O1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUudXBkYXRlQ3VzdG9tQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8pIHsgLy8gZm9yIG5vbi1bcF1yZWFjdFxuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5yZW5kZXIodGhpcy5pbm5lckVsUmVmLmN1cnJlbnQgfHwgdGhpcy5wcm9wcy5iYWNrdXBFbFJlZi5jdXJyZW50LCAvLyB0aGUgZWxlbWVudCB0byByZW5kZXIgaW50b1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbnRlbnRIb29rSW5uZXI7XG59KEJhc2VDb21wb25lbnQpKTtcbnZhciBNb3VudEhvb2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1vdW50SG9vaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VudEhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAocm9vdEVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIHJvb3RFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW91bnRIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaGFuZGxlUm9vdEVsKTtcbiAgICB9O1xuICAgIE1vdW50SG9vay5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMucHJvcHMuZGlkTW91bnQ7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMucHJvcHMuaG9va1Byb3BzKSwgeyBlbDogdGhpcy5yb290RWwgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb3VudEhvb2sucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzLndpbGxVbm1vdW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmhvb2tQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vdW50SG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCkge1xuICAgIHZhciBjdXJyZW50R2VuZXJhdG9yO1xuICAgIHZhciBjdXJyZW50SG9va1Byb3BzO1xuICAgIHZhciBjdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZ2VuZXJhdG9yLCBob29rUHJvcHMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va1Byb3BzIHx8ICFpc1Byb3BzRXF1YWwoY3VycmVudEhvb2tQcm9wcywgaG9va1Byb3BzKSB8fCBnZW5lcmF0b3IgIT09IGN1cnJlbnRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICBjdXJyZW50SG9va1Byb3BzID0gaG9va1Byb3BzO1xuICAgICAgICAgICAgY3VycmVudENsYXNzTmFtZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKGdlbmVyYXRvciwgaG9va1Byb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENsYXNzTmFtZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcywgaG9va1Byb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKGhvb2tQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUNsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGlucHV0LCBob29rUHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbnB1dChob29rUHJvcHMsIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQpOyAvLyBnaXZlIHRoZSBmdW5jdGlvbiB0aGUgdmRvbS1jcmVhdGlvbiBmdW5jXG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxudmFyIFZpZXdSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhWaWV3Um9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3Um9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9O1xuICAgICAgICB2YXIgY3VzdG9tQ2xhc3NOYW1lcyA9IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBob29rUHJvcHMpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCwgZWxSZWY6IHByb3BzLmVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgW1wiZmMtXCIgKyBwcm9wcy52aWV3U3BlYy50eXBlICsgXCItdmlld1wiLCAnZmMtdmlldyddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Um9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xuICAgIHZhciByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgICAgICBpbnB1dDtcbiAgICB2YXIgY29tcG9uZW50ID0gcmF3T3B0aW9ucy5jb21wb25lbnQ7XG4gICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBlclR5cGU6IHJhd09wdGlvbnMudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIHJhd09wdGlvbnM6IHJhd09wdGlvbnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXdQcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgZnVuY3Rpb24gKHZpZXdFbFJlZiwgdmlld0NsYXNzTmFtZXMpIHtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5jbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCwgZWxSZWY6IHZpZXdFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH0pKTsgfSkpOyB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcbiAgICB2YXIgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpO1xuICAgIHZhciB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgZnVuY3Rpb24gKHZpZXdEZWYpIHsgcmV0dXJuIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTsgfSk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIHZhciBkdXJhdGlvbklucHV0ID0gdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbjtcbiAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xuICAgIHZhciBkdXJhdGlvblVuaXQgPSAnJztcbiAgICB2YXIgc2luZ2xlVW5pdCA9ICcnO1xuICAgIHZhciBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgdmFyIGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XG4gICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVlcnlCdXR0b25UZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnNTdWJzZXQpIHtcbiAgICAgICAgdmFyIGJ1dHRvblRleHRNYXAgPSBvcHRpb25zU3Vic2V0LmJ1dHRvblRleHQgfHwge307XG4gICAgICAgIHZhciBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xuICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIHF1ZXJ5QnV0dG9uVGl0bGUgPSBmdW5jdGlvbiAob3B0aW9uc1N1YnNldCkge1xuICAgICAgICB2YXIgYnV0dG9uSGludHMgPSBvcHRpb25zU3Vic2V0LmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgICAgICB2YXIgYnV0dG9uS2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5OyAvLyB1c2Ugc2FtZSBrZXkgYXMgdGV4dFxuICAgICAgICBpZiAoYnV0dG9uS2V5ICE9IG51bGwgJiYgYnV0dG9uSGludHNbYnV0dG9uS2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbYnV0dG9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdDogZHVyYXRpb25Vbml0LFxuICAgICAgICBzaW5nbGVVbml0OiBzaW5nbGVVbml0LFxuICAgICAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcbiAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXG4gICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcbiAgICAgICAgLy8gbm90IERSWVxuICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXG4gICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXG4gICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxuICAgIH07XG59XG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG52YXIgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XG4gICAgdmFyIHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLm5vd0RhdGUgPSBnZXROb3cocHJvcHMubm93SW5wdXQsIHByb3BzLmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgfVxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgcHJldkRhdGUgPSBkYXRlRW52LnN1YnRyYWN0KGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQocHJldkRhdGUsIC0xLCBmb3JjZVRvVmFsaWQpO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLnByb3BzLmRhdGVFbnY7XG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGRhdGVFbnYuYWRkKGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQobmV4dERhdGUsIDEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkID09PSB2b2lkIDApIHsgZm9yY2VUb1ZhbGlkID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdmFsaWRSYW5nZTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xuICAgICAgICB2YXIgaXNSYW5nZUFsbERheTtcbiAgICAgICAgdmFyIHJlbmRlclJhbmdlO1xuICAgICAgICB2YXIgYWN0aXZlUmFuZ2U7XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRSYW5nZSk7XG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gY29uc3RyYWluTWFya2VyVG9SYW5nZShjdXJyZW50RGF0ZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZm8gPSB0aGlzLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyhjdXJyZW50RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby5yYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IHJlbmRlclJhbmdlO1xuICAgICAgICBpZiAoIXByb3BzLnNob3dOb25DdXJyZW50RGF0ZXMpIHtcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCBjdXJyZW50SW5mby5yYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUmFuZ2UgPSB0aGlzLmFkanVzdEFjdGl2ZVJhbmdlKGFjdGl2ZVJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIHZhbGlkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICAgIGlzVmFsaWQgPSByYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhbGlkUmFuZ2U6IHZhbGlkUmFuZ2UsXG4gICAgICAgICAgICAvLyByYW5nZSB0aGUgdmlldyBpcyBmb3JtYWxseSByZXNwb25zaWJsZSBmb3IuXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogY3VycmVudEluZm8ucmFuZ2UsXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuICAgICAgICAgICAgaXNSYW5nZUFsbERheTogaXNSYW5nZUFsbERheSxcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2U6IGFjdGl2ZVJhbmdlLFxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgcmVuZGVyUmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRWYWxpZFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgcmFuZ2UgPSBudWxsO1xuICAgICAgICB2YXIgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG4gICAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB1c2VzTWluTWF4VGltZSA9IF9hLnVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSA9IF9hLnNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSA9IF9hLnNsb3RNYXhUaW1lO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbUR1cmF0aW9uID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgPSBfYS5kYXRlQWxpZ25tZW50O1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxuICAgICAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSW5jcmVtZW50ID0gdGhpcy5wcm9wcy5kYXRlSW5jcmVtZW50O1xuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZGF0ZUluY3JlbWVudCkudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZUFsaWdubWVudCA9IF9hLmRhdGVBbGlnbm1lbnQ7XG4gICAgICAgIHZhciBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlO1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy52aXNpYmxlUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZERhdGVJbmNyZW1lbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnQgPSB0aGlzLnByb3BzLmRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUucmVmaW5lUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VJbnB1dCkge1xuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmluaXRIaWRkZW5EYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGlkZGVuRGF5cyA9IHRoaXMucHJvcHMuaGlkZGVuRGF5cyB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cbiAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG4gICAgICAgIHZhciBkYXlDbnQgPSAwO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2Vla2VuZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gaGlkZGVuRGF5cy5pbmRleE9mKGkpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBkYXlDbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRheUNudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpZGRlbkRheXMnKTsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcbiAgICB9O1xuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xuICAgIH07XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxuICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHZvaWQgMCkgeyBpc0V4Y2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIChfYSA9IHt9LCBfYVthY3Rpb24ub3B0aW9uTmFtZV0gPSBhY3Rpb24ucmF3T3B0aW9uVmFsdWUsIF9hKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9pIDwgc291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19pXTtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7IHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQ7IH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCk7IH0pLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIGNhbGVuZGFyQXBpID0gY29udGV4dC5jYWxlbmRhckFwaTtcbiAgICB2YXIgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdO1xuICAgIHZhciBmZXRjaElkID0gZ3VpZCgpO1xuICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgIGV2ZW50U291cmNlOiBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaDogaXNSZWZldGNoLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIH0sIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50cyA9IHJlcy5yYXdFdmVudHM7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZDogZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHM6IHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiB0cnVlLCBsYXRlc3RGZXRjaElkOiBmZXRjaElkIH0pO1xufVxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2gsIHNvdXJjZUlkLCBmZXRjaElkLCBmZXRjaFJhbmdlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzb3VyY2VIYXNoKSwgKF9hID0ge30sIF9hW3NvdXJjZUlkXSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UgfSksIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpOyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICB2YXIgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgcmF3U291cmNlc18xID0gcmF3U291cmNlczsgX2kgPCByYXdTb3VyY2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdTb3VyY2UgPSByYXdTb3VyY2VzXzFbX2ldO1xuICAgICAgICB2YXIgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGV2ZW50RGVmKSB7IHJldHVybiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcbiAgICAgICAgICAgICk7IH0pO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcbiAgICApIHtcbiAgICAgICAgdmFyIHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xuICAgIHZhciBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0V2ZW50cztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICB2YXIgcmVmaW5lZEV2ZW50cztcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgICAgIHZhciByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmVmaW5lZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmUsIHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoZXhwYW5kUmFuZ2UpIHtcbiAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBzdWJzZXQpO1xufVxuZnVuY3Rpb24gcmV6b25lRXZlbnRTdG9yZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcbiAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlOyAvLyBpc24ndCBkZXBlbmRlbnQgb24gdGltZXpvbmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmczogZGVmcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkOyB9KTtcbn1cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTsgfSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbikge1xuICAgIHZhciBuZXdEcmFnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERyYWc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24pIHtcbiAgICB2YXIgbmV3UmVzaXplO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdSZXNpemUuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc2l6ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgdmFyIGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHJldHVybiB7IGhlYWRlcjogaGVhZGVyLCBmb290ZXI6IGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIHZhciB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgdmFyIGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIHZhciBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2guYXBwbHkodmlld3NXaXRoQnV0dG9ucywgc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0czogc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnM6IHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlOiBoYXNUaXRsZSB9O1xufVxuLypcbkJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcbiovXG5mdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxuY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXG50aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcbiAgICB2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIHZhciBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIHZhciB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKGZ1bmN0aW9uIChidXR0b25Hcm91cFN0cikgeyByZXR1cm4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lOiBidXR0b25OYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xuICAgICAgICB2YXIgdmlld1NwZWM7XG4gICAgICAgIHZhciBidXR0b25DbGljaztcbiAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XG4gICAgICAgIHZhciBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICB2YXIgYnV0dG9uSGludDtcbiAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgdmFyIHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxuICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmdW5jdGlvbiAobmF2VW5pdCkgeyByZXR1cm4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxuICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2s6IGJ1dHRvbkNsaWNrLCBidXR0b25JY29uOiBidXR0b25JY29uLCBidXR0b25UZXh0OiBidXR0b25UZXh0LCBidXR0b25IaW50OiBidXR0b25IaW50IH07XG4gICAgfSkpOyB9KTtcbiAgICByZXR1cm4geyB3aWRnZXRzOiB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zOiB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZTogaGFzVGl0bGUgfTtcbn1cblxudmFyIGV2ZW50U291cmNlRGVmJDIgPSB7XG4gICAgaWdub3JlUmFuZ2U6IHRydWUsXG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzKSB7XG4gICAgICAgIHN1Y2Nlc3Moe1xuICAgICAgICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxudmFyIGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGFyZy5jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCBmdW5jdGlvbiAocmF3RXZlbnRzKSB7XG4gICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMgfSk7IC8vIG5lZWRzIGFuIG9iamVjdCByZXNwb25zZVxuICAgICAgICB9LCBmYWlsdXJlKTtcbiAgICB9LFxufTtcbnZhciBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxufSk7XG5cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCA9IGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGFuZGxlIHBhcnNlZD1mYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhyZXMsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XG4gICAgfTtcbiAgICB4aHIuc2VuZChib2R5KTtcbn1cbmZ1bmN0aW9uIGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybCArXG4gICAgICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJicpO1xufVxuXG52YXIgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxudmFyIGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgIHZhciBtZXRhID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMsIGZ1bmN0aW9uIChyYXdFdmVudHMsIHhocikge1xuICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgeGhyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKHsgbWVzc2FnZTogZXJyb3JNZXNzYWdlLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KTtcbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBzdGFydFBhcmFtO1xuICAgIHZhciBlbmRQYXJhbTtcbiAgICB2YXIgdGltZVpvbmVQYXJhbTtcbiAgICB2YXIgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICB0c2xpYi5fX2Fzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG52YXIgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcbiAgICBlbmRSZWN1cjogaWRlbnRpdHksXG59O1xuXG52YXIgcmVjdXJyaW5nID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiAocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgdmFyIHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbiAodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICB2YXIgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xudmFyIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIHZhciBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICB2YXIgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQgXG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgPSB2b2lkIDA7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxudmFyIGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgICAgIGV2ZW50czogZnVuY3Rpb24gKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIHZhciB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIHZhciBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgIHZhciBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCB1bmZvdW5kU291cmNlc18xID0gdW5mb3VuZFNvdXJjZXM7IF9hIDwgdW5mb3VuZFNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHVuZm91bmRTb3VyY2UgPSB1bmZvdW5kU291cmNlc18xW19hXTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgbmV3SW5wdXRzXzEgPSBuZXdJbnB1dHM7IF9iIDwgbmV3SW5wdXRzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dCA9IG5ld0lucHV0c18xW19iXTtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpKSwgeyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlcjtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG52YXIgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAgICAgICBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyk7IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGh0bWw6IGJ1aWxkSHRtbFJlbmRlcmVyLFxuICAgICAgICAgICAgZG9tTm9kZXM6IGJ1aWxkRG9tTm9kZVJlbmRlcmVyLFxuICAgICAgICB9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuZnVuY3Rpb24gYnVpbGRIdG1sUmVuZGVyZXIoKSB7XG4gICAgdmFyIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRIdG1sID0gJyc7XG4gICAgZnVuY3Rpb24gcmVuZGVyKGVsLCBodG1sKSB7XG4gICAgICAgIGlmIChlbCAhPT0gY3VycmVudEVsIHx8IGh0bWwgIT09IGN1cnJlbnRIdG1sKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRFbCA9IGVsO1xuICAgICAgICBjdXJyZW50SHRtbCA9IGh0bWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGN1cnJlbnRFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgY3VycmVudEh0bWwgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyOiByZW5kZXIsIGRlc3Ryb3k6IGRlc3Ryb3kgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRG9tTm9kZVJlbmRlcmVyKCkge1xuICAgIHZhciBjdXJyZW50RWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RG9tTm9kZXMgPSBbXTtcbiAgICBmdW5jdGlvbiByZW5kZXIoZWwsIGRvbU5vZGVzKSB7XG4gICAgICAgIHZhciBuZXdEb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvbU5vZGVzKTtcbiAgICAgICAgaWYgKGVsICE9PSBjdXJyZW50RWwgfHwgIWlzQXJyYXlzRXF1YWwoY3VycmVudERvbU5vZGVzLCBuZXdEb21Ob2RlcykpIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBmaXJzdCwgcmVtb3ZlIHNlY29uZCAoZm9yIHNjcm9sbCByZXNldHRpbmcpXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0RvbU5vZGVzXzEgPSBuZXdEb21Ob2RlczsgX2kgPCBuZXdEb21Ob2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3RG9tTm9kZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEVsID0gZWw7XG4gICAgICAgIGN1cnJlbnREb21Ob2RlcyA9IG5ld0RvbU5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjdXJyZW50RG9tTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcbiAgICAgICAgY3VycmVudERvbU5vZGVzID0gW107XG4gICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlcjogcmVuZGVyLCBkZXN0cm95OiBkZXN0cm95IH07XG59XG5cbnZhciBEZWxheWVkUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5ZWRSdW5uZXIoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS50cnlEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiAhdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkKCk7IC8vIG1pZ2h0IHNldCBpc0RpcnR5IHRvIHRydWUgYWdhaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmRyYWluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXllZFJ1bm5lcjtcbn0oKSk7XG5cbnZhciBUYXNrUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tSdW5uZXIocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucGF1c2Uoc2NvcGUpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICB2YXIgdGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUuZHJhaW5lZCA9IGZ1bmN0aW9uIChjb21wbGV0ZWRUYXNrcykge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFza1J1bm5lcjtcbn0oKSk7XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIHZhciByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH07IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG4gICAgfVxuICAgIHZhciBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbn1cblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xudmFyIENhbGVuZGFyRGF0YU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJEYXRhTWFuYWdlcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZU9wdGlvbnNEYXRhKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcbiAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcbiAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRhdGE7IH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcbiAgICAgICAgdmFyIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZTogY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGU6IGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2VyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2NbX2JdO1xuICAgICAgICAgICAgdHNsaWIuX19hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IGFwcGVuZFxuICAgICAgICAgICAgPyB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzKSwgb3B0aW9uT3ZlcnJpZGVzKSA6IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUuX2hhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgZW1pdHRlciA9IF9hLmVtaXR0ZXI7XG4gICAgICAgIHZhciBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICB2YXIgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBzdGF0ZS5jdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgPSBzdGF0ZS5kYXRlUHJvZmlsZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgdmFyIHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLCBldmVudFVpU2luZ2xlQmFzZSA9IF9iLmV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgPSBfYi5zZWxlY3Rpb25Db25maWc7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgdmFyIGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGU6IGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlZHVjZXIgPSBfY1tfaV07XG4gICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICB2YXIgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgdmFyIG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLl9jb21wdXRlT3B0aW9uc0RhdGEgPSBmdW5jdGlvbiAob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyA9IF9hLnBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cyA9IF9hLmxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhID0gX2EuYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIHZhciB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XG4gICAgICAgIHZhciB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCBvcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICAgICAgdmlld1NwZWNzOiB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnOiB0b29sYmFyQ29uZmlnLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHM6IGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgX2EgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKSwgbG9jYWxlcyA9IF9hLmxvY2FsZXMsIGxvY2FsZSA9IF9hLmxvY2FsZTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcDtcbiAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9ucztcbiAgICAgICAgdmFyIHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKTtcbiAgICAgICAgdmFyIHJlZmluZXJzID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIHZhciBleHRyYSA9IHt9O1xuICAgICAgICB2YXIgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25OYW1lICE9PSAncGx1Z2lucycpIHsgLy8gYmVjYXVzZSBwbHVnaW5zIGlzIHNwZWNpYWwtY2FzZWRcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGE6IGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0czogbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aWV3VHlwZSBcXFwiXCIgKyB2aWV3VHlwZSArIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgbW9udGhNb2RlOiByZWZpbmVkT3B0aW9ucy5tb250aE1vZGUsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIHsgdmlld1NwZWM6IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpOiB2aWV3QXBpIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Vmlld09wdGlvbnMgPSBmdW5jdGlvbiAodmlld1NwZWMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIHZhciByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByZWZpbmVycyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgVklFV19PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICB2YXIgcmVmaW5lZCA9IHt9O1xuICAgICAgICB2YXIgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQ7XG4gICAgICAgIHZhciBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dHJhID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgaW4gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCkgeyAvLyBtaWdodCBiZSBhbiBcImV4dHJhXCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckRhdGFNYW5hZ2VyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudih0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xuICAgIHZhciBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICAgIGZpcnN0RGF5OiBmaXJzdERheSxcbiAgICAgICAgd2Vla1RleHQ6IHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICB2YXIgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICB2YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gZXZlbnRTb3VyY2UudWk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XG4gICAgdmFyIGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjYWxlbmRhckNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpc0xvYWRpbmdGdW5jID0gX2FbX2ldO1xuICAgICAgICBpZiAoaXNMb2FkaW5nRnVuYyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQub3B0aW9ucy5idXNpbmVzc0hvdXJzLCBjYWxlbmRhckNvbnRleHQpO1xufVxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnMsIHZpZXdOYW1lKSB7XG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gb3B0aW9uICdcIiArIG9wdGlvbk5hbWUgKyBcIidcIiArXG4gICAgICAgICAgICAodmlld05hbWUgPyBcIiBmb3IgdmlldyAnXCIgKyB2aWV3TmFtZSArIFwiJ1wiIDogJycpKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IG1vdmUgdGhpcyB0byByZWFjdCBwbHVnaW4/XG52YXIgQ2FsZW5kYXJEYXRhUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKENhbGVuZGFyRGF0YVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyRGF0YVByb3ZpZGVyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGF0YU1hbmFnZXIpIHsgLy8gc3RpbGwgd2l0aGluIGluaXRpYWwgcnVuLCBiZWZvcmUgYXNzaWdubWVudCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaXJlY3QtbXV0YXRpb24tc3RhdGVcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IGRhdGE7IC8vIGNhbid0IHVzZSBzZXRTdGF0ZSB5ZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kYXRhTWFuYWdlciA9IG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlczogcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgb25EYXRhOiBfdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYWxlbmRhckRhdGFQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25PdmVycmlkZXMgPSB0aGlzLnByb3BzLm9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgaWYgKG5ld09wdGlvbk92ZXJyaWRlcyAhPT0gcHJldlByb3BzLm9wdGlvbk92ZXJyaWRlcykgeyAvLyBwcmV2ZW50IHJlY3Vyc2l2ZSBoYW5kbGVEYXRhXG4gICAgICAgICAgICB0aGlzLmRhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhuZXdPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRhUHJvdmlkZXI7XG59KHZkb21fY2pzLkNvbXBvbmVudCkpO1xuXG4vLyBIRUxQRVJTXG4vKlxuaWYgbmV4dERheVRocmVzaG9sZCBpcyBzcGVjaWZpZWQsIHNsaWNpbmcgaXMgZG9uZSBpbiBhbiBhbGwtZGF5IGZhc2hpb24uXG55b3UgY2FuIGdldCBuZXh0RGF5VGhyZXNob2xkIGZyb20gY29udGV4dC5uZXh0RGF5VGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudHMocHJvcHMsIGFsbERheSkge1xuICAgIHJldHVybiBzbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBwcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgYWxsRGF5ID8gcHJvcHMubmV4dERheVRocmVzaG9sZCA6IG51bGwpLmZnO1xufVxuXG52YXIgTmFtZWRUaW1lWm9uZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZWRUaW1lWm9uZUltcGw7XG59KCkpO1xuXG52YXIgU2VnSGllcmFyY2h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBoaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KGlucHV0LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuRW50cmllcztcbiAgICB9O1xuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIGluc2VydGlvbiA9IHRoaXMuZmluZEluc2VydGlvbihlbnRyeSk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmlzSW5zZXJ0aW9uVmFsaWQgPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgZW50cnkudGhpY2tuZXNzIDw9IHRoaXMubWF4Q29vcmQpICYmXG4gICAgICAgICAgICAodGhpcy5tYXhTdGFja0NudCA9PT0gLTEgfHwgaW5zZXJ0aW9uLnN0YWNrQ250IDwgdGhpcy5tYXhTdGFja0NudCk7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIG51bWJlciBvZiBuZXcgZW50cmllcyBpbnNlcnRlZFxuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbiA9IGZ1bmN0aW9uIChpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEVudHJ5KGVudHJ5LCBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnNwbGl0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIHBhcnRDbnQgPSAwO1xuICAgICAgICB2YXIgc3BsaXRIaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIHZhciBlbnRyeVNwYW4gPSBlbnRyeS5zcGFuO1xuICAgICAgICB2YXIgYmFycmllclNwYW4gPSBiYXJyaWVyLnNwYW47XG4gICAgICAgIGlmIChlbnRyeVNwYW4uc3RhcnQgPCBiYXJyaWVyU3Bhbi5zdGFydCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBzcGxpdEhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICAgICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBiYXJyaWVyU3Bhbi5lbmQsIGVuZDogZW50cnlTcGFuLmVuZCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydENudCkge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoLmFwcGx5KGhpZGRlbkVudHJpZXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3tcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogaW50ZXJzZWN0U3BhbnMoYmFycmllclNwYW4sIGVudHJ5U3BhbiksIC8vIGd1YXJhbnRlZWQgdG8gaW50ZXJzZWN0XG4gICAgICAgICAgICAgICAgfV0sIHNwbGl0SGlkZGVuRW50cmllcykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRDbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmluc2VydEVudHJ5QXQgPSBmdW5jdGlvbiAoZW50cnksIGluc2VydGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5maW5kSW5zZXJ0aW9uID0gZnVuY3Rpb24gKG5ld0VudHJ5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyID0gX2Euc3RyaWN0T3JkZXIsIHN0YWNrQ250cyA9IF9hLnN0YWNrQ250cztcbiAgICAgICAgdmFyIGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICB2YXIgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICB2YXIgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICB2YXIgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIHZhciB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yICh2YXIgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdDb29yZCA9IGxldmVsQ29vcmRzW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgcGFzdCB0aGUgcGxhY2VkIGVudHJ5LCB3ZSBoYXZlIGZvdW5kIGEgZ29vZCBlbXB0eSBzcGFjZSBhbmQgY2FuIHN0b3AuXG4gICAgICAgICAgICAvLyBpZiBzdHJpY3RPcmRlciwga2VlcCBmaW5kaW5nIG1vcmUgbGF0ZXJhbCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICAgICAgaWYgKCFzdHJpY3RPcmRlciAmJiB0cmFja2luZ0Nvb3JkID49IGNhbmRpZGF0ZUNvb3JkICsgbmV3RW50cnkudGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXMgPSBiaW5hcnlTZWFyY2godHJhY2tpbmdFbnRyaWVzLCBuZXdFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpOyAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICAgICAgICB2YXIgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB0cmFja2luZ0VudHJ5LnNwYW4uc3RhcnQgPCBuZXdFbnRyeS5zcGFuLmVuZCAvLyBhbmQgbm90IGVudGlyZWx5IHBhc3QgbmV3RW50cnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRyYWNraW5nRW50cnkudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICB2YXIgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgdmFyIGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWw6IHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWw6IHRvdWNoaW5nTGF0ZXJhbCxcbiAgICAgICAgICAgIHRvdWNoaW5nRW50cnk6IHRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzdGFja0NudDogc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnRvUmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHM7XG4gICAgICAgIHZhciBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgICAgICB2YXIgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19pXTtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBlbnRyeSksIHsgbGV2ZWxDb29yZDogbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlZ0hpZXJhcmNoeTtcbn0oKSk7XG5mdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XG59XG5mdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcbn1cbi8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcbmZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XG4gICAgdmFyIG1lcmdlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18yID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMltfaV07XG4gICAgICAgIHZhciBmaWx0ZXJlZE1lcmdlcyA9IFtdO1xuICAgICAgICB2YXIgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICBzcGFuOiBlbnRyeS5zcGFuLFxuICAgICAgICAgICAgZW50cmllczogW2VudHJ5XSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBtZXJnZXNfMSA9IG1lcmdlczsgX2EgPCBtZXJnZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IG1lcmdlc18xW19hXTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xuICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcbiAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZXM7XG59XG5mdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XG4gICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBnZW5lcmFsIHV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xuICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICB2YXIgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXG4gICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXG4gICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xuICAgIH1cbiAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XG4gICAgICAgIHZhciBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcbiAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcbn1cblxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gSW50ZXJhY3Rpb247XG59KCkpO1xuZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVtzZXR0aW5ncy5jb21wb25lbnQudWlkXSA9IHNldHRpbmdzLFxuICAgICAgICBfYTtcbn1cbi8vIGdsb2JhbCBzdGF0ZVxudmFyIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbnZhciBFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudERyYWdnaW5nKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvck5lZWRzUmV2ZXJ0ID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9O1xuICAgIEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnREcmFnZ2luZztcbn0oKSk7XG5cbi8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBpbiBmYXZvciBvZiBvcHRpb25zIHN5c3RlbSxcbi8vIHRobyBpdCdzIHJlYWxseSBlYXN5IHRvIGFjY2VzcyB0aGlzIGdsb2JhbGx5IHJhdGhlciB0aGFuIHBhc3MgdGhydSBvcHRpb25zLlxudmFyIGNvbmZpZyA9IHt9O1xuXG4vKlxuSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxub250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXG4qL1xudmFyIERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG52YXIgVG9vbGJhclNlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRvb2xiYXJTZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJTZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXJTZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcChmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHsgcmV0dXJuIF90aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKTsgfSk7XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfV0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBUb29sYmFyU2VjdGlvbi5wcm90b3R5cGUucmVuZGVyV2lkZ2V0R3JvdXAgPSBmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jb250ZXh0LnRoZW1lO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHdpZGdldEdyb3VwXzEgPSB3aWRnZXRHcm91cDsgX2kgPCB3aWRnZXRHcm91cF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHdpZGdldEdyb3VwXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbk5hbWUgPSB3aWRnZXQuYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2sgPSB3aWRnZXQuYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQgPSB3aWRnZXQuYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiA9IHdpZGdldC5idXR0b25JY29uLCBidXR0b25IaW50ID0gd2lkZ2V0LmJ1dHRvbkhpbnQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJmYy10b29sYmFyLXRpdGxlXCIsIGlkOiBwcm9wcy50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQcmVzc2VkID0gYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uO1xuICAgICAgICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcyA9IFtcImZjLVwiICsgYnV0dG9uTmFtZSArIFwiLWJ1dHRvblwiLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godmRvbV9janMuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiB0eXBlb2YgYnV0dG9uSGludCA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkhpbnQocHJvcHMubmF2VW5pdCkgOiBidXR0b25IaW50LCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgXCJhcmlhLXByZXNzZWRcIjogaXNQcmVzc2VkLCBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiBidXR0b25DbGljayB9LCBidXR0b25UZXh0IHx8IChidXR0b25JY29uID8gdmRvbV9janMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkljb24gfSkgOiAnJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwQ2xhc3NOYW1lID0gKGlzT25seUJ1dHRvbnMgJiYgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFsnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH1dLCBjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyU2VjdGlvbjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVG9vbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVG9vbGJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbW9kZWwgPSBfYS5tb2RlbCwgZXh0cmFDbGFzc05hbWUgPSBfYS5leHRyYUNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFydENvbnRlbnQ7XG4gICAgICAgIHZhciBlbmRDb250ZW50O1xuICAgICAgICB2YXIgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgdmFyIGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChrZXksIHdpZGdldEdyb3Vwcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZG8gZnVuY3Rpb24gY29tcG9uZW50P1xudmFyIFZpZXdDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFZpZXdDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gcHJvcHMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXZpZXctaGFybmVzcycsXG4gICAgICAgICAgICAoYXNwZWN0UmF0aW8gfHwgcHJvcHMubGlxdWlkIHx8IHByb3BzLmhlaWdodClcbiAgICAgICAgICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHQgPSAnJztcbiAgICAgICAgdmFyIHBhZGRpbmdCb3R0b20gPSAnJztcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzdGF0ZS5hdmFpbGFibGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2lsbCBjYXVzZSBsb3RzIG9mIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMgd2l0aGluIHNjcm9sbGdyaWQuXG4gICAgICAgICAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9ICgxIC8gYXNwZWN0UmF0aW8pICogMTAwICsgXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBoZWlnaHQsIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVBdmFpbGFibGVXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xudmFyIEV2ZW50Q2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEV2ZW50Q2xpY2tpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRDbGlja2luZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2sgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIHZhciBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2spO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFdmVudENsaWNraW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbnZhciBFdmVudEhvdmVyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudEhvdmVyaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50SG92ZXJpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICBfdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IF90aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIF90aGlzLmN1cnJlbnRTZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0VudGVyID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdFbnRlciwgX3RoaXMuaGFuZGxlU2VnTGVhdmUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudEhvdmVyaW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG52YXIgQ2FsZW5kYXJDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDYWxlbmRhckNvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dCk7XG4gICAgICAgIF90aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBfdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICBfdGhpcy5oZWFkZXJSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuZm9vdGVyUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KTtcbiAgICAgICAgICAgIHZhciBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcbiAgICAgICAgICAgICAgICBFdmVudENsaWNraW5nLFxuICAgICAgICAgICAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uQ2xhc3NlcyA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdChfdGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUludGVyYWN0aW9uQ2xhc3MpIHsgcmV0dXJuIG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignd2luZG93UmVzaXplJywgeyB2aWV3OiBfdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaGFuZGxlV2luZG93UmVzaXplID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLnByb3BzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHByb3BzLnRvb2xiYXJDb25maWcsIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zO1xuICAgICAgICB2YXIgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICB2YXIgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIHZhciB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICB2YXIgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIsIHsgdmFsdWU6IHZpZXdDb250ZXh0IH0sXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChUb29sYmFyLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGxpcXVpZDogdmlld1ZHcm93LCBoZWlnaHQ6IHZpZXdIZWlnaHQsIGFzcGVjdFJhdGlvOiB2aWV3QXNwZWN0UmF0aW8sIGxhYmVsZWRCeUlkOiB2aWV3TGFiZWxJZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmZvb3RlciAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChUb29sYmFyLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSB7IHJldHVybiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKTsgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPT0gcHJldlByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyLmNsZWFyKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5idWlsZEFwcGVuZENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcChmdW5jdGlvbiAoYnVpbGRBcHBlbmRDb250ZW50KSB7IHJldHVybiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpOyB9KTtcbiAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt2ZG9tX2Nqcy5GcmFnbWVudCwge31dLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBwcm9wcy52aWV3U3BlYztcbiAgICAgICAgdmFyIHZpZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxuICAgICAgICAgICAgaXNIZWlnaHRBdXRvOiBwcm9wcy5pc0hlaWdodEF1dG8sXG4gICAgICAgICAgICBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMocGx1Z2luSG9va3Mudmlld1Byb3BzVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgICAgIHRzbGliLl9fYXNzaWduKHZpZXdQcm9wcywgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVmlld0NvbXBvbmVudCA9IHZpZXdTcGVjLmNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb21wb25lbnQsIHRzbGliLl9fYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJDb250ZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBidWlsZFRvb2xiYXJQcm9wcyh2aWV3U3BlYywgZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBjdXJyZW50RGF0ZSwgbm93LCB0aXRsZSkge1xuICAgIC8vIGRvbid0IGZvcmNlIGFueSBkYXRlLXByb2ZpbGVzIHRvIHZhbGlkIGRhdGUgcHJvZmlsZXMgKHRoZSBgZmFsc2VgKSBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIGl0J3MgaW52YWxpZFxuICAgIHZhciB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3csIHVuZGVmaW5lZCwgZmFsc2UpOyAvLyBUT0RPOiBuZWVkIGB1bmRlZmluZWRgIG9yIGVsc2UgSU5GSU5JVEUgTE9PUCBmb3Igc29tZSByZWFzb25cbiAgICB2YXIgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgdmFyIG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUNsYXNzKSB7IHJldHVybiBuZXcgVGhlQ2xhc3MoKTsgfSk7XG59XG5cbnZhciBDYWxlbmRhclJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKENhbGVuZGFyUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhclJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZvclByaW50OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVBZnRlclByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICAgICAgdmFyIGZvclByaW50ID0gdGhpcy5zdGF0ZS5mb3JQcmludDtcbiAgICAgICAgdmFyIGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgXCJmYy1kaXJlY3Rpb24tXCIgKyBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgICAgIHByb3BzLnRoZW1lLmdldENsYXNzKCdyb290JyksXG4gICAgICAgIF07XG4gICAgICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KTtcbiAgICB9O1xuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5wcm9wcy5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVtaXR0ZXIgPSB0aGlzLnByb3BzLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vZmYoJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhclJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXlDbnQpIHtcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICAgIGlmICghZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgZGF5Q250ID4gMTApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSk7IC8vIFwiU2F0XCJcbiAgICB9XG4gICAgaWYgKGRheUNudCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnLCBvbWl0Q29tbWFzOiB0cnVlIH0pOyAvLyBcIlNhdCAxMS8xMlwiXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7IC8vIFwiU2F0dXJkYXlcIlxufVxuXG52YXIgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5mdW5jdGlvbiByZW5kZXJJbm5lciQxKGhvb2tQcm9wcykge1xuICAgIHJldHVybiBob29rUHJvcHMudGV4dDtcbn1cblxudmFyIFRhYmxlRGF0ZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlRGF0ZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEYXRlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZURhdGVDZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaTtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICAvLyBpZiBjb2xDbnQgaXMgMSwgd2UgYXJlIGFscmVhZHkgaW4gYSBkYXktdmlldyBhbmQgZG9uJ3QgbmVlZCBhIG5hdmxpbmtcbiAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9ICghZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF0ZSlcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhSG9va1Byb3BzKSwgeyB0ZXh0OiB0ZXh0IH0pLCBkYXlNZXRhKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXIkMSwgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCByb2xlOiBcImNvbHVtbmhlYWRlclwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgXCJkYXRhLWRhdGVcIjogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCwgY29sU3BhbjogcHJvcHMuY29sU3BhbiB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCkpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEYXRlQ2VsbDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgV0VFS0RBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7XG52YXIgVGFibGVEb3dDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZURvd0NlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEb3dDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlRG93Q2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaSwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIHZhciBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF0ZU1ldGEsIHRoZW1lKSwgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFIb29rUHJvcHMpLCB7IHRleHQ6IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyJDEsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwidGhcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgXCJhcmlhLWxhYmVsXCI6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZURvd0NlbGw7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIE5vd1RpbWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhOb3dUaW1lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3dUaW1lcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTm93VGltZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMudW5pdCAhPT0gdGhpcy5wcm9wcy51bml0KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wdXRlVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xuICAgICAgICB2YXIgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xuICAgICAgICB2YXIgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcbiAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIHdhaXRNczogd2FpdE1zLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLCBuZXh0U3RhdGUgPSBfYS5uZXh0U3RhdGUsIHdhaXRNcyA9IF9hLndhaXRNcztcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB3YWl0TXMpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gTm93VGltZXI7XG59KHZkb21fY2pzLkNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xufVxuXG52YXIgRGF5SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5SGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUhlYWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZXMgPSBfYS5kYXRlcywgZGF0ZVByb2ZpbGUgPSBfYS5kYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMgPSBfYS5kYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gPSBfYS5yZW5kZXJJbnRybztcbiAgICAgICAgdmFyIGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCBmdW5jdGlvbiAobm93RGF0ZSwgdG9kYXlSYW5nZSkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcbiAgICAgICAgICAgIGRhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpOyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5SGVhZGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbnZhciBEYXlTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXlTZXJpZXNNb2RlbChyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgdmFyIGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgRGF5U2VyaWVzTW9kZWwucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG4gICAgICAgIHZhciBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xuICAgICAgICB2YXIgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgICBEYXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzWzBdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgIH07XG4gICAgcmV0dXJuIERheVNlcmllc01vZGVsO1xufSgpKTtcblxudmFyIERheVRhYmxlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICB2YXIgZGF0ZXMgPSBkYXlTZXJpZXMuZGF0ZXM7XG4gICAgICAgIHZhciBkYXlzUGVyUm93O1xuICAgICAgICB2YXIgZmlyc3REYXk7XG4gICAgICAgIHZhciByb3dDbnQ7XG4gICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XG4gICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcbiAgICB9XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZENlbGwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZEhlYWRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcbiAgICAgICAgdmFyIHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgc2VncyA9IFtdO1xuICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IHNlcmllc1NlZy5maXJzdEluZGV4LCBsYXN0SW5kZXggPSBzZXJpZXNTZWcubGFzdEluZGV4O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZU1vZGVsO1xufSgpKTtcblxudmFyIFNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZXIoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRVaUJhc2VzID0gcHJvcHMuZXZlbnRVaUJhc2VzO1xuICAgICAgICB2YXIgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50VWlCYXNlcywgY29udGV4dF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VOb3dEYXRlID0gZnVuY3Rpb24gKC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbi5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgY29udGV4dF0sIGV4dHJhQXJncykpO1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2V4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkXSwgZXh0cmFBcmdzKSkuYmc7XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtkYXRlU3Bhbi5yYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9hIDwgc2Vnc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfYV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudFJhbmdlc18xID0gZXZlbnRSYW5nZXM7IF9pIDwgZXZlbnRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gZXZlbnRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSB7XG4gICAgICAgIHZhciBkYXRlUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAvLyBoYWNrIHRvIG1ha2UgbXVsdGktZGF5IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBmb3JjZS1kaXNwbGF5ZWQgYXMgbGlzdC1pdGVtcyB0byB0YWtlIHVwIG9ubHkgb25lIGRheVxuICAgICAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2RhdGVSYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMltfaV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlcjtcbn0oKSk7XG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XG4gICAgfTtcbn1cblxuLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZXMgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLmluc3RhbmNlcztcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgdmFyIHByb3BzID0gdHNsaWIuX19hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiAnJywgZXZlbnREcmFnOiBudWxsLCBldmVudFJlc2l6ZTogbnVsbCB9LCBuZXdQcm9wcyk7XG4gICAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoZGF0ZVNwYW5NZXRhID09PSB2b2lkIDApIHsgZGF0ZVNwYW5NZXRhID0ge307IH1cbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIHZhciBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgdmFyIHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICB2YXIgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIHZhciBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAodmFyIHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICB2YXIgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICB2YXIgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIHZhciBldmVudE92ZXJsYXAgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRPdmVybGFwO1xuICAgICAgICB2YXIgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKHZhciBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEFwaShjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICB2YXIgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJqZWN0Q29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0QWxsb3cgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgc3ViamVjdERhdGVTcGFuID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHsgcmFuZ2U6IHN1YmplY3RJbnN0YW5jZS5yYW5nZSwgYWxsRGF5OiBzdWJqZWN0RGVmLmFsbERheSB9KTtcbiAgICAgICAgICAgIHZhciBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICB2YXIgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgdmFyIHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIHZhciByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgdmFyIHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIHZhciBzZWxlY3Rpb25Db25maWcgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuc2VsZWN0aW9uQ29uZmlnO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIHZhciBzZWxlY3RPdmVybGFwID0gY29udGV4dC5vcHRpb25zLnNlbGVjdE92ZXJsYXA7XG4gICAgdmFyIHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcbiAgICBmb3IgKHZhciByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xuICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNlbGVjdGlvbkNvbmZpZy5hbGxvd3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25BbGxvdyA9IF9hW19pXTtcbiAgICAgICAgdmFyIGZ1bGxEYXRlU3BhbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgY29uc3RyYWludHNfMSA9IGNvbnN0cmFpbnRzOyBfaSA8IGNvbnN0cmFpbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNfMVtfaV07XG4gICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xub3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXG5idXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG5jb250ZXh0KSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludDsgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2Vcbn1cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgdmFyIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG91dGVyUmFuZ2VzXzEgPSBvdXRlclJhbmdlczsgX2kgPCBvdXRlclJhbmdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb3V0ZXJSYW5nZSA9IG91dGVyUmFuZ2VzXzFbX2ldO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTY3JvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGxpcXVpZCA9IHByb3BzLmxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSA9IHByb3BzLmxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XG4gICAgICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLm5lZWRzWFNjcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5uZWVkc1lTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WVNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xudmFyIFJlZk1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZNYXAobWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayA9IG1hc3RlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgZGVwdGhzID0gX2EuZGVwdGhzLCBjdXJyZW50TWFwID0gX2EuY3VycmVudE1hcDtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFJlZk1hcC5wcm90b3R5cGUuY3JlYXRlUmVmID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVZhbHVlKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmQ2FsbGJhY2s7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAgIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAgIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICAgIFJlZk1hcC5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdEZyb21IYXNoKHRoaXMuY3VycmVudE1hcCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApO1xuICAgIH07XG4gICAgUmVmTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZk1hcDtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xuICAgIHZhciBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xuICAgIHZhciBsYXJnZXN0V2lkdGggPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgc2hyaW5rQ2VsbHNfMSA9IHNocmlua0NlbGxzOyBfaSA8IHNocmlua0NlbGxzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzaHJpbmtDZWxsID0gc2hyaW5rQ2VsbHNfMVtfaV07XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICB2YXIgZXhwYW5kUm93cyA9IGFyZy5leHBhbmRSb3dzO1xuICAgIHZhciBjb250ZW50ID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjaHVua0NvbmZpZy5jb250ZW50KGFyZykgOlxuICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgY2h1bmtDb25maWcudGFibGVDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkNvbmZpZy5zeW5jUm93SGVpZ2h0cyA/ICdmYy1zY3JvbGxncmlkLXN5bmMtdGFibGUnIDogJycsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdmRvbV9janMuY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aGVhZCcgOiAndGJvZHknLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2h1bmtDb25maWcucm93Q29udGVudChhcmcpXG4gICAgICAgICAgICA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMCwgY29sczEpIHtcbiAgICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbCk7XG59XG5mdW5jdGlvbiByZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHNocmlua1dpZHRoKSB7XG4gICAgdmFyIGNvbE5vZGVzID0gW107XG4gICAgLypcbiAgICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gICAgSE9XRVZFUiwgQ2hyb21lIHdhcyBnZXR0aW5nIG1lc3NpbmcgdXAgZGlzdHJpYnV0aW5nIHRoZSB3aWR0aCB0byA8dGQ+Lzx0aD4gZWxlbWVudHMgd2l0aCBjb2xzcGFucy5cbiAgICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgICAqL1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sc18xID0gY29sczsgX2kgPCBjb2xzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb2xQcm9wcyA9IGNvbHNfMVtfaV07XG4gICAgICAgIHZhciBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sTm9kZXMucHVzaCh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiY29sXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ2NvbGdyb3VwJywge31dLCBjb2xOb2RlcykpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHNfMiA9IGNvbHM7IF9pIDwgY29sc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sID0gY29sc18yW19pXTtcbiAgICAgICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZCwgY29udGV4dCkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgXTtcbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1saXF1aWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3cpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgICAgIFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLVwiICsgc2VjdGlvbkNvbmZpZy50eXBlLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcztcbiAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5zdGlja3lGb290ZXJTY3JvbGxiYXI7XG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XG59XG5cbnZhciBTaW1wbGVTY3JvbGxHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTaW1wbGVTY3JvbGxHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVNjcm9sbEdyaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9jZXNzQ29scyA9IG1lbW9pemUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH0sIGlzQ29sUHJvcHNFcXVhbCk7IC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG4gICAgICAgIC8vIHl1Y2t5IHRvIG1lbW9pemUgVk5vZGVzLCBidXQgbXVjaCBtb3JlIGVmZmljaWVudCBmb3IgY29uc3VtZXJzXG4gICAgICAgIF90aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICBfdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcChfdGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGNhbiBkbyBhIHJlYWxseSBzaW1wbGUgcHJpbnQtdmlldy4gZG9udCBuZWVkIHRvIGpvaW4gcm93c1xuICAgICAgICBfdGhpcy5oYW5kbGVTaXppbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh0c2xpYi5fX2Fzc2lnbih7IHNocmlua1dpZHRoOiBfdGhpcy5jb21wdXRlU2hyaW5rV2lkdGgoKSB9LCBfdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcbiAgICAgICAgdmFyIGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xuICAgICAgICB2YXIgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgICAgICB2YXIgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgY29uZmlnSSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50Q29uZmlnO1xuICAgICAgICB2YXIgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB2YXIgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB2YXIgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxuICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxuICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cbiAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXG4gICAgICAgIHZhciBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgICAgICB2YXIgcm9sZUF0dHJzID0geyByb2xlOiAncm93Z3JvdXAnIH07XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdncmlkJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZTogeyBoZWlnaHQ6IHByb3BzLmhlaWdodCB9LFxuICAgICAgICB9LCBCb29sZWFuKCFpc0J1Z2d5ICYmIGhlYWRTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ3RoZWFkJywgcm9sZUF0dHJzXSwgaGVhZFNlY3Rpb25Ob2RlcykpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ3Rib2R5Jywgcm9sZUF0dHJzXSwgYm9keVNlY3Rpb25Ob2RlcykpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ3Rmb290Jywgcm9sZUF0dHJzXSwgZm9vdFNlY3Rpb25Ob2RlcykpLCBpc0J1Z2d5ICYmIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkodHNsaWIuX19zcHJlYWRBcnJheShbJ3Rib2R5Jywgcm9sZUF0dHJzXSwgaGVhZFNlY3Rpb25Ob2RlcyksIGJvZHlTZWN0aW9uTm9kZXMpLCBmb290U2VjdGlvbk5vZGVzKSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudCh2ZG9tX2Nqcy5GcmFnbWVudCwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5IH0sIHNlY3Rpb25Db25maWcub3V0ZXJDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNlY3Rpb25Db25maWcua2V5LCByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHRoaXMucHJvcHMubGlxdWlkKS5qb2luKCcgJykgfSwgdGhpcy5yZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBzZWN0aW9uQ29uZmlnLmNodW5rLCBpc0hlYWRlcikpKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLnJlbmRlckNodW5rVGQgPSBmdW5jdGlvbiAoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGNodW5rQ29uZmlnLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gY2h1bmtDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0NvbmZpZy5vdXRlckNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgZm9yY2VZU2Nyb2xsYmFycyA9IF9hLmZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzID0gX2Euc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IF9hLnNjcm9sbGVyQ2xpZW50SGVpZ2h0cztcbiAgICAgICAgdmFyIG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIFRPRE86IGRvIGxhemlseS4gZG8gaW4gc2VjdGlvbiBjb25maWc/XG4gICAgICAgIHZhciBpc0xpcXVpZCA9IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpO1xuICAgICAgICAvLyBmb3IgYCFwcm9wcy5saXF1aWRgIC0gaXMgV0hPTEUgc2Nyb2xsZ3JpZCBuYXR1cmFsIGhlaWdodD9cbiAgICAgICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgICAgICB2YXIgb3ZlcmZsb3dZID0gIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID8gJ3Njcm9sbCcgOlxuICAgICAgICAgICAgICAgICFuZWVkc1lTY3JvbGxpbmcgPyAnaGlkZGVuJyA6XG4gICAgICAgICAgICAgICAgICAgICdhdXRvJztcbiAgICAgICAgdmFyIHNlY3Rpb25LZXkgPSBzZWN0aW9uQ29uZmlnLmtleTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIHtcbiAgICAgICAgICAgIHRhYmxlQ29sR3JvdXBOb2RlOiBtaWNyb0NvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgIHRhYmxlTWluV2lkdGg6ICcnLFxuICAgICAgICAgICAgY2xpZW50V2lkdGg6ICghcHJvcHMuY29sbGFwc2libGVXaWR0aCAmJiBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkKSA/IHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQgPyBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgZXhwYW5kUm93czogc2VjdGlvbkNvbmZpZy5leHBhbmRSb3dzLFxuICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IGZhbHNlLFxuICAgICAgICAgICAgcm93U3luY0hlaWdodHM6IFtdLFxuICAgICAgICAgICAgcmVwb3J0Um93SGVpZ2h0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIH0sIGlzSGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGgnIDogJ3RkJywge1xuICAgICAgICAgICAgcmVmOiBjaHVua0NvbmZpZy5lbFJlZixcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGVyLWhhcm5lc3NcIiArIChpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJycpIH0sXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IHJlZjogdGhpcy5zY3JvbGxlclJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBlbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIG92ZXJmbG93WTogb3ZlcmZsb3dZLCBvdmVyZmxvd1g6ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi8sIG1heEhlaWdodDogc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQsIGxpcXVpZDogaXNMaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgLy8gYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzc1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9LCBjb250ZW50KSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuX2hhbmRsZVNjcm9sbGVyRWwgPSBmdW5jdGlvbiAoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogbmVlZCBiZXR0ZXIgc29sdXRpb24gd2hlbiBzdGF0ZSBjb250YWlucyBub24tc2l6aW5nIHRoaW5nc1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXB1dGVTaHJpbmtXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhhc1Nocmlua1dpZHRoKHRoaXMucHJvcHMuY29scylcbiAgICAgICAgICAgID8gY29tcHV0ZVNocmlua1dpZHRoKHRoaXMuc2Nyb2xsZXJFbFJlZnMuZ2V0QWxsKCkpXG4gICAgICAgICAgICA6IDA7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJEaW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc2Nyb2xsZXJSZWZzID0gX2Euc2Nyb2xsZXJSZWZzLCBzY3JvbGxlckVsUmVmcyA9IF9hLnNjcm9sbGVyRWxSZWZzO1xuICAgICAgICB2YXIgZm9yY2VZU2Nyb2xsYmFycyA9IGZhbHNlO1xuICAgICAgICB2YXIgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSB7fTtcbiAgICAgICAgdmFyIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBzZWN0aW9uS2V5IGluIHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXIgPSBzY3JvbGxlclJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5uZWVkc1lTY3JvbGxpbmcoKSkge1xuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSB0aGlzLnByb3BzLnNlY3Rpb25zOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBfYltfaV07XG4gICAgICAgICAgICB2YXIgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgdmFyIHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFyczogZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHM6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNpbXBsZVNjcm9sbEdyaWQ7XG59KEJhc2VDb21wb25lbnQpKTtcblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlY3Rpb25zXzEgPSBzZWN0aW9uczsgX2kgPCBzZWN0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHNlY3Rpb25zXzFbX2ldO1xuICAgICAgICBpZiAoc2VjdGlvbi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBFdmVudFJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEV2ZW50Um9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudFJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbFJlZiA9IHZkb21fY2pzLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV2ZW50Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWcgPSBwcm9wcy5zZWc7XG4gICAgICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgIHZhciB1aSA9IGV2ZW50UmFuZ2UudWk7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIHRpbWVUZXh0OiBwcm9wcy50aW1lVGV4dCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogdWkudGV4dENvbG9yLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogIXByb3BzLmRpc2FibGVEcmFnZ2luZyAmJiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc1N0YXJ0UmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNFbmRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcpLFxuICAgICAgICAgICAgaXNNaXJyb3I6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyB8fCBwcm9wcy5pc1Jlc2l6aW5nIHx8IHByb3BzLmlzRGF0ZVNlbGVjdGluZyksXG4gICAgICAgICAgICBpc1N0YXJ0OiBCb29sZWFuKHNlZy5pc1N0YXJ0KSxcbiAgICAgICAgICAgIGlzRW5kOiBCb29sZWFuKHNlZy5pc0VuZCksXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4ocHJvcHMuaXNQYXN0KSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKHByb3BzLmlzRnV0dXJlKSxcbiAgICAgICAgICAgIGlzVG9kYXk6IEJvb2xlYW4ocHJvcHMuaXNUb2RheSksXG4gICAgICAgICAgICBpc1NlbGVjdGVkOiBCb29sZWFuKHByb3BzLmlzU2VsZWN0ZWQpLFxuICAgICAgICAgICAgaXNEcmFnZ2luZzogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nKSxcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IEJvb2xlYW4ocHJvcHMuaXNSZXNpemluZyksXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFuZGFyZENsYXNzTmFtZXMgPSBnZXRFdmVudENsYXNzTmFtZXMoaG9va1Byb3BzKS5jb25jYXQodWkuY2xhc3NOYW1lcyk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCwgZWxSZWY6IHRoaXMuZWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIHN0YW5kYXJkQ2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKTsgfSkpO1xuICAgIH07XG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLnNlZyk7XG4gICAgfTtcbiAgICAvKlxuICAgIG5lZWQgdG8gcmUtYXNzaWduIHNlZyB0byB0aGUgZWxlbWVudCBpZiBzZWcgY2hhbmdlcywgZXZlbiBpZiB0aGUgZWxlbWVudCBpcyB0aGUgc2FtZVxuICAgICovXG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBzZWcgPSB0aGlzLnByb3BzLnNlZztcbiAgICAgICAgaWYgKHNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbFJlZi5jdXJyZW50LCBzZWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIHNob3VsZCBub3QgYmUgYSBwdXJlY29tcG9uZW50XG52YXIgU3RhbmRhcmRFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU3RhbmRhcmRFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0YW5kYXJkRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWcgPSBwcm9wcy5zZWc7XG4gICAgICAgIHZhciB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgdmFyIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KEV2ZW50Um9vdCwgeyBzZWc6IHNlZywgdGltZVRleHQ6IHRpbWVUZXh0LCBkaXNhYmxlRHJhZ2dpbmc6IHByb3BzLmRpc2FibGVEcmFnZ2luZywgZGlzYWJsZVJlc2l6aW5nOiBwcm9wcy5kaXNhYmxlUmVzaXppbmcsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJJbm5lckNvbnRlbnQkMSwgaXNEcmFnZ2luZzogcHJvcHMuaXNEcmFnZ2luZywgaXNSZXNpemluZzogcHJvcHMuaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBwcm9wcy5pc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IHByb3BzLmlzU2VsZWN0ZWQsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXkgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IGNsYXNzTmFtZTogcHJvcHMuZXh0cmFDbGFzc05hbWVzLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhvb2tQcm9wcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCByZWY6IHJvb3RFbFJlZiB9LCBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpblwiLCByZWY6IGlubmVyRWxSZWYsIHN0eWxlOiB7IGNvbG9yOiBob29rUHJvcHMudGV4dENvbG9yIH0gfSwgaW5uZXJDb250ZW50KSxcbiAgICAgICAgICAgIGhvb2tQcm9wcy5pc1N0YXJ0UmVzaXphYmxlICYmXG4gICAgICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItc3RhcnRcIiB9KSxcbiAgICAgICAgICAgIGhvb2tQcm9wcy5pc0VuZFJlc2l6YWJsZSAmJlxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLWVuZFwiIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGFuZGFyZEV2ZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KHZkb21fY2pzLkZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG52YXIgTm93SW5kaWNhdG9yUm9vdCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgfTtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpO1xufSkpOyB9O1xuXG52YXIgREFZX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyBkYXk6ICdudW1lcmljJyB9KTtcbnZhciBEYXlDZWxsQ29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5Q2VsbENvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5Q2VsbENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRGF5Q2VsbENvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gcmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVByb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChDb250ZW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY29udGVudDogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5Q2VsbENvbnRlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlZmluZURheUNlbGxIb29rUHJvcHMocmF3KSB7XG4gICAgdmFyIGRhdGUgPSByYXcuZGF0ZSwgZGF0ZUVudiA9IHJhdy5kYXRlRW52O1xuICAgIHZhciBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIHJhdy5kYXRlUHJvZmlsZSk7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGRheU51bWJlclRleHQ6IHJhdy5zaG93RGF5TnVtYmVyID8gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgREFZX05VTV9GT1JNQVQpIDogJycgfSksIHJhdy5leHRyYVByb3BzKTtcbn1cblxudmFyIERheUNlbGxSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlDZWxsUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlDZWxsUm9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZmluZUhvb2tQcm9wcyA9IG1lbW9pemVPYmpBcmcocmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyk7XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlDZWxsUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB0aGlzLnJlZmluZUhvb2tQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXG4gICAgICAgICAgICBleHRyYVByb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gZ2V0RGF5Q2xhc3NOYW1lcyhob29rUHJvcHMsIGNvbnRleHQudGhlbWUpLmNvbmNhdChob29rUHJvcHMuaXNEaXNhYmxlZFxuICAgICAgICAgICAgPyBbXSAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcbiAgICAgICAgICAgIDogdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGhvb2tQcm9wcykpO1xuICAgICAgICB2YXIgZGF0YUF0dHJzID0gaG9va1Byb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcocHJvcHMuZGF0ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChNb3VudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50LCBlbFJlZjogcHJvcHMuZWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZikgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMsIGhvb2tQcm9wcy5pc0Rpc2FibGVkKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUNlbGxSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtXCIgKyBmaWxsVHlwZSB9KSk7XG59XG52YXIgQmdFdmVudCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoRXZlbnRSb290LCB7IGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogcHJvcHMuc2VnIC8qIHVzZWxlc3NzIGkgdGhpbmsgKi8sIHRpbWVUZXh0OiBcIlwiLCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWJnLWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgIH0gfSwgaW5uZXJDb250ZW50KSk7IH0pKTsgfTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIHZhciB0aXRsZSA9IHByb3BzLmV2ZW50LnRpdGxlO1xuICAgIHJldHVybiB0aXRsZSAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHByb3BzLmV2ZW50LnRpdGxlKSk7XG59XG5cbnZhciBXZWVrTnVtYmVyUm9vdCA9IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkYXRlID0gcHJvcHMuZGF0ZTtcbiAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy53ZWVrTnVtYmVyRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRGb3JtYXQ7XG4gICAgdmFyIG51bSA9IGRhdGVFbnYuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZSk7IC8vIFRPRE86IHNvbWVob3cgdXNlIGZvciBmb3JtYXR0aW5nIGFzIHdlbGw/XG4gICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIHZhciBob29rUHJvcHMgPSB7IG51bTogbnVtLCB0ZXh0OiB0ZXh0LCBkYXRlOiBkYXRlIH07XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lciwgZGlkTW91bnQ6IG9wdGlvbnMud2Vla051bWJlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyV2lsbFVubW91bnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn0pKTsgfTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0O1xufVxuXG52YXIgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG52YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoUG9wb3ZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3BvdmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IGVsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gICAgICAgIF90aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5yb290RWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbkNsb3NlID0gX3RoaXMucHJvcHMub25DbG9zZTtcbiAgICAgICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCB0aGVtZSA9IF9hLnRoZW1lLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIF9iID0gdGhpcywgcHJvcHMgPSBfYi5wcm9wcywgc3RhdGUgPSBfYi5zdGF0ZTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtcG9wb3ZlcicsXG4gICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygncG9wb3ZlcicpLFxuICAgICAgICBdLmNvbmNhdChwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pO1xuICAgICAgICByZXR1cm4gdmRvbV9janMuY3JlYXRlUG9ydGFsKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgdHNsaWIuX19hc3NpZ24oeyBpZDogcHJvcHMuaWQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMuZXh0cmFBdHRycywgeyByZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0pLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpIH0sXG4gICAgICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtcG9wb3Zlci10aXRsZVwiLCBpZDogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy50aXRsZSksXG4gICAgICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJyksIHRpdGxlOiBvcHRpb25zLmNsb3NlSGludCwgb25DbGljazogdGhpcy5oYW5kbGVDbG9zZUNsaWNrIH0pKSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpIH0sIHByb3BzLmNoaWxkcmVuKSksIHByb3BzLnBhcmVudEVsKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNSdGwgPSB0aGlzLmNvbnRleHQuaXNSdGw7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGFsaWdubWVudEVsID0gX2EuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCA9IF9hLmFsaWduR3JpZFRvcDtcbiAgICAgICAgdmFyIHJvb3RFbCA9IHRoaXMucm9vdEVsO1xuICAgICAgICB2YXIgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgdmFyIHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgdmFyIHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5fMSA9IHJvb3RFbC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHJvb3RFbCwge1xuICAgICAgICAgICAgICAgIHRvcDogcG9wb3ZlclRvcCAtIG9yaWdpbl8xLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3BvdmVyTGVmdCAtIG9yaWdpbl8xLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBvcG92ZXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIE1vcmVQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhNb3JlUG9wb3ZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3JlUG9wb3ZlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChyb290RWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vcmVQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGRhdGVFbnYgPSBfYS5kYXRlRW52O1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgc3RhcnREYXRlID0gcHJvcHMuc3RhcnREYXRlLCB0b2RheVJhbmdlID0gcHJvcHMudG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoRGF5Q2VsbFJvb3QsIHsgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBkYXlDbGFzc05hbWVzLCBkYXRhQXR0cnMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFBvcG92ZXIsIHsgZWxSZWY6IHJvb3RFbFJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZGF5Q2xhc3NOYW1lcyksIGV4dHJhQXR0cnM6IGRhdGFBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KERheUNlbGxDb250ZW50LCB7IGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLW1vcmUtcG9wb3Zlci1taXNjXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSksXG4gICAgICAgICAgICBwcm9wcy5jaGlsZHJlbikpOyB9KSk7XG4gICAgfTtcbiAgICBNb3JlUG9wb3Zlci5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcm9vdEVsID0gX2Eucm9vdEVsLCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxuICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogdHNsaWIuX19hc3NpZ24oeyBhbGxEYXk6IHRydWUsIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE1vcmVQb3BvdmVyO1xufShEYXRlQ29tcG9uZW50KSk7XG5cbnZhciBNb3JlTGlua1Jvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1vcmVMaW5rUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3JlTGlua1Jvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rRWxSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBtb3JlTGlua0NsaWNrID0gY29udGV4dC5vcHRpb25zLm1vcmVMaW5rQ2xpY2s7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGNvbXB1dGVSYW5nZShwcm9wcykuc3RhcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZFB1YmxpY1NlZyhzZWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBzZWcuZXZlbnRSYW5nZSwgZGVmID0gX2EuZGVmLCBpbnN0YW5jZSA9IF9hLmluc3RhbmNlLCByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb3JlTGlua0NsaWNrID0gbW9yZUxpbmtDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGFsbERheTogQm9vbGVhbihwcm9wcy5hbGxEYXlEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VnczogcHJvcHMuYWxsU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vcmVMaW5rQ2xpY2sgfHwgbW9yZUxpbmtDbGljayA9PT0gJ3BvcG92ZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdmlld0FwaSA9IGNvbnRleHQudmlld0FwaSwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgY2FsZW5kYXJBcGkgPSBjb250ZXh0LmNhbGVuZGFyQXBpO1xuICAgICAgICAgICAgdmFyIG1vcmVMaW5rVGV4dCA9IG9wdGlvbnMubW9yZUxpbmtUZXh0O1xuICAgICAgICAgICAgdmFyIG1vcmVDbnQgPSBwcm9wcy5tb3JlQ250O1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcbiAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxuICAgICAgICAgICAgICAgIDogXCIrXCIgKyBtb3JlQ250ICsgXCIgXCIgKyBtb3JlTGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5tb3JlTGlua0hpbnQsIFttb3JlQ250XSwgdGV4dCk7XG4gICAgICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IFwiK1wiICsgbW9yZUNudCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KHZkb21fY2pzLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIEJvb2xlYW4ocHJvcHMubW9yZUNudCkgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBlbFJlZjogX3RoaXMubGlua0VsUmVmLCBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5tb3JlTGlua0NsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMubW9yZUxpbmtDb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgWydmYy1tb3JlLWxpbmsnXS5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgX3RoaXMuaGFuZGxlQ2xpY2ssIHRpdGxlLCBzdGF0ZS5pc1BvcG92ZXJPcGVuLCBzdGF0ZS5pc1BvcG92ZXJPcGVuID8gc3RhdGUucG9wb3ZlcklkIDogJycpOyB9KSksXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IF90aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IF90aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSB9LCBwcm9wcy5wb3BvdmVyQ29udGVudCgpKSkpKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9O1xuICAgIE1vcmVMaW5rUm9vdC5wcm90b3R5cGUudXBkYXRlUGFyZW50RWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtFbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWxSZWYuY3VycmVudCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vcmVMaW5rUm9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGlkZGVuU2VncyA9IHByb3BzLmhpZGRlblNlZ3M7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpLFxuICAgICAgICBlbmQ6IGNvbXB1dGVMYXRlc3RTZWdFbmQoaGlkZGVuU2VncyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0VhcmxpZXN0U3RhcnQpLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG59XG5mdW5jdGlvbiBwaWNrRWFybGllc3RTdGFydChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA8IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA/IHNlZzAgOiBzZWcxO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxhdGVzdFNlZ0VuZChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tMYXRlc3RFbmQpLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gcGlja0xhdGVzdEVuZChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPiBzZWcxLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID8gc2VnMCA6IHNlZzE7XG59XG5cbi8vIGV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdmVyc2lvbiA9ICc1LjEwLjEnOyAvLyBpbXBvcnRhbnQgdG8gdHlwZSBpdCwgc28gLmQudHMgaGFzIGdlbmVyaWMgc3RyaW5nXG5cbmV4cG9ydHMuQkFTRV9PUFRJT05fREVGQVVMVFMgPSBCQVNFX09QVElPTl9ERUZBVUxUUztcbmV4cG9ydHMuQkFTRV9PUFRJT05fUkVGSU5FUlMgPSBCQVNFX09QVElPTl9SRUZJTkVSUztcbmV4cG9ydHMuQmFzZUNvbXBvbmVudCA9IEJhc2VDb21wb25lbnQ7XG5leHBvcnRzLkJnRXZlbnQgPSBCZ0V2ZW50O1xuZXhwb3J0cy5DYWxlbmRhckFwaSA9IENhbGVuZGFyQXBpO1xuZXhwb3J0cy5DYWxlbmRhckNvbnRlbnQgPSBDYWxlbmRhckNvbnRlbnQ7XG5leHBvcnRzLkNhbGVuZGFyRGF0YU1hbmFnZXIgPSBDYWxlbmRhckRhdGFNYW5hZ2VyO1xuZXhwb3J0cy5DYWxlbmRhckRhdGFQcm92aWRlciA9IENhbGVuZGFyRGF0YVByb3ZpZGVyO1xuZXhwb3J0cy5DYWxlbmRhclJvb3QgPSBDYWxlbmRhclJvb3Q7XG5leHBvcnRzLkNvbnRlbnRIb29rID0gQ29udGVudEhvb2s7XG5leHBvcnRzLkN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0ID0gQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQ7XG5leHBvcnRzLkRhdGVDb21wb25lbnQgPSBEYXRlQ29tcG9uZW50O1xuZXhwb3J0cy5EYXRlRW52ID0gRGF0ZUVudjtcbmV4cG9ydHMuRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbmV4cG9ydHMuRGF5Q2VsbENvbnRlbnQgPSBEYXlDZWxsQ29udGVudDtcbmV4cG9ydHMuRGF5Q2VsbFJvb3QgPSBEYXlDZWxsUm9vdDtcbmV4cG9ydHMuRGF5SGVhZGVyID0gRGF5SGVhZGVyO1xuZXhwb3J0cy5EYXlTZXJpZXNNb2RlbCA9IERheVNlcmllc01vZGVsO1xuZXhwb3J0cy5EYXlUYWJsZU1vZGVsID0gRGF5VGFibGVNb2RlbDtcbmV4cG9ydHMuRGVsYXllZFJ1bm5lciA9IERlbGF5ZWRSdW5uZXI7XG5leHBvcnRzLkVsZW1lbnREcmFnZ2luZyA9IEVsZW1lbnREcmFnZ2luZztcbmV4cG9ydHMuRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgPSBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcjtcbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5leHBvcnRzLkV2ZW50QXBpID0gRXZlbnRBcGk7XG5leHBvcnRzLkV2ZW50Um9vdCA9IEV2ZW50Um9vdDtcbmV4cG9ydHMuRXZlbnRTb3VyY2VBcGkgPSBFdmVudFNvdXJjZUFwaTtcbmV4cG9ydHMuSW50ZXJhY3Rpb24gPSBJbnRlcmFjdGlvbjtcbmV4cG9ydHMuTW9yZUxpbmtSb290ID0gTW9yZUxpbmtSb290O1xuZXhwb3J0cy5Nb3VudEhvb2sgPSBNb3VudEhvb2s7XG5leHBvcnRzLk5hbWVkVGltZVpvbmVJbXBsID0gTmFtZWRUaW1lWm9uZUltcGw7XG5leHBvcnRzLk5vd0luZGljYXRvclJvb3QgPSBOb3dJbmRpY2F0b3JSb290O1xuZXhwb3J0cy5Ob3dUaW1lciA9IE5vd1RpbWVyO1xuZXhwb3J0cy5Qb3NpdGlvbkNhY2hlID0gUG9zaXRpb25DYWNoZTtcbmV4cG9ydHMuUmVmTWFwID0gUmVmTWFwO1xuZXhwb3J0cy5SZW5kZXJIb29rID0gUmVuZGVySG9vaztcbmV4cG9ydHMuU2Nyb2xsQ29udHJvbGxlciA9IFNjcm9sbENvbnRyb2xsZXI7XG5leHBvcnRzLlNjcm9sbFJlc3BvbmRlciA9IFNjcm9sbFJlc3BvbmRlcjtcbmV4cG9ydHMuU2Nyb2xsZXIgPSBTY3JvbGxlcjtcbmV4cG9ydHMuU2VnSGllcmFyY2h5ID0gU2VnSGllcmFyY2h5O1xuZXhwb3J0cy5TaW1wbGVTY3JvbGxHcmlkID0gU2ltcGxlU2Nyb2xsR3JpZDtcbmV4cG9ydHMuU2xpY2VyID0gU2xpY2VyO1xuZXhwb3J0cy5TcGxpdHRlciA9IFNwbGl0dGVyO1xuZXhwb3J0cy5TdGFuZGFyZEV2ZW50ID0gU3RhbmRhcmRFdmVudDtcbmV4cG9ydHMuVGFibGVEYXRlQ2VsbCA9IFRhYmxlRGF0ZUNlbGw7XG5leHBvcnRzLlRhYmxlRG93Q2VsbCA9IFRhYmxlRG93Q2VsbDtcbmV4cG9ydHMuVGhlbWUgPSBUaGVtZTtcbmV4cG9ydHMuVmlld0FwaSA9IFZpZXdBcGk7XG5leHBvcnRzLlZpZXdDb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmV4cG9ydHMuVmlld1Jvb3QgPSBWaWV3Um9vdDtcbmV4cG9ydHMuV2Vla051bWJlclJvb3QgPSBXZWVrTnVtYmVyUm9vdDtcbmV4cG9ydHMuV2luZG93U2Nyb2xsQ29udHJvbGxlciA9IFdpbmRvd1Njcm9sbENvbnRyb2xsZXI7XG5leHBvcnRzLmFkZERheXMgPSBhZGREYXlzO1xuZXhwb3J0cy5hZGREdXJhdGlvbnMgPSBhZGREdXJhdGlvbnM7XG5leHBvcnRzLmFkZE1zID0gYWRkTXM7XG5leHBvcnRzLmFkZFdlZWtzID0gYWRkV2Vla3M7XG5leHBvcnRzLmFsbG93Q29udGV4dE1lbnUgPSBhbGxvd0NvbnRleHRNZW51O1xuZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IGFsbG93U2VsZWN0aW9uO1xuZXhwb3J0cy5hcHBseU11dGF0aW9uVG9FdmVudFN0b3JlID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZTtcbmV4cG9ydHMuYXBwbHlTdHlsZSA9IGFwcGx5U3R5bGU7XG5leHBvcnRzLmFwcGx5U3R5bGVQcm9wID0gYXBwbHlTdHlsZVByb3A7XG5leHBvcnRzLmFzQ2xlYW5EYXlzID0gYXNDbGVhbkRheXM7XG5leHBvcnRzLmFzUm91Z2hNaW51dGVzID0gYXNSb3VnaE1pbnV0ZXM7XG5leHBvcnRzLmFzUm91Z2hNcyA9IGFzUm91Z2hNcztcbmV4cG9ydHMuYXNSb3VnaFNlY29uZHMgPSBhc1JvdWdoU2Vjb25kcztcbmV4cG9ydHMuYmluYXJ5U2VhcmNoID0gYmluYXJ5U2VhcmNoO1xuZXhwb3J0cy5idWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXI7XG5leHBvcnRzLmJ1aWxkRW50cnlLZXkgPSBidWlsZEVudHJ5S2V5O1xuZXhwb3J0cy5idWlsZEV2ZW50QXBpcyA9IGJ1aWxkRXZlbnRBcGlzO1xuZXhwb3J0cy5idWlsZEV2ZW50UmFuZ2VLZXkgPSBidWlsZEV2ZW50UmFuZ2VLZXk7XG5leHBvcnRzLmJ1aWxkSGFzaEZyb21BcnJheSA9IGJ1aWxkSGFzaEZyb21BcnJheTtcbmV4cG9ydHMuYnVpbGRJc29TdHJpbmcgPSBidWlsZElzb1N0cmluZztcbmV4cG9ydHMuYnVpbGROYXZMaW5rQXR0cnMgPSBidWlsZE5hdkxpbmtBdHRycztcbmV4cG9ydHMuYnVpbGRTZWdDb21wYXJlT2JqID0gYnVpbGRTZWdDb21wYXJlT2JqO1xuZXhwb3J0cy5idWlsZFNlZ1RpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dDtcbmV4cG9ydHMuY29sbGVjdEZyb21IYXNoID0gY29sbGVjdEZyb21IYXNoO1xuZXhwb3J0cy5jb21iaW5lRXZlbnRVaXMgPSBjb21iaW5lRXZlbnRVaXM7XG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IGNvbXBhcmVCeUZpZWxkU3BlYztcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XG5leHBvcnRzLmNvbXBhcmVOdW1iZXJzID0gY29tcGFyZU51bWJlcnM7XG5leHBvcnRzLmNvbXBhcmVPYmpzID0gY29tcGFyZU9ianM7XG5leHBvcnRzLmNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0ID0gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQ7XG5leHBvcnRzLmNvbXB1dGVFZGdlcyA9IGNvbXB1dGVFZGdlcztcbmV4cG9ydHMuY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0ID0gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0O1xuZXhwb3J0cy5jb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyA9IGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zO1xuZXhwb3J0cy5jb21wdXRlSW5uZXJSZWN0ID0gY29tcHV0ZUlubmVyUmVjdDtcbmV4cG9ydHMuY29tcHV0ZVJlY3QgPSBjb21wdXRlUmVjdDtcbmV4cG9ydHMuY29tcHV0ZVNlZ0RyYWdnYWJsZSA9IGNvbXB1dGVTZWdEcmFnZ2FibGU7XG5leHBvcnRzLmNvbXB1dGVTZWdFbmRSZXNpemFibGUgPSBjb21wdXRlU2VnRW5kUmVzaXphYmxlO1xuZXhwb3J0cy5jb21wdXRlU2VnU3RhcnRSZXNpemFibGUgPSBjb21wdXRlU2VnU3RhcnRSZXNpemFibGU7XG5leHBvcnRzLmNvbXB1dGVTaHJpbmtXaWR0aCA9IGNvbXB1dGVTaHJpbmtXaWR0aDtcbmV4cG9ydHMuY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoID0gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoO1xuZXhwb3J0cy5jb21wdXRlVmlzaWJsZURheVJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuZXhwb3J0cy5jb25zdHJhaW5Qb2ludCA9IGNvbnN0cmFpblBvaW50O1xuZXhwb3J0cy5jcmVhdGVBcmlhQ2xpY2tBdHRycyA9IGNyZWF0ZUFyaWFDbGlja0F0dHJzO1xuZXhwb3J0cy5jcmVhdGVEdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuZXhwb3J0cy5jcmVhdGVFbXB0eUV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmU7XG5leHBvcnRzLmNyZWF0ZUV2ZW50SW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlO1xuZXhwb3J0cy5jcmVhdGVFdmVudFVpID0gY3JlYXRlRXZlbnRVaTtcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5jcmVhdGVQbHVnaW4gPSBjcmVhdGVQbHVnaW47XG5leHBvcnRzLmRpZmZEYXRlcyA9IGRpZmZEYXRlcztcbmV4cG9ydHMuZGlmZkRheUFuZFRpbWUgPSBkaWZmRGF5QW5kVGltZTtcbmV4cG9ydHMuZGlmZkRheXMgPSBkaWZmRGF5cztcbmV4cG9ydHMuZGlmZlBvaW50cyA9IGRpZmZQb2ludHM7XG5leHBvcnRzLmRpZmZXZWVrcyA9IGRpZmZXZWVrcztcbmV4cG9ydHMuZGlmZldob2xlRGF5cyA9IGRpZmZXaG9sZURheXM7XG5leHBvcnRzLmRpZmZXaG9sZVdlZWtzID0gZGlmZldob2xlV2Vla3M7XG5leHBvcnRzLmRpc2FibGVDdXJzb3IgPSBkaXNhYmxlQ3Vyc29yO1xuZXhwb3J0cy5lbGVtZW50Q2xvc2VzdCA9IGVsZW1lbnRDbG9zZXN0O1xuZXhwb3J0cy5lbGVtZW50TWF0Y2hlcyA9IGVsZW1lbnRNYXRjaGVzO1xuZXhwb3J0cy5lbmFibGVDdXJzb3IgPSBlbmFibGVDdXJzb3I7XG5leHBvcnRzLmV2ZW50VHVwbGVUb1N0b3JlID0gZXZlbnRUdXBsZVRvU3RvcmU7XG5leHBvcnRzLmZpbHRlckV2ZW50U3RvcmVEZWZzID0gZmlsdGVyRXZlbnRTdG9yZURlZnM7XG5leHBvcnRzLmZpbHRlckhhc2ggPSBmaWx0ZXJIYXNoO1xuZXhwb3J0cy5maW5kRGlyZWN0Q2hpbGRyZW4gPSBmaW5kRGlyZWN0Q2hpbGRyZW47XG5leHBvcnRzLmZpbmRFbGVtZW50cyA9IGZpbmRFbGVtZW50cztcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbmV4cG9ydHMuZm9ybWF0RGF5U3RyaW5nID0gZm9ybWF0RGF5U3RyaW5nO1xuZXhwb3J0cy5mb3JtYXRJc29UaW1lU3RyaW5nID0gZm9ybWF0SXNvVGltZVN0cmluZztcbmV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBmb3JtYXRSYW5nZTtcbmV4cG9ydHMuZ2V0QWxsb3dZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nO1xuZXhwb3J0cy5nZXRDYW5WR3Jvd1dpdGhpbkNlbGwgPSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGw7XG5leHBvcnRzLmdldENsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cztcbmV4cG9ydHMuZ2V0RGF0ZU1ldGEgPSBnZXREYXRlTWV0YTtcbmV4cG9ydHMuZ2V0RGF5Q2xhc3NOYW1lcyA9IGdldERheUNsYXNzTmFtZXM7XG5leHBvcnRzLmdldERlZmF1bHRFdmVudEVuZCA9IGdldERlZmF1bHRFdmVudEVuZDtcbmV4cG9ydHMuZ2V0RWxSb290ID0gZ2V0RWxSb290O1xuZXhwb3J0cy5nZXRFbFNlZyA9IGdldEVsU2VnO1xuZXhwb3J0cy5nZXRFbnRyeVNwYW5FbmQgPSBnZXRFbnRyeVNwYW5FbmQ7XG5leHBvcnRzLmdldEV2ZW50Q2xhc3NOYW1lcyA9IGdldEV2ZW50Q2xhc3NOYW1lcztcbmV4cG9ydHMuZ2V0RXZlbnRUYXJnZXRWaWFSb290ID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290O1xuZXhwb3J0cy5nZXRJc1J0bFNjcm9sbGJhck9uTGVmdCA9IGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0O1xuZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcbmV4cG9ydHMuZ2V0UmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cztcbmV4cG9ydHMuZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcztcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzO1xuZXhwb3J0cy5nZXRTZWN0aW9uQ2xhc3NOYW1lcyA9IGdldFNlY3Rpb25DbGFzc05hbWVzO1xuZXhwb3J0cy5nZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0ID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodDtcbmV4cG9ydHMuZ2V0U2VnQW5jaG9yQXR0cnMgPSBnZXRTZWdBbmNob3JBdHRycztcbmV4cG9ydHMuZ2V0U2VnTWV0YSA9IGdldFNlZ01ldGE7XG5leHBvcnRzLmdldFNsb3RDbGFzc05hbWVzID0gZ2V0U2xvdENsYXNzTmFtZXM7XG5leHBvcnRzLmdldFN0aWNreUZvb3RlclNjcm9sbGJhciA9IGdldFN0aWNreUZvb3RlclNjcm9sbGJhcjtcbmV4cG9ydHMuZ2V0U3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcztcbmV4cG9ydHMuZ2V0VW5lcXVhbFByb3BzID0gZ2V0VW5lcXVhbFByb3BzO1xuZXhwb3J0cy5nZXRVbmlxdWVEb21JZCA9IGdldFVuaXF1ZURvbUlkO1xuZXhwb3J0cy5nbG9iYWxMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcztcbmV4cG9ydHMuZ2xvYmFsUGx1Z2lucyA9IGdsb2JhbFBsdWdpbnM7XG5leHBvcnRzLmdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcjtcbmV4cG9ydHMuZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzID0gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzO1xuZXhwb3J0cy5ndWlkID0gZ3VpZDtcbmV4cG9ydHMuaGFzQmdSZW5kZXJpbmcgPSBoYXNCZ1JlbmRlcmluZztcbmV4cG9ydHMuaGFzU2hyaW5rV2lkdGggPSBoYXNTaHJpbmtXaWR0aDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0gaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlO1xuZXhwb3J0cy5pbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSA9IGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlO1xuZXhwb3J0cy5pbnRlcnNlY3RSYW5nZXMgPSBpbnRlcnNlY3RSYW5nZXM7XG5leHBvcnRzLmludGVyc2VjdFJlY3RzID0gaW50ZXJzZWN0UmVjdHM7XG5leHBvcnRzLmludGVyc2VjdFNwYW5zID0gaW50ZXJzZWN0U3BhbnM7XG5leHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xuZXhwb3J0cy5pc0NvbFByb3BzRXF1YWwgPSBpc0NvbFByb3BzRXF1YWw7XG5leHBvcnRzLmlzRGF0ZVNlbGVjdGlvblZhbGlkID0gaXNEYXRlU2VsZWN0aW9uVmFsaWQ7XG5leHBvcnRzLmlzRGF0ZVNwYW5zRXF1YWwgPSBpc0RhdGVTcGFuc0VxdWFsO1xuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuZXhwb3J0cy5pc0ludGVyYWN0aW9uVmFsaWQgPSBpc0ludGVyYWN0aW9uVmFsaWQ7XG5leHBvcnRzLmlzTXVsdGlEYXlSYW5nZSA9IGlzTXVsdGlEYXlSYW5nZTtcbmV4cG9ydHMuaXNQcm9wc0VxdWFsID0gaXNQcm9wc0VxdWFsO1xuZXhwb3J0cy5pc1Byb3BzVmFsaWQgPSBpc1Byb3BzVmFsaWQ7XG5leHBvcnRzLmlzVmFsaWREYXRlID0gaXNWYWxpZERhdGU7XG5leHBvcnRzLmpvaW5TcGFucyA9IGpvaW5TcGFucztcbmV4cG9ydHMubGlzdGVuQnlTZWxlY3RvciA9IGxpc3RlbkJ5U2VsZWN0b3I7XG5leHBvcnRzLm1hcEhhc2ggPSBtYXBIYXNoO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmV4cG9ydHMubWVtb2l6ZUFycmF5bGlrZSA9IG1lbW9pemVBcnJheWxpa2U7XG5leHBvcnRzLm1lbW9pemVIYXNobGlrZSA9IG1lbW9pemVIYXNobGlrZTtcbmV4cG9ydHMubWVtb2l6ZU9iakFyZyA9IG1lbW9pemVPYmpBcmc7XG5leHBvcnRzLm1lcmdlRXZlbnRTdG9yZXMgPSBtZXJnZUV2ZW50U3RvcmVzO1xuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gbXVsdGlwbHlEdXJhdGlvbjtcbmV4cG9ydHMucGFkU3RhcnQgPSBwYWRTdGFydDtcbmV4cG9ydHMucGFyc2VCdXNpbmVzc0hvdXJzID0gcGFyc2VCdXNpbmVzc0hvdXJzO1xuZXhwb3J0cy5wYXJzZUNsYXNzTmFtZXMgPSBwYXJzZUNsYXNzTmFtZXM7XG5leHBvcnRzLnBhcnNlRHJhZ01ldGEgPSBwYXJzZURyYWdNZXRhO1xuZXhwb3J0cy5wYXJzZUV2ZW50RGVmID0gcGFyc2VFdmVudERlZjtcbmV4cG9ydHMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xuZXhwb3J0cy5wYXJzZU1hcmtlciA9IHBhcnNlO1xuZXhwb3J0cy5wb2ludEluc2lkZVJlY3QgPSBwb2ludEluc2lkZVJlY3Q7XG5leHBvcnRzLnByZXZlbnRDb250ZXh0TWVudSA9IHByZXZlbnRDb250ZXh0TWVudTtcbmV4cG9ydHMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbmV4cG9ydHMucHJldmVudFNlbGVjdGlvbiA9IHByZXZlbnRTZWxlY3Rpb247XG5leHBvcnRzLnJhbmdlQ29udGFpbnNNYXJrZXIgPSByYW5nZUNvbnRhaW5zTWFya2VyO1xuZXhwb3J0cy5yYW5nZUNvbnRhaW5zUmFuZ2UgPSByYW5nZUNvbnRhaW5zUmFuZ2U7XG5leHBvcnRzLnJhbmdlc0VxdWFsID0gcmFuZ2VzRXF1YWw7XG5leHBvcnRzLnJhbmdlc0ludGVyc2VjdCA9IHJhbmdlc0ludGVyc2VjdDtcbmV4cG9ydHMucmVmaW5lRXZlbnREZWYgPSByZWZpbmVFdmVudERlZjtcbmV4cG9ydHMucmVmaW5lUHJvcHMgPSByZWZpbmVQcm9wcztcbmV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHJlbW92ZUVsZW1lbnQ7XG5leHBvcnRzLnJlbW92ZUV4YWN0ID0gcmVtb3ZlRXhhY3Q7XG5leHBvcnRzLnJlbmRlckNodW5rQ29udGVudCA9IHJlbmRlckNodW5rQ29udGVudDtcbmV4cG9ydHMucmVuZGVyRmlsbCA9IHJlbmRlckZpbGw7XG5leHBvcnRzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSByZW5kZXJNaWNyb0NvbEdyb3VwO1xuZXhwb3J0cy5yZW5kZXJTY3JvbGxTaGltID0gcmVuZGVyU2Nyb2xsU2hpbTtcbmV4cG9ydHMucmVxdWVzdEpzb24gPSByZXF1ZXN0SnNvbjtcbmV4cG9ydHMuc2FuaXRpemVTaHJpbmtXaWR0aCA9IHNhbml0aXplU2hyaW5rV2lkdGg7XG5leHBvcnRzLnNldEVsU2VnID0gc2V0RWxTZWc7XG5leHBvcnRzLnNldFJlZiA9IHNldFJlZjtcbmV4cG9ydHMuc2xpY2VFdmVudFN0b3JlID0gc2xpY2VFdmVudFN0b3JlO1xuZXhwb3J0cy5zbGljZUV2ZW50cyA9IHNsaWNlRXZlbnRzO1xuZXhwb3J0cy5zb3J0RXZlbnRTZWdzID0gc29ydEV2ZW50U2VncztcbmV4cG9ydHMuc3RhcnRPZkRheSA9IHN0YXJ0T2ZEYXk7XG5leHBvcnRzLnRyYW5zbGF0ZVJlY3QgPSB0cmFuc2xhdGVSZWN0O1xuZXhwb3J0cy50cmlnZ2VyRGF0ZVNlbGVjdCA9IHRyaWdnZXJEYXRlU2VsZWN0O1xuZXhwb3J0cy51bnByb21pc2lmeSA9IHVucHJvbWlzaWZ5O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMud2hlblRyYW5zaXRpb25Eb25lID0gd2hlblRyYW5zaXRpb25Eb25lO1xuZXhwb3J0cy53aG9sZURpdmlkZUR1cmF0aW9ucyA9IHdob2xlRGl2aWRlRHVyYXRpb25zO1xuT2JqZWN0LmtleXModmRvbV9janMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZG9tX2Nqc1trXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYiIsInJlcXVpcmUiLCJ2ZG9tX2NqcyIsIkV2ZW50U291cmNlQXBpIiwiY29udGV4dCIsImludGVybmFsRXZlbnRTb3VyY2UiLCJwcm90b3R5cGUiLCJyZW1vdmUiLCJkaXNwYXRjaCIsInR5cGUiLCJzb3VyY2VJZCIsInJlZmV0Y2giLCJzb3VyY2VJZHMiLCJpc1JlZmV0Y2giLCJnZXQiLCJwdWJsaWNJZCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtZXRhIiwidXJsIiwiZm9ybWF0IiwicmVtb3ZlRWxlbWVudCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZWxlbWVudENsb3Nlc3QiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiZWxlbWVudE1hdGNoZXMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJtZXRob2QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJjYWxsIiwiZmluZEVsZW1lbnRzIiwiY29udGFpbmVyIiwiY29udGFpbmVycyIsIkhUTUxFbGVtZW50IiwiYWxsTWF0Y2hlcyIsImkiLCJsZW5ndGgiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaiIsInB1c2giLCJmaW5kRGlyZWN0Q2hpbGRyZW4iLCJwYXJlbnQiLCJwYXJlbnRzIiwiY2hpbGROb2RlcyIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwiUElYRUxfUFJPUF9SRSIsImFwcGx5U3R5bGUiLCJwcm9wcyIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJuYW1lIiwidmFsIiwic3R5bGUiLCJ0ZXN0IiwiZ2V0RXZlbnRUYXJnZXRWaWFSb290IiwiZXYiLCJfYSIsIl9iIiwiY29tcG9zZWRQYXRoIiwidGFyZ2V0IiwiZ2V0RWxSb290IiwiZ2V0Um9vdE5vZGUiLCJndWlkJDEiLCJnZXRVbmlxdWVEb21JZCIsInByZXZlbnREZWZhdWx0IiwiYnVpbGREZWxlZ2F0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJtYXRjaGVkQ2hpbGQiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiZXZlbnRUeXBlIiwiYXR0YWNoZWRIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsImN1cnJlbnRNYXRjaGVkQ2hpbGQiLCJtb3VzZU92ZXJFdiIsInJlYWxPbk1vdXNlTGVhdmVfMSIsIm1vdXNlTGVhdmVFdiIsInRyYW5zaXRpb25FdmVudE5hbWVzIiwid2hlblRyYW5zaXRpb25Eb25lIiwiY2FsbGJhY2siLCJyZWFsQ2FsbGJhY2siLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwiY3JlYXRlQXJpYUNsaWNrQXR0cnMiLCJfX2Fzc2lnbiIsIm9uQ2xpY2siLCJjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyIsInRhYkluZGV4Iiwib25LZXlEb3duIiwia2V5IiwiZ3VpZE51bWJlciIsImd1aWQiLCJTdHJpbmciLCJkaXNhYmxlQ3Vyc29yIiwiYm9keSIsImNsYXNzTGlzdCIsImFkZCIsImVuYWJsZUN1cnNvciIsInByZXZlbnRTZWxlY3Rpb24iLCJhbGxvd1NlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93Q29udGV4dE1lbnUiLCJwYXJzZUZpZWxkU3BlY3MiLCJpbnB1dCIsInNwZWNzIiwidG9rZW5zIiwidG9rZW4iLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsImNoYXJBdCIsImZpZWxkIiwic3Vic3RyaW5nIiwib3JkZXIiLCJmdW5jIiwiY29tcGFyZUJ5RmllbGRTcGVjcyIsIm9iajAiLCJvYmoxIiwiZmllbGRTcGVjcyIsImNtcCIsImNvbXBhcmVCeUZpZWxkU3BlYyIsImZpZWxkU3BlYyIsImZsZXhpYmxlQ29tcGFyZSIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInBhZFN0YXJ0IiwibGVuIiwicyIsInN1YnN0ciIsImZvcm1hdFdpdGhPcmRpbmFscyIsImZvcm1hdHRlciIsImFyZ3MiLCJmYWxsYmFja1RleHQiLCJhcHBseSIsInJlZHVjZSIsInN0ciIsImFyZyIsImluZGV4IiwicmVwbGFjZSIsImNvbXBhcmVOdW1iZXJzIiwiaXNJbnQiLCJuIiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsInF1ZXJ5U2VsZWN0b3IiLCJjb250ZW50V2lkdGhFbCIsIkVycm9yIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJtIiwiZGF0ZVRvVXRjQXJyYXkiLCJhcnJheVRvVXRjRGF0ZSIsImFkZERheXMiLCJhZGRNcyIsImRpZmZXZWVrcyIsIm0wIiwibTEiLCJkaWZmRGF5cyIsInZhbHVlT2YiLCJkaWZmSG91cnMiLCJkaWZmTWludXRlcyIsImRpZmZTZWNvbmRzIiwiZGlmZkRheUFuZFRpbWUiLCJtMGRheSIsInN0YXJ0T2ZEYXkiLCJtMWRheSIsInllYXJzIiwibW9udGhzIiwiZGF5cyIsIk1hdGgiLCJyb3VuZCIsIm1pbGxpc2Vjb25kcyIsImRpZmZXaG9sZVdlZWtzIiwiZCIsImRpZmZXaG9sZURheXMiLCJ0aW1lQXNNcyIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwic3RhcnRPZkhvdXIiLCJnZXRVVENIb3VycyIsInN0YXJ0T2ZNaW51dGUiLCJnZXRVVENNaW51dGVzIiwic3RhcnRPZlNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJ3ZWVrT2ZZZWFyIiwibWFya2VyIiwiZG93IiwiZG95IiwieSIsInciLCJ3ZWVrT2ZHaXZlblllYXIiLCJuZXh0VyIsIm1pbiIsInllYXIiLCJmaXJzdFdlZWtTdGFydCIsImZpcnN0V2Vla09mZnNldCIsImRheVN0YXJ0IiwiZmxvb3IiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRhdGVUb0xvY2FsQXJyYXkiLCJkYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiYXJyYXlUb0xvY2FsRGF0ZSIsIkRhdGUiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJjb25jYXQiLCJVVEMiLCJpc1ZhbGlkRGF0ZSIsImlzTmFOIiwiY3JlYXRlRXZlbnRJbnN0YW5jZSIsImRlZklkIiwicmFuZ2UiLCJmb3JjZWRTdGFydFR6byIsImZvcmNlZEVuZFR6byIsImluc3RhbmNlSWQiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlUHJvcHMiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJuYW1lXzEiLCJjb21wbGV4T2JqcyIsInVuc2hpZnQiLCJ1bmRlZmluZWQiLCJuYW1lXzIiLCJmaWx0ZXJIYXNoIiwiaGFzaCIsImZpbHRlcmVkIiwibWFwSGFzaCIsIm5ld0hhc2giLCJhcnJheVRvSGFzaCIsIl9pIiwiYV8xIiwiaXRlbSIsImJ1aWxkSGFzaEZyb21BcnJheSIsInR1cGxlIiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJvYmoiLCJpc1Byb3BzRXF1YWwiLCJnZXRVbmVxdWFsUHJvcHMiLCJrZXlzIiwiY29tcGFyZU9ianMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiZXF1YWxpdHlGdW5jcyIsImlzT2JqVmFsc0VxdWFsIiwidmFsMCIsInZhbDEiLCJjb21wYXJhdG9yIiwiY29sbGVjdEZyb21IYXNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic3RlcCIsInJlcyIsInBhcnNlUmVjdXJyaW5nIiwicmVmaW5lZCIsImRlZmF1bHRBbGxEYXkiLCJkYXRlRW52IiwicmVjdXJyaW5nVHlwZXMiLCJwYXJzZWQiLCJwYXJzZSIsImFsbERheSIsImFsbERheUd1ZXNzIiwiZHVyYXRpb24iLCJ0eXBlRGF0YSIsInR5cGVJZCIsImV4cGFuZFJlY3VycmluZyIsImV2ZW50U3RvcmUiLCJmcmFtaW5nUmFuZ2UiLCJwbHVnaW5Ib29rcyIsIm9wdGlvbnMiLCJkZWZzIiwiaW5zdGFuY2VzIiwiaW5zdGFuY2UiLCJyZWN1cnJpbmdEZWYiLCJkZWYiLCJkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiIsImRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24iLCJzdGFydHMiLCJleHBhbmRSZWN1cnJpbmdSYW5nZXMiLCJzdGFydHNfMSIsInN0YXJ0IiwiZW5kIiwiZXZlbnREZWYiLCJ0eXBlRGVmIiwibWFya2VycyIsImV4cGFuZCIsInN1YnRyYWN0IiwibWFwIiwiSU5URVJOQUxfVU5JVFMiLCJQQVJTRV9SRSIsImNyZWF0ZUR1cmF0aW9uIiwidW5pdCIsInBhcnNlU3RyaW5nIiwicGFyc2VPYmplY3QiLCJleGVjIiwic2lnbiIsInBhcnNlSW50IiwibW9udGgiLCJkYXkiLCJob3VycyIsImhvdXIiLCJtaW51dGVzIiwibWludXRlIiwic2Vjb25kcyIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwibXMiLCJ3ZWVrcyIsIndlZWsiLCJzcGVjaWZpZWRXZWVrcyIsImR1cmF0aW9uc0VxdWFsIiwiZDAiLCJkMSIsImFzQ2xlYW5EYXlzIiwiZHVyIiwiYWRkRHVyYXRpb25zIiwic3VidHJhY3REdXJhdGlvbnMiLCJtdWx0aXBseUR1cmF0aW9uIiwiYXNSb3VnaFllYXJzIiwiYXNSb3VnaERheXMiLCJhc1JvdWdoTW9udGhzIiwiYXNSb3VnaE1zIiwiYXNSb3VnaE1pbnV0ZXMiLCJhc1JvdWdoU2Vjb25kcyIsIndob2xlRGl2aWRlRHVyYXRpb25zIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJsb2NhbFJlcyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsImJ1aWxkSXNvU3RyaW5nIiwidGltZVpvbmVPZmZzZXQiLCJzdHJpcFplcm9UaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRUaW1lWm9uZU9mZnNldCIsImZvcm1hdERheVN0cmluZyIsImZvcm1hdElzb1RpbWVTdHJpbmciLCJkb0lzbyIsImFicyIsIm1pbnMiLCJyZW1vdmVFeGFjdCIsImFycmF5IiwiZXhhY3RWYWwiLCJyZW1vdmVDbnQiLCJzcGxpY2UiLCJpc0FycmF5c0VxdWFsIiwiYTAiLCJhMSIsImVxdWFsaXR5RnVuYyIsIm1lbW9pemUiLCJ3b3JrZXJGdW5jIiwicmVzRXF1YWxpdHkiLCJ0ZWFyZG93bkZ1bmMiLCJjdXJyZW50QXJncyIsImN1cnJlbnRSZXMiLCJuZXdBcmdzIiwiYXJndW1lbnRzIiwibWVtb2l6ZU9iakFyZyIsIl90aGlzIiwiY3VycmVudEFyZyIsIm5ld0FyZyIsIm1lbW9pemVBcnJheWxpa2UiLCJjdXJyZW50QXJnU2V0cyIsImN1cnJlbnRSZXN1bHRzIiwibmV3QXJnU2V0cyIsImN1cnJlbnRMZW4iLCJuZXdMZW4iLCJtZW1vaXplSGFzaGxpa2UiLCJjdXJyZW50QXJnSGFzaCIsImN1cnJlbnRSZXNIYXNoIiwibmV3QXJnSGFzaCIsIm5ld1Jlc0hhc2giLCJFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyIsInNlcGFyYXRvciIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJvbWl0Q29tbWFzIiwiU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMiLCJ0aW1lWm9uZU5hbWUiLCJlcmEiLCJ3ZWVrZGF5IiwiTUVSSURJRU1fUkUiLCJDT01NQV9SRSIsIk1VTFRJX1NQQUNFX1JFIiwiTFRSX1JFIiwiVVRDX1JFIiwiTmF0aXZlRm9ybWF0dGVyIiwiZm9ybWF0U2V0dGluZ3MiLCJzdGFuZGFyZERhdGVQcm9wcyIsImV4dGVuZGVkU2V0dGluZ3MiLCJzZXZlcml0eSIsIm1heCIsImJ1aWxkRm9ybWF0dGluZ0Z1bmMiLCJmb3JtYXRSYW5nZSIsImJldHRlckRlZmF1bHRTZXBhcmF0b3IiLCJkaWZmU2V2ZXJpdHkiLCJjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5IiwiY2FsZW5kYXJTeXN0ZW0iLCJiaWdnZXN0VW5pdEZvclBhcnRpYWwiLCJmdWxsMCIsImZ1bGwxIiwicGFydGlhbERhdGVQcm9wcyIsImNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMiLCJwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMiLCJwYXJ0aWFsMCIsInBhcnRpYWwxIiwiaW5zZXJ0aW9uIiwiZmluZENvbW1vbkluc2VydGlvbiIsImRlZmF1bHRTZXBhcmF0b3IiLCJiZWZvcmUiLCJhZnRlciIsImdldExhcmdlc3RVbml0Iiwic3RhbmRhcmREYXRlUHJvcENudCIsImZvcm1hdFdlZWtOdW1iZXIiLCJjb21wdXRlV2Vla051bWJlciIsIndlZWtUZXh0Iiwid2Vla1RleHRMb25nIiwibG9jYWxlIiwiYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyIsInNhbml0aXplU2V0dGluZ3MiLCJ0aW1lWm9uZSIsIm5vcm1hbEZvcm1hdCIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsImNvZGVzIiwiemVyb0Zvcm1hdCIsInplcm9Qcm9wcyIsInBvc3RQcm9jZXNzIiwiaW5qZWN0VHpvU3RyIiwidHJpbSIsInRvTG9jYWxlTG93ZXJDYXNlIiwidHpvU3RyIiwicmVwbGFjZWQiLCJudW0iLCJkaXNwbGF5IiwicGFydHMiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJkaXJlY3Rpb24iLCJyZXZlcnNlIiwiam9pbiIsImNhIiwiZ2V0TWFya2VyWWVhciIsImdldE1hcmtlck1vbnRoIiwiZ2V0TWFya2VyRGF5IiwiYmlnZ2VzdFVuaXQiLCJwYXJ0aWFsT3B0aW9ucyIsImkwIiwiZm91bmQwIiwiaW5kZXhPZiIsImJlZm9yZTAiLCJhZnRlcjAiLCJpMSIsImZvdW5kMSIsImJlZm9yZTEiLCJhZnRlcjEiLCJleHBhbmRab25lZE1hcmtlciIsImRhdGVJbmZvIiwibWFya2VyVG9BcnJheSIsImNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnIiwic3RhcnRJbmZvIiwiZW5kSW5mbyIsImxvY2FsZUNvZGVzIiwiQ21kRm9ybWF0dGVyIiwiY21kU3RyIiwiY21kRm9ybWF0dGVyIiwiRnVuY0Zvcm1hdHRlciIsImNyZWF0ZUZvcm1hdHRlciIsIkJBU0VfT1BUSU9OX1JFRklORVJTIiwibmF2TGlua0RheUNsaWNrIiwiaWRlbnRpdHkiLCJuYXZMaW5rV2Vla0NsaWNrIiwiYm9vdHN0cmFwRm9udEF3ZXNvbWUiLCJidXR0b25JY29ucyIsImN1c3RvbUJ1dHRvbnMiLCJuZXh0RGF5VGhyZXNob2xkIiwic2Nyb2xsVGltZSIsInNjcm9sbFRpbWVSZXNldCIsIkJvb2xlYW4iLCJzbG90TWluVGltZSIsInNsb3RNYXhUaW1lIiwiZGF5UG9wb3ZlckZvcm1hdCIsInNsb3REdXJhdGlvbiIsInNuYXBEdXJhdGlvbiIsImhlYWRlclRvb2xiYXIiLCJmb290ZXJUb29sYmFyIiwiZGVmYXVsdFJhbmdlU2VwYXJhdG9yIiwidGl0bGVSYW5nZVNlcGFyYXRvciIsImZvcmNlRXZlbnREdXJhdGlvbiIsImRheUhlYWRlcnMiLCJkYXlIZWFkZXJGb3JtYXQiLCJkYXlIZWFkZXJDbGFzc05hbWVzIiwiZGF5SGVhZGVyQ29udGVudCIsImRheUhlYWRlckRpZE1vdW50IiwiZGF5SGVhZGVyV2lsbFVubW91bnQiLCJkYXlDZWxsQ2xhc3NOYW1lcyIsImRheUNlbGxDb250ZW50IiwiZGF5Q2VsbERpZE1vdW50IiwiZGF5Q2VsbFdpbGxVbm1vdW50IiwiaW5pdGlhbFZpZXciLCJhc3BlY3RSYXRpbyIsIk51bWJlciIsIndlZWtlbmRzIiwid2Vla051bWJlckNhbGN1bGF0aW9uIiwid2Vla051bWJlcnMiLCJ3ZWVrTnVtYmVyQ2xhc3NOYW1lcyIsIndlZWtOdW1iZXJDb250ZW50Iiwid2Vla051bWJlckRpZE1vdW50Iiwid2Vla051bWJlcldpbGxVbm1vdW50IiwiZWRpdGFibGUiLCJ2aWV3Q2xhc3NOYW1lcyIsInZpZXdEaWRNb3VudCIsInZpZXdXaWxsVW5tb3VudCIsIm5vd0luZGljYXRvciIsIm5vd0luZGljYXRvckNsYXNzTmFtZXMiLCJub3dJbmRpY2F0b3JDb250ZW50Iiwibm93SW5kaWNhdG9yRGlkTW91bnQiLCJub3dJbmRpY2F0b3JXaWxsVW5tb3VudCIsInNob3dOb25DdXJyZW50RGF0ZXMiLCJsYXp5RmV0Y2hpbmciLCJzdGFydFBhcmFtIiwiZW5kUGFyYW0iLCJ0aW1lWm9uZVBhcmFtIiwibG9jYWxlcyIsInRoZW1lU3lzdGVtIiwiZHJhZ1JldmVydER1cmF0aW9uIiwiZHJhZ1Njcm9sbCIsImFsbERheU1haW50YWluRHVyYXRpb24iLCJ1bnNlbGVjdEF1dG8iLCJkcm9wQWNjZXB0IiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJoYW5kbGVXaW5kb3dSZXNpemUiLCJ3aW5kb3dSZXNpemVEZWxheSIsImxvbmdQcmVzc0RlbGF5IiwiZXZlbnREcmFnTWluRGlzdGFuY2UiLCJleHBhbmRSb3dzIiwiaGVpZ2h0IiwiY29udGVudEhlaWdodCIsIndlZWtOdW1iZXJGb3JtYXQiLCJldmVudFJlc2l6YWJsZUZyb21TdGFydCIsImRpc3BsYXlFdmVudFRpbWUiLCJkaXNwbGF5RXZlbnRFbmQiLCJwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nIiwiYnVzaW5lc3NIb3VycyIsImluaXRpYWxEYXRlIiwibm93IiwiZXZlbnREYXRhVHJhbnNmb3JtIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJzdGlja3lGb290ZXJTY3JvbGxiYXIiLCJ2aWV3SGVpZ2h0IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwibW9udGhNb2RlIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwiQkFTRV9PUFRJT05fREVGQVVMVFMiLCJjZW50ZXIiLCJDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyIsImRhdGVzU2V0IiwiZXZlbnRzU2V0IiwiZXZlbnRBZGQiLCJldmVudENoYW5nZSIsImV2ZW50UmVtb3ZlIiwid2luZG93UmVzaXplIiwiZXZlbnRDbGljayIsImV2ZW50TW91c2VFbnRlciIsImV2ZW50TW91c2VMZWF2ZSIsInNlbGVjdCIsInVuc2VsZWN0IiwibG9hZGluZyIsIl91bm1vdW50IiwiX2JlZm9yZXByaW50IiwiX2FmdGVycHJpbnQiLCJfbm9FdmVudERyb3AiLCJfbm9FdmVudFJlc2l6ZSIsIl9yZXNpemUiLCJfc2Nyb2xsUmVxdWVzdCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsImJ1dHRvblRleHQiLCJidXR0b25IaW50cyIsInZpZXdzIiwiaW5pdGlhbEV2ZW50cyIsImV2ZW50cyIsImV2ZW50U291cmNlcyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiaXNCb29sQ29tcGxleEVxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJleHRyYSIsInJhdyIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsImV2ZW50UmVmaW5lcnMiLCJidWlsZEV2ZW50UmVmaW5lcnMiLCJyYXdFdmVudHNfMSIsInJhd0V2ZW50IiwicGFyc2VFdmVudCIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJkZWZfMSIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsInN1YiIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY2xhc3NOYW1lIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzaW5nbGVSZXMiLCJwYXJzZVNpbmdsZSIsImhhc0VuZCIsInVpIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJtZW1iZXJBZGRlciIsImZyZWV6ZSIsInN0YXJ0TWV0YSIsInN0YXJ0TWFya2VyIiwiZW5kTWV0YSIsImVuZE1hcmtlciIsInN0YXJ0SW5wdXQiLCJjcmVhdGVNYXJrZXJNZXRhIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJmb3JjZWRUem8iLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsImNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsImRpZmZEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJsYXJnZVVuaXQiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsInNvcnQiLCJjb21wYXJlUmFuZ2VzIiwicmFuZ2UwIiwicmFuZ2UxIiwiaW50ZXJzZWN0UmFuZ2VzIiwibmV3UmFuZ2UiLCJyYW5nZXNFcXVhbCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsIm91dGVyUmFuZ2UiLCJpbm5lclJhbmdlIiwicmFuZ2VDb250YWluc01hcmtlciIsImNvbnN0cmFpbk1hcmtlclRvUmFuZ2UiLCJzbGljZUV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpbnZlcnNlQmdCeUdyb3VwSWQiLCJpbnZlcnNlQmdCeURlZklkIiwiZGVmQnlHcm91cElkIiwiYmdSYW5nZXMiLCJmZ1JhbmdlcyIsImV2ZW50VWlzIiwiY29tcGlsZUV2ZW50VWlzIiwib3JpZ1JhbmdlIiwibm9ybWFsUmFuZ2UiLCJzbGljZWRSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsImludmVydGVkUmFuZ2VzXzEiLCJpbnZlcnRlZFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXNfMiIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiYyIsIl9zZWciLCJldmVudFJhbmdlIiwiY29tcHV0ZVNlZ0RyYWdnYWJsZSIsInRyYW5zZm9ybWVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXJzXzEiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsImV2ZW50SW5zdGFuY2UiLCJ3aG9sZUV2ZW50U3RhcnQiLCJ3aG9sZUV2ZW50RW5kIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJpc1N0YXJ0RGF5IiwiaXNFbmREYXkiLCJnZXRTZWdNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJzZWdSYW5nZSIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImdldEV2ZW50Q2xhc3NOYW1lcyIsImlzTWlycm9yIiwiaXNEcmFnZ2FibGUiLCJpc1N0YXJ0UmVzaXphYmxlIiwiaXNFbmRSZXNpemFibGUiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzU2VsZWN0ZWQiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJnZXRTZWdBbmNob3JBdHRycyIsImhyZWYiLCJlbWl0dGVyIiwiaGFzSGFuZGxlcnMiLCJ0cmlnZ2VyIiwiZXZlbnQiLCJFdmVudEFwaSIsImpzRXZlbnQiLCJ2aWV3Iiwidmlld0FwaSIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsInN0YW5kYXJkUHJvcHMiLCJpc0RhdGVTcGFuc0VxdWFsIiwic3BhbjAiLCJzcGFuMSIsImlzU3BhblByb3BzRXF1YWwiLCJidWlsZERhdGVTcGFuQXBpIiwiYnVpbGRSYW5nZUFwaSIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJvbWl0VGltZSIsInRvRGF0ZSIsInN0YXJ0U3RyIiwiZm9ybWF0SXNvIiwiZW5kU3RyIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImRhdGVTcGFuIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJvcmlnRXZlbnQiLCJjYWxlbmRhckFwaSIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJnZXREZWZhdWx0RXZlbnRFbmQiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiZXZlbnRDb25maWdCYXNlIiwibXV0YXRpb24iLCJldmVudENvbmZpZ3MiLCJhcHBseU11dGF0aW9uVG9FdmVudERlZiIsImFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UiLCJldmVudENvbmZpZyIsInN0YXJ0RGVsdGEiLCJlbmREZWx0YSIsImNvcHkiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJhcHBsaWVyIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJWaWV3QXBpIiwiZ2V0Q3VycmVudERhdGEiLCJ2aWV3VGl0bGUiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiY3VycmVudFJhbmdlIiwiZ2V0T3B0aW9uIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJsYXRlc3RGZXRjaElkIiwiZmV0Y2hSYW5nZSIsInNvdXJjZURlZklkIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImV2ZW50U291cmNlRGVmcyIsInBhcnNlTWV0YSIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJkYXRlTWFya2VyIiwiZ2V0SW5pdGlhbERhdGUiLCJpbml0aWFsRGF0ZUlucHV0IiwiZ2V0Tm93Iiwibm93SW5wdXQiLCJjcmVhdGVOb3dNYXJrZXIiLCJDYWxlbmRhckFwaSIsImN1cnJlbnREYXRhTWFuYWdlciIsImJhdGNoUmVuZGVyaW5nIiwidXBkYXRlU2l6ZSIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsIm9uIiwiaGFuZGxlck5hbWUiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMiLCJjb25zb2xlIiwid2FybiIsIm9mZiIsIl9fc3ByZWFkQXJyYXkiLCJjaGFuZ2VWaWV3Iiwidmlld1R5cGUiLCJkYXRlT3JSYW5nZSIsInpvb21UbyIsInN0YXRlIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJhZGRZZWFycyIsIm5leHRZZWFyIiwidG9kYXkiLCJjYWxlbmRhck9wdGlvbnMiLCJnb3RvRGF0ZSIsInpvbmVkRGF0ZUlucHV0IiwiaW5jcmVtZW50RGF0ZSIsImRlbHRhSW5wdXQiLCJkZWx0YSIsImZvcm1hdERhdGUiLCJzZXR0aW5ncyIsImRhdGVPck9iaiIsImVuZERhdGUiLCJzZWxlY3Rpb25JbnB1dCIsImRhdGVTZWxlY3Rpb24iLCJhZGRFdmVudCIsImV2ZW50SW5wdXQiLCJzb3VyY2VJbnB1dCIsIl9kZWYiLCJfaW5zdGFuY2UiLCJjdXJyZW50RGF0YSIsInRyaWdnZXJFdmVudEFkZCIsInNvdXJjZUFwaSIsImdldEV2ZW50U291cmNlQnlJZCIsIm5ld0V2ZW50QXBpIiwiZXZlbnRBcGkiLCJyZWxhdGVkRXZlbnRzIiwicmV2ZXJ0IiwiZXZlbnRBcGlUb1N0b3JlIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZW1vdmVBbGxFdmVudHMiLCJnZXRFdmVudFNvdXJjZXMiLCJzb3VyY2VIYXNoIiwic291cmNlQXBpcyIsImludGVybmFsSWQiLCJhZGRFdmVudFNvdXJjZSIsInNvdXJjZXMiLCJyZW1vdmVBbGxFdmVudFNvdXJjZXMiLCJyZWZldGNoRXZlbnRzIiwic2Nyb2xsVG9UaW1lIiwidGltZUlucHV0IiwidGltZSIsIl9jb250ZXh0Iiwic2V0UHJvcCIsIm11dGF0ZSIsInNldEV4dGVuZGVkUHJvcCIsInNldFN0YXJ0IiwiaW5zdGFuY2VSYW5nZSIsImdyYW51bGFyaXR5IiwibWFpbnRhaW5EdXJhdGlvbiIsInNldEVuZCIsImVuZElucHV0Iiwic2V0RGF0ZXMiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwibW92ZURhdGVzIiwic2V0QWxsRGF5IiwiZm9ybWF0SW5wdXQiLCJjb250ZXh0XzEiLCJldmVudFN0b3JlXzEiLCJyZWxldmFudEV2ZW50cyIsIm9sZEV2ZW50IiwiYXNTdG9yZSIsInRvUGxhaW5PYmplY3QiLCJjb2xsYXBzZUNvbG9yIiwiY29sbGFwc2VFeHRlbmRlZFByb3BzIiwidG9KU09OIiwiZXhjbHVkZUluc3RhbmNlIiwiZXZlbnRBcGlzIiwiZXhjbHVkZUluc3RhbmNlSWQiLCJjYWxlbmRhclN5c3RlbUNsYXNzTWFwIiwicmVnaXN0ZXJDYWxlbmRhclN5c3RlbSIsInRoZUNsYXNzIiwiY3JlYXRlQ2FsZW5kYXJTeXN0ZW0iLCJHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSIsImFycmF5VG9NYXJrZXIiLCJhcnIiLCJJU09fUkUiLCJEYXRlRW52IiwiaXNOYW1lZFRpbWVab25lIiwibmFtZWRUaW1lWm9uZUltcGwiLCJjYW5Db21wdXRlT2Zmc2V0Iiwid2Vla0RvdyIsIndlZWtEb3kiLCJ3ZWVrTnVtYmVyRnVuYyIsInRpbWVzdGFtcFRvTWFya2VyIiwiZ2V0WWVhciIsImFkZE1vbnRocyIsImdyZWF0ZXN0V2hvbGVVbml0IiwiY291bnREdXJhdGlvbnNCZXR3ZWVuIiwiZGlmZiIsInN0YXJ0T2YiLCJzdGFydE9mWWVhciIsInN0YXJ0T2ZNb250aCIsInN0YXJ0T2ZXZWVrIiwiZGF0ZU9wdGlvbnMiLCJvZmZzZXRGb3JNYXJrZXIiLCJpc0VuZEV4Y2x1c2l2ZSIsImV4dHJhT3B0aW9ucyIsIm9taXRUaW1lWm9uZU9mZnNldCIsInRpbWVzdGFtcFRvQXJyYXkiLCJnZXRUaW1lem9uZU9mZnNldCIsIm9mZnNldEZvckFycmF5IiwiZ2xvYmFsTG9jYWxlcyIsIk1JTklNQUxfUkFXX0VOX0xPQ0FMRSIsImNvZGUiLCJsaXN0IiwiUkFXX0VOX0xPQ0FMRSIsImV2ZW50Q250Iiwib3JnYW5pemVSYXdMb2NhbGVzIiwiZXhwbGljaXRSYXdMb2NhbGVzIiwiZGVmYXVsdENvZGUiLCJhbGxSYXdMb2NhbGVzIiwicmF3TG9jYWxlTWFwIiwiZW4iLCJhbGxSYXdMb2NhbGVzXzEiLCJyYXdMb2NhbGUiLCJidWlsZExvY2FsZSIsImlucHV0U2luZ3VsYXIiLCJhdmFpbGFibGUiLCJwYXJzZUxvY2FsZSIsInF1ZXJ5TG9jYWxlIiwiY29kZUFyZyIsInF1ZXJ5UmF3TG9jYWxlIiwic2ltcGxlSWQiLCJzbGljZSIsIm1lcmdlZCIsIk51bWJlckZvcm1hdCIsImRhdGVJbnB1dCIsImJ1aWxkRGF0ZUVudiQxIiwiZGF0ZU1ldGEiLCJERUZfREVGQVVMVFMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF5c09mV2VlayIsInBhcnNlQnVzaW5lc3NIb3VycyIsInJlZmluZUlucHV0cyIsInJhd0RlZnMiLCJmaWx0ZXIiLCJyYXdEZWYiLCJwb2ludEluc2lkZVJlY3QiLCJwb2ludCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJjcmVhdGVFbGVtZW50IiwicG9zaXRpb24iLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImRpdiIsInBvc3NpYmxlIiwib2Zmc2V0SGVpZ2h0IiwiRU1QVFlfRVZFTlRfU1RPUkUiLCJTcGxpdHRlciIsImdldEtleXNGb3JFdmVudERlZnMiLCJfZ2V0S2V5c0ZvckV2ZW50RGVmcyIsInNwbGl0RGF0ZVNlbGVjdGlvbiIsIl9zcGxpdERhdGVTcGFuIiwic3BsaXRFdmVudFN0b3JlIiwiX3NwbGl0RXZlbnRTdG9yZSIsInNwbGl0SW5kaXZpZHVhbFVpIiwiX3NwbGl0SW5kaXZpZHVhbFVpIiwic3BsaXRFdmVudERyYWciLCJfc3BsaXRJbnRlcmFjdGlvbiIsInNwbGl0RXZlbnRSZXNpemUiLCJldmVudFVpQnVpbGRlcnMiLCJzcGxpdFByb3BzIiwia2V5SW5mb3MiLCJnZXRLZXlJbmZvIiwiZGVmS2V5cyIsImRhdGVTZWxlY3Rpb25zIiwiaW5kaXZpZHVhbFVpIiwiZXZlbnRTdG9yZXMiLCJldmVudERyYWdzIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemVzIiwiZXZlbnRSZXNpemUiLCJpbmZvIiwiYnVpbGRFdmVudFVpRm9yS2V5Iiwia2V5SW5mbyIsImJ1aWxkRXZlbnRVaSIsImV2ZW50U2VsZWN0aW9uIiwiZGF0ZVNwYW5zIiwiZ2V0S2V5c0ZvckRhdGVTcGFuIiwia2V5c18xIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwic3BsaXRTdG9yZXMiLCJfYyIsInNwbGl0SGFzaGVzIiwiaW50ZXJhY3Rpb24iLCJzcGxpdFN0YXRlcyIsImFmZmVjdGVkU3RvcmVzXzEiLCJhZmZlY3RlZEV2ZW50cyIsIm11dGF0ZWRLZXlzQnlEZWZJZCIsIm11dGF0ZWRFdmVudHMiLCJtdXRhdGVkU3RvcmVzXzEiLCJwb3B1bGF0ZSIsImlzRXZlbnQiLCJhbGxVaSIsImV2ZW50VWlGb3JLZXkiLCJiYXNlUGFydHMiLCJzdHVmZiIsImdldERhdGVNZXRhIiwiaXNEaXNhYmxlZCIsImlzT3RoZXIiLCJnZXREYXlDbGFzc05hbWVzIiwidGhlbWUiLCJnZXRDbGFzcyIsImdldFNsb3RDbGFzc05hbWVzIiwiREFZX0ZPUk1BVCIsIldFRUtfRk9STUFUIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJpc1RhYmJhYmxlIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsImZpcnN0Q2hpbGQiLCJfc2Nyb2xsYmFyV2lkdGhzIiwiZ2V0U2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRocyIsImNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbCIsIngiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwiY29tcHV0ZUVkZ2VzIiwiZ2V0UGFkZGluZyIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclRvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJiYWRTY3JvbGxiYXJXaWR0aHMiLCJzY3JvbGxiYXJMZWZ0UmlnaHQiLCJzY3JvbGxiYXJCb3R0b20iLCJzY3JvbGxiYXJMZWZ0Iiwic2Nyb2xsYmFyUmlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiY29tcHV0ZUlubmVyUmVjdCIsImdvV2l0aGluUGFkZGluZyIsImRvRnJvbVdpbmRvd1ZpZXdwb3J0Iiwib3V0ZXJSZWN0IiwiY29tcHV0ZVJlY3QiLCJlZGdlcyIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QiLCJjbGlwcGluZ1BhcmVudHMiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjbGlwcGluZ1BhcmVudHNfMSIsImNsaXBwaW5nUGFyZW50IiwiaW50ZXJzZWN0aW9uIiwiY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMiLCJjb21wdXRlVk1hcmdpbnMiLCJjb21wdXRlZCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInVucHJvbWlzaWZ5IiwiaXNSZXNvbHZlZCIsIndyYXBwZWRTdWNjZXNzIiwid3JhcHBlZEZhaWx1cmUiLCJ0aGVuIiwiRW1pdHRlciIsImhhbmRsZXJzIiwidGhpc0NvbnRleHQiLCJzZXRUaGlzQ29udGV4dCIsInNldE9wdGlvbnMiLCJhZGRUb0hhc2giLCJyZW1vdmVGcm9tSGFzaCIsImF0dGFjaGVkSGFuZGxlcnMiLCJvcHRpb25IYW5kbGVyIiwiaGFuZGxlcnNfMSIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImVscyIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJvcmlnaW5DbGllbnRSZWN0IiwiYnVpbGRFbEhvcml6b250YWxzIiwiYnVpbGRFbFZlcnRpY2FscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsIm9yaWdpbkNsaWVudFRvcCIsInRvcHMiLCJib3R0b21zIiwibGVmdFRvSW5kZXgiLCJsZWZ0UG9zaXRpb24iLCJ0b3BUb0luZGV4IiwidG9wUG9zaXRpb24iLCJnZXRXaWR0aCIsImxlZnRJbmRleCIsImdldEhlaWdodCIsInRvcEluZGV4IiwiU2Nyb2xsQ29udHJvbGxlciIsImdldE1heFNjcm9sbFRvcCIsImdldFNjcm9sbEhlaWdodCIsImdldENsaWVudEhlaWdodCIsImdldE1heFNjcm9sbExlZnQiLCJnZXRTY3JvbGxXaWR0aCIsImdldENsaWVudFdpZHRoIiwiY2FuU2Nyb2xsVmVydGljYWxseSIsImNhblNjcm9sbEhvcml6b250YWxseSIsImNhblNjcm9sbFVwIiwiZ2V0U2Nyb2xsVG9wIiwiY2FuU2Nyb2xsRG93biIsImNhblNjcm9sbExlZnQiLCJnZXRTY3JvbGxMZWZ0IiwiY2FuU2Nyb2xsUmlnaHQiLCJFbGVtZW50U2Nyb2xsQ29udHJvbGxlciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJzZXRTY3JvbGxUb3AiLCJzZXRTY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJXaW5kb3dTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsIiwiVGhlbWUiLCJpY29uT3ZlcnJpZGVPcHRpb24iLCJzZXRJY29uT3ZlcnJpZGUiLCJpY29uT3ZlcnJpZGVIYXNoIiwiaWNvbkNsYXNzZXNDb3B5IiwiYnV0dG9uTmFtZSIsImljb25DbGFzc2VzIiwiYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgiLCJwcmVmaXgiLCJpY29uT3ZlcnJpZGVQcmVmaXgiLCJjbGFzc2VzIiwiZ2V0SWNvbkNsYXNzIiwiaXNSdGwiLCJydGxJY29uQ2xhc3NlcyIsImJhc2VJY29uQ2xhc3MiLCJnZXRDdXN0b21CdXR0b25JY29uQ2xhc3MiLCJjdXN0b21CdXR0b25Qcm9wcyIsImljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiIsIlNjcm9sbFJlc3BvbmRlciIsImV4ZWNGdW5jIiwiaGFuZGxlU2Nyb2xsUmVxdWVzdCIsInJlcXVlc3QiLCJxdWV1ZWRSZXF1ZXN0IiwiZHJhaW4iLCJmaXJlSW5pdGlhbFNjcm9sbCIsImRldGFjaCIsInVwZGF0ZSIsImlzRGF0ZXNOZXciLCJWaWV3Q29udGV4dFR5cGUiLCJjcmVhdGVDb250ZXh0IiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJhZGRSZXNpemVIYW5kbGVyIiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImNyZWF0ZVNjcm9sbFJlc3BvbmRlciIsIlB1cmVDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJkZWJ1ZyIsImxvZyIsInByb3BFcXVhbGl0eSIsInN0YXRlRXF1YWxpdHkiLCJhZGRQcm9wc0VxdWFsaXR5IiwiYWRkU3RhdGVFcXVhbGl0eSIsImNvbnRleHRUeXBlIiwiQ29tcG9uZW50IiwiQmFzZUNvbXBvbmVudCIsImNyZWF0ZSIsInNldFJlZiIsInJlZiIsImN1cnJlbnQiLCJEYXRlQ29tcG9uZW50IiwidWlkIiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiY3JlYXRlUGx1Z2luIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNMb2FkaW5nRnVuY3MiLCJjb250ZXh0SW5pdCIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyIsImRhdGVQb2ludFRyYW5zZm9ybXMiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJpc1Byb3BzVmFsaWQiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvbkNoYW5nZUhhbmRsZXJzIiwic2Nyb2xsR3JpZEltcGwiLCJjb250ZW50VHlwZUhhbmRsZXJzIiwibGlzdGVuZXJSZWZpbmVycyIsIm9wdGlvblJlZmluZXJzIiwicHJvcFNldEhhbmRsZXJzIiwiYnVpbGRQbHVnaW5Ib29rcyIsInBsdWdpbkRlZnMiLCJnbG9iYWxEZWZzIiwiaXNBZGRlZCIsImhvb2tzIiwiYWRkRGVmcyIsImRlZnNfMSIsImNvbWJpbmVIb29rcyIsImJ1aWxkQnVpbGRQbHVnaW5Ib29rcyIsImN1cnJlbnRPdmVycmlkZURlZnMiLCJjdXJyZW50R2xvYmFsRGVmcyIsImN1cnJlbnRIb29rcyIsIm92ZXJyaWRlRGVmcyIsImhvb2tzMCIsImhvb2tzMSIsIlN0YW5kYXJkVGhlbWUiLCJyb290IiwidGFibGVDZWxsU2hhZGVkIiwiYnV0dG9uR3JvdXAiLCJidXR0b24iLCJidXR0b25BY3RpdmUiLCJjbG9zZSIsImNvbXBpbGVWaWV3RGVmcyIsImRlZmF1bHRDb25maWdzIiwib3ZlcnJpZGVDb25maWdzIiwiZW5zdXJlVmlld0RlZiIsInZpZXdEZWYiLCJidWlsZFZpZXdEZWYiLCJkZWZhdWx0Q29uZmlnIiwib3ZlcnJpZGVDb25maWciLCJxdWVyeVByb3AiLCJ0aGVDb21wb25lbnQiLCJzdXBlclR5cGUiLCJzdXBlckRlZiIsImRlZmF1bHRzIiwicmF3T3B0aW9ucyIsIm92ZXJyaWRlcyIsIlJlbmRlckhvb2siLCJyb290RWxSZWYiLCJjcmVhdGVSZWYiLCJoYW5kbGVSb290RWwiLCJlbFJlZiIsInJlbmRlciIsImhvb2tQcm9wcyIsIk1vdW50SG9vayIsIkNvbnRlbnRIb29rIiwiZGVmYXVsdENvbnRlbnQiLCJiYWNrdXBFbFJlZiIsImlubmVyRWxSZWYiLCJpbm5lckNvbnRlbnQiLCJub3JtYWxpemVDbGFzc05hbWVzIiwiQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQiLCJDb25zdW1lciIsInJlbmRlcklkIiwiQ29udGVudEhvb2tJbm5lciIsInJlbmRlcklubmVyQ29udGVudCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlQ3VzdG9tQ29udGVudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY3VzdG9tQ29udGVudEluZm8iLCJkZXN0cm95IiwiZ2V0SW5uZXJDb250ZW50IiwiZ2V0Q29udGVudE1ldGEiLCJjb250ZW50S2V5IiwiY29udGVudFZhbCIsImJ1aWxkTGlmZWN5Y2xlRnVuY3MiLCJub3JtYWxpemVDb250ZW50Iiwic2VhcmNoS2V5Iiwicm9vdEVsIiwiYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyIiwiY3VycmVudEdlbmVyYXRvciIsImN1cnJlbnRIb29rUHJvcHMiLCJjdXJyZW50Q2xhc3NOYW1lcyIsImdlbmVyYXRvciIsIlZpZXdSb290IiwiY3VzdG9tQ2xhc3NOYW1lcyIsInBhcnNlVmlld0NvbmZpZ3MiLCJpbnB1dHMiLCJwYXJzZVZpZXdDb25maWciLCJjcmVhdGVWaWV3SG9va0NvbXBvbmVudCIsInZpZXdQcm9wcyIsInZpZXdFbFJlZiIsImJ1aWxkVmlld1NwZWNzIiwiZGVmYXVsdElucHV0cyIsIm9wdGlvbk92ZXJyaWRlcyIsImR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJsb2NhbGVEZWZhdWx0cyIsInZpZXdEZWZzIiwiYnVpbGRWaWV3U3BlYyIsImR1cmF0aW9uSW5wdXQiLCJkdXJhdGlvblVuaXQiLCJzaW5nbGVVbml0T3ZlcnJpZGVzIiwiY3JlYXRlRHVyYXRpb25DYWNoZWQiLCJkZW5vbSIsInF1ZXJ5QnV0dG9uVGV4dCIsIm9wdGlvbnNTdWJzZXQiLCJidXR0b25UZXh0TWFwIiwicXVlcnlCdXR0b25UaXRsZSIsImJ1dHRvbktleSIsIm9wdGlvbkRlZmF1bHRzIiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJidXR0b25UaXRsZU92ZXJyaWRlIiwiYnV0dG9uSGludCIsImJ1dHRvblRpdGxlRGVmYXVsdCIsImR1cmF0aW9uSW5wdXRNYXAiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJmb3JjZVRvVmFsaWQiLCJwcmV2RGF0ZSIsImN1cnJlbnRSYW5nZVVuaXQiLCJidWlsZCIsImJ1aWxkTmV4dCIsIm5leHREYXRlIiwiY3VycmVudEluZm8iLCJpc1JhbmdlQWxsRGF5IiwicmVuZGVyUmFuZ2UiLCJpc1ZhbGlkIiwiYnVpbGRWYWxpZFJhbmdlIiwidHJpbUhpZGRlbkRheXMiLCJidWlsZEN1cnJlbnRSYW5nZUluZm8iLCJidWlsZFJlbmRlclJhbmdlIiwiYWRqdXN0QWN0aXZlUmFuZ2UiLCJidWlsZERhdGVJbmNyZW1lbnQiLCJ2YWxpZFJhbmdlSW5wdXQiLCJzaW1wbGVJbnB1dCIsInJlZmluZVJhbmdlIiwiYnVpbGRSYW5nZUZyb21EdXJhdGlvbiIsImJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQiLCJidWlsZEN1c3RvbVZpc2libGVSYW5nZSIsImdldEZhbGxiYWNrRHVyYXRpb24iLCJpc0hpZGRlbkRheSIsInNraXBIaWRkZW5EYXlzIiwiY29tcHV0ZVJlcyIsInJ1bm5pbmdDb3VudCIsInZpc2libGVSYW5nZUlucHV0IiwiZmFsbGJhY2siLCJjdXN0b21BbGlnbm1lbnQiLCJyYW5nZUlucHV0IiwiaXNIaWRkZW5EYXlIYXNoIiwiaW5jIiwiaXNFeGNsdXNpdmUiLCJyZWR1Y2VWaWV3VHlwZSIsInJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJyZWR1Y2VEYXRlUHJvZmlsZSIsImRwIiwiaW5pdEV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJwYXJzZUluaXRpYWxTb3VyY2VzIiwicmVkdWNlRXZlbnRTb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwiZmV0Y2hJZCIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJldmVudFNvdXJjZUhhc2giLCJzb3VyY2VzXzEiLCJzb3VyY2UiLCJpc1NvdXJjZURpcnR5IiwiZG9lc1NvdXJjZU5lZWRSYW5nZSIsInByZXZTb3VyY2VzIiwic291cmNlSWRIYXNoIiwibmV4dFNvdXJjZXMiLCJmZXRjaFNvdXJjZSIsInNvdXJjZURlZiIsImZldGNoIiwieGhyIiwiZXJyb3IiLCJtZXNzYWdlIiwicmF3U291cmNlcyIsInJhd1NvdXJjZXNfMSIsInJhd1NvdXJjZSIsImlnbm9yZVJhbmdlIiwicmVkdWNlRXZlbnRTdG9yZSIsInJlY2VpdmVSYXdFdmVudHMiLCJleGNsdWRlRXZlbnRzQnlTb3VyY2VJZCIsInN1YnNldCIsInRyYW5zZm9ybVJhd0V2ZW50cyIsImNhbEVhY2hUcmFuc2Zvcm0iLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJlZmluZWRFdmVudCIsImV4cGFuZFJhbmdlIiwicmV6b25lRXZlbnRTdG9yZURhdGVzIiwib2xkRGF0ZUVudiIsIm5ld0RhdGVFbnYiLCJleGNsdWRlSW5zdGFuY2VzIiwicmVtb3ZhbHMiLCJyZWR1Y2VEYXRlU2VsZWN0aW9uIiwiY3VycmVudFNlbGVjdGlvbiIsInJlZHVjZVNlbGVjdGVkRXZlbnQiLCJjdXJyZW50SW5zdGFuY2VJZCIsImV2ZW50SW5zdGFuY2VJZCIsInJlZHVjZUV2ZW50RHJhZyIsImN1cnJlbnREcmFnIiwibmV3RHJhZyIsInJlZHVjZUV2ZW50UmVzaXplIiwiY3VycmVudFJlc2l6ZSIsIm5ld1Jlc2l6ZSIsInBhcnNlVG9vbGJhcnMiLCJjYWxlbmRhck9wdGlvbk92ZXJyaWRlcyIsInBhcnNlVG9vbGJhciIsInNlY3Rpb25TdHJIYXNoIiwic2VjdGlvbldpZGdldHMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiY2FsZW5kYXJDdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJjbGljayIsInRleHQiLCJoaW50IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJldmVudFNvdXJjZURlZiQyIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJiaW5kIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwicmVxdWVzdEpzb24iLCJwYXJhbXMiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJ0b1VwcGVyQ2FzZSIsImluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zIiwiZW5jb2RlUGFyYW1zIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsImVyciIsIm9uZXJyb3IiLCJzZW5kIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsImV4dHJhUGFyYW1zIiwiZXZlbnRTb3VyY2VEZWYiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwiZXJyb3JNZXNzYWdlIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwic3RhcnRSZWN1ciIsImVuZFJlY3VyIiwicmVjdXJyaW5nIiwicmVjdXJyaW5nRGF0YSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwibmV3SW5wdXRzIiwiaW5wdXRzXzEiLCJpbnB1dEZvdW5kIiwidW5mb3VuZFNvdXJjZXNfMSIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dHNfMSIsIm5ld0lucHV0IiwiaGFuZGxlRGF0ZVByb2ZpbGUiLCJoYW5kbGVFdmVudFN0b3JlIiwiZ2xvYmFsUGx1Z2lucyIsImh0bWwiLCJidWlsZEh0bWxSZW5kZXJlciIsImRvbU5vZGVzIiwiYnVpbGREb21Ob2RlUmVuZGVyZXIiLCJjdXJyZW50RWwiLCJjdXJyZW50SHRtbCIsImN1cnJlbnREb21Ob2RlcyIsIm5ld0RvbU5vZGVzIiwibmV3RG9tTm9kZXNfMSIsIm5ld05vZGUiLCJEZWxheWVkUnVubmVyIiwiZHJhaW5lZE9wdGlvbiIsImlzUnVubmluZyIsImlzRGlydHkiLCJwYXVzZURlcHRocyIsInRpbWVvdXRJZCIsImRlbGF5IiwiaXNQYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJ0cnlEcmFpbiIsInNldFRpbWVvdXQiLCJwYXVzZSIsInNjb3BlIiwicmVzdW1lIiwiZm9yY2UiLCJkZXB0aCIsImRyYWluZWQiLCJjbGVhciIsIlRhc2tSdW5uZXIiLCJydW5UYXNrT3B0aW9uIiwicXVldWUiLCJkZWxheWVkUnVubmVyIiwidGFzayIsImNvbXBsZXRlZFRhc2tzIiwic2hpZnQiLCJydW5UYXNrIiwiYnVpbGRUaXRsZSIsImJ1aWxkVGl0bGVGb3JtYXQiLCJDYWxlbmRhckRhdGFNYW5hZ2VyIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiX2NvbXB1dGVPcHRpb25zRGF0YSIsImNvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkVGhlbWUiLCJidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRWaWV3QXBpIiwiYnVpbGRWaWV3VWlQcm9wcyIsImJ1aWxkRXZlbnRVaUJ5U291cmNlIiwiYnVpbGRFdmVudFVpQmFzZXMiLCJwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzIiwiYWN0aW9uUnVubmVyIiwiX2hhbmRsZUFjdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRWaWV3T3B0aW9uc0lucHV0IiwiY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCIsImRhdGEiLCJvcHRpb25zRGF0YSIsImN1cnJlbnRWaWV3VHlwZSIsImN1cnJlbnRWaWV3RGF0YSIsImNhbGVuZGFyQ29udGV4dCIsImluaXRpYWxTdGF0ZSIsInJlbmRlcmFibGVFdmVudFN0b3JlIiwic2VsZWN0aW9uQ29uZmlnIiwiY29udGV4dEFuZFN0YXRlIiwicmVkdWNlciIsImNvbXB1dGVJc0xvYWRpbmciLCJyZXNldE9wdGlvbnMiLCJhcHBlbmQiLCJpc0V2ZW50c0xvYWRpbmciLCJldmVudFVpU2luZ2xlQmFzZSIsImV2ZW50VWlCeVNvdXJjZSIsIm5ld1N0YXRlIiwid2FzTG9hZGluZyIsImlzTG9hZGluZyIsIm9uQWN0aW9uIiwib2xkRGF0YSIsImNoYW5nZUhhbmRsZXJzIiwib2xkQ2FsZW5kYXJPcHRpb25zIiwibmV3Q2FsZW5kYXJPcHRpb25zIiwib25EYXRhIiwicHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyIsInJlZmluZWRPcHRpb25zIiwiYXZhaWxhYmxlTG9jYWxlRGF0YSIsIndhcm5Vbmtub3duT3B0aW9ucyIsImN1cnJlbnRSYXciLCJjdXJyZW50UmVmaW5lZCIsImFueUNoYW5nZXMiLCJwcm9jZXNzUmF3Vmlld09wdGlvbnMiLCJleHBsaWNpdExvY2FsZSIsIlRoZW1lQ2xhc3MiLCJEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiaXNMb2FkaW5nRnVuYyIsInZpZXdOYW1lIiwiQ2FsZW5kYXJEYXRhUHJvdmlkZXIiLCJoYW5kbGVEYXRhIiwiZGF0YU1hbmFnZXIiLCJzZXRTdGF0ZSIsInByZXZQcm9wcyIsIm5ld09wdGlvbk92ZXJyaWRlcyIsInNsaWNlRXZlbnRzIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJzdHJpY3RPcmRlciIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJtYXhTdGFja0NudCIsImxldmVsQ29vcmRzIiwiZW50cmllc0J5TGV2ZWwiLCJzdGFja0NudHMiLCJhZGRTZWdzIiwiaGlkZGVuRW50cmllcyIsImluc2VydEVudHJ5IiwiZW50cnkiLCJmaW5kSW5zZXJ0aW9uIiwiaXNJbnNlcnRpb25WYWxpZCIsImluc2VydEVudHJ5QXQiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsInN0YWNrQ250IiwidG91Y2hpbmdFbnRyeSIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwicGFydENudCIsInNwbGl0SGlkZGVuRW50cmllcyIsImVudHJ5U3BhbiIsImJhcnJpZXJTcGFuIiwiaW50ZXJzZWN0U3BhbnMiLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImVudHJpZXNfMSIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImVudHJpZXNfMiIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZXNfMSIsIm1lcmdlIiwiam9pblNwYW5zIiwic2VhcmNoVmFsIiwiZ2V0SXRlbVZhbCIsIm1pZGRsZUluZGV4IiwibWlkZGxlVmFsIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiVG9vbGJhclNlY3Rpb24iLCJ3aWRnZXRHcm91cHMiLCJ3aWRnZXRHcm91cCIsInJlbmRlcldpZGdldEdyb3VwIiwiaXNPbmx5QnV0dG9ucyIsIndpZGdldEdyb3VwXzEiLCJ3aWRnZXQiLCJ0aXRsZUlkIiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwicmVuZGVyU2VjdGlvbiIsIlZpZXdDb250YWluZXIiLCJhdmFpbGFibGVXaWR0aCIsImhhbmRsZUVsIiwidXBkYXRlQXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVSZXNpemUiLCJsaXF1aWQiLCJsYWJlbGVkQnlJZCIsIkV2ZW50Q2xpY2tpbmciLCJoYW5kbGVTZWdDbGljayIsInNlZ0VsIiwiaGFzVXJsQ29udGFpbmVyIiwiZGVmYXVsdFByZXZlbnRlZCIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJDYWxlbmRhckNvbnRlbnQiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiYnVpbGRUb29sYmFyUHJvcHMiLCJoZWFkZXJSZWYiLCJmb290ZXJSZWYiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInZpZXdMYWJlbElkIiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsImxpc3RlbmVyIiwicmVzaXplUnVubmVyIiwidG9vbGJhclByb3BzIiwidmlld1ZHcm93Iiwidmlld0FzcGVjdFJhdGlvIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJ2aWV3Q29udGV4dCIsIlByb3ZpZGVyIiwicmVuZGVyVmlldyIsImJ1aWxkQXBwZW5kQ29udGVudCIsIkNhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyIsIkZyYWdtZW50IiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhclJvb3QiLCJoYW5kbGVCZWZvcmVQcmludCIsImhhbmRsZUFmdGVyUHJpbnQiLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwiVGFibGVEYXRlQ2VsbCIsImRheU1ldGEiLCJuYXZMaW5rQXR0cnMiLCJjb2xDbnQiLCJleHRyYUhvb2tQcm9wcyIsInJvbGUiLCJjb2xTcGFuIiwiZXh0cmFEYXRhQXR0cnMiLCJpc1N0aWNreSIsIldFRUtEQVlfRk9STUFUIiwiVGFibGVEb3dDZWxsIiwiZXh0cmFDbGFzc05hbWVzIiwiTm93VGltZXIiLCJpbml0aWFsTm93RGF0ZSIsImluaXRpYWxOb3dRdWVyaWVkTXMiLCJjb21wdXRlVGltaW5nIiwiY3VycmVudFN0YXRlIiwidW5yb3VuZGVkTm93IiwiY3VycmVudFVuaXRTdGFydCIsIm5leHRVbml0U3RhcnQiLCJ3YWl0TXMiLCJidWlsZERheVJhbmdlIiwiRGF5SGVhZGVyIiwiY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyIiwiZGF0ZXMiLCJyZW5kZXJJbnRybyIsImV4cGxpY2l0Rm9ybWF0IiwiZGF0ZUNudCIsIkRheVNlcmllc01vZGVsIiwiaW5kaWNlcyIsImRheUluZGV4IiwiY250Iiwic2xpY2VSYW5nZSIsImZpcnN0SW5kZXgiLCJnZXREYXRlRGF5SW5kZXgiLCJsYXN0SW5kZXgiLCJjbGlwcGVkRmlyc3RJbmRleCIsImNsaXBwZWRMYXN0SW5kZXgiLCJjZWlsIiwiZGF5T2Zmc2V0IiwiRGF5VGFibGVNb2RlbCIsImRheVNlcmllcyIsImJyZWFrT25XZWVrcyIsImRheXNQZXJSb3ciLCJyb3dDbnQiLCJjZWxscyIsImJ1aWxkQ2VsbHMiLCJoZWFkZXJEYXRlcyIsImJ1aWxkSGVhZGVyRGF0ZXMiLCJyb3dzIiwicm93IiwiY29sIiwiYnVpbGRDZWxsIiwic2VyaWVzU2VnIiwibmV4dEluZGV4IiwiZmlyc3RDb2wiLCJsYXN0Q29sIiwiU2xpY2VyIiwic2xpY2VCdXNpbmVzc0hvdXJzIiwiX3NsaWNlQnVzaW5lc3NIb3VycyIsInNsaWNlRGF0ZVNlbGVjdGlvbiIsIl9zbGljZURhdGVTcGFuIiwiX3NsaWNlRXZlbnRTdG9yZSIsInNsaWNlRXZlbnREcmFnIiwiX3NsaWNlSW50ZXJhY3Rpb24iLCJzbGljZUV2ZW50UmVzaXplIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VQcm9wcyIsImV4dHJhQXJncyIsImV2ZW50U2VncyIsImRhdGVTZWxlY3Rpb25TZWdzIiwiYnVzaW5lc3NIb3VyU2VncyIsImZnRXZlbnRTZWdzIiwiYmdFdmVudFNlZ3MiLCJzbGljZU5vd0RhdGUiLCJjb21wdXRlQWN0aXZlUmFuZ2UiLCJyYW5nZVJlcyIsInNsaWNlRXZlbnRSYW5nZXMiLCJhZmZlY3RlZEluc3RhbmNlcyIsInNlZ3NfMSIsImV2ZW50UmFuZ2VzIiwiZXZlbnRSYW5nZXNfMSIsInNsaWNlRXZlbnRSYW5nZSIsInNlZ3NfMiIsImlzQ29tcG9uZW50QWxsRGF5IiwiaXNJbnRlcmFjdGlvblZhbGlkIiwiaXNOZXdQcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uVmFsaWQiLCJjYWxlbmRhclN0YXRlIiwiZGF0ZVNwYW5NZXRhIiwiZmlsdGVyQ29uZmlnIiwiaXNJbnRlcmFjdGlvblByb3BzVmFsaWQiLCJpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkIiwic3ViamVjdEV2ZW50U3RvcmUiLCJzdWJqZWN0RGVmcyIsInN1YmplY3RJbnN0YW5jZXMiLCJzdWJqZWN0Q29uZmlncyIsIm90aGVyRXZlbnRTdG9yZSIsIm90aGVyRGVmcyIsIm90aGVySW5zdGFuY2VzIiwib3RoZXJDb25maWdzIiwic3ViamVjdEluc3RhbmNlSWQiLCJzdWJqZWN0SW5zdGFuY2UiLCJzdWJqZWN0UmFuZ2UiLCJzdWJqZWN0Q29uZmlnIiwic3ViamVjdERlZiIsImFsbENvbnN0cmFpbnRzUGFzcyIsImV2ZW50T3ZlcmxhcEZ1bmMiLCJvdGhlckluc3RhbmNlSWQiLCJvdGhlckluc3RhbmNlIiwib3RoZXJPdmVybGFwIiwiY2FsZW5kYXJFdmVudFN0b3JlIiwic3ViamVjdEFsbG93Iiwic3ViamVjdERhdGVTcGFuIiwib3JpZ0RlZiIsIm9yaWdJbnN0YW5jZSIsInJlbGV2YW50RXZlbnRTdG9yZSIsInJlbGV2YW50RGVmcyIsInJlbGV2YW50SW5zdGFuY2VzIiwic2VsZWN0aW9uUmFuZ2UiLCJzZWxlY3RPdmVybGFwRnVuYyIsInJlbGV2YW50SW5zdGFuY2VJZCIsInJlbGV2YW50SW5zdGFuY2UiLCJzZWxlY3Rpb25BbGxvdyIsImZ1bGxEYXRlU3BhbiIsImJ1c2luZXNzSG91cnNVbmV4cGFuZGVkIiwiY29uc3RyYWludHNfMSIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwib3V0ZXJSYW5nZXNfMSIsIlZJU0lCTEVfSElEREVOX1JFIiwiU2Nyb2xsZXIiLCJsaXF1aWRJc0Fic29sdXRlIiwiaXNBYnNvbHV0ZSIsIm92ZXJjb21lTGVmdCIsIm92ZXJjb21lUmlnaHQiLCJvdmVyY29tZUJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1heEhlaWdodCIsIm5lZWRzWFNjcm9sbGluZyIsInJlYWxDbGllbnRXaWR0aCIsImdldFlTY3JvbGxiYXJXaWR0aCIsImNoaWxkRWwiLCJuZWVkc1lTY3JvbGxpbmciLCJyZWFsQ2xpZW50SGVpZ2h0IiwiZ2V0WFNjcm9sbGJhcldpZHRoIiwiUmVmTWFwIiwibWFzdGVyQ2FsbGJhY2siLCJjdXJyZW50TWFwIiwiZGVwdGhzIiwiY2FsbGJhY2tNYXAiLCJoYW5kbGVWYWx1ZSIsInJlbW92ZWQiLCJhZGRlZCIsInJlZkNhbGxiYWNrIiwiY29sbGVjdCIsImdldEFsbCIsImNvbXB1dGVTaHJpbmtXaWR0aCIsImNodW5rRWxzIiwic2hyaW5rQ2VsbHMiLCJsYXJnZXN0V2lkdGgiLCJzaHJpbmtDZWxsc18xIiwic2hyaW5rQ2VsbCIsImdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQiLCJzZWN0aW9uQ29uZmlnIiwiZ2V0QWxsb3dZU2Nyb2xsaW5nIiwicmVuZGVyQ2h1bmtDb250ZW50IiwiY2h1bmtDb25maWciLCJpc0hlYWRlciIsInRhYmxlQ2xhc3NOYW1lIiwic3luY1Jvd0hlaWdodHMiLCJtaW5XaWR0aCIsInRhYmxlTWluV2lkdGgiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsInJvd0NvbnRlbnQiLCJpc0NvbFByb3BzRXF1YWwiLCJjb2xzMCIsImNvbHMxIiwicmVuZGVyTWljcm9Db2xHcm91cCIsImNvbHMiLCJzaHJpbmtXaWR0aCIsImNvbE5vZGVzIiwiY29sc18xIiwiY29sUHJvcHMiLCJzYW5pdGl6ZVNocmlua1dpZHRoIiwiaGFzU2hyaW5rV2lkdGgiLCJjb2xzXzIiLCJnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyIsImdldFNlY3Rpb25DbGFzc05hbWVzIiwid2hvbGVUYWJsZVZHcm93IiwicmVuZGVyU2Nyb2xsU2hpbSIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiU2ltcGxlU2Nyb2xsR3JpZCIsInByb2Nlc3NDb2xzIiwic2Nyb2xsZXJSZWZzIiwic2Nyb2xsZXJFbFJlZnMiLCJfaGFuZGxlU2Nyb2xsZXJFbCIsImZvcmNlWVNjcm9sbGJhcnMiLCJzY3JvbGxlckNsaWVudFdpZHRocyIsInNjcm9sbGVyQ2xpZW50SGVpZ2h0cyIsImhhbmRsZVNpemluZyIsImNvbXB1dGVTY3JvbGxlckRpbXMiLCJzZWN0aW9uQ29uZmlncyIsInNlY3Rpb25zIiwibWljcm9Db2xHcm91cE5vZGUiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29uZmlnQ250IiwiY29uZmlnSSIsImN1cnJlbnRDb25maWciLCJoZWFkU2VjdGlvbk5vZGVzIiwiYm9keVNlY3Rpb25Ob2RlcyIsImZvb3RTZWN0aW9uTm9kZXMiLCJpc0J1Z2d5Iiwicm9sZUF0dHJzIiwib3V0ZXJDb250ZW50IiwicmVuZGVyQ2h1bmtUZCIsImNodW5rIiwiaXNMaXF1aWQiLCJzZWN0aW9uS2V5Iiwicm93U3luY0hlaWdodHMiLCJyZXBvcnRSb3dIZWlnaHRDaGFuZ2UiLCJzY3JvbGxlckVsIiwic2VjdGlvbiIsImdldFNlY3Rpb25CeUtleSIsInNjcm9sbGVyRWxSZWYiLCJzY3JvbGxiYXJXaWR0aCIsInNjcm9sbGVyIiwiaGFybmVzc0VsIiwic2VjdGlvbnNfMSIsIkV2ZW50Um9vdCIsInRpbWVUZXh0IiwiZGlzYWJsZURyYWdnaW5nIiwiZGlzYWJsZVJlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwic3RhbmRhcmRDbGFzc05hbWVzIiwiU3RhbmRhcmRFdmVudCIsImRlZmF1bHRUaW1lRm9ybWF0IiwicmVuZGVySW5uZXJDb250ZW50JDEiLCJpbm5lclByb3BzIiwiTm93SW5kaWNhdG9yUm9vdCIsImlzQXhpcyIsIkRBWV9OVU1fRk9STUFUIiwiRGF5Q2VsbENvbnRlbnQiLCJyZWZpbmVEYXlDZWxsSG9va1Byb3BzIiwic2hvd0RheU51bWJlciIsImV4dHJhUHJvcHMiLCJkYXlOdW1iZXJUZXh0IiwiRGF5Q2VsbFJvb3QiLCJyZWZpbmVIb29rUHJvcHMiLCJkYXRhQXR0cnMiLCJyZW5kZXJGaWxsIiwiZmlsbFR5cGUiLCJCZ0V2ZW50IiwiV2Vla051bWJlclJvb3QiLCJkZWZhdWx0Rm9ybWF0IiwicmVuZGVySW5uZXIiLCJQQURESU5HX0ZST01fVklFV1BPUlQiLCJQb3BvdmVyIiwiaGFuZGxlRG9jdW1lbnRNb3VzZURvd24iLCJoYW5kbGVDbG9zZUNsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwib25DbG9zZSIsImNyZWF0ZVBvcnRhbCIsImV4dHJhQXR0cnMiLCJwYXJlbnRFbCIsImFsaWdubWVudEVsIiwiYWxpZ25HcmlkVG9wIiwiYWxpZ25tZW50UmVjdCIsInBvcG92ZXJEaW1zIiwicG9wb3ZlclRvcCIsInBvcG92ZXJMZWZ0Iiwib3JpZ2luXzEiLCJvZmZzZXRQYXJlbnQiLCJNb3JlUG9wb3ZlciIsInN0YXJ0RGF0ZSIsImRheUNsYXNzTmFtZXMiLCJleHRyYURhdGVTcGFuIiwiZGF5RWwiLCJsYXllciIsIk1vcmVMaW5rUm9vdCIsImxpbmtFbFJlZiIsImlzUG9wb3Zlck9wZW4iLCJwb3BvdmVySWQiLCJoYW5kbGVDbGljayIsImNvbXB1dGVSYW5nZSIsImJ1aWxkUHVibGljU2VnIiwiYWxsRGF5RGF0ZSIsImFsbFNlZ3MiLCJoaWRkZW5TZWdzIiwiaGFuZGxlUG9wb3ZlckNsb3NlIiwibW9yZUNudCIsInNob3J0VGV4dCIsInJlbmRlck1vcmVMaW5rSW5uZXIiLCJhbGlnbm1lbnRFbFJlZiIsInBvcG92ZXJDb250ZW50IiwidXBkYXRlUGFyZW50RWwiLCJjb21wdXRlRWFybGllc3RTZWdTdGFydCIsImNvbXB1dGVMYXRlc3RTZWdFbmQiLCJwaWNrRWFybGllc3RTdGFydCIsInNlZzAiLCJzZWcxIiwicGlja0xhdGVzdEVuZCIsInZlcnNpb24iLCJwYXJzZU1hcmtlciIsImsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n})); /// <reference types=\"@fullcalendar/core-preact\" />\n\nif (typeof FullCalendarVDom === 'undefined') {\n  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n}\n\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushToDom = FullCalendarVDom.flushToDom;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */\n\nexports.Component = Component;\nexports.Fragment = Fragment;\nexports.createContext = createContext;\nexports.createElement = createElement;\nexports.createPortal = createPortal;\nexports.createRef = createRef;\nexports.flushToDom = flushToDom;\nexports.render = render;\nexports.unmountComponentAtNode = unmountComponentAtNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLDhDQUE2QztBQUFFRyxFQUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3QyxHLENBRUE7O0FBQ0EsSUFBSSxPQUFPQyxnQkFBUCxLQUE0QixXQUFoQyxFQUE2QztBQUN6QyxRQUFNLElBQUlDLEtBQUosQ0FBVSxvRkFBVixDQUFOO0FBQ0g7O0FBQ0QsSUFBSUMsU0FBUyxHQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBakM7QUFDQSxJQUFJQyxhQUFhLEdBQUdILGdCQUFnQixDQUFDRyxhQUFyQztBQUNBLElBQUlDLE1BQU0sR0FBR0osZ0JBQWdCLENBQUNJLE1BQTlCO0FBQ0EsSUFBSUMsU0FBUyxHQUFHTCxnQkFBZ0IsQ0FBQ0ssU0FBakM7QUFDQSxJQUFJQyxRQUFRLEdBQUdOLGdCQUFnQixDQUFDTSxRQUFoQztBQUNBLElBQUlDLGFBQWEsR0FBR1AsZ0JBQWdCLENBQUNPLGFBQXJDO0FBQ0EsSUFBSUMsWUFBWSxHQUFHUixnQkFBZ0IsQ0FBQ1EsWUFBcEM7QUFDQSxJQUFJQyxVQUFVLEdBQUdULGdCQUFnQixDQUFDUyxVQUFsQztBQUNBLElBQUlDLHNCQUFzQixHQUFHVixnQkFBZ0IsQ0FBQ1Usc0JBQTlDO0FBQ0E7O0FBRUFaLGlCQUFBLEdBQW9CSSxTQUFwQjtBQUNBSixnQkFBQSxHQUFtQlEsUUFBbkI7QUFDQVIscUJBQUEsR0FBd0JTLGFBQXhCO0FBQ0FULHFCQUFBLEdBQXdCSyxhQUF4QjtBQUNBTCxvQkFBQSxHQUF1QlUsWUFBdkI7QUFDQVYsaUJBQUEsR0FBb0JPLFNBQXBCO0FBQ0FQLGtCQUFBLEdBQXFCVyxVQUFyQjtBQUNBWCxjQUFBLEdBQWlCTSxNQUFqQjtBQUNBTiw4QkFBQSxHQUFpQ1ksc0JBQWpDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVsbGNhbGxlbmRhci10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL3Zkb20uY2pzLmpzPzM3MjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkBmdWxsY2FsZW5kYXIvY29yZS1wcmVhY3RcIiAvPlxuaWYgKHR5cGVvZiBGdWxsQ2FsZW5kYXJWRG9tID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGltcG9ydCB0aGUgdG9wLWxldmVsIGZ1bGxjYWxlbmRhciBsaWIgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW1wb3J0IGEgcGx1Z2luLicpO1xufVxudmFyIENvbXBvbmVudCA9IEZ1bGxDYWxlbmRhclZEb20uQ29tcG9uZW50O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUVsZW1lbnQ7XG52YXIgcmVuZGVyID0gRnVsbENhbGVuZGFyVkRvbS5yZW5kZXI7XG52YXIgY3JlYXRlUmVmID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVSZWY7XG52YXIgRnJhZ21lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLkZyYWdtZW50O1xudmFyIGNyZWF0ZUNvbnRleHQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUNvbnRleHQ7XG52YXIgY3JlYXRlUG9ydGFsID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVQb3J0YWw7XG52YXIgZmx1c2hUb0RvbSA9IEZ1bGxDYWxlbmRhclZEb20uZmx1c2hUb0RvbTtcbnZhciB1bm1vdW50Q29tcG9uZW50QXROb2RlID0gRnVsbENhbGVuZGFyVkRvbS51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZmx1c2hUb0RvbSA9IGZsdXNoVG9Eb207XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdWxsQ2FsZW5kYXJWRG9tIiwiRXJyb3IiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hUb0RvbSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.cjs.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\n;\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView = function (_super) {\n  tslib.__extends(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = common.createRef();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = common.getStickyHeaderDates(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return common.createElement(common.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return common.createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, common.createElement(common.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && common.getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && common.getStickyFooterScrollbar(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: common.renderScrollShim\n        }]\n      });\n    }\n\n    return common.createElement(common.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return common.createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, common.createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(common.DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TableCellTop = function (_super) {\n  tslib.__extends(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = common.buildNavLinkAttrs(this.context, props.date);\n    return common.createElement(common.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return (innerContent || props.forceDayTop) && common.createElement(\"div\", {\n        className: \"fc-daygrid-day-top\",\n        ref: innerElRef\n      }, common.createElement(\"a\", tslib.__assign({\n        id: props.dayNumberId,\n        className: \"fc-daygrid-day-number\"\n      }, navLinkAttrs), innerContent || common.createElement(common.Fragment, null, \"\\u00A0\")));\n    });\n  };\n\n  return TableCellTop;\n}(common.BaseComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = common.createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableBlockEvent = function (_super) {\n  tslib.__extends(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return common.createElement(common.StandardEvent, tslib.__assign({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(common.BaseComponent);\n\nvar TableListItemEvent = function (_super) {\n  tslib.__extends(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = common.buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return common.createElement(common.EventRoot, {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        common.createElement(\"a\", tslib.__assign({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, common.getSegAnchorAttrs(props.seg, context)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(common.BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return common.createElement(common.Fragment, null, common.createElement(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && common.createElement(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), common.createElement(\"div\", {\n    className: \"fc-event-title\"\n  }, innerProps.event.title || common.createElement(common.Fragment, null, \"\\u00A0\")));\n}\n\nvar TableCellMoreLink = function (_super) {\n  tslib.__extends(TableCellMoreLink, _super);\n\n  function TableCellMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileSegs = common.memoize(compileSegs);\n    return _this;\n  }\n\n  TableCellMoreLink.prototype.render = function () {\n    var props = this.props;\n\n    var _a = this.compileSegs(props.singlePlacements),\n        allSegs = _a.allSegs,\n        invisibleSegs = _a.invisibleSegs;\n\n    return common.createElement(common.MoreLinkRoot, {\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      allDayDate: props.allDayDate,\n      moreCnt: props.moreCnt,\n      allSegs: allSegs,\n      hiddenSegs: invisibleSegs,\n      alignmentElRef: props.alignmentElRef,\n      alignGridTop: props.alignGridTop,\n      extraDateSpan: props.extraDateSpan,\n      popoverContent: function () {\n        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n        return common.createElement(common.Fragment, null, allSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return common.createElement(\"div\", {\n            className: \"fc-daygrid-event-harness\",\n            key: instanceId,\n            style: {\n              visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n            seg: seg,\n            isDragging: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, common.getSegMeta(seg, props.todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, common.getSegMeta(seg, props.todayRange))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return common.createElement(\"a\", tslib.__assign({\n        ref: rootElRef,\n        className: ['fc-daygrid-more-link'].concat(classNames).join(' '),\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, common.createAriaClickAttrs(handleClick)), innerContent);\n    });\n  };\n\n  return TableCellMoreLink;\n}(common.BaseComponent);\n\nfunction compileSegs(singlePlacements) {\n  var allSegs = [];\n  var invisibleSegs = [];\n\n  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {\n    var placement = singlePlacements_1[_i];\n    allSegs.push(placement.seg);\n\n    if (!placement.isVisible) {\n      invisibleSegs.push(placement.seg);\n    }\n  }\n\n  return {\n    allSegs: allSegs,\n    invisibleSegs: invisibleSegs\n  };\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = common.createFormatter({\n  week: 'narrow'\n});\n\nvar TableCell = function (_super) {\n  tslib.__extends(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = common.createRef();\n    _this.state = {\n      dayNumberId: common.getUniqueDomId()\n    };\n\n    _this.handleRootEl = function (el) {\n      common.setRef(_this.rootElRef, el);\n      common.setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _a = this,\n        context = _a.context,\n        props = _a.props,\n        state = _a.state,\n        rootElRef = _a.rootElRef;\n\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var navLinkAttrs = common.buildNavLinkAttrs(context, date, 'week');\n    return common.createElement(common.DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n      return common.createElement(\"td\", tslib.__assign({\n        ref: dayElRef,\n        role: \"gridcell\",\n        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {\n        'aria-labelledby': state.dayNumberId\n      } : {}), common.createElement(\"div\", {\n        className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && common.createElement(common.WeekNumberRoot, {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {\n        return common.createElement(\"a\", tslib.__assign({\n          ref: weekElRef,\n          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && common.createElement(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        dayNumberId: state.dayNumberId,\n        forceDayTop: props.forceDayTop,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), common.createElement(\"div\", {\n        className: \"fc-daygrid-day-events\",\n        ref: props.fgContentElRef\n      }, props.fgContent, common.createElement(\"div\", {\n        className: \"fc-daygrid-day-bottom\",\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, common.createElement(TableCellMoreLink, {\n        allDayDate: date,\n        singlePlacements: props.singlePlacements,\n        moreCnt: props.moreCnt,\n        alignmentElRef: rootElRef,\n        alignGridTop: !props.showDayNumber,\n        extraDateSpan: props.extraDateSpan,\n        dateProfile: props.dateProfile,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        todayRange: props.todayRange\n      }))), common.createElement(\"div\", {\n        className: \"fc-daygrid-day-bg\"\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(common.DateComponent);\n\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n  var hierarchy = new DayGridSegHierarchy();\n  hierarchy.allowReslicing = true;\n  hierarchy.strictOrder = strictOrder;\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    hierarchy.maxCoord = maxContentHeight;\n    hierarchy.hiddenConsumes = true;\n  } else if (typeof dayMaxEvents === 'number') {\n    hierarchy.maxStackCnt = dayMaxEvents;\n  } else if (typeof dayMaxEventRows === 'number') {\n    hierarchy.maxStackCnt = dayMaxEventRows;\n    hierarchy.hiddenConsumes = true;\n  } // create segInputs only for segs with known heights\n\n\n  var segInputs = [];\n  var unknownHeightSegs = [];\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventInstanceHeights[instanceId];\n\n    if (eventHeight != null) {\n      segInputs.push({\n        index: i,\n        thickness: eventHeight,\n        span: {\n          start: seg.firstCol,\n          end: seg.lastCol + 1\n        }\n      });\n    } else {\n      unknownHeightSegs.push(seg);\n    }\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var segRects = hierarchy.toRects();\n\n  var _a = placeRects(segRects, segs, cells),\n      singleColPlacements = _a.singleColPlacements,\n      multiColPlacements = _a.multiColPlacements,\n      leftoverMargins = _a.leftoverMargins;\n\n  var moreCnts = [];\n  var moreMarginTops = []; // add segs with unknown heights\n\n  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {\n    var seg = unknownHeightSegs_1[_i];\n    multiColPlacements[seg.firstCol].push({\n      seg: seg,\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // add the hidden entries\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreCnts.push(0);\n  }\n\n  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {\n    var hiddenEntry = hiddenEntries_1[_b];\n    var seg = segs[hiddenEntry.index];\n    var hiddenSpan = hiddenEntry.span;\n    multiColPlacements[hiddenSpan.start].push({\n      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {\n      moreCnts[col] += 1;\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // deal with leftover margins\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreMarginTops.push(leftoverMargins[col]);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    moreCnts: moreCnts,\n    moreMarginTops: moreMarginTops\n  };\n} // rects ordered by top coord, then left\n\n\nfunction placeRects(allRects, segs, cells) {\n  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n  var singleColPlacements = [];\n  var multiColPlacements = [];\n  var leftoverMargins = [];\n\n  for (var col = 0; col < cells.length; col += 1) {\n    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements\n\n    var singlePlacements = [];\n    var currentHeight = 0;\n    var currentMarginTop = 0;\n\n    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {\n      var rect = rects_1[_i];\n      var seg = segs[rect.index];\n      singlePlacements.push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: true,\n        isAbsolute: false,\n        absoluteTop: rect.levelCoord,\n        marginTop: rect.levelCoord - currentHeight\n      });\n      currentHeight = rect.levelCoord + rect.thickness;\n    } // compute mixed static/absolute segs in multiPlacements\n\n\n    var multiPlacements = [];\n    currentHeight = 0;\n    currentMarginTop = 0;\n\n    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {\n      var rect = rects_2[_a];\n      var seg = segs[rect.index];\n      var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n\n      var isFirstCol = rect.span.start === col;\n      currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n\n      currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n\n      if (isAbsolute) {\n        currentMarginTop += rect.thickness;\n\n        if (isFirstCol) {\n          multiPlacements.push({\n            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: rect.levelCoord,\n            marginTop: 0\n          });\n        }\n      } else if (isFirstCol) {\n        multiPlacements.push({\n          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n          isVisible: true,\n          isAbsolute: false,\n          absoluteTop: rect.levelCoord,\n          marginTop: currentMarginTop // claim the margin\n\n        });\n        currentMarginTop = 0;\n      }\n    }\n\n    singleColPlacements.push(singlePlacements);\n    multiColPlacements.push(multiPlacements);\n    leftoverMargins.push(currentMarginTop);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    leftoverMargins: leftoverMargins\n  };\n}\n\nfunction groupRectsByEachCol(rects, colCnt) {\n  var rectsByEachCol = [];\n\n  for (var col = 0; col < colCnt; col += 1) {\n    rectsByEachCol.push([]);\n  }\n\n  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {\n    var rect = rects_3[_i];\n\n    for (var col = rect.span.start; col < rect.span.end; col += 1) {\n      rectsByEachCol[col].push(rect);\n    }\n  }\n\n  return rectsByEachCol;\n}\n\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n    return seg;\n  }\n\n  var eventRange = seg.eventRange;\n  var origRange = eventRange.range;\n  var slicedRange = common.intersectRanges(origRange, {\n    start: cells[spanStart].date,\n    end: common.addDays(cells[spanEnd - 1].date, 1)\n  });\n  return tslib.__assign(tslib.__assign({}, seg), {\n    firstCol: spanStart,\n    lastCol: spanEnd - 1,\n    eventRange: {\n      def: eventRange.def,\n      ui: tslib.__assign(tslib.__assign({}, eventRange.ui), {\n        durationEditable: false\n      }),\n      instance: eventRange.instance,\n      range: slicedRange\n    },\n    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n  });\n}\n\nvar DayGridSegHierarchy = function (_super) {\n  tslib.__extends(DayGridSegHierarchy, _super);\n\n  function DayGridSegHierarchy() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // config\n\n\n    _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space\n\n    _this.forceHidden = {};\n    return _this;\n  }\n\n  DayGridSegHierarchy.prototype.addSegs = function (segInputs) {\n    var _this = this;\n\n    var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n\n    var entriesByLevel = this.entriesByLevel;\n\n    var excludeHidden = function (entry) {\n      return !_this.forceHidden[common.buildEntryKey(entry)];\n    }; // remove the forced-hidden segs\n\n\n    for (var level = 0; level < entriesByLevel.length; level += 1) {\n      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n    }\n\n    return hiddenSegs;\n  };\n\n  DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        forceHidden = _a.forceHidden;\n\n    var touchingEntry = insertion.touchingEntry,\n        touchingLevel = insertion.touchingLevel,\n        touchingLateral = insertion.touchingLateral;\n\n    if (this.hiddenConsumes && touchingEntry) {\n      var touchingEntryId = common.buildEntryKey(touchingEntry); // if not already hidden\n\n      if (!forceHidden[touchingEntryId]) {\n        if (this.allowReslicing) {\n          var placeholderEntry = tslib.__assign(tslib.__assign({}, touchingEntry), {\n            span: common.intersectSpans(touchingEntry.span, entry.span)\n          });\n\n          var placeholderEntryId = common.buildEntryKey(placeholderEntry);\n          forceHidden[placeholderEntryId] = true;\n          entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n\n          this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n        } else {\n          forceHidden[touchingEntryId] = true;\n          hiddenEntries.push(touchingEntry);\n        }\n      }\n    }\n\n    return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n  };\n\n  return DayGridSegHierarchy;\n}(common.SegHierarchy);\n\nvar TableRow = function (_super) {\n  tslib.__extends(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new common.RefMap(); // the <td>\n\n    _this.frameElRefs = new common.RefMap(); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new common.RefMap(); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new common.RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = common.createRef();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      eventInstanceHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement(common.sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),\n        singleColPlacements = _b.singleColPlacements,\n        multiColPlacements = _b.multiColPlacements,\n        moreCnts = _b.moreCnts,\n        moreMarginTops = _b.moreMarginTops;\n\n    var isForcedInvisible = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return common.createElement(\"tr\", {\n      ref: this.rootElRef,\n      role: \"row\"\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n\n      var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n      return common.createElement(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers,\n        showWeekNumber: props.showWeekNumbers && col === 0,\n        forceDayTop: props.showWeekNumbers\n        /* even displaying weeknum for row, not necessarily day */\n        ,\n        todayRange: props.todayRange,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        moreCnt: moreCnts[col],\n        moreMarginTop: moreMarginTops[col],\n        singlePlacements: singleColPlacements[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        common.createElement(common.Fragment, null, common.createElement(common.Fragment, null, normalFgNodes), common.createElement(common.Fragment, null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        common.createElement(common.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!common.isPropsEqual(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    }\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return props.dateSelectionSegs;\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return [];\n  };\n\n  TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {\n        var placement = segPlacements_1[_i];\n        var seg = placement.seg;\n        var instanceId = seg.eventRange.instance.instanceId;\n        var key = instanceId + ':' + col;\n        var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n        var isAbsolute = placement.isAbsolute;\n        var left = '';\n        var right = '';\n\n        if (isAbsolute) {\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        todo: in print view, for multi-day events, don't display title within non-start/end segs\n        */\n\n\n        nodes.push(common.createElement(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: key,\n          ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n          style: {\n            visibility: isVisible ? '' : 'hidden',\n            marginTop: isAbsolute ? '' : placement.marginTop,\n            top: isAbsolute ? placement.absoluteTop : '',\n            left: left,\n            right: right\n          }\n        }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, common.getSegMeta(seg, todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, common.getSegMeta(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push(common.createElement(\"div\", {\n          key: common.buildEventRangeKey(seg.eventRange),\n          className: \"fc-daygrid-bg-harness\",\n          style: leftRightCss\n        }, fillType === 'bg-event' ? common.createElement(common.BgEvent, tslib.__assign({\n          seg: seg\n        }, common.getSegMeta(seg, todayRange))) : common.renderFill(fillType)));\n      }\n    }\n\n    return common.createElement.apply(void 0, tslib.__spreadArray([common.Fragment, {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (!props.forPrint && props.clientWidth !== null // positioning ready?\n    ) {\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new common.PositionCache(originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var oldInstanceHeights = this.state.eventInstanceHeights;\n      var newInstanceHeights = this.queryEventInstanceHeights();\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n        // Essentially, once you compute an element's height, never null-out.\n        // TODO: always display all events, as visibility:hidden?\n        eventInstanceHeights: tslib.__assign(tslib.__assign({}, oldInstanceHeights), newInstanceHeights),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.queryEventInstanceHeights = function () {\n    var segElMap = this.segHarnessRefs.currentMap;\n    var eventInstanceHeights = {}; // get the max height amongst instance segs\n\n    for (var key in segElMap) {\n      var height = Math.round(segElMap[key].getBoundingClientRect().height);\n      var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n\n      eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n    }\n\n    return eventInstanceHeights;\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(common.DateComponent);\n\nTableRow.addStateEquality({\n  eventInstanceHeights: common.isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n  if (!mirrorSegs.length) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      isVisible: true,\n      isAbsolute: true,\n      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n      marginTop: 0\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(colPlacements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {\n    var placements = colPlacements_1[_i];\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar Table = function (_super) {\n  tslib.__extends(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = common.memoize(splitSegsByRow);\n    _this.splitBgEventSegs = common.memoize(splitSegsByRow);\n    _this.splitFgEventSegs = common.memoize(splitSegsByRow);\n    _this.splitDateSelectionSegs = common.memoize(splitSegsByRow);\n    _this.splitEventDrag = common.memoize(splitInteractionByRow);\n    _this.splitEventResize = common.memoize(splitInteractionByRow);\n    _this.rowRefs = new common.RefMap();\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n    ];\n    return common.createElement(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, common.createElement(common.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return common.createElement(common.Fragment, null, common.createElement(\"table\", {\n        role: \"presentation\",\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, common.createElement(\"tbody\", {\n        role: \"presentation\"\n      }, props.cells.map(function (cells, row) {\n        return common.createElement(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n          /* hack */\n          ,\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          forPrint: props.forPrint\n        });\n      }))));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new common.PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true);\n    this.colPositions = new common.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(positionLeft);\n    var row = rowPositions.topToIndex(positionTop);\n\n    if (row != null && col != null) {\n      var cell = this.props.cells[row][col];\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: tslib.__assign({\n          range: this.getCellRange(row, col),\n          allDay: true\n        }, cell.extraDateSpan),\n        dayEl: this.getCellEl(row, col),\n        rect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = common.addDays(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(common.DateComponent);\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer = function (_super) {\n  tslib.__extends(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(common.Slicer);\n\nvar DayTable = function (_super) {\n  tslib.__extends(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = common.createRef();\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return common.createElement(Table, tslib.__assign({\n      ref: this.tableRef\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  return DayTable;\n}(common.DateComponent);\n\nvar DayTableView = function (_super) {\n  tslib.__extends(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = common.memoize(buildDayTableModel);\n    _this.headerRef = common.createRef();\n    _this.tableRef = common.createRef();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && common.createElement(common.DayHeader, {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function (contentArg) {\n      return common.createElement(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new common.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator = function (_super) {\n  tslib.__extends(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = common.addWeeks(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      common.diffWeeks(start, end));\n      end = common.addWeeks(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(common.DateProfileGenerator);\n\nvar main = common.createPlugin({\n  initialView: 'dayGridMonth',\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\nexports.DayGridView = DayTableView;\nexports.DayTable = DayTable;\nexports.DayTableSlicer = DayTableSlicer;\nexports.Table = Table;\nexports.TableView = TableView;\nexports.buildDayTableModel = buildDayTableModel;\nexports[\"default\"] = main;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYkEsOENBQTZDO0FBQUVHLEVBQUFBLEtBQUssRUFBRTtBQUFULENBQTdDOztBQUVBLElBQUlDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw2RUFBRCxDQUFwQjs7QUFDQSxJQUFJQyxLQUFLLEdBQUdELG1CQUFPLENBQUMsb0JBQUQsQ0FBbkI7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJRSxTQUFTLEdBQWtCLFVBQVVDLE1BQVYsRUFBa0I7QUFDN0NGLEVBQUFBLEtBQUssQ0FBQ0csU0FBTixDQUFnQkYsU0FBaEIsRUFBMkJDLE1BQTNCOztBQUNBLFdBQVNELFNBQVQsR0FBcUI7QUFDakIsUUFBSUcsS0FBSyxHQUFHRixNQUFNLEtBQUssSUFBWCxJQUFtQkEsTUFBTSxDQUFDRyxLQUFQLENBQWEsSUFBYixFQUFtQkMsU0FBbkIsQ0FBbkIsSUFBb0QsSUFBaEU7O0FBQ0FGLElBQUFBLEtBQUssQ0FBQ0csV0FBTixHQUFvQlQsTUFBTSxDQUFDVSxTQUFQLEVBQXBCO0FBQ0EsV0FBT0osS0FBUDtBQUNIOztBQUNESCxFQUFBQSxTQUFTLENBQUNRLFNBQVYsQ0FBb0JDLGtCQUFwQixHQUF5QyxVQUFVQyxnQkFBVixFQUE0QkMsV0FBNUIsRUFBeUM7QUFDOUUsUUFBSUMsRUFBRSxHQUFHLElBQVQ7QUFBQSxRQUFlQyxLQUFLLEdBQUdELEVBQUUsQ0FBQ0MsS0FBMUI7QUFBQSxRQUFpQ0MsT0FBTyxHQUFHRixFQUFFLENBQUNFLE9BQTlDOztBQUNBLFFBQUlDLFFBQVEsR0FBRyxFQUFmO0FBQ0EsUUFBSUMsaUJBQWlCLEdBQUduQixNQUFNLENBQUNvQixvQkFBUCxDQUE0QkgsT0FBTyxDQUFDSSxPQUFwQyxDQUF4Qjs7QUFDQSxRQUFJUixnQkFBSixFQUFzQjtBQUNsQkssTUFB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RTNCQyxFQUFBQSxLQUFLLEVBQUU7QUFDSEMsSUFBQUEsT0FBTyxFQUFFO0FBQ0xDLE1BQUFBLFNBQVMsRUFBRXpDLFlBRE47QUFFTDBDLE1BQUFBLHlCQUF5QixFQUFFbkI7QUFGdEIsS0FETjtBQUtIb0IsSUFBQUEsVUFBVSxFQUFFO0FBQ1IxYixNQUFBQSxJQUFJLEVBQUUsU0FERTtBQUVSMmIsTUFBQUEsUUFBUSxFQUFFO0FBQUVDLFFBQUFBLElBQUksRUFBRTtBQUFSO0FBRkYsS0FMVDtBQVNIQyxJQUFBQSxXQUFXLEVBQUU7QUFDVDdiLE1BQUFBLElBQUksRUFBRSxTQURHO0FBRVQyYixNQUFBQSxRQUFRLEVBQUU7QUFBRUcsUUFBQUEsS0FBSyxFQUFFO0FBQVQ7QUFGRCxLQVRWO0FBYUhDLElBQUFBLFlBQVksRUFBRTtBQUNWL2IsTUFBQUEsSUFBSSxFQUFFLFNBREk7QUFFVjJiLE1BQUFBLFFBQVEsRUFBRTtBQUFFSyxRQUFBQSxNQUFNLEVBQUU7QUFBVixPQUZBO0FBR1ZsQixNQUFBQSxTQUFTLEVBQUUsSUFIRDtBQUlWQyxNQUFBQSxjQUFjLEVBQUU7QUFKTjtBQWJYO0FBRm9CLENBQXBCLENBQVg7QUF3QkF4YyxtQkFBQSxHQUFzQndhLFlBQXRCO0FBQ0F4YSxnQkFBQSxHQUFtQmthLFFBQW5CO0FBQ0FsYSxzQkFBQSxHQUF5QjRaLGNBQXpCO0FBQ0E1WixhQUFBLEdBQWdCNlcsS0FBaEI7QUFDQTdXLGlCQUFBLEdBQW9CSyxTQUFwQjtBQUNBTCwwQkFBQSxHQUE2QnlhLGtCQUE3QjtBQUNBemEsa0JBQUEsR0FBa0I0YyxJQUFsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Z1bGxjYWxsZW5kYXItdGVzdC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5janMuanM/YjdhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMC4xXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMSBBZGFtIFNoYXdcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvbW1vbicpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbjtcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG52YXIgVGFibGVWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGVhZGVyRWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGVWaWV3LnByb3RvdHlwZS5yZW5kZXJTaW1wbGVMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSBjb21tb24uZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5TaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbXSAvKiBUT0RPOiBtYWtlIG9wdGlvbmFsPyAqLywgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIFRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVySFNjcm9sbExheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCkge1xuICAgICAgICB2YXIgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGNvbW1vbi5nZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGNvbW1vbi5nZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbW1vbi5yZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVWaWV3O1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzLCByb3dDbnQpIHtcbiAgICB2YXIgYnlSb3cgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Um93W2ldID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzXzFbX2ldO1xuICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XG4gICAgdmFyIGJ5Q29sID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieUNvbFtpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcbiAgICAgICAgYnlDb2xbc2VnLmZpcnN0Q29sXS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aSwgcm93Q250KSB7XG4gICAgdmFyIGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdWkuc2VnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbnZhciBUYWJsZUNlbGxUb3AgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlQ2VsbFRvcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVDZWxsVG9wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSBjb21tb24uYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBwcm9wcy5kYXRlKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbENvbnRlbnQsIHsgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsIGRlZmF1bHRDb250ZW50OiByZW5kZXJUb3BJbm5lciB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoKGlubmVyQ29udGVudCB8fCBwcm9wcy5mb3JjZURheVRvcCkgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCByZWY6IGlubmVyRWxSZWYgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IGlkOiBwcm9wcy5kYXlOdW1iZXJJZCwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCB8fCBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGxUb3A7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0O1xufVxuXG52YXIgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ25hcnJvdycsXG59KTtcbmZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpIHtcbiAgICB2YXIgZGlzcGxheSA9IHNlZy5ldmVudFJhbmdlLnVpLmRpc3BsYXk7XG4gICAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAgICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICAgICAgc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiAvLyBjYW4ndCBiZSBtdWx0aS1kYXlcbiAgICAgICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICAgICAgc2VnLmlzRW5kIC8vIFwiXG4gICAgKTtcbn1cblxudmFyIFRhYmxlQmxvY2tFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVCbG9ja0V2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQmxvY2tFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUJsb2NrRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uU3RhbmRhcmRFdmVudCwgdHNsaWIuX19hc3NpZ24oe30sIHByb3BzLCB7IGV4dHJhQ2xhc3NOYW1lczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQmxvY2tFdmVudDtcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcblxudmFyIFRhYmxlTGlzdEl0ZW1FdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVMaXN0SXRlbUV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlTGlzdEl0ZW1FdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUxpc3RJdGVtRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUO1xuICAgICAgICB2YXIgdGltZVRleHQgPSBjb21tb24uYnVpbGRTZWdUaW1lVGV4dChwcm9wcy5zZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRydWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5FdmVudFJvb3QsIHsgc2VnOiBwcm9wcy5zZWcsIHRpbWVUZXh0OiB0aW1lVGV4dCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgaXNEcmFnZ2luZzogcHJvcHMuaXNEcmFnZ2luZywgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IHByb3BzLmlzU2VsZWN0ZWQsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXkgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoIC8vIHdlIGRvbid0IHVzZSBzdHlsZXMhXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IGNsYXNzTmFtZTogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSwgY29tbW9uLmdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCkpLCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlTGlzdEl0ZW1FdmVudDtcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtZG90XCIsIHN0eWxlOiB7IGJvcmRlckNvbG9yOiBpbm5lclByb3BzLmJvcmRlckNvbG9yIHx8IGlubmVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKTtcbn1cblxudmFyIFRhYmxlQ2VsbE1vcmVMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZUNlbGxNb3JlTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxNb3JlTGluaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbXBpbGVTZWdzID0gY29tbW9uLm1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbE1vcmVMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyksIGFsbFNlZ3MgPSBfYS5hbGxTZWdzLCBpbnZpc2libGVTZWdzID0gX2EuaW52aXNpYmxlU2VncztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uTW9yZUxpbmtSb290LCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCwgYWxsU2Vncy5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzXCIsIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpIDogKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2ssIHRpdGxlLCBpc0V4cGFuZGVkLCBwb3BvdmVySWQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgdGl0bGU6IHRpdGxlLCBcImFyaWEtZXhwYW5kZWRcIjogaXNFeHBhbmRlZCwgXCJhcmlhLWNvbnRyb2xzXCI6IHBvcG92ZXJJZCB9LCBjb21tb24uY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlQ2xpY2spKSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGxNb3JlTGluaztcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICB2YXIgYWxsU2VncyA9IFtdO1xuICAgIHZhciBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzaW5nbGVQbGFjZW1lbnRzXzEgPSBzaW5nbGVQbGFjZW1lbnRzOyBfaSA8IHNpbmdsZVBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNpbmdsZVBsYWNlbWVudHNfMVtfaV07XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VnczogYWxsU2VncywgaW52aXNpYmxlU2VnczogaW52aXNpYmxlU2VncyB9O1xufVxuXG52YXIgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjb21tb24uY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ25hcnJvdycgfSk7XG52YXIgVGFibGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRheU51bWJlcklkOiBjb21tb24uZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBjb21tb24uc2V0UmVmKF90aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgY29tbW9uLnNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0ID0gX2EuY29udGV4dCwgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgcm9vdEVsUmVmID0gX2Eucm9vdEVsUmVmO1xuICAgICAgICB2YXIgZGF0ZSA9IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSBjb21tb24uYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbFJvb3QsIHsgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9LCBmdW5jdGlvbiAoZGF5RWxSZWYsIGRheUNsYXNzTmFtZXMsIHJvb3REYXRhQXR0cnMsIGlzRGlzYWJsZWQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBkYXlFbFJlZiwgcm9sZTogXCJncmlkY2VsbFwiLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1kYXknXS5jb25jYXQoZGF5Q2xhc3NOYW1lcywgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKS5qb2luKCcgJykgfSwgcm9vdERhdGFBdHRycywgcHJvcHMuZXh0cmFEYXRhQXR0cnMsIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1mcmFtZSBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgcmVmOiBwcm9wcy5pbm5lckVsUmVmIC8qIGRpZmZlcmVudCBmcm9tIGhvb2sgc3lzdGVtISBSRU5BTUUgKi8gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLldlZWtOdW1iZXJSb290LCB7IGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uICh3ZWVrRWxSZWYsIHdlZWtDbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHdlZWtFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXS5jb25jYXQod2Vla0NsYXNzTmFtZXMpLmpvaW4oJyAnKSB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQpKTsgfSkpLFxuICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkICYmIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUNlbGxUb3AsIHsgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBkYXlOdW1iZXJJZDogc3RhdGUuZGF5TnVtYmVySWQsIGZvcmNlRGF5VG9wOiBwcm9wcy5mb3JjZURheVRvcCwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0pKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiLCBzdHlsZTogeyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzZWdzLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cywgc3RyaWN0T3JkZXIsIGV2ZW50SW5zdGFuY2VIZWlnaHRzLCBtYXhDb250ZW50SGVpZ2h0LCBjZWxscykge1xuICAgIHZhciBoaWVyYXJjaHkgPSBuZXcgRGF5R3JpZFNlZ0hpZXJhcmNoeSgpO1xuICAgIGhpZXJhcmNoeS5hbGxvd1Jlc2xpY2luZyA9IHRydWU7XG4gICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heENvb3JkID0gbWF4Q29udGVudEhlaWdodDtcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRSb3dzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBzZWdJbnB1dHMgb25seSBmb3Igc2VncyB3aXRoIGtub3duIGhlaWdodHNcbiAgICB2YXIgc2VnSW5wdXRzID0gW107XG4gICAgdmFyIHVua25vd25IZWlnaHRTZWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHZhciBldmVudEhlaWdodCA9IGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdO1xuICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZXZlbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIHZhciBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XG4gICAgdmFyIF9hID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpLCBzaW5nbGVDb2xQbGFjZW1lbnRzID0gX2Euc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzID0gX2EubXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgPSBfYS5sZWZ0b3Zlck1hcmdpbnM7XG4gICAgdmFyIG1vcmVDbnRzID0gW107XG4gICAgdmFyIG1vcmVNYXJnaW5Ub3BzID0gW107XG4gICAgLy8gYWRkIHNlZ3Mgd2l0aCB1bmtub3duIGhlaWdodHNcbiAgICBmb3IgKHZhciBfaSA9IDAsIHVua25vd25IZWlnaHRTZWdzXzEgPSB1bmtub3duSGVpZ2h0U2VnczsgX2kgPCB1bmtub3duSGVpZ2h0U2Vnc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnID0gdW5rbm93bkhlaWdodFNlZ3NfMVtfaV07XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiBzZWcsXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIGhpZGRlbiBlbnRyaWVzXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlQ250cy5wdXNoKDApO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYiA9IDAsIGhpZGRlbkVudHJpZXNfMSA9IGhpZGRlbkVudHJpZXM7IF9iIDwgaGlkZGVuRW50cmllc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgaGlkZGVuRW50cnkgPSBoaWRkZW5FbnRyaWVzXzFbX2JdO1xuICAgICAgICB2YXIgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF07XG4gICAgICAgIHZhciBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhbjtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMTtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzOiBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzOiBtb3JlQ250cywgbW9yZU1hcmdpblRvcHM6IG1vcmVNYXJnaW5Ub3BzIH07XG59XG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xuICAgIHZhciByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XG4gICAgdmFyIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XG4gICAgdmFyIGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgdmFyIHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcbiAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgICAgICB2YXIgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZWN0c18xID0gcmVjdHM7IF9pIDwgcmVjdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVjdHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICAgICAgdmFyIG11bHRpUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcmVjdHNfMiA9IHJlY3RzOyBfYSA8IHJlY3RzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlY3RzXzJbX2FdO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHJlY3Quc3Bhbi5lbmQgLSByZWN0LnNwYW4uc3RhcnQgPiAxOyAvLyBtdWx0aS1jb2x1bW4/XG4gICAgICAgICAgICB2YXIgaXNGaXJzdENvbCA9IHJlY3Quc3Bhbi5zdGFydCA9PT0gY29sO1xuICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2Ugc2luY2UgYm90dG9tIG9mIHByZXZpb3VzIHNlZ1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzOyAvLyBoZWlnaHQgd2lsbCBub3cgYmUgYm90dG9tIG9mIGN1cnJlbnQgc2VnXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogY3VycmVudE1hcmdpblRvcCwgLy8gY2xhaW0gdGhlIG1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHMucHVzaChzaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzLnB1c2gobXVsdGlQbGFjZW1lbnRzKTtcbiAgICAgICAgbGVmdG92ZXJNYXJnaW5zLnB1c2goY3VycmVudE1hcmdpblRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50czogbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnM6IGxlZnRvdmVyTWFyZ2lucyB9O1xufVxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0cywgY29sQ250KSB7XG4gICAgdmFyIHJlY3RzQnlFYWNoQ29sID0gW107XG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZWN0c18zID0gcmVjdHM7IF9pIDwgcmVjdHNfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHJlY3QgPSByZWN0c18zW19pXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcbn1cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XG4gICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH1cbiAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIHZhciBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgIHZhciBzbGljZWRSYW5nZSA9IGNvbW1vbi5pbnRlcnNlY3RSYW5nZXMob3JpZ1JhbmdlLCB7XG4gICAgICAgIHN0YXJ0OiBjZWxsc1tzcGFuU3RhcnRdLmRhdGUsXG4gICAgICAgIGVuZDogY29tbW9uLmFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxudmFyIERheUdyaWRTZWdIaWVyYXJjaHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheUdyaWRTZWdIaWVyYXJjaHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5R3JpZFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICBfdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICBfdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUdyaWRTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoc2VnSW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoaWRkZW5TZWdzID0gX3N1cGVyLnByb3RvdHlwZS5hZGRTZWdzLmNhbGwodGhpcywgc2VnSW5wdXRzKTtcbiAgICAgICAgdmFyIGVudHJpZXNCeUxldmVsID0gdGhpcy5lbnRyaWVzQnlMZXZlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVIaWRkZW4gPSBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5mb3JjZUhpZGRlbltjb21tb24uYnVpbGRFbnRyeUtleShlbnRyeSldOyB9O1xuICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgICAgICBmb3IgKHZhciBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xuICAgIH07XG4gICAgRGF5R3JpZFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbiA9IGZ1bmN0aW9uIChpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIGZvcmNlSGlkZGVuID0gX2EuZm9yY2VIaWRkZW47XG4gICAgICAgIHZhciB0b3VjaGluZ0VudHJ5ID0gaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIHRvdWNoaW5nTGV2ZWwgPSBpbnNlcnRpb24udG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsID0gaW5zZXJ0aW9uLnRvdWNoaW5nTGF0ZXJhbDtcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgdmFyIHRvdWNoaW5nRW50cnlJZCA9IGNvbW1vbi5idWlsZEVudHJ5S2V5KHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IGFscmVhZHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJFbnRyeSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0b3VjaGluZ0VudHJ5KSwgeyBzcGFuOiBjb21tb24uaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnlJZCA9IGNvbW1vbi5idWlsZEVudHJ5S2V5KHBsYWNlaG9sZGVyRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbltwbGFjZWhvbGRlckVudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbdG91Y2hpbmdMZXZlbF1bdG91Y2hpbmdMYXRlcmFsXSA9IHBsYWNlaG9sZGVyRW50cnk7IC8vIHJlcGxhY2UgdG91Y2hpbmdFbnRyeSB3aXRoIG91ciBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0RW50cnkodG91Y2hpbmdFbnRyeSwgZW50cnksIGhpZGRlbkVudHJpZXMpOyAvLyBzcGxpdCB1cCB0aGUgdG91Y2hpbmdFbnRyeSwgcmVpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2godG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUludmFsaWRJbnNlcnRpb24uY2FsbCh0aGlzLCBpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlHcmlkU2VnSGllcmFyY2h5O1xufShjb21tb24uU2VnSGllcmFyY2h5KSk7XG5cbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVSb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVSb3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jZWxsRWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgX3RoaXMuZnJhbWVFbFJlZnMgPSBuZXcgY29tbW9uLlJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZnJhbWVcbiAgICAgICAgX3RoaXMuZmdFbFJlZnMgPSBuZXcgY29tbW9uLlJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gICAgICAgIF90aGlzLnNlZ0hhcm5lc3NSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91cnNCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgdmFyIG1pcnJvclNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRNaXJyb3JTZWdzKCksIGNvbENudCk7XG4gICAgICAgIHZhciBfYiA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChjb21tb24uc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSwgcHJvcHMuZGF5TWF4RXZlbnRzLCBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCwgc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHMsIHN0YXRlLm1heENvbnRlbnRIZWlnaHQsIHByb3BzLmNlbGxzKSwgc2luZ2xlQ29sUGxhY2VtZW50cyA9IF9iLnNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cyA9IF9iLm11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMgPSBfYi5tb3JlQ250cywgbW9yZU1hcmdpblRvcHMgPSBfYi5tb3JlTWFyZ2luVG9wcztcbiAgICAgICAgdmFyIGlzRm9yY2VkSW52aXNpYmxlID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1pcnJvckZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IF90aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgaW5uZXJFbFJlZjogX3RoaXMuZnJhbWVFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSAvKiBGRiA8dGQ+IHByb2JsZW0sIGJ1dCBva2F5IHRvIHVzZSBmb3IgbGVmdC9yaWdodC4gVE9ETzogcmVuYW1lIHByb3AgKi8sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVycywgc2hvd1dlZWtOdW1iZXI6IHByb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDAsIGZvcmNlRGF5VG9wOiBwcm9wcy5zaG93V2Vla051bWJlcnMgLyogZXZlbiBkaXNwbGF5aW5nIHdlZWtudW0gZm9yIHJvdywgbm90IG5lY2Vzc2FyaWx5IGRheSAqLywgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBleHRyYUhvb2tQcm9wczogY2VsbC5leHRyYUhvb2tQcm9wcywgZXh0cmFEYXRhQXR0cnM6IGNlbGwuZXh0cmFEYXRhQXR0cnMsIGV4dHJhQ2xhc3NOYW1lczogY2VsbC5leHRyYUNsYXNzTmFtZXMsIGV4dHJhRGF0ZVNwYW46IGNlbGwuZXh0cmFEYXRlU3BhbiwgbW9yZUNudDogbW9yZUNudHNbY29sXSwgbW9yZU1hcmdpblRvcDogbW9yZU1hcmdpblRvcHNbY29sXSwgc2luZ2xlUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLCBmZ0NvbnRlbnRFbFJlZjogX3RoaXMuZmdFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIG5vcm1hbEZnTm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLCBtaXJyb3JGZ05vZGVzKSkpLCBiZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpIH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWNvbW1vbi5pc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldE1pcnJvclNlZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChjb2wsIHNlZ1BsYWNlbWVudHMsIHRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBldmVudFNlbGVjdGlvbiA9IHRoaXMucHJvcHMuZXZlbnRTZWxlY3Rpb247XG4gICAgICAgIHZhciBmcmFtZVBvc2l0aW9ucyA9IHRoaXMuc3RhdGUuZnJhbWVQb3NpdGlvbnM7XG4gICAgICAgIHZhciBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxuICAgICAgICB2YXIgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ1BsYWNlbWVudHNfMSA9IHNlZ1BsYWNlbWVudHM7IF9pIDwgc2VnUGxhY2VtZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBzZWdQbGFjZW1lbnRzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBwbGFjZW1lbnQuc2VnO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW5zdGFuY2VJZCArICc6JyArIGNvbDtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gcGxhY2VtZW50LmlzVmlzaWJsZSAmJiAhaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwbGFjZW1lbnQuaXNBYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB0b2RvOiBpbiBwcmludCB2aWV3LCBmb3IgbXVsdGktZGF5IGV2ZW50cywgZG9uJ3QgZGlzcGxheSB0aXRsZSB3aXRoaW4gbm9uLXN0YXJ0L2VuZCBzZWdzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKSwga2V5OiBrZXksIHJlZjogaXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoa2V5KSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICcnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGlzQWJzb2x1dGUgPyAnJyA6IHBsYWNlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGlzQWJzb2x1dGUgPyBwbGFjZW1lbnQuYWJzb2x1dGVUb3AgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGNvbW1vbi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmlsbFNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgdmFyIGlzUnRsID0gdGhpcy5jb250ZXh0LmlzUnRsO1xuICAgICAgICB2YXIgdG9kYXlSYW5nZSA9IHRoaXMucHJvcHMudG9kYXlSYW5nZTtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBjb21tb24uYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkJnRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLnJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbY29tbW9uLkZyYWdtZW50LCB7fV0sIG5vZGVzKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUudXBkYXRlU2l6aW5nID0gZnVuY3Rpb24gKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgZnJhbWVFbFJlZnMgPSBfYS5mcmFtZUVsUmVmcztcbiAgICAgICAgaWYgKCFwcm9wcy5mb3JQcmludCAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gcG9zaXRpb25pbmcgcmVhZHk/XG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBjb21tb24uUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkSW5zdGFuY2VIZWlnaHRzID0gdGhpcy5zdGF0ZS5ldmVudEluc3RhbmNlSGVpZ2h0cztcbiAgICAgICAgICAgIHZhciBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcbiAgICAgICAgICAgIHZhciBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xuICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb2xkSW5zdGFuY2VIZWlnaHRzKSwgbmV3SW5zdGFuY2VIZWlnaHRzKSxcbiAgICAgICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBsaW1pdEJ5Q29udGVudEhlaWdodCA/IHRoaXMuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcDtcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VIZWlnaHRzID0ge307XG4gICAgICAgIC8vIGdldCB0aGUgbWF4IGhlaWdodCBhbW9uZ3N0IGluc3RhbmNlIHNlZ3NcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNlZ0VsTWFwKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtrZXldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IGtleS5zcGxpdCgnOicpWzBdOyAvLyBkZWNvbnN0cnVjdCBob3cgcmVuZGVyRmdTZWdzIG1ha2VzIHRoZSBrZXlcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdID0gTWF0aC5tYXgoZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gfHwgMCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZUhlaWdodHM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xuICAgICAgICB2YXIgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICB2YXIgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0Q2VsbEVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gZWxNYXBbY2VsbC5rZXldOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZVJvdztcbn0oY29tbW9uLkRhdGVDb21wb25lbnQpKTtcblRhYmxlUm93LmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiBjb21tb24uaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2VncywgY29sUGxhY2VtZW50cykge1xuICAgIGlmICghbWlycm9yU2Vncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgdG9wc0J5SW5zdGFuY2VJZCA9IGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpOyAvLyBUT0RPOiBjYWNoZSB0aGlzIGF0IGZpcnN0IHJlbmRlcj9cbiAgICByZXR1cm4gbWlycm9yU2Vncy5tYXAoZnVuY3Rpb24gKHNlZykgeyByZXR1cm4gKHtcbiAgICAgICAgc2VnOiBzZWcsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IHRvcHNCeUluc3RhbmNlSWRbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0sXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICB9KTsgfSk7XG59XG5mdW5jdGlvbiBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKSB7XG4gICAgdmFyIHRvcHNCeUluc3RhbmNlSWQgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbFBsYWNlbWVudHNfMSA9IGNvbFBsYWNlbWVudHM7IF9pIDwgY29sUGxhY2VtZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGxhY2VtZW50cyA9IGNvbFBsYWNlbWVudHNfMVtfaV07XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcGxhY2VtZW50c18xID0gcGxhY2VtZW50czsgX2EgPCBwbGFjZW1lbnRzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c18xW19hXTtcbiAgICAgICAgICAgIHRvcHNCeUluc3RhbmNlSWRbcGxhY2VtZW50LnNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LmFic29sdXRlVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3BzQnlJbnN0YW5jZUlkO1xufVxuXG52YXIgVGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEV2ZW50RHJhZyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBjb21tb24ubWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICBfdGhpcy5yb3dSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogX3RoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGUsIGRheU1heEV2ZW50Um93cyA9IHByb3BzLmRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzID0gcHJvcHMuZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzID0gcHJvcHMuZXhwYW5kUm93cztcbiAgICAgICAgdmFyIHJvd0NudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCByb3dDbnQpO1xuICAgICAgICB2YXIgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KTtcbiAgICAgICAgdmFyIGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgICAgIC8vIFRPRE86IGJlc3QgcGxhY2UgdG8gbm9ybWFsaXplIHRoZXNlIG9wdGlvbnM/XG4gICAgICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcbiAgICAgICAgICAgIGV4cGFuZFJvd3MgPyAnJyA6ICdmYy1kYXlncmlkLWJvZHktbmF0dXJhbCcsIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgZnVuY3Rpb24gKG5vd0RhdGUsIHRvZGF5UmFuZ2UpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtdGFibGVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGxzLCByb3cpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZVJvdywgeyByZWY6IF90aGlzLnJvd1JlZnMuY3JlYXRlUmVmKHJvdyksIGtleTogY2VsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjZWxsc1swXS5kYXRlLnRvSVNPU3RyaW5nKCkgLyogYmVzdD8gb3IgcHV0IGtleSBvbiBjZWxsPyBvciB1c2UgZGlmZiBmb3JtYXR0ZXI/ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByb3cgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2VsbHMgKGxpa2Ugd2hlbiByZXNvdXJjZSB2aWV3IGlzIGxvYWRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAsIHNob3dEYXlOdW1iZXJzOiByb3dDbnQgPiAxLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBjZWxsczogY2VsbHMsIHJlbmRlckludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W3Jvd10sIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbcm93XS5maWx0ZXIoaXNTZWdBbGxEYXkpIC8qIGhhY2sgKi8sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W3Jvd10sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W3Jvd10sIGV2ZW50RHJhZzogZXZlbnREcmFnQnlSb3dbcm93XSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbcm93XSwgZGF5TWF4RXZlbnRzOiBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogZGF5TWF4RXZlbnRSb3dzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpOyB9KSkpKSk7IH0pKSk7XG4gICAgfTtcbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFRhYmxlLnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgY29tbW9uLlBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jb2xsZWN0KCkubWFwKGZ1bmN0aW9uIChyb3dPYmopIHsgcmV0dXJuIHJvd09iai5nZXRDZWxsRWxzKClbMF07IH0pLCAvLyBmaXJzdCBjZWxsIGVsIGluIGVhY2ggcm93LiBUT0RPOiBub3Qgb3B0aW1hbFxuICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IGNvbW1vbi5Qb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgIGZhbHNlKTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbFBvc2l0aW9ucyA9IF9hLmNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zID0gX2Eucm93UG9zaXRpb25zO1xuICAgICAgICB2YXIgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIHZhciByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IHRzbGliLl9fYXNzaWduKHsgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSwgYWxsRGF5OiB0cnVlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRDZWxsRWwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF07IC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XG4gICAgICAgIHZhciBlbmQgPSBjb21tb24uYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZTtcbn0oY29tbW9uLkRhdGVDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xufVxuXG52YXIgRGF5VGFibGVTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheVRhYmxlU2xpY2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRhYmxlU2xpY2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZVNsaWNlci5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChkYXRlUmFuZ2UsIGRheVRhYmxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRhYmxlU2xpY2VyO1xufShjb21tb24uU2xpY2VyKSk7XG5cbnZhciBEYXlUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcbiAgICAgICAgX3RoaXMudGFibGVSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5VGFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGUsIHRzbGliLl9fYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZTtcbn0oY29tbW9uLkRhdGVDb21wb25lbnQpKTtcblxudmFyIERheVRhYmxlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGFibGVWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRhYmxlVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IGNvbW1vbi5tZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XG4gICAgICAgIF90aGlzLmhlYWRlclJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMudGFibGVSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5VGFibGVWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yID0gX2EuZGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5EYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcbiAgICAgICAgdmFyIGJvZHlDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChEYXlUYWJsZSwgeyByZWY6IF90aGlzLnRhYmxlUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGRheU1heEV2ZW50czogb3B0aW9ucy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogb3B0aW9ucy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgZXhwYW5kUm93czogIXByb3BzLmlzSGVpZ2h0QXV0bywgaGVhZGVyQWxpZ25FbFJlZjogX3RoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpOyB9O1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGVWaWV3O1xufShUYWJsZVZpZXcpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZGF5U2VyaWVzID0gbmV3IGNvbW1vbi5EYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgY29tbW9uLkRheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcbn1cblxudmFyIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLnByb3BzLmRhdGVFbnY7XG4gICAgICAgIHZhciByZW5kZXJSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHZhciBzdGFydCA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gcmVuZGVyUmFuZ2UuZW5kO1xuICAgICAgICB2YXIgZW5kT2ZXZWVrO1xuICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xuICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBjb21tb24uYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb250aE1vZGUgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZml4ZWRXZWVrQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICAgICAgY29tbW9uLmRpZmZXZWVrcyhzdGFydCwgZW5kKSk7XG4gICAgICAgICAgICBlbmQgPSBjb21tb24uYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbn0oY29tbW9uLkRhdGVQcm9maWxlR2VuZXJhdG9yKSk7XG5cbnZhciBtYWluID0gY29tbW9uLmNyZWF0ZVBsdWdpbih7XG4gICAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIGRheUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcbiAgICAgICAgICAgIG1vbnRoTW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0cy5EYXlHcmlkVmlldyA9IERheVRhYmxlVmlldztcbmV4cG9ydHMuRGF5VGFibGUgPSBEYXlUYWJsZTtcbmV4cG9ydHMuRGF5VGFibGVTbGljZXIgPSBEYXlUYWJsZVNsaWNlcjtcbmV4cG9ydHMuVGFibGUgPSBUYWJsZTtcbmV4cG9ydHMuVGFibGVWaWV3ID0gVGFibGVWaWV3O1xuZXhwb3J0cy5idWlsZERheVRhYmxlTW9kZWwgPSBidWlsZERheVRhYmxlTW9kZWw7XG5leHBvcnRzLmRlZmF1bHQgPSBtYWluO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tbW9uIiwicmVxdWlyZSIsInRzbGliIiwiVGFibGVWaWV3IiwiX3N1cGVyIiwiX19leHRlbmRzIiwiX3RoaXMiLCJhcHBseSIsImFyZ3VtZW50cyIsImhlYWRlckVsUmVmIiwiY3JlYXRlUmVmIiwicHJvdG90eXBlIiwicmVuZGVyU2ltcGxlTGF5b3V0IiwiaGVhZGVyUm93Q29udGVudCIsImJvZHlDb250ZW50IiwiX2EiLCJwcm9wcyIsImNvbnRleHQiLCJzZWN0aW9ucyIsInN0aWNreUhlYWRlckRhdGVzIiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJvcHRpb25zIiwicHVzaCIsInR5cGUiLCJrZXkiLCJpc1N0aWNreSIsImNodW5rIiwiZWxSZWYiLCJ0YWJsZUNsYXNzTmFtZSIsInJvd0NvbnRlbnQiLCJsaXF1aWQiLCJjb250ZW50IiwiY3JlYXRlRWxlbWVudCIsIlZpZXdSb290Iiwidmlld1NwZWMiLCJyb290RWxSZWYiLCJjbGFzc05hbWVzIiwicmVmIiwiY2xhc3NOYW1lIiwiY29uY2F0Iiwiam9pbiIsIlNpbXBsZVNjcm9sbEdyaWQiLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb2xzIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsImNodW5rcyIsInJlbmRlclNjcm9sbFNoaW0iLCJjb2xHcm91cHMiLCJzcGFuIiwibWluV2lkdGgiLCJEYXRlQ29tcG9uZW50Iiwic3BsaXRTZWdzQnlSb3ciLCJzZWdzIiwicm93Q250IiwiYnlSb3ciLCJpIiwiX2kiLCJzZWdzXzEiLCJsZW5ndGgiLCJzZWciLCJyb3ciLCJzcGxpdFNlZ3NCeUZpcnN0Q29sIiwiYnlDb2wiLCJzZWdzXzIiLCJmaXJzdENvbCIsInNwbGl0SW50ZXJhY3Rpb25CeVJvdyIsInVpIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50IiwiVGFibGVDZWxsVG9wIiwicmVuZGVyIiwibmF2TGlua0F0dHJzIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJkYXRlIiwiRGF5Q2VsbENvbnRlbnQiLCJkYXRlUHJvZmlsZSIsInRvZGF5UmFuZ2UiLCJzaG93RGF5TnVtYmVyIiwiZXh0cmFIb29rUHJvcHMiLCJkZWZhdWx0Q29udGVudCIsInJlbmRlclRvcElubmVyIiwiaW5uZXJFbFJlZiIsImlubmVyQ29udGVudCIsImZvcmNlRGF5VG9wIiwiX19hc3NpZ24iLCJpZCIsImRheU51bWJlcklkIiwiRnJhZ21lbnQiLCJCYXNlQ29tcG9uZW50IiwiZGF5TnVtYmVyVGV4dCIsIkRFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQiLCJjcmVhdGVGb3JtYXR0ZXIiLCJob3VyIiwibWludXRlIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsImhhc0xpc3RJdGVtRGlzcGxheSIsImRpc3BsYXkiLCJldmVudFJhbmdlIiwiZGVmIiwiYWxsRGF5IiwibGFzdENvbCIsImlzU3RhcnQiLCJpc0VuZCIsIlRhYmxlQmxvY2tFdmVudCIsIlN0YW5kYXJkRXZlbnQiLCJleHRyYUNsYXNzTmFtZXMiLCJkZWZhdWx0VGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRFbmQiLCJkaXNhYmxlUmVzaXppbmciLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJ0aW1lRm9ybWF0IiwiZXZlbnRUaW1lRm9ybWF0IiwidGltZVRleHQiLCJidWlsZFNlZ1RpbWVUZXh0IiwiRXZlbnRSb290IiwicmVuZGVySW5uZXJDb250ZW50IiwiaXNEcmFnZ2luZyIsImlzUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJpc1NlbGVjdGVkIiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJpc1RvZGF5IiwiZ2V0U2VnQW5jaG9yQXR0cnMiLCJpbm5lclByb3BzIiwic3R5bGUiLCJib3JkZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImV2ZW50IiwidGl0bGUiLCJUYWJsZUNlbGxNb3JlTGluayIsImNvbXBpbGVTZWdzIiwibWVtb2l6ZSIsInNpbmdsZVBsYWNlbWVudHMiLCJhbGxTZWdzIiwiaW52aXNpYmxlU2VncyIsIk1vcmVMaW5rUm9vdCIsImFsbERheURhdGUiLCJtb3JlQ250IiwiaGlkZGVuU2VncyIsImFsaWdubWVudEVsUmVmIiwiYWxpZ25HcmlkVG9wIiwiZXh0cmFEYXRlU3BhbiIsInBvcG92ZXJDb250ZW50IiwiaXNGb3JjZWRJbnZpc2libGUiLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsIm1hcCIsImluc3RhbmNlSWQiLCJpbnN0YW5jZSIsInZpc2liaWxpdHkiLCJldmVudFNlbGVjdGlvbiIsImdldFNlZ01ldGEiLCJoYW5kbGVDbGljayIsImlzRXhwYW5kZWQiLCJwb3BvdmVySWQiLCJjcmVhdGVBcmlhQ2xpY2tBdHRycyIsInNpbmdsZVBsYWNlbWVudHNfMSIsInBsYWNlbWVudCIsImlzVmlzaWJsZSIsIkRFRkFVTFRfV0VFS19OVU1fRk9STUFUIiwid2VlayIsIlRhYmxlQ2VsbCIsInN0YXRlIiwiZ2V0VW5pcXVlRG9tSWQiLCJoYW5kbGVSb290RWwiLCJlbCIsInNldFJlZiIsIkRheUNlbGxSb290IiwiZGF5RWxSZWYiLCJkYXlDbGFzc05hbWVzIiwicm9vdERhdGFBdHRycyIsImlzRGlzYWJsZWQiLCJyb2xlIiwiZXh0cmFEYXRhQXR0cnMiLCJzaG93V2Vla051bWJlciIsIldlZWtOdW1iZXJSb290IiwiZGVmYXVsdEZvcm1hdCIsIndlZWtFbFJlZiIsIndlZWtDbGFzc05hbWVzIiwiZmdDb250ZW50RWxSZWYiLCJmZ0NvbnRlbnQiLCJtYXJnaW5Ub3AiLCJtb3JlTWFyZ2luVG9wIiwiYmdDb250ZW50IiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50IiwiZGF5TWF4RXZlbnRzIiwiZGF5TWF4RXZlbnRSb3dzIiwic3RyaWN0T3JkZXIiLCJldmVudEluc3RhbmNlSGVpZ2h0cyIsIm1heENvbnRlbnRIZWlnaHQiLCJjZWxscyIsImhpZXJhcmNoeSIsIkRheUdyaWRTZWdIaWVyYXJjaHkiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwiaGlkZGVuQ29uc3VtZXMiLCJtYXhTdGFja0NudCIsInNlZ0lucHV0cyIsInVua25vd25IZWlnaHRTZWdzIiwiZXZlbnRIZWlnaHQiLCJpbmRleCIsInRoaWNrbmVzcyIsInN0YXJ0IiwiZW5kIiwiaGlkZGVuRW50cmllcyIsImFkZFNlZ3MiLCJzZWdSZWN0cyIsInRvUmVjdHMiLCJwbGFjZVJlY3RzIiwic2luZ2xlQ29sUGxhY2VtZW50cyIsIm11bHRpQ29sUGxhY2VtZW50cyIsImxlZnRvdmVyTWFyZ2lucyIsIm1vcmVDbnRzIiwibW9yZU1hcmdpblRvcHMiLCJ1bmtub3duSGVpZ2h0U2Vnc18xIiwiaXNBYnNvbHV0ZSIsImFic29sdXRlVG9wIiwiY29sIiwicmVzbGljZVNlZyIsIl9iIiwiaGlkZGVuRW50cmllc18xIiwiaGlkZGVuRW50cnkiLCJoaWRkZW5TcGFuIiwiYWxsUmVjdHMiLCJyZWN0c0J5RWFjaENvbCIsImdyb3VwUmVjdHNCeUVhY2hDb2wiLCJyZWN0cyIsImN1cnJlbnRIZWlnaHQiLCJjdXJyZW50TWFyZ2luVG9wIiwicmVjdHNfMSIsInJlY3QiLCJsZXZlbENvb3JkIiwibXVsdGlQbGFjZW1lbnRzIiwicmVjdHNfMiIsImlzRmlyc3RDb2wiLCJyZWN0c18zIiwic3BhblN0YXJ0Iiwic3BhbkVuZCIsIm9yaWdSYW5nZSIsInJhbmdlIiwic2xpY2VkUmFuZ2UiLCJpbnRlcnNlY3RSYW5nZXMiLCJhZGREYXlzIiwiZHVyYXRpb25FZGl0YWJsZSIsInZhbHVlT2YiLCJmb3JjZUhpZGRlbiIsImNhbGwiLCJlbnRyaWVzQnlMZXZlbCIsImV4Y2x1ZGVIaWRkZW4iLCJlbnRyeSIsImJ1aWxkRW50cnlLZXkiLCJsZXZlbCIsImZpbHRlciIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJpbnNlcnRpb24iLCJ0b3VjaGluZ0VudHJ5IiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRvdWNoaW5nRW50cnlJZCIsInBsYWNlaG9sZGVyRW50cnkiLCJpbnRlcnNlY3RTcGFucyIsInBsYWNlaG9sZGVyRW50cnlJZCIsInNwbGl0RW50cnkiLCJTZWdIaWVyYXJjaHkiLCJUYWJsZVJvdyIsImNlbGxFbFJlZnMiLCJSZWZNYXAiLCJmcmFtZUVsUmVmcyIsImZnRWxSZWZzIiwic2VnSGFybmVzc1JlZnMiLCJmcmFtZVBvc2l0aW9ucyIsImJ1c2luZXNzSG91cnNCeUNvbCIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2Vnc0J5Q29sIiwiYmdFdmVudFNlZ3MiLCJoaWdobGlnaHRTZWdzQnlDb2wiLCJnZXRIaWdobGlnaHRTZWdzIiwibWlycm9yU2Vnc0J5Q29sIiwiZ2V0TWlycm9yU2VncyIsInNvcnRFdmVudFNlZ3MiLCJmZ0V2ZW50U2VncyIsImV2ZW50T3JkZXIiLCJldmVudE9yZGVyU3RyaWN0IiwicmVuZGVySW50cm8iLCJjZWxsIiwibm9ybWFsRmdOb2RlcyIsInJlbmRlckZnU2VncyIsIm1pcnJvckZnTm9kZXMiLCJidWlsZE1pcnJvclBsYWNlbWVudHMiLCJCb29sZWFuIiwic2hvd0RheU51bWJlcnMiLCJzaG93V2Vla051bWJlcnMiLCJyZW5kZXJGaWxsU2VncyIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlU2l6aW5nIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY3VycmVudFByb3BzIiwiaXNQcm9wc0VxdWFsIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJzZWdQbGFjZW1lbnRzIiwiaXNNaXJyb3IiLCJub2RlcyIsInNlZ1BsYWNlbWVudHNfMSIsImxlZnQiLCJyaWdodCIsImlzUnRsIiwibGVmdHMiLCJyaWdodHMiLCJ0b3AiLCJmaWxsVHlwZSIsImxlZnRSaWdodENzcyIsImJ1aWxkRXZlbnRSYW5nZUtleSIsIkJnRXZlbnQiLCJyZW5kZXJGaWxsIiwiX19zcHJlYWRBcnJheSIsImlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UiLCJjbGllbnRXaWR0aCIsImZyYW1lRWxzIiwiY3VycmVudE1hcCIsIm9yaWdpbkVsIiwiY3VycmVudCIsInNldFN0YXRlIiwiUG9zaXRpb25DYWNoZSIsIm9sZEluc3RhbmNlSGVpZ2h0cyIsIm5ld0luc3RhbmNlSGVpZ2h0cyIsInF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMiLCJsaW1pdEJ5Q29udGVudEhlaWdodCIsImNvbXB1dGVNYXhDb250ZW50SGVpZ2h0Iiwic2VnRWxNYXAiLCJoZWlnaHQiLCJNYXRoIiwicm91bmQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzcGxpdCIsIm1heCIsImZpcnN0S2V5IiwiY2VsbEVsIiwiZmNDb250YWluZXJFbCIsImJvdHRvbSIsImdldENlbGxFbHMiLCJlbE1hcCIsImFkZFN0YXRlRXF1YWxpdHkiLCJtaXJyb3JTZWdzIiwiY29sUGxhY2VtZW50cyIsInRvcHNCeUluc3RhbmNlSWQiLCJidWlsZEFic29sdXRlVG9wSGFzaCIsImNvbFBsYWNlbWVudHNfMSIsInBsYWNlbWVudHMiLCJwbGFjZW1lbnRzXzEiLCJUYWJsZSIsInNwbGl0QnVzaW5lc3NIb3VyU2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEZnRXZlbnRTZWdzIiwic3BsaXREYXRlU2VsZWN0aW9uU2VncyIsInNwbGl0RXZlbnREcmFnIiwic3BsaXRFdmVudFJlc2l6ZSIsInJvd1JlZnMiLCJyb290RWwiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiaXNIaXRDb21ib0FsbG93ZWQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJleHBhbmRSb3dzIiwiYnVzaW5lc3NIb3VyU2Vnc0J5Um93IiwiYmdFdmVudFNlZ3NCeVJvdyIsImZnRXZlbnRTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwibGltaXRWaWFCYWxhbmNlZCIsIndpZHRoIiwidGFibGVNaW5XaWR0aCIsIk5vd1RpbWVyIiwidW5pdCIsIm5vd0RhdGUiLCJjbGllbnRIZWlnaHQiLCJjb2xHcm91cE5vZGUiLCJ0b0lTT1N0cmluZyIsInJlbmRlclJvd0ludHJvIiwiaXNTZWdBbGxEYXkiLCJwcmVwYXJlSGl0cyIsInJvd1Bvc2l0aW9ucyIsImNvbGxlY3QiLCJyb3dPYmoiLCJjb2xQb3NpdGlvbnMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4IiwiZGF0ZVNwYW4iLCJnZXRDZWxsUmFuZ2UiLCJkYXlFbCIsImdldENlbGxFbCIsInRvcHMiLCJib3R0b21zIiwibGF5ZXIiLCJEYXlUYWJsZVNsaWNlciIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUmFuZ2UiLCJkYXRlUmFuZ2UiLCJkYXlUYWJsZU1vZGVsIiwiU2xpY2VyIiwiRGF5VGFibGUiLCJzbGljZXIiLCJ0YWJsZVJlZiIsInNsaWNlUHJvcHMiLCJuZXh0RGF5VGhyZXNob2xkIiwiaGVhZGVyQWxpZ25FbFJlZiIsIkRheVRhYmxlVmlldyIsImJ1aWxkRGF5VGFibGVNb2RlbCIsImhlYWRlclJlZiIsImRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaGVhZGVyQ29udGVudCIsImRheUhlYWRlcnMiLCJEYXlIZWFkZXIiLCJkYXRlcyIsImhlYWRlckRhdGVzIiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJjb250ZW50QXJnIiwiYnVzaW5lc3NIb3VycyIsImRhdGVTZWxlY3Rpb24iLCJldmVudFN0b3JlIiwiZXZlbnRVaUJhc2VzIiwidGFibGVDb2xHcm91cE5vZGUiLCJ3ZWVrTnVtYmVycyIsImRheVNlcmllcyIsIkRheVNlcmllc01vZGVsIiwicmVuZGVyUmFuZ2UiLCJEYXlUYWJsZU1vZGVsIiwidGVzdCIsImN1cnJlbnRSYW5nZVVuaXQiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRSZW5kZXJSYW5nZSIsImN1cnJlbnRSYW5nZSIsImlzUmFuZ2VBbGxEYXkiLCJkYXRlRW52IiwiZW5kT2ZXZWVrIiwic3RhcnRPZldlZWsiLCJhZGRXZWVrcyIsIm1vbnRoTW9kZSIsImZpeGVkV2Vla0NvdW50IiwiY2VpbCIsImRpZmZXZWVrcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwibWFpbiIsImNyZWF0ZVBsdWdpbiIsImluaXRpYWxWaWV3Iiwidmlld3MiLCJkYXlHcmlkIiwiY29tcG9uZW50IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsImRheUdyaWREYXkiLCJkdXJhdGlvbiIsImRheXMiLCJkYXlHcmlkV2VlayIsIndlZWtzIiwiZGF5R3JpZE1vbnRoIiwibW9udGhzIiwiRGF5R3JpZFZpZXciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/main.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/main.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\n__webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/react/dist/vdom.cjs.js\");\n\nvar React = __webpack_require__(/*! react */ \"react\");\n\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\n\nvar FullCalendar = function (_super) {\n  tslib.__extends(FullCalendar, _super);\n\n  function FullCalendar() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._calendarApi = new common.CalendarApi();\n    return _this;\n  }\n\n  FullCalendar.prototype.render = function () {\n    return React.createElement(common.CalendarDataProvider, {\n      optionOverrides: this.props,\n      calendarApi: this._calendarApi\n    }, function (data) {\n      return React.createElement(common.CalendarRoot, {\n        options: data.calendarOptions,\n        theme: data.theme,\n        emitter: data.emitter\n      }, function (classNames, height, isHeightAuto, forPrint) {\n        return React.createElement(\"div\", {\n          className: classNames.join(' '),\n          style: {\n            height: height\n          }\n        }, React.createElement(common.CalendarContent, tslib.__assign({\n          isHeightAuto: isHeightAuto,\n          forPrint: forPrint\n        }, data)));\n      });\n    });\n  };\n\n  FullCalendar.prototype.getApi = function () {\n    return this._calendarApi;\n  };\n\n  return FullCalendar;\n}(React.Component);\n\nObject.keys(common).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return common[k];\n    }\n  });\n});\nexports[\"default\"] = FullCalendar;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBRUEsSUFBSUMsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLG9CQUFELENBQW5COztBQUNBQSxtQkFBTyxDQUFDLHdFQUFSOztBQUNBLElBQUlDLEtBQUssR0FBR0QsbUJBQU8sQ0FBQyxvQkFBRCxDQUFuQjs7QUFDQSxJQUFJRSxNQUFNLEdBQUdGLG1CQUFPLENBQUMsNkVBQUQsQ0FBcEI7O0FBRUEsSUFBSUcsWUFBWSxHQUFrQixVQUFVQyxNQUFWLEVBQWtCO0FBQ2hETCxFQUFBQSxLQUFLLENBQUNNLFNBQU4sQ0FBZ0JGLFlBQWhCLEVBQThCQyxNQUE5Qjs7QUFDQSxXQUFTRCxZQUFULEdBQXdCO0FBQ3BCLFFBQUlHLEtBQUssR0FBR0YsTUFBTSxLQUFLLElBQVgsSUFBbUJBLE1BQU0sQ0FBQ0csS0FBUCxDQUFhLElBQWIsRUFBbUJDLFNBQW5CLENBQW5CLElBQW9ELElBQWhFOztBQUNBRixJQUFBQSxLQUFLLENBQUNHLFlBQU4sR0FBcUIsSUFBSVAsTUFBTSxDQUFDUSxXQUFYLEVBQXJCO0FBQ0EsV0FBT0osS0FBUDtBQUNIOztBQUNESCxFQUFBQSxZQUFZLENBQUNRLFNBQWIsQ0FBdUJDLE1BQXZCLEdBQWdDLFlBQVk7QUFDeEMsV0FBUVgsS0FBSyxDQUFDWSxhQUFOLENBQW9CWCxNQUFNLENBQUNZLG9CQUEzQixFQUFpRDtBQUFFQyxNQUFBQSxlQUFlLEVBQUUsS0FBS0MsS0FBeEI7QUFBK0JDLE1BQUFBLFdBQVcsRUFBRSxLQUFLUjtBQUFqRCxLQUFqRCxFQUFrSCxVQUFVUyxJQUFWLEVBQWdCO0FBQUUsYUFBUWpCLEtBQUssQ0FBQ1ksYUFBTixDQUFvQlgsTUFBTSxDQUFDaUIsWUFBM0IsRUFBeUM7QUFBRUMsUUFBQUEsT0FBTyxFQUFFRixJQUFJLENBQUNHLGVBQWhCO0FBQWlDQyxRQUFBQSxLQUFLLEVBQUVKLElBQUksQ0FBQ0ksS0FBN0M7QUFBb0RDLFFBQUFBLE9BQU8sRUFBRUwsSUFBSSxDQUFDSztBQUFsRSxPQUF6QyxFQUFzSCxVQUFVQyxVQUFWLEVBQXNCQyxNQUF0QixFQUE4QkMsWUFBOUIsRUFBNENDLFFBQTVDLEVBQXNEO0FBQUUsZUFBUTFCLEtBQUssQ0FBQ1ksYUFBTixDQUFvQixLQUFwQixFQUEyQjtBQUFFZSxVQUFBQSxTQUFTLEVBQUVKLFVBQVUsQ0FBQ0ssSUFBWCxDQUFnQixHQUFoQixDQUFiO0FBQW1DQyxVQUFBQSxLQUFLLEVBQUU7QUFBRUwsWUFBQUEsTUFBTSxFQUFFQTtBQUFWO0FBQTFDLFNBQTNCLEVBQ3RVeEIsS0FBSyxDQUFDWSxhQUFOLENBQW9CWCxNQUFNLENBQUM2QixlQUEzQixFQUE0Q2hDLEtBQUssQ0FBQ2lDLFFBQU4sQ0FBZTtBQUFFTixVQUFBQSxZQUFZLEVBQUVBLFlBQWhCO0FBQThCQyxVQUFBQSxRQUFRLEVBQUVBO0FBQXhDLFNBQWYsRUFBbUVULElBQW5FLENBQTVDLENBRHNVLENBQVI7QUFDcE0sT0FEc0IsQ0FBUjtBQUNULEtBRDNILENBQVI7QUFFSCxHQUhEOztBQUlBZixFQUFBQSxZQUFZLENBQUNRLFNBQWIsQ0FBdUJzQixNQUF2QixHQUFnQyxZQUFZO0FBQ3hDLFdBQU8sS0FBS3hCLFlBQVo7QUFDSCxHQUZEOztBQUdBLFNBQU9OLFlBQVA7QUFDSCxDQWZpQyxDQWVoQ0YsS0FBSyxDQUFDaUMsU0FmMEIsQ0FBbEM7O0FBaUJBdkMsTUFBTSxDQUFDd0MsSUFBUCxDQUFZakMsTUFBWixFQUFvQmtDLE9BQXBCLENBQTRCLFVBQVVDLENBQVYsRUFBYTtBQUNyQyxNQUFJQSxDQUFDLEtBQUssU0FBVixFQUFxQjFDLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0J3QyxDQUEvQixFQUFrQztBQUNuREMsSUFBQUEsVUFBVSxFQUFFLElBRHVDO0FBRW5EQyxJQUFBQSxHQUFHLEVBQUUsWUFBWTtBQUNiLGFBQU9yQyxNQUFNLENBQUNtQyxDQUFELENBQWI7QUFDSDtBQUprRCxHQUFsQztBQU14QixDQVBEO0FBUUF4QyxrQkFBQSxHQUFrQk0sWUFBbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdWxsY2FsbGVuZGFyLXRlc3QvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uY2pzLmpzP2VhMjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xucmVxdWlyZSgnLi92ZG9tLmNqcycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvbW1vbicpO1xuXG52YXIgRnVsbENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhGdWxsQ2FsZW5kYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVsbENhbGVuZGFyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhbGVuZGFyQXBpID0gbmV3IGNvbW1vbi5DYWxlbmRhckFwaSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1bGxDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tbW9uLkNhbGVuZGFyRGF0YVByb3ZpZGVyLCB7IG9wdGlvbk92ZXJyaWRlczogdGhpcy5wcm9wcywgY2FsZW5kYXJBcGk6IHRoaXMuX2NhbGVuZGFyQXBpIH0sIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChjb21tb24uQ2FsZW5kYXJSb290LCB7IG9wdGlvbnM6IGRhdGEuY2FsZW5kYXJPcHRpb25zLCB0aGVtZTogZGF0YS50aGVtZSwgZW1pdHRlcjogZGF0YS5lbWl0dGVyIH0sIGZ1bmN0aW9uIChjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBoZWlnaHQgfSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChjb21tb24uQ2FsZW5kYXJDb250ZW50LCB0c2xpYi5fX2Fzc2lnbih7IGlzSGVpZ2h0QXV0bzogaXNIZWlnaHRBdXRvLCBmb3JQcmludDogZm9yUHJpbnQgfSwgZGF0YSkpKSk7IH0pKTsgfSkpO1xuICAgIH07XG4gICAgRnVsbENhbGVuZGFyLnByb3RvdHlwZS5nZXRBcGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhckFwaTtcbiAgICB9O1xuICAgIHJldHVybiBGdWxsQ2FsZW5kYXI7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuXG5PYmplY3Qua2V5cyhjb21tb24pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25ba107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gRnVsbENhbGVuZGFyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWIiLCJyZXF1aXJlIiwiUmVhY3QiLCJjb21tb24iLCJGdWxsQ2FsZW5kYXIiLCJfc3VwZXIiLCJfX2V4dGVuZHMiLCJfdGhpcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiX2NhbGVuZGFyQXBpIiwiQ2FsZW5kYXJBcGkiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50IiwiQ2FsZW5kYXJEYXRhUHJvdmlkZXIiLCJvcHRpb25PdmVycmlkZXMiLCJwcm9wcyIsImNhbGVuZGFyQXBpIiwiZGF0YSIsIkNhbGVuZGFyUm9vdCIsIm9wdGlvbnMiLCJjYWxlbmRhck9wdGlvbnMiLCJ0aGVtZSIsImVtaXR0ZXIiLCJjbGFzc05hbWVzIiwiaGVpZ2h0IiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjbGFzc05hbWUiLCJqb2luIiwic3R5bGUiLCJDYWxlbmRhckNvbnRlbnQiLCJfX2Fzc2lnbiIsImdldEFwaSIsIkNvbXBvbmVudCIsImtleXMiLCJmb3JFYWNoIiwiayIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/vdom.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/vdom.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar React = __webpack_require__(/*! react */ \"react\");\n\nvar reactDom = __webpack_require__(/*! react-dom */ \"react-dom\");\n\n(typeof globalThis !== 'undefined' ? globalThis : window).FullCalendarVDom = {\n  Component: React.Component,\n  createElement: React.createElement,\n  render: reactDom.render,\n  createRef: React.createRef,\n  Fragment: React.Fragment,\n  createContext: React.createContext,\n  createPortal: reactDom.createPortal,\n  flushToDom: flushToDom,\n  unmountComponentAtNode: reactDom.unmountComponentAtNode\n};\n\nfunction flushToDom() {// always sync from top-level\n}\n\nexports.flushToDom = flushToDom;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViQSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBRUEsSUFBSUMsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLG9CQUFELENBQW5COztBQUNBLElBQUlDLFFBQVEsR0FBR0QsbUJBQU8sQ0FBQyw0QkFBRCxDQUF0Qjs7QUFFQSxDQUFDLE9BQU9FLFVBQVAsS0FBc0IsV0FBdEIsR0FBb0NBLFVBQXBDLEdBQWlEQyxNQUFsRCxFQUEwREMsZ0JBQTFELEdBQTZFO0FBQ3pFQyxFQUFBQSxTQUFTLEVBQUVOLEtBQUssQ0FBQ00sU0FEd0Q7QUFFekVDLEVBQUFBLGFBQWEsRUFBRVAsS0FBSyxDQUFDTyxhQUZvRDtBQUd6RUMsRUFBQUEsTUFBTSxFQUFFTixRQUFRLENBQUNNLE1BSHdEO0FBSXpFQyxFQUFBQSxTQUFTLEVBQUVULEtBQUssQ0FBQ1MsU0FKd0Q7QUFLekVDLEVBQUFBLFFBQVEsRUFBRVYsS0FBSyxDQUFDVSxRQUx5RDtBQU16RUMsRUFBQUEsYUFBYSxFQUFFWCxLQUFLLENBQUNXLGFBTm9EO0FBT3pFQyxFQUFBQSxZQUFZLEVBQUVWLFFBQVEsQ0FBQ1UsWUFQa0Q7QUFRekVDLEVBQUFBLFVBQVUsRUFBRUEsVUFSNkQ7QUFTekVDLEVBQUFBLHNCQUFzQixFQUFFWixRQUFRLENBQUNZO0FBVHdDLENBQTdFOztBQVdBLFNBQVNELFVBQVQsR0FBc0IsQ0FDbEI7QUFDSDs7QUFFRGYsa0JBQUEsR0FBcUJlLFVBQXJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVsbGNhbGxlbmRhci10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC92ZG9tLmNqcy5qcz81OTc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG4odHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHdpbmRvdykuRnVsbENhbGVuZGFyVkRvbSA9IHtcbiAgICBDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudCxcbiAgICBjcmVhdGVFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgIHJlbmRlcjogcmVhY3REb20ucmVuZGVyLFxuICAgIGNyZWF0ZVJlZjogUmVhY3QuY3JlYXRlUmVmLFxuICAgIEZyYWdtZW50OiBSZWFjdC5GcmFnbWVudCxcbiAgICBjcmVhdGVDb250ZXh0OiBSZWFjdC5jcmVhdGVDb250ZXh0LFxuICAgIGNyZWF0ZVBvcnRhbDogcmVhY3REb20uY3JlYXRlUG9ydGFsLFxuICAgIGZsdXNoVG9Eb206IGZsdXNoVG9Eb20sXG4gICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogcmVhY3REb20udW5tb3VudENvbXBvbmVudEF0Tm9kZVxufTtcbmZ1bmN0aW9uIGZsdXNoVG9Eb20oKSB7XG4gICAgLy8gYWx3YXlzIHN5bmMgZnJvbSB0b3AtbGV2ZWxcbn1cblxuZXhwb3J0cy5mbHVzaFRvRG9tID0gZmx1c2hUb0RvbTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlYWN0IiwicmVxdWlyZSIsInJlYWN0RG9tIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsIkZ1bGxDYWxlbmRhclZEb20iLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hUb0RvbSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/vdom.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/timegrid/main.cjs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.cjs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\nvar daygrid = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.cjs.js\");\n\n;\n\nvar AllDaySplitter = function (_super) {\n  tslib.__extends(AllDaySplitter, _super);\n\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    }\n\n    return ['timed'];\n  };\n\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    }\n\n    if (common.hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    }\n\n    return ['allDay'];\n  };\n\n  return AllDaySplitter;\n}(common.Splitter);\n\nvar DEFAULT_SLAT_LABEL_FORMAT = common.createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\n\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return common.createElement(common.ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return common.createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    }\n\n    var dateEnv = context.dateEnv,\n        options = context.options,\n        viewApi = context.viewApi;\n    var labelFormat = // TODO: fully pre-parse\n    options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? common.createFormatter(options.slotLabelFormat[0]) : common.createFormatter(options.slotLabelFormat);\n    var hookProps = {\n      level: 0,\n      time: props.time,\n      date: dateEnv.toDate(props.date),\n      view: viewApi,\n      text: dateEnv.format(props.date, labelFormat)\n    };\n    return common.createElement(common.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLabelClassNames,\n      content: options.slotLabelContent,\n      defaultContent: renderInnerContent,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return common.createElement(\"td\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-time\": props.isoTimeStr\n      }, common.createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n      }, common.createElement(\"div\", {\n        className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n        ref: innerElRef\n      }, innerContent)));\n    });\n  });\n}\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nvar TimeBodyAxis = function (_super) {\n  tslib.__extends(TimeBodyAxis, _super);\n\n  function TimeBodyAxis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeBodyAxis.prototype.render = function () {\n    return this.props.slatMetas.map(function (slatMeta) {\n      return common.createElement(\"tr\", {\n        key: slatMeta.key\n      }, common.createElement(TimeColsAxisCell, tslib.__assign({}, slatMeta)));\n    });\n  };\n\n  return TimeBodyAxis;\n}(common.BaseComponent);\n\nvar DEFAULT_WEEK_NUM_FORMAT = common.createFormatter({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n\nvar TimeColsView = function (_super) {\n  tslib.__extends(TimeColsView, _super);\n\n  function TimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n\n    _this.headerElRef = common.createRef();\n    _this.rootElRef = common.createRef();\n    _this.scrollerElRef = common.createRef();\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n\n\n    _this.renderHeadAxis = function (rowKey, frameHeight) {\n      if (frameHeight === void 0) {\n        frameHeight = '';\n      }\n\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = common.diffDays(range.start, range.end);\n      var navLinkAttrs = dayCnt === 1 ? common.buildNavLinkAttrs(_this.context, range.start, 'week') : {};\n\n      if (options.weekNumbers && rowKey === 'day') {\n        return common.createElement(common.WeekNumberRoot, {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return common.createElement(\"th\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, common.createElement(\"div\", {\n            className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n            style: {\n              height: frameHeight\n            }\n          }, common.createElement(\"a\", tslib.__assign({\n            ref: innerElRef,\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n          }, navLinkAttrs), innerContent)));\n        });\n      }\n\n      return common.createElement(\"th\", {\n        \"aria-hidden\": true,\n        className: \"fc-timegrid-axis\"\n      }, common.createElement(\"div\", {\n        className: \"fc-timegrid-axis-frame\",\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n\n\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _a = _this.context,\n          options = _a.options,\n          viewApi = _a.viewApi;\n      var hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (// TODO: make reusable hook. used in list view too\n        common.createElement(common.RenderHook, {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return common.createElement(\"td\", {\n            ref: rootElRef,\n            \"aria-hidden\": true,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, common.createElement(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n            style: {\n              height: rowHeight\n            }\n          }, common.createElement(\"span\", {\n            className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n            ref: innerElRef\n          }, innerContent)));\n        })\n      );\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n\n    return _this;\n  } // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n\n  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var sections = [];\n    var stickyHeaderDates = common.getStickyHeaderDates(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        common.createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, common.createElement(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return common.createElement(common.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return common.createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, common.createElement(common.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n    var _this = this;\n\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    var stickyHeaderDates = !props.forPrint && common.getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && common.getStickyFooterScrollbar(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function (arg) {\n            return common.createElement(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderHeadAxis('day', arg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function (contentArg) {\n            return common.createElement(\"tr\", {\n              role: \"presentation\"\n            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: // TODO: rename to cellContent so don't need to define <tr>?\n        common.createElement(\"tr\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-section\"\n        }, common.createElement(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n\n    var isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: function (arg) {\n          return (// TODO: make this now-indicator arrow more DRY with TimeColsContent\n            common.createElement(\"div\", {\n              className: \"fc-timegrid-axis-chunk\"\n            }, common.createElement(\"table\", {\n              \"aria-hidden\": true,\n              style: {\n                height: arg.expandRows ? arg.clientHeight : ''\n              }\n            }, arg.tableColGroupNode, common.createElement(\"tbody\", null, common.createElement(TimeBodyAxis, {\n              slatMetas: slatMetas\n            }))), common.createElement(\"div\", {\n              className: \"fc-timegrid-now-indicator-container\"\n            }, common.createElement(common.NowTimer, {\n              unit: isNowIndicator ? 'minute' : 'day'\n              /* hacky */\n\n            }, function (nowDate) {\n              var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n\n              if (typeof nowIndicatorTop === 'number') {\n                return common.createElement(common.NowIndicatorRoot, {\n                  isAxis: true,\n                  date: nowDate\n                }, function (rootElRef, classNames, innerElRef, innerContent) {\n                  return common.createElement(\"div\", {\n                    ref: rootElRef,\n                    className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n                    style: {\n                      top: nowIndicatorTop\n                    }\n                  }, innerContent);\n                });\n              }\n\n              return null;\n            })))\n          );\n        }\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: common.renderScrollShim\n        }, {\n          key: 'cols',\n          content: common.renderScrollShim\n        }]\n      });\n    }\n\n    return common.createElement(common.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return common.createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, common.createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeColsView.prototype.getAllDayMaxEventProps = function () {\n    var _a = this.context.options,\n        dayMaxEvents = _a.dayMaxEvents,\n        dayMaxEventRows = _a.dayMaxEventRows;\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n\n    return {\n      dayMaxEvents: dayMaxEvents,\n      dayMaxEventRows: dayMaxEventRows\n    };\n  };\n\n  return TimeColsView;\n}(common.DateComponent);\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\n\nvar TimeColsSlatsCoords = function () {\n  function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slotDuration = slotDuration;\n  }\n\n  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n    var dateProfile = this.dateProfile;\n\n    if (common.rangeContainsMarker(dateProfile.currentRange, date)) {\n      var startOfDayDate = common.startOfDay(date);\n      var timeMs = date.valueOf() - startOfDayDate.valueOf();\n\n      if (timeMs >= common.asRoughMs(dateProfile.slotMinTime) && timeMs < common.asRoughMs(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(common.createDuration(timeMs));\n      }\n    }\n\n    return null;\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\n\n  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = common.startOfDay(when);\n    }\n\n    return this.computeTimeTop(common.createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n\n\n  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n    var _a = this,\n        positions = _a.positions,\n        dateProfile = _a.dateProfile;\n\n    var len = positions.els.length; // floating-point value of # of slots covered\n\n    var slatCoverage = (duration.milliseconds - common.asRoughMs(dateProfile.slotMinTime)) / common.asRoughMs(this.slotDuration);\n    var slatIndex;\n    var slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  };\n\n  return TimeColsSlatsCoords;\n}();\n\nvar TimeColsSlatsBody = function (_super) {\n  tslib.__extends(TimeColsSlatsBody, _super);\n\n  function TimeColsSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColsSlatsBody.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var slatElRefs = props.slatElRefs;\n    return common.createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n      var hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return common.createElement(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && common.createElement(TimeColsAxisCell, tslib.__assign({}, slatMeta)), common.createElement(common.RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return common.createElement(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": slatMeta.isoTimeStr\n        }, innerContent);\n      }));\n    }));\n  };\n\n  return TimeColsSlatsBody;\n}(common.BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\n\nvar TimeColsSlats = function (_super) {\n  tslib.__extends(TimeColsSlats, _super);\n\n  function TimeColsSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = common.createRef();\n    _this.slatElRefs = new common.RefMap();\n    return _this;\n  }\n\n  TimeColsSlats.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return common.createElement(\"div\", {\n      ref: this.rootElRef,\n      className: \"fc-timegrid-slots\"\n    }, common.createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode\n    /* relies on there only being a single <col> for the axis */\n    , common.createElement(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  };\n\n  TimeColsSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentDidUpdate = function () {\n    this.updateSizing();\n  };\n\n  TimeColsSlats.prototype.componentWillUnmount = function () {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n\n  TimeColsSlats.prototype.updateSizing = function () {\n    var _a = this,\n        context = _a.context,\n        props = _a.props;\n\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      var rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new common.PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n      }\n    }\n  };\n\n  return TimeColsSlats;\n}(common.BaseComponent);\n\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n\n  for (i = 0; i < colCnt; i += 1) {\n    segsByCol.push([]);\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i += 1) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n\n  return segsByCol;\n}\n\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < colCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TimeColMoreLink = function (_super) {\n  tslib.__extends(TimeColMoreLink, _super);\n\n  function TimeColMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = common.createRef();\n    return _this;\n  }\n\n  TimeColMoreLink.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    return common.createElement(common.MoreLinkRoot, {\n      allDayDate: null,\n      moreCnt: props.hiddenSegs.length,\n      allSegs: props.hiddenSegs,\n      hiddenSegs: props.hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      defaultContent: renderMoreLinkInner,\n      extraDateSpan: props.extraDateSpan,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      popoverContent: function () {\n        return renderPlainFgSegs(props.hiddenSegs, props);\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return common.createElement(\"a\", {\n        ref: function (el) {\n          common.setRef(rootElRef, el);\n          common.setRef(_this.rootElRef, el);\n        },\n        className: ['fc-timegrid-more-link'].concat(classNames).join(' '),\n        style: {\n          top: props.top,\n          bottom: props.bottom\n        },\n        onClick: handleClick,\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, common.createElement(\"div\", {\n        ref: innerElRef,\n        className: \"fc-timegrid-more-link-inner fc-sticky\"\n      }, innerContent));\n    });\n  };\n\n  return TimeColMoreLink;\n}(common.BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.shortText;\n} // segInputs assumed sorted\n\n\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n  var hierarchy = new common.SegHierarchy();\n\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenGroups = common.groupIntersectingEntries(hiddenEntries);\n  var web = buildWeb(hierarchy);\n  web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n\n  var segRects = webToRects(web);\n  return {\n    segRects: segRects,\n    hiddenGroups: hiddenGroups\n  };\n}\n\nfunction buildWeb(hierarchy) {\n  var entriesByLevel = hierarchy.entriesByLevel;\n  var buildNode = cacheable(function (level, lateral) {\n    return level + ':' + lateral;\n  }, function (level, lateral) {\n    var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n    var nextLevelRes = buildNodes(siblingRange, buildNode);\n    var entry = entriesByLevel[level][lateral];\n    return [tslib.__assign(tslib.__assign({}, entry), {\n      nextLevelNodes: nextLevelRes[0]\n    }), entry.thickness + nextLevelRes[1] // the pressure builds\n    ];\n  });\n  return buildNodes(entriesByLevel.length ? {\n    level: 0,\n    lateralStart: 0,\n    lateralEnd: entriesByLevel[0].length\n  } : null, buildNode)[0];\n}\n\nfunction buildNodes(siblingRange, buildNode) {\n  if (!siblingRange) {\n    return [[], 0];\n  }\n\n  var level = siblingRange.level,\n      lateralStart = siblingRange.lateralStart,\n      lateralEnd = siblingRange.lateralEnd;\n  var lateral = lateralStart;\n  var pairs = [];\n\n  while (lateral < lateralEnd) {\n    pairs.push(buildNode(level, lateral));\n    lateral += 1;\n  }\n\n  pairs.sort(cmpDescPressures);\n  return [pairs.map(extractNode), pairs[0][1] // first item's pressure\n  ];\n}\n\nfunction cmpDescPressures(a, b) {\n  return b[1] - a[1];\n}\n\nfunction extractNode(a) {\n  return a[0];\n}\n\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n  var levelCoords = hierarchy.levelCoords,\n      entriesByLevel = hierarchy.entriesByLevel;\n  var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n  var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n  var levelCnt = levelCoords.length;\n  var level = subjectLevel; // skip past levels that are too high up\n\n  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n\n\n  for (; level < levelCnt; level += 1) {\n    var entries = entriesByLevel[level];\n    var entry = void 0;\n    var searchIndex = common.binarySearch(entries, subjectEntry.span.start, common.getEntrySpanEnd);\n    var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n\n    var lateralEnd = lateralStart;\n\n    while ( // loop through entries that horizontally intersect\n    (entry = entries[lateralEnd]) && // but not past the whole seg list\n    entry.span.start < subjectEntry.span.end) {\n      lateralEnd += 1;\n    }\n\n    if (lateralStart < lateralEnd) {\n      return {\n        level: level,\n        lateralStart: lateralStart,\n        lateralEnd: lateralEnd\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction stretchWeb(topLevelNodes, totalThickness) {\n  var stretchNode = cacheable(function (node, startCoord, prevThickness) {\n    return common.buildEntryKey(node);\n  }, function (node, startCoord, prevThickness) {\n    var nextLevelNodes = node.nextLevelNodes,\n        thickness = node.thickness;\n    var allThickness = thickness + prevThickness;\n    var thicknessFraction = thickness / allThickness;\n    var endCoord;\n    var newChildren = [];\n\n    if (!nextLevelNodes.length) {\n      endCoord = totalThickness;\n    } else {\n      for (var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++) {\n        var childNode = nextLevelNodes_1[_i];\n\n        if (endCoord === undefined) {\n          var res = stretchNode(childNode, startCoord, allThickness);\n          endCoord = res[0];\n          newChildren.push(res[1]);\n        } else {\n          var res = stretchNode(childNode, endCoord, 0);\n          newChildren.push(res[1]);\n        }\n      }\n    }\n\n    var newThickness = (endCoord - startCoord) * thicknessFraction;\n    return [endCoord - newThickness, tslib.__assign(tslib.__assign({}, node), {\n      thickness: newThickness,\n      nextLevelNodes: newChildren\n    })];\n  });\n  return topLevelNodes.map(function (node) {\n    return stretchNode(node, 0, 0)[1];\n  });\n} // not sorted in any particular order\n\n\nfunction webToRects(topLevelNodes) {\n  var rects = [];\n  var processNode = cacheable(function (node, levelCoord, stackDepth) {\n    return common.buildEntryKey(node);\n  }, function (node, levelCoord, stackDepth) {\n    var rect = tslib.__assign(tslib.__assign({}, node), {\n      levelCoord: levelCoord,\n      stackDepth: stackDepth,\n      stackForward: 0\n    });\n\n    rects.push(rect);\n    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n  });\n\n  function processNodes(nodes, levelCoord, stackDepth) {\n    var stackForward = 0;\n\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n      var node = nodes_1[_i];\n      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n    }\n\n    return stackForward;\n  }\n\n  processNodes(topLevelNodes, 0, 0);\n  return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n} // TODO: move to general util\n\n\nfunction cacheable(keyFunc, workFunc) {\n  var cache = {};\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var key = keyFunc.apply(void 0, args);\n    return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);\n  };\n}\n\nfunction computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {\n  if (slatCoords === void 0) {\n    slatCoords = null;\n  }\n\n  if (eventMinHeight === void 0) {\n    eventMinHeight = 0;\n  }\n\n  var vcoords = [];\n\n  if (slatCoords) {\n    for (var i = 0; i < segs.length; i += 1) {\n      var seg = segs[i];\n      var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n      var spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(\n      slatCoords.computeDateTop(seg.end, colDate));\n      vcoords.push({\n        start: Math.round(spanStart),\n        end: Math.round(spanEnd) //\n\n      });\n    }\n  }\n\n  return vcoords;\n}\n\nfunction computeFgSegPlacements(segs, segVCoords, // might not have for every seg\neventOrderStrict, eventMaxStack) {\n  var segInputs = [];\n  var dumbSegs = []; // segs without coords\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var vcoords = segVCoords[i];\n\n    if (vcoords) {\n      segInputs.push({\n        index: i,\n        thickness: 1,\n        span: vcoords\n      });\n    } else {\n      dumbSegs.push(segs[i]);\n    }\n  }\n\n  var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack),\n      segRects = _a.segRects,\n      hiddenGroups = _a.hiddenGroups;\n\n  var segPlacements = [];\n\n  for (var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++) {\n    var segRect = segRects_1[_i];\n    segPlacements.push({\n      seg: segs[segRect.index],\n      rect: segRect\n    });\n  }\n\n  for (var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++) {\n    var dumbSeg = dumbSegs_1[_b];\n    segPlacements.push({\n      seg: dumbSeg,\n      rect: null\n    });\n  }\n\n  return {\n    segPlacements: segPlacements,\n    hiddenGroups: hiddenGroups\n  };\n}\n\nvar DEFAULT_TIME_FORMAT = common.createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\n\nvar TimeColEvent = function (_super) {\n  tslib.__extends(TimeColEvent, _super);\n\n  function TimeColEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColEvent.prototype.render = function () {\n    var classNames = ['fc-timegrid-event', 'fc-v-event'];\n\n    if (this.props.isShort) {\n      classNames.push('fc-timegrid-event-short');\n    }\n\n    return common.createElement(common.StandardEvent, tslib.__assign({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  };\n\n  return TimeColEvent;\n}(common.BaseComponent);\n\nvar TimeColMisc = function (_super) {\n  tslib.__extends(TimeColMisc, _super);\n\n  function TimeColMisc() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeColMisc.prototype.render = function () {\n    var props = this.props;\n    return common.createElement(common.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (innerElRef, innerContent) {\n      return innerContent && common.createElement(\"div\", {\n        className: \"fc-timegrid-col-misc\",\n        ref: innerElRef\n      }, innerContent);\n    });\n  };\n\n  return TimeColMisc;\n}(common.BaseComponent);\n\nvar TimeCol = function (_super) {\n  tslib.__extends(TimeCol, _super);\n\n  function TimeCol() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.sortEventSegs = common.memoize(common.sortEventSegs);\n    return _this;\n  } // TODO: memoize event-placement?\n\n\n  TimeCol.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var isSelectMirror = context.options.selectMirror;\n    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    var interactionAffectedInstances = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n    return common.createElement(common.DayCellRoot, {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (rootElRef, classNames, dataAttrs) {\n      return common.createElement(\"td\", tslib.__assign({\n        ref: rootElRef,\n        role: \"gridcell\",\n        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, dataAttrs, props.extraDataAttrs), common.createElement(\"div\", {\n        className: \"fc-timegrid-col-frame\"\n      }, common.createElement(\"div\", {\n        className: \"fc-timegrid-col-bg\"\n      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), common.createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), common.createElement(\"div\", {\n        className: \"fc-timegrid-col-events\"\n      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), common.createElement(\"div\", {\n        className: \"fc-timegrid-now-indicator-container\"\n      }, _this.renderNowIndicator(props.nowIndicatorSegs)), common.createElement(TimeColMisc, {\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      })));\n    });\n  };\n\n  TimeCol.prototype.renderFgSegs = function (sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var props = this.props;\n\n    if (props.forPrint) {\n      return renderPlainFgSegs(sortedFgSegs, props);\n    }\n\n    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n  };\n\n  TimeCol.prototype.renderPositionedFgSegs = function (segs, // if not mirror, needs to be sorted\n  segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var _this = this;\n\n    var _a = this.context.options,\n        eventMaxStack = _a.eventMaxStack,\n        eventShortHeight = _a.eventShortHeight,\n        eventOrderStrict = _a.eventOrderStrict,\n        eventMinHeight = _a.eventMinHeight;\n    var _b = this.props,\n        date = _b.date,\n        slatCoords = _b.slatCoords,\n        eventSelection = _b.eventSelection,\n        todayRange = _b.todayRange,\n        nowDate = _b.nowDate;\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n\n    var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack),\n        segPlacements = _c.segPlacements,\n        hiddenGroups = _c.hiddenGroups;\n\n    return common.createElement(common.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function (segPlacement) {\n      var seg = segPlacement.seg,\n          rect = segPlacement.rect;\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n      var vStyle = computeSegVStyle(rect && rect.span);\n      var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {\n        left: 0,\n        right: 0\n      };\n      var isInset = Boolean(rect) && rect.stackForward > 0;\n      var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n\n      return common.createElement(\"div\", {\n        className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: tslib.__assign(tslib.__assign({\n          visibility: isVisible ? '' : 'hidden'\n        }, vStyle), hStyle)\n      }, common.createElement(TimeColEvent, tslib.__assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === eventSelection,\n        isShort: isShort\n      }, common.getSegMeta(seg, todayRange, nowDate))));\n    }));\n  }; // will already have eventMinHeight applied because segInputs already had it\n\n\n  TimeCol.prototype.renderHiddenGroups = function (hiddenGroups, segs) {\n    var _a = this.props,\n        extraDateSpan = _a.extraDateSpan,\n        dateProfile = _a.dateProfile,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate,\n        eventSelection = _a.eventSelection,\n        eventDrag = _a.eventDrag,\n        eventResize = _a.eventResize;\n    return common.createElement(common.Fragment, null, hiddenGroups.map(function (hiddenGroup) {\n      var positionCss = computeSegVStyle(hiddenGroup.span);\n      var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n      return common.createElement(TimeColMoreLink, {\n        key: common.buildIsoString(common.computeEarliestSegStart(hiddenSegs)),\n        hiddenSegs: hiddenSegs,\n        top: positionCss.top,\n        bottom: positionCss.bottom,\n        extraDateSpan: extraDateSpan,\n        dateProfile: dateProfile,\n        todayRange: todayRange,\n        nowDate: nowDate,\n        eventSelection: eventSelection,\n        eventDrag: eventDrag,\n        eventResize: eventResize\n      });\n    }));\n  };\n\n  TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n\n    var children = segVCoords.map(function (vcoords, i) {\n      var seg = segs[i];\n      return common.createElement(\"div\", {\n        key: common.buildEventRangeKey(seg.eventRange),\n        className: \"fc-timegrid-bg-harness\",\n        style: computeSegVStyle(vcoords)\n      }, fillType === 'bg-event' ? common.createElement(common.BgEvent, tslib.__assign({\n        seg: seg\n      }, common.getSegMeta(seg, props.todayRange, props.nowDate))) : common.renderFill(fillType));\n    });\n    return common.createElement(common.Fragment, null, children);\n  };\n\n  TimeCol.prototype.renderNowIndicator = function (segs) {\n    var _a = this.props,\n        slatCoords = _a.slatCoords,\n        date = _a.date;\n\n    if (!slatCoords) {\n      return null;\n    }\n\n    return segs.map(function (seg, i) {\n      return common.createElement(common.NowIndicatorRoot, {\n        isAxis: false,\n        date: date,\n        // key doesn't matter. will only ever be one\n        key: i\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return common.createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n          style: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          }\n        }, innerContent);\n      });\n    });\n  };\n\n  TimeCol.prototype.computeSegHStyle = function (segHCoords) {\n    var _a = this.context,\n        isRtl = _a.isRtl,\n        options = _a.options;\n    var shouldOverlap = options.slotEventOverlap;\n    var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n\n    var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n\n    var left; // amount of space from left edge, a fraction of the total width\n\n    var right; // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n    }\n\n    if (isRtl) {\n      left = 1 - farCoord;\n      right = nearCoord;\n    } else {\n      left = nearCoord;\n      right = 1 - farCoord;\n    }\n\n    var props = {\n      zIndex: segHCoords.stackDepth + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n\n    if (shouldOverlap && !segHCoords.stackForward) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return props;\n  };\n\n  return TimeCol;\n}(common.BaseComponent);\n\nfunction renderPlainFgSegs(sortedFgSegs, _a) {\n  var todayRange = _a.todayRange,\n      nowDate = _a.nowDate,\n      eventSelection = _a.eventSelection,\n      eventDrag = _a.eventDrag,\n      eventResize = _a.eventResize;\n  var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n  return common.createElement(common.Fragment, null, sortedFgSegs.map(function (seg) {\n    var instanceId = seg.eventRange.instance.instanceId;\n    return common.createElement(\"div\", {\n      key: instanceId,\n      style: {\n        visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n      }\n    }, common.createElement(TimeColEvent, tslib.__assign({\n      seg: seg,\n      isDragging: false,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: instanceId === eventSelection,\n      isShort: false\n    }, common.getSegMeta(seg, todayRange, nowDate))));\n  }));\n}\n\nfunction computeSegVStyle(segVCoords) {\n  if (!segVCoords) {\n    return {\n      top: '',\n      bottom: ''\n    };\n  }\n\n  return {\n    top: segVCoords.start,\n    bottom: -segVCoords.end\n  };\n}\n\nfunction compileSegsFromEntries(segEntries, allSegs) {\n  return segEntries.map(function (segEntry) {\n    return allSegs[segEntry.index];\n  });\n}\n\nvar TimeColsContent = function (_super) {\n  tslib.__extends(TimeColsContent, _super);\n\n  function TimeColsContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitFgEventSegs = common.memoize(splitSegsByCol);\n    _this.splitBgEventSegs = common.memoize(splitSegsByCol);\n    _this.splitBusinessHourSegs = common.memoize(splitSegsByCol);\n    _this.splitNowIndicatorSegs = common.memoize(splitSegsByCol);\n    _this.splitDateSelectionSegs = common.memoize(splitSegsByCol);\n    _this.splitEventDrag = common.memoize(splitInteractionByCol);\n    _this.splitEventResize = common.memoize(splitInteractionByCol);\n    _this.rootElRef = common.createRef();\n    _this.cellElRefs = new common.RefMap();\n    return _this;\n  }\n\n  TimeColsContent.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n\n    var colCnt = props.cells.length;\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return common.createElement(\"div\", {\n      className: \"fc-timegrid-cols\",\n      ref: this.rootElRef\n    }, common.createElement(\"table\", {\n      role: \"presentation\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, common.createElement(\"tbody\", {\n      role: \"presentation\"\n    }, common.createElement(\"tr\", {\n      role: \"row\"\n    }, props.axis && common.createElement(\"td\", {\n      \"aria-hidden\": true,\n      className: \"fc-timegrid-col fc-timegrid-axis\"\n    }, common.createElement(\"div\", {\n      className: \"fc-timegrid-col-frame\"\n    }, common.createElement(\"div\", {\n      className: \"fc-timegrid-now-indicator-container\"\n    }, typeof nowIndicatorTop === 'number' && common.createElement(common.NowIndicatorRoot, {\n      isAxis: true,\n      date: props.nowDate\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return common.createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n        style: {\n          top: nowIndicatorTop\n        }\n      }, innerContent);\n    })))), props.cells.map(function (cell, i) {\n      return common.createElement(TimeCol, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        fgEventSegs: fgEventSegsByRow[i],\n        bgEventSegs: bgEventSegsByRow[i],\n        businessHourSegs: businessHourSegsByRow[i],\n        nowIndicatorSegs: nowIndicatorSegsByRow[i],\n        dateSelectionSegs: dateSelectionSegsByRow[i],\n        eventDrag: eventDragByRow[i],\n        eventResize: eventResizeByRow[i],\n        slatCoords: props.slatCoords,\n        eventSelection: props.eventSelection,\n        forPrint: props.forPrint\n      });\n    })))));\n  };\n\n  TimeColsContent.prototype.componentDidMount = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.componentDidUpdate = function () {\n    this.updateCoords();\n  };\n\n  TimeColsContent.prototype.updateCoords = function () {\n    var props = this.props;\n\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new common.PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n      false));\n    }\n  };\n\n  return TimeColsContent;\n}(common.BaseComponent);\n\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nvar TimeCols = function (_super) {\n  tslib.__extends(TimeCols, _super);\n\n  function TimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processSlotOptions = common.memoize(processSlotOptions);\n    _this.state = {\n      slatCoords: null\n    };\n\n    _this.handleRootEl = function (el) {\n      if (el) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: el,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    _this.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this.props.onScrollTopRequest;\n      var slatCoords = _this.state.slatCoords;\n\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top_1 = slatCoords.computeTimeTop(request.time);\n          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n\n          if (top_1) {\n            top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n          }\n\n          onScrollTopRequest(top_1);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.handleColCoords = function (colCoords) {\n      _this.colCoords = colCoords;\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(slatCoords);\n      }\n    };\n\n    return _this;\n  }\n\n  TimeCols.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return common.createElement(\"div\", {\n      className: \"fc-timegrid-body\",\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, common.createElement(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null\n      /* axis depends on the colgroup's shrinking */\n      ,\n      onCoords: this.handleSlatCoords\n    }), common.createElement(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  };\n\n  TimeCols.prototype.componentDidMount = function () {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n\n  TimeCols.prototype.componentDidUpdate = function (prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n\n  TimeCols.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n  };\n\n  TimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var colCoords = this.colCoords;\n    var dateProfile = this.props.dateProfile;\n    var slatCoords = this.state.slatCoords;\n\n    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n        snapDuration = _b.snapDuration,\n        snapsPerSlot = _b.snapsPerSlot;\n\n    var colIndex = colCoords.leftToIndex(positionLeft);\n    var slatIndex = slatCoords.positions.topToIndex(positionTop);\n\n    if (colIndex != null && slatIndex != null) {\n      var cell = this.props.cells[colIndex];\n      var slatTop = slatCoords.positions.tops[slatIndex];\n      var slatHeight = slatCoords.positions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = common.addDurations(dateProfile.slotMinTime, common.multiplyDuration(snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, snapDuration);\n      return {\n        dateProfile: dateProfile,\n        dateSpan: tslib.__assign({\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        }, cell.extraDateSpan),\n        dayEl: colCoords.els[colIndex],\n        rect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return TimeCols;\n}(common.DateComponent);\n\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = common.wholeDivideDurations(slotDuration, snapDuration);\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1; // TODO: say warning?\n  }\n\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\n\nvar DayTimeColsSlicer = function (_super) {\n  tslib.__extends(DayTimeColsSlicer, _super);\n\n  function DayTimeColsSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n\n    for (var col = 0; col < dayRanges.length; col += 1) {\n      var segRange = common.intersectRanges(range, dayRanges[col]);\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTimeColsSlicer;\n}(common.Slicer);\n\nvar DayTimeCols = function (_super) {\n  tslib.__extends(DayTimeCols, _super);\n\n  function DayTimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayRanges = common.memoize(buildDayRanges);\n    _this.slicer = new DayTimeColsSlicer();\n    _this.timeColsRef = common.createRef();\n    return _this;\n  }\n\n  DayTimeCols.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateProfile = props.dateProfile,\n        dayTableModel = props.dayTableModel;\n    var isNowIndicator = context.options.nowIndicator;\n    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv); // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n\n    return common.createElement(common.NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, function (nowDate, todayRange) {\n      return common.createElement(TimeCols, tslib.__assign({\n        ref: _this.timeColsRef\n      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n        forPrint: props.forPrint,\n        axis: props.axis,\n        dateProfile: dateProfile,\n        slatMetas: props.slatMetas,\n        slotDuration: props.slotDuration,\n        cells: dayTableModel.cells[0],\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        expandRows: props.expandRows,\n        nowDate: nowDate,\n        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n        todayRange: todayRange,\n        onScrollTopRequest: props.onScrollTopRequest,\n        onSlatCoords: props.onSlatCoords\n      }));\n    });\n  };\n\n  return DayTimeCols;\n}(common.DateComponent);\n\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n\n  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n\n  return ranges;\n} // potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n\n\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = common.createDuration(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n\n  while (common.asRoughMs(slatTime) < common.asRoughMs(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = common.wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: common.formatIsoTimeString(date),\n      isLabeled: isLabeled\n    });\n    slatTime = common.addDurations(slatTime, slotDuration);\n    slatIterator = common.addDurations(slatIterator, slotDuration);\n  }\n\n  return metas;\n} // Computes an automatic value for slotLabelInterval\n\n\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n    labelInterval = common.createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = common.wholeDivideDurations(labelInterval, slotDuration);\n\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n\n  return slotDuration; // fall back\n}\n\nvar DayTimeColsView = function (_super) {\n  tslib.__extends(DayTimeColsView, _super);\n\n  function DayTimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildTimeColsModel = common.memoize(buildTimeColsModel);\n    _this.buildSlatMetas = common.memoize(buildSlatMetas);\n    return _this;\n  }\n\n  DayTimeColsView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dateProfile = props.dateProfile;\n    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    var splitProps = this.allDaySplitter.splitProps(props);\n    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    var dayMinWidth = options.dayMinWidth;\n    var hasAttachedAxis = !dayMinWidth;\n    var hasDetachedAxis = dayMinWidth;\n    var headerContent = options.dayHeaders && common.createElement(common.DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n\n    var allDayContent = options.allDaySlot !== false && function (contentArg) {\n      return common.createElement(daygrid.DayTable, tslib.__assign({}, splitProps.allDay, {\n        dateProfile: dateProfile,\n        dayTableModel: dayTableModel,\n        nextDayThreshold: options.nextDayThreshold,\n        tableMinWidth: contentArg.tableMinWidth,\n        colGroupNode: contentArg.tableColGroupNode,\n        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n        showWeekNumbers: false,\n        expandRows: false,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      }, _this.getAllDayMaxEventProps()));\n    };\n\n    var timeGridContent = function (contentArg) {\n      return common.createElement(DayTimeCols, tslib.__assign({}, splitProps.timed, {\n        dayTableModel: dayTableModel,\n        dateProfile: dateProfile,\n        axis: hasAttachedAxis,\n        slotDuration: options.slotDuration,\n        slatMetas: slatMetas,\n        forPrint: props.forPrint,\n        tableColGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        onSlatCoords: _this.handleSlatCoords,\n        expandRows: contentArg.expandRows,\n        onScrollTopRequest: _this.handleScrollTopRequest\n      }));\n    };\n\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  };\n\n  return DayTimeColsView;\n}(TimeColsView);\n\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new common.DayTableModel(daySeries, false);\n}\n\nvar OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nvar main = common.createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexports.DayTimeCols = DayTimeCols;\nexports.DayTimeColsSlicer = DayTimeColsSlicer;\nexports.DayTimeColsView = DayTimeColsView;\nexports.TimeCols = TimeCols;\nexports.TimeColsSlatsCoords = TimeColsSlatsCoords;\nexports.TimeColsView = TimeColsView;\nexports.buildDayRanges = buildDayRanges;\nexports.buildSlatMetas = buildSlatMetas;\nexports.buildTimeColsModel = buildTimeColsModel;\nexports[\"default\"] = main;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmNqcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWJBLDhDQUE2QztBQUFFRyxFQUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3Qzs7QUFFQSxJQUFJQyxNQUFNLEdBQUdDLG1CQUFPLENBQUMsNkVBQUQsQ0FBcEI7O0FBQ0EsSUFBSUMsS0FBSyxHQUFHRCxtQkFBTyxDQUFDLG9CQUFELENBQW5COztBQUNBLElBQUlFLE9BQU8sR0FBR0YsbUJBQU8sQ0FBQywrRUFBRCxDQUFyQjs7QUFDQTs7QUFFQSxJQUFJRyxjQUFjLEdBQWtCLFVBQVVDLE1BQVYsRUFBa0I7QUFDbERILEVBQUFBLEtBQUssQ0FBQ0ksU0FBTixDQUFnQkYsY0FBaEIsRUFBZ0NDLE1BQWhDOztBQUNBLFdBQVNELGNBQVQsR0FBMEI7QUFDdEIsV0FBT0MsTUFBTSxLQUFLLElBQVgsSUFBbUJBLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhLElBQWIsRUFBbUJDLFNBQW5CLENBQW5CLElBQW9ELElBQTNEO0FBQ0g7O0FBQ0RKLEVBQUFBLGNBQWMsQ0FBQ0ssU0FBZixDQUF5QkMsVUFBekIsR0FBc0MsWUFBWTtBQUM5QyxXQUFPO0FBQ0hDLE1BQUFBLE1BQU0sRUFBRSxFQURMO0FBRUhDLE1BQUFBLEtBQUssRUFBRTtBQUZKLEtBQVA7QUFJSCxHQUxEOztBQU1BUixFQUFBQSxjQUFjLENBQUNLLFNBQWYsQ0FBeUJJLGtCQUF6QixHQUE4QyxVQUFVQyxRQUFWLEVBQW9CO0FBQzlELFFBQUlBLFFBQVEsQ0FBQ0gsTUFBYixFQUFxQjtBQUNqQixhQUFPLENBQUMsUUFBRCxDQUFQO0FBQ0g7O0FBQ0QsV0FBTyxDQUFDLE9BQUQsQ0FBUDtBQUNILEdBTEQ7O0FBTUFQLEVBQUFBLGNBQWMsQ0FBQ0ssU0FBZixDQUF5Qk0sa0JBQXpCLEdBQThDLFVBQVVDLFFBQVYsRUFBb0I7QUFDOUQsUUFBSSxD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QUEsV0FBVyxFQUFFLGNBRGM7QUFFM0JDLEVBQUFBLGNBQWMsRUFBRUosZUFGVztBQUczQkssRUFBQUEsS0FBSyxFQUFFO0FBQ0hDLElBQUFBLFFBQVEsRUFBRTtBQUNOQyxNQUFBQSxTQUFTLEVBQUUvQixlQURMO0FBRU5nQyxNQUFBQSxjQUFjLEVBQUUsSUFGVjtBQUdObkIsTUFBQUEsVUFBVSxFQUFFLElBSE47QUFJTnpXLE1BQUFBLFlBQVksRUFBRSxVQUpSO0FBS05xUCxNQUFBQSxnQkFBZ0IsRUFBRSxJQUxaLENBS2tCOztBQUxsQixLQURQO0FBUUh3SSxJQUFBQSxXQUFXLEVBQUU7QUFDVHhiLE1BQUFBLElBQUksRUFBRSxVQURHO0FBRVR5RSxNQUFBQSxRQUFRLEVBQUU7QUFBRWdYLFFBQUFBLElBQUksRUFBRTtBQUFSO0FBRkQsS0FSVjtBQVlIQyxJQUFBQSxZQUFZLEVBQUU7QUFDVjFiLE1BQUFBLElBQUksRUFBRSxVQURJO0FBRVZ5RSxNQUFBQSxRQUFRLEVBQUU7QUFBRWtYLFFBQUFBLEtBQUssRUFBRTtBQUFUO0FBRkE7QUFaWDtBQUhvQixDQUFwQixDQUFYO0FBc0JBMWpCLG1CQUFBLEdBQXNCNmYsV0FBdEI7QUFDQTdmLHlCQUFBLEdBQTRCcWYsaUJBQTVCO0FBQ0FyZix1QkFBQSxHQUEwQnNoQixlQUExQjtBQUNBdGhCLGdCQUFBLEdBQW1CMmMsUUFBbkI7QUFDQTNjLDJCQUFBLEdBQThCd0wsbUJBQTlCO0FBQ0F4TCxvQkFBQSxHQUF1QmdGLFlBQXZCO0FBQ0FoRixzQkFBQSxHQUF5QjhmLGNBQXpCO0FBQ0E5ZixzQkFBQSxHQUF5QjBnQixjQUF6QjtBQUNBMWdCLDBCQUFBLEdBQTZCdWhCLGtCQUE3QjtBQUNBdmhCLGtCQUFBLEdBQWtCK2lCLElBQWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVsbGNhbGxlbmRhci10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvdGltZWdyaWQvbWFpbi5janMuanM/ODVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMC4xXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMSBBZGFtIFNoYXdcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvbW1vbicpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBkYXlncmlkID0gcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9kYXlncmlkJyk7XG47XG5cbnZhciBBbGxEYXlTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoQWxsRGF5U3BsaXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWxsRGF5U3BsaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxEYXk6IHt9LFxuICAgICAgICAgICAgdGltZWQ6IHt9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbW9uLmhhc0JnUmVuZGVyaW5nKGV2ZW50RGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnLCAnYWxsRGF5J107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XG4gICAgfTtcbiAgICByZXR1cm4gQWxsRGF5U3BsaXR0ZXI7XG59KGNvbW1vbi5TcGxpdHRlcikpO1xuXG52YXIgREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFwcm9wcy5pc0xhYmVsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCB2aWV3QXBpID0gY29udGV4dC52aWV3QXBpO1xuICAgICAgICB2YXIgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY29tbW9uLmNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdFswXSkgOlxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5SZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLnNsb3RMYWJlbENsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuc2xvdExhYmVsQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYWJlbFdpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbiBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5cbnZhciBUaW1lQm9keUF4aXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVCb2R5QXhpcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQm9keUF4aXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGltZUJvZHlBeGlzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCB0c2xpYi5fX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSkpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQm9keUF4aXM7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5cbnZhciBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xudmFyIEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUyA9IDU7XG52YXIgVGltZUNvbHNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIF90aGlzLmhlYWRlckVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbGVyRWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlckVsID0gX3RoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgX3RoaXMucmVuZGVySGVhZEF4aXMgPSBmdW5jdGlvbiAocm93S2V5LCBmcmFtZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKGZyYW1lSGVpZ2h0ID09PSB2b2lkIDApIHsgZnJhbWVIZWlnaHQgPSAnJzsgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBfdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgdmFyIGRheUNudCA9IGNvbW1vbi5kaWZmRGF5cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKSAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgICAgICA/IGNvbW1vbi5idWlsZE5hdkxpbmtBdHRycyhfdGhpcy5jb250ZXh0LCByYW5nZS5zdGFydCwgJ3dlZWsnKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53ZWVrTnVtYmVycyAmJiByb3dLZXkgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uV2Vla051bWJlclJvb3QsIHsgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGhcIiwgeyByZWY6IHJvb3RFbFJlZiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluaycsXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgbmF2TGlua0F0dHJzKSwgaW5uZXJDb250ZW50KSkpKTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRoXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgX3RoaXMucmVuZGVyVGFibGVSb3dBeGlzID0gZnVuY3Rpb24gKHJvd0hlaWdodCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHZpZXdBcGkgPSBfYS52aWV3QXBpO1xuICAgICAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5SZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmFsbERheUNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlckFsbERheUlubmVyLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHJlZjogcm9vdEVsUmVmLCBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluaycsXG4gICAgICAgICAgICAgICAgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyArIChyb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2xhdENvb3JkcyA9IGZ1bmN0aW9uIChzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHM6IHNsYXRDb29yZHMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gcmVuZGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVyU2ltcGxlTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gY29tbW9uLmdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMsIGVsUmVmOiB0aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVySFNjcm9sbExheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCBzbGF0Q29vcmRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgY29tbW9uLmdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIHZhciBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgY29tbW9uLmdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBfdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpOyB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBfdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMoY29udGVudEFyZy5yb3dTeW5jSGVpZ2h0c1swXSkpKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhbGxEYXlDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1kYXktZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWNodW5rXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVCb2R5QXhpcywgeyBzbGF0TWV0YXM6IHNsYXRNZXRhcyB9KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Ob3dUaW1lciwgeyB1bml0OiBpc05vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgLyogaGFja3kgKi8gfSwgZnVuY3Rpb24gKG5vd0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vd0luZGljYXRvclRvcCA9IGlzTm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGF0Q29vcmRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKG5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkpOyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tbW9uLnJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tbW9uLnJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjLCBlbFJlZjogdGhpcy5yb290RWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogZmFsc2UsIGNvbEdyb3VwczogW1xuICAgICAgICAgICAgICAgICAgICB7IHdpZHRoOiAnc2hyaW5rJywgY29sczogW3sgd2lkdGg6ICdzaHJpbmsnIH1dIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfSxcbiAgICAgICAgICAgICAgICBdLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgLyogRGltZW5zaW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgVGltZUNvbHNWaWV3LnByb3RvdHlwZS5nZXRBbGxEYXlNYXhFdmVudFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQub3B0aW9ucywgZGF5TWF4RXZlbnRzID0gX2EuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MgPSBfYS5kYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7IC8vIGlzIGF1dG8/XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1M7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1ZpZXc7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihob29rUHJvcHMpIHtcbiAgICByZXR1cm4gaG9va1Byb3BzLnRleHQ7XG59XG5cbnZhciBUaW1lQ29sc1NsYXRzQ29vcmRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzU2xhdHNDb29yZHMocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5zYWZlQ29tcHV0ZVRvcCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIGlmIChjb21tb24ucmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZkRheURhdGUgPSBjb21tb24uc3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgIHZhciB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gY29tbW9uLmFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSkgJiZcbiAgICAgICAgICAgICAgICB0aW1lTXMgPCBjb21tb24uYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNvbW1vbi5jcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5jb21wdXRlRGF0ZVRvcCA9IGZ1bmN0aW9uICh3aGVuLCBzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgICAgICBzdGFydE9mRGF5RGF0ZSA9IGNvbW1vbi5zdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNvbW1vbi5jcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH07XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXG4gICAgLy8gVGhpcyBpcyBhIG1ha2VzaGlmeSB3YXkgdG8gY29tcHV0ZSB0aGUgdGltZS10b3AuIEFzc3VtZXMgYWxsIHNsYXRNZXRhcyBkYXRlcyBhcmUgdW5pZm9ybS5cbiAgICAvLyBFdmVudHVhbGx5IGFsbG93IGNvbXB1dGF0aW9uIHdpdGggYXJiaXJhcnkgc2xhdCBkYXRlcy5cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5jb21wdXRlVGltZVRvcCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwb3NpdGlvbnMgPSBfYS5wb3NpdGlvbnMsIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gY29tbW9uLmFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSkpIC8gY29tbW9uLmFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIHZhciBzbGF0SW5kZXg7XG4gICAgICAgIHZhciBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzQ29vcmRzO1xufSgpKTtcblxudmFyIFRpbWVDb2xzU2xhdHNCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc1NsYXRzQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzbGF0RWxSZWZzID0gcHJvcHMuc2xhdEVsUmVmcztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgIHNsYXRNZXRhLmlzTGFiZWxlZCA/ICcnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCB0c2xpYi5fX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuc2xvdExhbmVDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLnNsb3RMYW5lQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuc2xvdExhbmVEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhbmVXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBzbGF0TWV0YS5pc29UaW1lU3RyIH0sIGlubmVyQ29udGVudCkpOyB9KSkpO1xuICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzU2xhdHNCb2R5O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG52YXIgVGltZUNvbHNTbGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGltZUNvbHNTbGF0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zbGF0RWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5taW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlIC8qIHJlbGllcyBvbiB0aGVyZSBvbmx5IGJlaW5nIGEgc2luZ2xlIDxjb2w+IGZvciB0aGUgYXhpcyAqLyxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH07XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVDb2xzU2xhdHMucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0U2xhdEVscyh0aGlzLnNsYXRFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuc2xhdE1ldGFzKSwgZmFsc2UsIHRydWUpLCB0aGlzLnByb3BzLmRhdGVQcm9maWxlLCBjb250ZXh0Lm9wdGlvbnMuc2xvdER1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xuICAgIHJldHVybiBzbGF0TWV0YXMubWFwKGZ1bmN0aW9uIChzbGF0TWV0YSkgeyByZXR1cm4gZWxNYXBbc2xhdE1ldGEua2V5XTsgfSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIHZhciBzZWdzQnlDb2wgPSBbXTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xuICAgIH1cbiAgICBpZiAoc2Vncykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzQnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlDb2wodWksIGNvbENudCkge1xuICAgIHZhciBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHVpLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gX2FbX2ldO1xuICAgICAgICAgICAgYnlSb3dbc2VnLmNvbF0uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG52YXIgVGltZUNvbE1vcmVMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sTW9yZUxpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbE1vcmVMaW5rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xNb3JlTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Nb3JlTGlua1Jvb3QsIHsgYWxsRGF5RGF0ZTogbnVsbCwgbW9yZUNudDogcHJvcHMuaGlkZGVuU2Vncy5sZW5ndGgsIGFsbFNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGFsaWdubWVudEVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgcG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHByb3BzLmhpZGRlblNlZ3MsIHByb3BzKTsgfSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhhbmRsZUNsaWNrLCB0aXRsZSwgaXNFeHBhbmRlZCwgcG9wb3ZlcklkKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgcmVmOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBjb21tb24uc2V0UmVmKHJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgICAgIGNvbW1vbi5zZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9LCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBwcm9wcy50b3AsIGJvdHRvbTogcHJvcHMuYm90dG9tIH0sIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCB0aXRsZTogdGl0bGUsIFwiYXJpYS1leHBhbmRlZFwiOiBpc0V4cGFuZGVkLCBcImFyaWEtY29udHJvbHNcIjogcG9wb3ZlcklkIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lciBmYy1zdGlja3lcIiB9LCBpbm5lckNvbnRlbnQpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sTW9yZUxpbms7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnNob3J0VGV4dDtcbn1cblxuLy8gc2VnSW5wdXRzIGFzc3VtZWQgc29ydGVkXG5mdW5jdGlvbiBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgc3RyaWN0T3JkZXIsIG1heFN0YWNrQ250KSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IG5ldyBjb21tb24uU2VnSGllcmFyY2h5KCk7XG4gICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgfVxuICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xuICAgIH1cbiAgICB2YXIgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgdmFyIGhpZGRlbkdyb3VwcyA9IGNvbW1vbi5ncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgdmFyIHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgdmFyIHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzOiBzZWdSZWN0cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIHZhciBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgYnVpbGROb2RlID0gY2FjaGVhYmxlKGZ1bmN0aW9uIChsZXZlbCwgbGF0ZXJhbCkgeyByZXR1cm4gbGV2ZWwgKyAnOicgKyBsYXRlcmFsOyB9LCBmdW5jdGlvbiAobGV2ZWwsIGxhdGVyYWwpIHtcbiAgICAgICAgdmFyIHNpYmxpbmdSYW5nZSA9IGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgbGV2ZWwsIGxhdGVyYWwpO1xuICAgICAgICB2YXIgbmV4dExldmVsUmVzID0gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNCeUxldmVsW2xldmVsXVtsYXRlcmFsXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICB2YXIgbGV2ZWwgPSBzaWJsaW5nUmFuZ2UubGV2ZWwsIGxhdGVyYWxTdGFydCA9IHNpYmxpbmdSYW5nZS5sYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgPSBzaWJsaW5nUmFuZ2UubGF0ZXJhbEVuZDtcbiAgICB2YXIgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgdmFyIGxldmVsQ29vcmRzID0gaGllcmFyY2h5LmxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgc3ViamVjdEVudHJ5ID0gZW50cmllc0J5TGV2ZWxbc3ViamVjdExldmVsXVtzdWJqZWN0TGF0ZXJhbF07XG4gICAgdmFyIGFmdGVyU3ViamVjdCA9IGxldmVsQ29vcmRzW3N1YmplY3RMZXZlbF0gKyBzdWJqZWN0RW50cnkudGhpY2tuZXNzO1xuICAgIHZhciBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcbiAgICB2YXIgbGV2ZWwgPSBzdWJqZWN0TGV2ZWw7XG4gICAgLy8gc2tpcCBwYXN0IGxldmVscyB0aGF0IGFyZSB0b28gaGlnaCB1cFxuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2xldmVsXSA8IGFmdGVyU3ViamVjdDsgbGV2ZWwgKz0gMSlcbiAgICAgICAgOyAvLyBkbyBub3RoaW5nXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgIHZhciBlbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHNlYXJjaEluZGV4ID0gY29tbW9uLmJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgY29tbW9uLmdldEVudHJ5U3BhbkVuZCk7XG4gICAgICAgIHZhciBsYXRlcmFsU3RhcnQgPSBzZWFyY2hJbmRleFswXSArIHNlYXJjaEluZGV4WzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgdmFyIGxhdGVyYWxFbmQgPSBsYXRlcmFsU3RhcnQ7XG4gICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgIChlbnRyeSA9IGVudHJpZXNbbGF0ZXJhbEVuZF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgc2VnIGxpc3RcbiAgICAgICAgICAgIGVudHJ5LnNwYW4uc3RhcnQgPCBzdWJqZWN0RW50cnkuc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgIGxhdGVyYWxFbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXJhbFN0YXJ0IDwgbGF0ZXJhbEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGV2ZWw6IGxldmVsLCBsYXRlcmFsU3RhcnQ6IGxhdGVyYWxTdGFydCwgbGF0ZXJhbEVuZDogbGF0ZXJhbEVuZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyZXRjaFdlYih0b3BMZXZlbE5vZGVzLCB0b3RhbFRoaWNrbmVzcykge1xuICAgIHZhciBzdHJldGNoTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykgeyByZXR1cm4gY29tbW9uLmJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSB7XG4gICAgICAgIHZhciBuZXh0TGV2ZWxOb2RlcyA9IG5vZGUubmV4dExldmVsTm9kZXMsIHRoaWNrbmVzcyA9IG5vZGUudGhpY2tuZXNzO1xuICAgICAgICB2YXIgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgdmFyIHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICB2YXIgZW5kQ29vcmQ7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV4dExldmVsTm9kZXNfMSA9IG5leHRMZXZlbE5vZGVzOyBfaSA8IG5leHRMZXZlbE5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5leHRMZXZlbE5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdOyB9KTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIHZhciByZWN0cyA9IFtdO1xuICAgIHZhciBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgeyByZXR1cm4gY29tbW9uLmJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQ6IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoOiBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgdmFyIHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGtleUZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCkge1xuICAgIGlmIChzbGF0Q29vcmRzID09PSB2b2lkIDApIHsgc2xhdENvb3JkcyA9IG51bGw7IH1cbiAgICBpZiAoZXZlbnRNaW5IZWlnaHQgPT09IHZvaWQgMCkgeyBldmVudE1pbkhlaWdodCA9IDA7IH1cbiAgICB2YXIgdmNvb3JkcyA9IFtdO1xuICAgIGlmIChzbGF0Q29vcmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICB2YXIgc3BhblN0YXJ0ID0gc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGNvbERhdGUpO1xuICAgICAgICAgICAgdmFyIHNwYW5FbmQgPSBNYXRoLm1heChzcGFuU3RhcnQgKyAoZXZlbnRNaW5IZWlnaHQgfHwgMCksIC8vIDooXG4gICAgICAgICAgICBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGNvbERhdGUpKTtcbiAgICAgICAgICAgIHZjb29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoc3BhblN0YXJ0KSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoc3BhbkVuZCksIC8vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmNvb3Jkcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgLy8gbWlnaHQgbm90IGhhdmUgZm9yIGV2ZXJ5IHNlZ1xuZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjaykge1xuICAgIHZhciBzZWdJbnB1dHMgPSBbXTtcbiAgICB2YXIgZHVtYlNlZ3MgPSBbXTsgLy8gc2VncyB3aXRob3V0IGNvb3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmNvb3JkcyA9IHNlZ1ZDb29yZHNbaV07XG4gICAgICAgIGlmICh2Y29vcmRzKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgICAgIHNwYW46IHZjb29yZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1bWJTZWdzLnB1c2goc2Vnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spLCBzZWdSZWN0cyA9IF9hLnNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgPSBfYS5oaWRkZW5Hcm91cHM7XG4gICAgdmFyIHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ1JlY3RzXzEgPSBzZWdSZWN0czsgX2kgPCBzZWdSZWN0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnUmVjdCA9IHNlZ1JlY3RzXzFbX2ldO1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgc2VnOiBzZWdzW3NlZ1JlY3QuaW5kZXhdLFxuICAgICAgICAgICAgcmVjdDogc2VnUmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgZHVtYlNlZ3NfMSA9IGR1bWJTZWdzOyBfYiA8IGR1bWJTZWdzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBkdW1iU2VnID0gZHVtYlNlZ3NfMVtfYl07XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50czogc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cblxudmFyIERFRkFVTFRfVElNRV9GT1JNQVQgPSBjb21tb24uY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgbWVyaWRpZW06IGZhbHNlLFxufSk7XG52YXIgVGltZUNvbEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy10aW1lZ3JpZC1ldmVudCcsXG4gICAgICAgICAgICAnZmMtdi1ldmVudCcsXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlzU2hvcnQpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5TdGFuZGFyZEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCwgZXh0cmFDbGFzc05hbWVzOiBjbGFzc05hbWVzIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbEV2ZW50O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGltZUNvbE1pc2MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVDb2xNaXNjLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xNaXNjKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xNaXNjLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUNlbGxDb250ZW50LCB7IGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1taXNjXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xNaXNjO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGltZUNvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGltZUNvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc29ydEV2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKGNvbW1vbi5zb3J0RXZlbnRTZWdzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtZW1vaXplIGV2ZW50LXBsYWNlbWVudD9cbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgaXNTZWxlY3RNaXJyb3IgPSBjb250ZXh0Lm9wdGlvbnMuc2VsZWN0TWlycm9yO1xuICAgICAgICB2YXIgbWlycm9yU2VncyA9IChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2VncykgfHxcbiAgICAgICAgICAgIChpc1NlbGVjdE1pcnJvciAmJiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncykgfHxcbiAgICAgICAgICAgIFtdO1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcyA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHZhciBzb3J0ZWRGZ1NlZ3MgPSB0aGlzLnNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIGNvbnRleHQub3B0aW9ucy5ldmVudE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbFJvb3QsIHsgZWxSZWY6IHByb3BzLmVsUmVmLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiByb290RWxSZWYsIHJvbGU6IFwiZ3JpZGNlbGxcIiwgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkLWNvbCddLmNvbmNhdChjbGFzc05hbWVzLCBwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLmpvaW4oJyAnKSB9LCBkYXRhQXR0cnMsIHByb3BzLmV4dHJhRGF0YUF0dHJzKSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCBfdGhpcy5yZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIF90aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvcikpKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIF90aGlzLnJlbmRlck5vd0luZGljYXRvcihwcm9wcy5ub3dJbmRpY2F0b3JTZWdzKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbE1pc2MsIHsgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMgfSkpKSk7IH0pKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzb3J0ZWRGZ1NlZ3MsIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUG9zaXRpb25lZEZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpO1xuICAgIH07XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVyUG9zaXRpb25lZEZnU2VncyA9IGZ1bmN0aW9uIChzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcbiAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dC5vcHRpb25zLCBldmVudE1heFN0YWNrID0gX2EuZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCA9IF9hLmV2ZW50U2hvcnRIZWlnaHQsIGV2ZW50T3JkZXJTdHJpY3QgPSBfYS5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1pbkhlaWdodCA9IF9hLmV2ZW50TWluSGVpZ2h0O1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBkYXRlID0gX2IuZGF0ZSwgc2xhdENvb3JkcyA9IF9iLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uID0gX2IuZXZlbnRTZWxlY3Rpb24sIHRvZGF5UmFuZ2UgPSBfYi50b2RheVJhbmdlLCBub3dEYXRlID0gX2Iubm93RGF0ZTtcbiAgICAgICAgdmFyIGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgdmFyIHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XG4gICAgICAgIHZhciBfYyA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayksIHNlZ1BsYWNlbWVudHMgPSBfYy5zZWdQbGFjZW1lbnRzLCBoaWRkZW5Hcm91cHMgPSBfYy5oaWRkZW5Hcm91cHM7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKGZ1bmN0aW9uIChzZWdQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2VnUGxhY2VtZW50LnNlZywgcmVjdCA9IHNlZ1BsYWNlbWVudC5yZWN0O1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIHZhciBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gX3RoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIHZhciBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0luc2V0ID8gJyBmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzLWluc2V0JyA6ICcnKSwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGlzU2hvcnQ6IGlzU2hvcnQgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckhpZGRlbkdyb3VwcyA9IGZ1bmN0aW9uIChoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZXh0cmFEYXRlU3BhbiA9IF9hLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UgPSBfYS50b2RheVJhbmdlLCBub3dEYXRlID0gX2Eubm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24gPSBfYS5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnID0gX2EuZXZlbnREcmFnLCBldmVudFJlc2l6ZSA9IF9hLmV2ZW50UmVzaXplO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcChmdW5jdGlvbiAoaGlkZGVuR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICB2YXIgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGNvbW1vbi5idWlsZElzb1N0cmluZyhjb21tb24uY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckZpbGxTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKGZ1bmN0aW9uICh2Y29vcmRzLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGNvbW1vbi5idWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogY29tcHV0ZVNlZ1ZTdHlsZSh2Y29vcmRzKSB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkJnRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlLCBwcm9wcy5ub3dEYXRlKSkpIDpcbiAgICAgICAgICAgICAgICBjb21tb24ucmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChzZWdzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNsYXRDb29yZHMgPSBfYS5zbGF0Q29vcmRzLCBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5tYXAoZnVuY3Rpb24gKHNlZywgaSkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Ob3dJbmRpY2F0b3JSb290LCB7IGlzQXhpczogZmFsc2UsIGRhdGU6IGRhdGUsIFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5lJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF0ZSkgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpOyB9KTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLmNvbXB1dGVTZWdIU3R5bGUgPSBmdW5jdGlvbiAoc2VnSENvb3Jkcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGlzUnRsID0gX2EuaXNSdGwsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgc2hvdWxkT3ZlcmxhcCA9IG9wdGlvbnMuc2xvdEV2ZW50T3ZlcmxhcDtcbiAgICAgICAgdmFyIG5lYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgdmFyIGZhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkICsgc2VnSENvb3Jkcy50aGlja25lc3M7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIHZhciBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG4gICAgICAgICAgICBmYXJDb29yZCA9IE1hdGgubWluKDEsIG5lYXJDb29yZCArIChmYXJDb29yZCAtIG5lYXJDb29yZCkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IG5lYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBuZWFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IHNlZ0hDb29yZHMuc3RhY2tEZXB0aCArIDEsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICogMTAwICsgJyUnLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICogMTAwICsgJyUnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiAhc2VnSENvb3Jkcy5zdGFja0ZvcndhcmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cbiAgICAgICAgICAgIHByb3BzW2lzUnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCBfYSkge1xuICAgIHZhciB0b2RheVJhbmdlID0gX2EudG9kYXlSYW5nZSwgbm93RGF0ZSA9IF9hLm5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uID0gX2EuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZyA9IF9hLmV2ZW50RHJhZywgZXZlbnRSZXNpemUgPSBfYS5ldmVudFJlc2l6ZTtcbiAgICB2YXIgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICB9KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZTdHlsZShzZWdWQ29vcmRzKSB7XG4gICAgaWYgKCFzZWdWQ29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogJycsIGJvdHRvbTogJycgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBzZWdWQ29vcmRzLnN0YXJ0LFxuICAgICAgICBib3R0b206IC1zZWdWQ29vcmRzLmVuZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhzZWdFbnRyaWVzLCBhbGxTZWdzKSB7XG4gICAgcmV0dXJuIHNlZ0VudHJpZXMubWFwKGZ1bmN0aW9uIChzZWdFbnRyeSkgeyByZXR1cm4gYWxsU2Vnc1tzZWdFbnRyeS5pbmRleF07IH0pO1xufVxuXG52YXIgVGltZUNvbHNDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc0NvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICBfdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnREcmFnID0gY29tbW9uLm1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IGNvbW1vbi5tZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBjb21tb24uUmVmTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHNDb250ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgbm93SW5kaWNhdG9yVG9wID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgcHJvcHMuc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChwcm9wcy5ub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgdmFyIGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIG5vd0luZGljYXRvclNlZ3NCeVJvdyA9IHRoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzKHByb3BzLm5vd0luZGljYXRvclNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgY29sQ250KTtcbiAgICAgICAgdmFyIGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGNvbENudCk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWZyYW1lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiB0cnVlLCBkYXRlOiBwcm9wcy5ub3dEYXRlIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IF90aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBjZWxsLmV4dHJhSG9va1Byb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfSkpKSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc0NvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUudXBkYXRlQ29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0Q2VsbEVscyh0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuY2VsbHMpLCB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHNDb250ZW50O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gZWxNYXBbY2VsbC5rZXldOyB9KTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgVGltZUNvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVDb2xzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gY29tbW9uLm1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBfdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgb25TY3JvbGxUb3BSZXF1ZXN0ID0gX3RoaXMucHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0O1xuICAgICAgICAgICAgdmFyIHNsYXRDb29yZHMgPSBfdGhpcy5zdGF0ZS5zbGF0Q29vcmRzO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcF8xID0gTWF0aC5jZWlsKHRvcF8xKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BfMSArPSAxOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFRvcFJlcXVlc3QodG9wXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ29sQ29vcmRzID0gZnVuY3Rpb24gKGNvbENvb3Jkcykge1xuICAgICAgICAgICAgX3RoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gZnVuY3Rpb24gKHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2xhdENvb3Jkczogc2xhdENvb3JkcyB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ib2R5XCIsIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0NvbnRlbnQsIHsgY2VsbHM6IHByb3BzLmNlbGxzLCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogcHJvcHMubm93SW5kaWNhdG9yU2VncywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHNsYXRDb29yZHM6IHN0YXRlLnNsYXRDb29yZHMsIG9uQ29sQ29vcmRzOiB0aGlzLmhhbmRsZUNvbENvb3JkcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLmRldGFjaCgpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb2xDb29yZHMgPSB0aGlzLmNvbENvb3JkcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIHNsYXRDb29yZHMgPSB0aGlzLnN0YXRlLnNsYXRDb29yZHM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zKHRoaXMucHJvcHMuc2xvdER1cmF0aW9uLCBvcHRpb25zLnNuYXBEdXJhdGlvbiksIHNuYXBEdXJhdGlvbiA9IF9iLnNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90ID0gX2Iuc25hcHNQZXJTbG90O1xuICAgICAgICB2YXIgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgdmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICB2YXIgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gY29tbW9uLmFkZER1cmF0aW9ucyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgY29tbW9uLm11bHRpcGx5RHVyYXRpb24oc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbmFwRHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IHRzbGliLl9fYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHM7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIHZhciBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgdmFyIHNuYXBzUGVyU2xvdCA9IGNvbW1vbi53aG9sZURpdmlkZUR1cmF0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbik7XG4gICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbG90RHVyYXRpb247XG4gICAgICAgIHNuYXBzUGVyU2xvdCA9IDE7XG4gICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xuICAgIH1cbiAgICByZXR1cm4geyBzbmFwRHVyYXRpb246IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90OiBzbmFwc1BlclNsb3QgfTtcbn1cblxudmFyIERheVRpbWVDb2xzU2xpY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlUaW1lQ29sc1NsaWNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUaW1lQ29sc1NsaWNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEYXlUaW1lQ29sc1NsaWNlci5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIHZhciBzZWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc2VnUmFuZ2UgPSBjb21tb24uaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbY29sXSk7XG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzU2xpY2VyO1xufShjb21tb24uU2xpY2VyKSk7XG5cbnZhciBEYXlUaW1lQ29scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGltZUNvbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGltZUNvbHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWlsZERheVJhbmdlcyA9IGNvbW1vbi5tZW1vaXplKGJ1aWxkRGF5UmFuZ2VzKTtcbiAgICAgICAgX3RoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XG4gICAgICAgIF90aGlzLnRpbWVDb2xzUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbCA9IHByb3BzLmRheVRhYmxlTW9kZWw7XG4gICAgICAgIHZhciBpc05vd0luZGljYXRvciA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3I7XG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIH0sIGZ1bmN0aW9uIChub3dEYXRlLCB0b2RheVJhbmdlKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBfdGhpcy50aW1lQ29sc1JlZiB9LCBfdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogaXNOb3dJbmRpY2F0b3IgJiYgX3RoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBvblNjcm9sbFRvcFJlcXVlc3Q6IHByb3BzLm9uU2Nyb2xsVG9wUmVxdWVzdCwgb25TbGF0Q29vcmRzOiBwcm9wcy5vblNsYXRDb29yZHMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzO1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkYXRlID0gX2FbX2ldO1xuICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxuLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XG52YXIgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICB2YXIgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICB2YXIgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICB2YXIgc2xhdEl0ZXJhdG9yID0gY29tbW9uLmNyZWF0ZUR1cmF0aW9uKDApO1xuICAgIHZhciBsYWJlbEludGVydmFsID0gZXhwbGljaXRMYWJlbEludGVydmFsIHx8IGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG4gICAgdmFyIG1ldGFzID0gW107XG4gICAgd2hpbGUgKGNvbW1vbi5hc1JvdWdoTXMoc2xhdFRpbWUpIDwgY29tbW9uLmFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICB2YXIgaXNMYWJlbGVkID0gY29tbW9uLndob2xlRGl2aWRlRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgbGFiZWxJbnRlcnZhbCkgIT09IG51bGw7XG4gICAgICAgIG1ldGFzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHNsYXRUaW1lLFxuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc29UaW1lU3RyOiBjb21tb24uZm9ybWF0SXNvVGltZVN0cmluZyhkYXRlKSxcbiAgICAgICAgICAgIGlzTGFiZWxlZDogaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBjb21tb24uYWRkRHVyYXRpb25zKHNsYXRUaW1lLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBzbGF0SXRlcmF0b3IgPSBjb21tb24uYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFzO1xufVxuLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxhYmVsSW50ZXJ2YWw7XG4gICAgdmFyIHNsb3RzUGVyTGFiZWw7XG4gICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG4gICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsYWJlbEludGVydmFsID0gY29tbW9uLmNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gY29tbW9uLndob2xlRGl2aWRlRHVyYXRpb25zKGxhYmVsSW50ZXJ2YWwsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIGlmIChzbG90c1BlckxhYmVsICE9PSBudWxsICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xvdER1cmF0aW9uOyAvLyBmYWxsIGJhY2tcbn1cblxudmFyIERheVRpbWVDb2xzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGltZUNvbHNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRpbWVDb2xzVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IGNvbW1vbi5tZW1vaXplKGJ1aWxkVGltZUNvbHNNb2RlbCk7XG4gICAgICAgIF90aGlzLmJ1aWxkU2xhdE1ldGFzID0gY29tbW9uLm1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBfYS5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICB2YXIgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgdmFyIGRheU1pbldpZHRoID0gb3B0aW9ucy5kYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUhlYWRlciwgeyBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5czogdHJ1ZSwgcmVuZGVySW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVySGVhZEF4aXMgOiBudWxsIH0pKTtcbiAgICAgICAgdmFyIGFsbERheUNvbnRlbnQgPSAob3B0aW9ucy5hbGxEYXlTbG90ICE9PSBmYWxzZSkgJiYgKGZ1bmN0aW9uIChjb250ZW50QXJnKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoZGF5Z3JpZC5EYXlUYWJsZSwgdHNsaWIuX19hc3NpZ24oe30sIHNwbGl0UHJvcHMuYWxsRGF5LCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgcmVuZGVyUm93SW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IF90aGlzLnJlbmRlclRhYmxlUm93QXhpcyA6IG51bGwsIHNob3dXZWVrTnVtYmVyczogZmFsc2UsIGV4cGFuZFJvd3M6IGZhbHNlLCBoZWFkZXJBbGlnbkVsUmVmOiBfdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9LCBfdGhpcy5nZXRBbGxEYXlNYXhFdmVudFByb3BzKCkpKSk7IH0pO1xuICAgICAgICB2YXIgdGltZUdyaWRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgdHNsaWIuX19hc3NpZ24oe30sIHNwbGl0UHJvcHMudGltZWQsIHsgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBheGlzOiBoYXNBdHRhY2hlZEF4aXMsIHNsb3REdXJhdGlvbjogb3B0aW9ucy5zbG90RHVyYXRpb24sIHNsYXRNZXRhczogc2xhdE1ldGFzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIHRhYmxlQ29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBvblNsYXRDb29yZHM6IF90aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiBfdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7IH07XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUaW1lQ29sc1ZpZXc7XG59KFRpbWVDb2xzVmlldykpO1xuZnVuY3Rpb24gYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgY29tbW9uLkRheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBjb21tb24uRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGZhbHNlKTtcbn1cblxudmFyIE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBhbGxEYXlTbG90OiBCb29sZWFuLFxufTtcblxudmFyIG1haW4gPSBjb21tb24uY3JlYXRlUGx1Z2luKHtcbiAgICBpbml0aWFsVmlldzogJ3RpbWVHcmlkV2VlaycsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICB2aWV3czoge1xuICAgICAgICB0aW1lR3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUaW1lQ29sc1ZpZXcsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsbERheVNsb3Q6IHRydWUsXG4gICAgICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXG4gICAgICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlLCAvLyBhIGJhZCBuYW1lLiBjb25mdXNlZCB3aXRoIG92ZXJsYXAvY29uc3RyYWludCBzeXN0ZW1cbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnRzLkRheVRpbWVDb2xzID0gRGF5VGltZUNvbHM7XG5leHBvcnRzLkRheVRpbWVDb2xzU2xpY2VyID0gRGF5VGltZUNvbHNTbGljZXI7XG5leHBvcnRzLkRheVRpbWVDb2xzVmlldyA9IERheVRpbWVDb2xzVmlldztcbmV4cG9ydHMuVGltZUNvbHMgPSBUaW1lQ29scztcbmV4cG9ydHMuVGltZUNvbHNTbGF0c0Nvb3JkcyA9IFRpbWVDb2xzU2xhdHNDb29yZHM7XG5leHBvcnRzLlRpbWVDb2xzVmlldyA9IFRpbWVDb2xzVmlldztcbmV4cG9ydHMuYnVpbGREYXlSYW5nZXMgPSBidWlsZERheVJhbmdlcztcbmV4cG9ydHMuYnVpbGRTbGF0TWV0YXMgPSBidWlsZFNsYXRNZXRhcztcbmV4cG9ydHMuYnVpbGRUaW1lQ29sc01vZGVsID0gYnVpbGRUaW1lQ29sc01vZGVsO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1vbiIsInJlcXVpcmUiLCJ0c2xpYiIsImRheWdyaWQiLCJBbGxEYXlTcGxpdHRlciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJvdG90eXBlIiwiZ2V0S2V5SW5mbyIsImFsbERheSIsInRpbWVkIiwiZ2V0S2V5c0ZvckRhdGVTcGFuIiwiZGF0ZVNwYW4iLCJnZXRLZXlzRm9yRXZlbnREZWYiLCJldmVudERlZiIsImhhc0JnUmVuZGVyaW5nIiwiU3BsaXR0ZXIiLCJERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIiwiY3JlYXRlRm9ybWF0dGVyIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJUaW1lQ29sc0F4aXNDZWxsIiwicHJvcHMiLCJjbGFzc05hbWVzIiwiaXNMYWJlbGVkIiwiY3JlYXRlRWxlbWVudCIsIlZpZXdDb250ZXh0VHlwZSIsIkNvbnN1bWVyIiwiY29udGV4dCIsImNsYXNzTmFtZSIsImpvaW4iLCJpc29UaW1lU3RyIiwiZGF0ZUVudiIsIm9wdGlvbnMiLCJ2aWV3QXBpIiwibGFiZWxGb3JtYXQiLCJzbG90TGFiZWxGb3JtYXQiLCJBcnJheSIsImlzQXJyYXkiLCJob29rUHJvcHMiLCJsZXZlbCIsInRpbWUiLCJkYXRlIiwidG9EYXRlIiwidmlldyIsInRleHQiLCJmb3JtYXQiLCJSZW5kZXJIb29rIiwic2xvdExhYmVsQ2xhc3NOYW1lcyIsImNvbnRlbnQiLCJzbG90TGFiZWxDb250ZW50IiwiZGVmYXVsdENvbnRlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJkaWRNb3VudCIsInNsb3RMYWJlbERpZE1vdW50Iiwid2lsbFVubW91bnQiLCJzbG90TGFiZWxXaWxsVW5tb3VudCIsInJvb3RFbFJlZiIsImN1c3RvbUNsYXNzTmFtZXMiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50IiwicmVmIiwiY29uY2F0IiwiVGltZUJvZHlBeGlzIiwicmVuZGVyIiwic2xhdE1ldGFzIiwibWFwIiwic2xhdE1ldGEiLCJrZXkiLCJfX2Fzc2lnbiIsIkJhc2VDb21wb25lbnQiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MiLCJUaW1lQ29sc1ZpZXciLCJfdGhpcyIsImFsbERheVNwbGl0dGVyIiwiaGVhZGVyRWxSZWYiLCJjcmVhdGVSZWYiLCJzY3JvbGxlckVsUmVmIiwic3RhdGUiLCJzbGF0Q29vcmRzIiwiaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCIsInNjcm9sbFRvcCIsInNjcm9sbGVyRWwiLCJjdXJyZW50IiwicmVuZGVySGVhZEF4aXMiLCJyb3dLZXkiLCJmcmFtZUhlaWdodCIsImRhdGVQcm9maWxlIiwicmFuZ2UiLCJyZW5kZXJSYW5nZSIsImRheUNudCIsImRpZmZEYXlzIiwic3RhcnQiLCJlbmQiLCJuYXZMaW5rQXR0cnMiLCJidWlsZE5hdkxpbmtBdHRycyIsIndlZWtOdW1iZXJzIiwiV2Vla051bWJlclJvb3QiLCJkZWZhdWx0Rm9ybWF0Iiwic3R5bGUiLCJoZWlnaHQiLCJyZW5kZXJUYWJsZVJvd0F4aXMiLCJyb3dIZWlnaHQiLCJfYSIsImFsbERheVRleHQiLCJhbGxEYXlDbGFzc05hbWVzIiwiYWxsRGF5Q29udGVudCIsInJlbmRlckFsbERheUlubmVyIiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsImhhbmRsZVNsYXRDb29yZHMiLCJzZXRTdGF0ZSIsInJlbmRlclNpbXBsZUxheW91dCIsImhlYWRlclJvd0NvbnRlbnQiLCJ0aW1lQ29udGVudCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsInB1c2giLCJ0eXBlIiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50Iiwib3V0ZXJDb250ZW50Iiwicm9sZSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJsaXF1aWQiLCJleHBhbmRSb3dzIiwiQm9vbGVhbiIsIlZpZXdSb290Iiwidmlld1NwZWMiLCJTaW1wbGVTY3JvbGxHcmlkIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsIndpZHRoIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsInN5bmNSb3dIZWlnaHRzIiwiY2h1bmtzIiwiYXJnIiwicm93U3luY0hlaWdodHMiLCJjb250ZW50QXJnIiwiY29sU3BhbiIsImlzTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yIiwiY2xpZW50SGVpZ2h0IiwidGFibGVDb2xHcm91cE5vZGUiLCJOb3dUaW1lciIsInVuaXQiLCJub3dEYXRlIiwibm93SW5kaWNhdG9yVG9wIiwic2FmZUNvbXB1dGVUb3AiLCJOb3dJbmRpY2F0b3JSb290IiwiaXNBeGlzIiwidG9wIiwicmVuZGVyU2Nyb2xsU2hpbSIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsImdldEFsbERheU1heEV2ZW50UHJvcHMiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJ1bmRlZmluZWQiLCJEYXRlQ29tcG9uZW50IiwiVGltZUNvbHNTbGF0c0Nvb3JkcyIsInBvc2l0aW9ucyIsInNsb3REdXJhdGlvbiIsInJhbmdlQ29udGFpbnNNYXJrZXIiLCJjdXJyZW50UmFuZ2UiLCJzdGFydE9mRGF5RGF0ZSIsInN0YXJ0T2ZEYXkiLCJ0aW1lTXMiLCJ2YWx1ZU9mIiwiYXNSb3VnaE1zIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsImNvbXB1dGVUaW1lVG9wIiwiY3JlYXRlRHVyYXRpb24iLCJjb21wdXRlRGF0ZVRvcCIsIndoZW4iLCJkdXJhdGlvbiIsImxlbiIsImVscyIsImxlbmd0aCIsInNsYXRDb3ZlcmFnZSIsIm1pbGxpc2Vjb25kcyIsInNsYXRJbmRleCIsInNsYXRSZW1haW5kZXIiLCJNYXRoIiwibWF4IiwibWluIiwiZmxvb3IiLCJ0b3BzIiwiZ2V0SGVpZ2h0IiwiVGltZUNvbHNTbGF0c0JvZHkiLCJzbGF0RWxSZWZzIiwiaSIsImF4aXMiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsIlRpbWVDb2xzU2xhdHMiLCJSZWZNYXAiLCJ0YWJsZU1pbldpZHRoIiwiY2xpZW50V2lkdGgiLCJtaW5IZWlnaHQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZVNpemluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwib25Db29yZHMiLCJyb290RWwiLCJvZmZzZXRIZWlnaHQiLCJQb3NpdGlvbkNhY2hlIiwiY29sbGVjdFNsYXRFbHMiLCJjdXJyZW50TWFwIiwiZWxNYXAiLCJzcGxpdFNlZ3NCeUNvbCIsInNlZ3MiLCJzZWdzQnlDb2wiLCJjb2wiLCJzcGxpdEludGVyYWN0aW9uQnlDb2wiLCJ1aSIsImJ5Um93IiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50IiwiX2kiLCJzZWciLCJUaW1lQ29sTW9yZUxpbmsiLCJNb3JlTGlua1Jvb3QiLCJhbGxEYXlEYXRlIiwibW9yZUNudCIsImhpZGRlblNlZ3MiLCJhbGxTZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiZXh0cmFEYXRlU3BhbiIsInRvZGF5UmFuZ2UiLCJwb3BvdmVyQ29udGVudCIsInJlbmRlclBsYWluRmdTZWdzIiwiaGFuZGxlQ2xpY2siLCJ0aXRsZSIsImlzRXhwYW5kZWQiLCJwb3BvdmVySWQiLCJlbCIsInNldFJlZiIsImJvdHRvbSIsIm9uQ2xpY2siLCJzaG9ydFRleHQiLCJidWlsZFBvc2l0aW9uaW5nIiwic2VnSW5wdXRzIiwic3RyaWN0T3JkZXIiLCJtYXhTdGFja0NudCIsImhpZXJhcmNoeSIsIlNlZ0hpZXJhcmNoeSIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwiaGlkZGVuR3JvdXBzIiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwid2ViIiwiYnVpbGRXZWIiLCJzdHJldGNoV2ViIiwic2VnUmVjdHMiLCJ3ZWJUb1JlY3RzIiwiZW50cmllc0J5TGV2ZWwiLCJidWlsZE5vZGUiLCJjYWNoZWFibGUiLCJsYXRlcmFsIiwic2libGluZ1JhbmdlIiwiZmluZE5leHRMZXZlbFNlZ3MiLCJuZXh0TGV2ZWxSZXMiLCJidWlsZE5vZGVzIiwiZW50cnkiLCJuZXh0TGV2ZWxOb2RlcyIsInRoaWNrbmVzcyIsImxhdGVyYWxTdGFydCIsImxhdGVyYWxFbmQiLCJwYWlycyIsInNvcnQiLCJjbXBEZXNjUHJlc3N1cmVzIiwiZXh0cmFjdE5vZGUiLCJhIiwiYiIsInN1YmplY3RMZXZlbCIsInN1YmplY3RMYXRlcmFsIiwibGV2ZWxDb29yZHMiLCJzdWJqZWN0RW50cnkiLCJhZnRlclN1YmplY3QiLCJsZXZlbENudCIsImVudHJpZXMiLCJzZWFyY2hJbmRleCIsImJpbmFyeVNlYXJjaCIsImdldEVudHJ5U3BhbkVuZCIsInRvcExldmVsTm9kZXMiLCJ0b3RhbFRoaWNrbmVzcyIsInN0cmV0Y2hOb2RlIiwibm9kZSIsInN0YXJ0Q29vcmQiLCJwcmV2VGhpY2tuZXNzIiwiYnVpbGRFbnRyeUtleSIsImFsbFRoaWNrbmVzcyIsInRoaWNrbmVzc0ZyYWN0aW9uIiwiZW5kQ29vcmQiLCJuZXdDaGlsZHJlbiIsIm5leHRMZXZlbE5vZGVzXzEiLCJjaGlsZE5vZGUiLCJyZXMiLCJuZXdUaGlja25lc3MiLCJyZWN0cyIsInByb2Nlc3NOb2RlIiwibGV2ZWxDb29yZCIsInN0YWNrRGVwdGgiLCJyZWN0Iiwic3RhY2tGb3J3YXJkIiwicHJvY2Vzc05vZGVzIiwibm9kZXMiLCJub2Rlc18xIiwia2V5RnVuYyIsIndvcmtGdW5jIiwiY2FjaGUiLCJhcmdzIiwiY29tcHV0ZVNlZ1ZDb29yZHMiLCJjb2xEYXRlIiwiZXZlbnRNaW5IZWlnaHQiLCJ2Y29vcmRzIiwic3BhblN0YXJ0Iiwic3BhbkVuZCIsInJvdW5kIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50cyIsInNlZ1ZDb29yZHMiLCJldmVudE9yZGVyU3RyaWN0IiwiZXZlbnRNYXhTdGFjayIsImR1bWJTZWdzIiwiaW5kZXgiLCJzZWdQbGFjZW1lbnRzIiwic2VnUmVjdHNfMSIsInNlZ1JlY3QiLCJfYiIsImR1bWJTZWdzXzEiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCIsIlRpbWVDb2xFdmVudCIsImlzU2hvcnQiLCJTdGFuZGFyZEV2ZW50IiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJleHRyYUNsYXNzTmFtZXMiLCJUaW1lQ29sTWlzYyIsIkRheUNlbGxDb250ZW50IiwiZXh0cmFIb29rUHJvcHMiLCJUaW1lQ29sIiwic29ydEV2ZW50U2VncyIsIm1lbW9pemUiLCJpc1NlbGVjdE1pcnJvciIsInNlbGVjdE1pcnJvciIsIm1pcnJvclNlZ3MiLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsImRhdGVTZWxlY3Rpb25TZWdzIiwiaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcyIsInNvcnRlZEZnU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsIkRheUNlbGxSb290IiwiZGF0YUF0dHJzIiwiZXh0cmFEYXRhQXR0cnMiLCJyZW5kZXJGaWxsU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2VncyIsInJlbmRlckZnU2VncyIsInJlbmRlck5vd0luZGljYXRvciIsIm5vd0luZGljYXRvclNlZ3MiLCJzZWdJc0ludmlzaWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwicmVuZGVyUG9zaXRpb25lZEZnU2VncyIsImV2ZW50U2hvcnRIZWlnaHQiLCJldmVudFNlbGVjdGlvbiIsImlzTWlycm9yIiwiX2MiLCJGcmFnbWVudCIsInJlbmRlckhpZGRlbkdyb3VwcyIsInNlZ1BsYWNlbWVudCIsImluc3RhbmNlSWQiLCJldmVudFJhbmdlIiwiaW5zdGFuY2UiLCJpc1Zpc2libGUiLCJ2U3R5bGUiLCJjb21wdXRlU2VnVlN0eWxlIiwiaFN0eWxlIiwiY29tcHV0ZVNlZ0hTdHlsZSIsImxlZnQiLCJyaWdodCIsImlzSW5zZXQiLCJ2aXNpYmlsaXR5IiwiaXNTZWxlY3RlZCIsImdldFNlZ01ldGEiLCJoaWRkZW5Hcm91cCIsInBvc2l0aW9uQ3NzIiwiY29tcGlsZVNlZ3NGcm9tRW50cmllcyIsImJ1aWxkSXNvU3RyaW5nIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJmaWxsVHlwZSIsImNoaWxkcmVuIiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJzZWdIQ29vcmRzIiwiaXNSdGwiLCJzaG91bGRPdmVybGFwIiwic2xvdEV2ZW50T3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiekluZGV4IiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdE5vd0luZGljYXRvclNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwiY2VsbEVsUmVmcyIsImNlbGxzIiwiZmdFdmVudFNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJub3dJbmRpY2F0b3JTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwiY2VsbCIsInVwZGF0ZUNvb3JkcyIsIm9uQ29sQ29vcmRzIiwiY29sbGVjdENlbGxFbHMiLCJUaW1lQ29scyIsInByb2Nlc3NTbG90T3B0aW9ucyIsImhhbmRsZVJvb3RFbCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJyZXF1ZXN0Iiwib25TY3JvbGxUb3BSZXF1ZXN0IiwidG9wXzEiLCJjZWlsIiwiaGFuZGxlQ29sQ29vcmRzIiwiY29sQ29vcmRzIiwib25TbGF0Q29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwicHJldlByb3BzIiwidXBkYXRlIiwiZGV0YWNoIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsInNuYXBEdXJhdGlvbiIsInNuYXBzUGVyU2xvdCIsImNvbEluZGV4IiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4Iiwic2xhdFRvcCIsInNsYXRIZWlnaHQiLCJwYXJ0aWFsIiwibG9jYWxTbmFwSW5kZXgiLCJzbmFwSW5kZXgiLCJkYXlEYXRlIiwiYWRkRHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFkZCIsImRheUVsIiwibGVmdHMiLCJyaWdodHMiLCJsYXllciIsInNuYXBEdXJhdGlvbk92ZXJyaWRlIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJEYXlUaW1lQ29sc1NsaWNlciIsInNsaWNlUmFuZ2UiLCJkYXlSYW5nZXMiLCJzZWdSYW5nZSIsImludGVyc2VjdFJhbmdlcyIsImlzU3RhcnQiLCJpc0VuZCIsIlNsaWNlciIsIkRheVRpbWVDb2xzIiwiYnVpbGREYXlSYW5nZXMiLCJzbGljZXIiLCJ0aW1lQ29sc1JlZiIsImRheVRhYmxlTW9kZWwiLCJzbGljZVByb3BzIiwic2xpY2VOb3dEYXRlIiwicmFuZ2VzIiwiaGVhZGVyRGF0ZXMiLCJTVE9DS19TVUJfRFVSQVRJT05TIiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsImJ1aWxkU2xhdE1ldGFzIiwiZXhwbGljaXRMYWJlbEludGVydmFsIiwiZGF5U3RhcnQiLCJEYXRlIiwic2xhdFRpbWUiLCJzbGF0SXRlcmF0b3IiLCJsYWJlbEludGVydmFsIiwiY29tcHV0ZUxhYmVsSW50ZXJ2YWwiLCJtZXRhcyIsInRvSVNPU3RyaW5nIiwiZm9ybWF0SXNvVGltZVN0cmluZyIsInNsb3RzUGVyTGFiZWwiLCJEYXlUaW1lQ29sc1ZpZXciLCJidWlsZFRpbWVDb2xzTW9kZWwiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInNwbGl0UHJvcHMiLCJzbG90TGFiZWxJbnRlcnZhbCIsImhhc0F0dGFjaGVkQXhpcyIsImhhc0RldGFjaGVkQXhpcyIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiRGF5SGVhZGVyIiwiZGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsInJlbmRlckludHJvIiwiYWxsRGF5U2xvdCIsIkRheVRhYmxlIiwibmV4dERheVRocmVzaG9sZCIsImNvbEdyb3VwTm9kZSIsInJlbmRlclJvd0ludHJvIiwic2hvd1dlZWtOdW1iZXJzIiwiaGVhZGVyQWxpZ25FbFJlZiIsInRpbWVHcmlkQ29udGVudCIsImRheVNlcmllcyIsIkRheVNlcmllc01vZGVsIiwiRGF5VGFibGVNb2RlbCIsIk9QVElPTl9SRUZJTkVSUyIsIm1haW4iLCJjcmVhdGVQbHVnaW4iLCJpbml0aWFsVmlldyIsIm9wdGlvblJlZmluZXJzIiwidmlld3MiLCJ0aW1lR3JpZCIsImNvbXBvbmVudCIsInVzZXNNaW5NYXhUaW1lIiwidGltZUdyaWREYXkiLCJkYXlzIiwidGltZUdyaWRXZWVrIiwid2Vla3MiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/timegrid/main.cjs.js\n");

/***/ }),

/***/ "@fullcalendar/interaction":
/*!********************************************!*\
  !*** external "@fullcalendar/interaction" ***!
  \********************************************/
/***/ ((module) => {

module.exports = require("@fullcalendar/interaction");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("react-dom");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

module.exports = require("tslib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./pages/index.tsx"));
module.exports = __webpack_exports__;

})();